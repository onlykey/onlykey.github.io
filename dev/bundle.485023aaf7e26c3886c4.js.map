{"version":3,"sources":["webpack:///webpack/bootstrap 485023aaf7e26c3886c4","webpack:///(webpack)/buildin/global.js","webpack:///(webpack)/buildin/module.js","webpack:///./node_modules/superagent/lib/is-object.js","webpack:///./src/app.js","webpack:///./src/kbpgp.js","webpack:///./node_modules/timers-browserify/main.js","webpack:///./node_modules/setimmediate/setImmediate.js","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/url/url.js","webpack:///./node_modules/punycode/punycode.js","webpack:///./node_modules/url/util.js","webpack:///./node_modules/querystring-es3/index.js","webpack:///./node_modules/querystring-es3/decode.js","webpack:///./node_modules/querystring-es3/encode.js","webpack:///./node_modules/superagent/lib/client.js","webpack:///./node_modules/component-emitter/index.js","webpack:///./node_modules/superagent/lib/request-base.js","webpack:///./node_modules/superagent/lib/response-base.js","webpack:///./node_modules/superagent/lib/utils.js","webpack:///./node_modules/superagent/lib/should-retry.js","webpack:///./node_modules/randomcolor/randomColor.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;ACrBA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,8DAA8D;AAC9D;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,yBAAyB,6CAA6C;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO,sDAAsD;AAC7D;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,WAAW;AACX,2BAA2B;AAC3B;AACA;AACA;AACA,6DAA6D,EAAE;AAC/D;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA,0EAA0E,WAAW;AACrF;AACA;AACA;AACA,WAAW;AACX,OAAO;AACP;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;wECvaA,yBAAa,2BAA2E,2DAA2D,KAAK,MAAM,wHAAwH,YAAY,0BAA0B,0BAA0B,gBAAgB,UAAU,UAAU,0CAA0C,8BAAwB,oBAAoB,8CAA8C,kCAAkC,YAAY,YAAY,mCAAmC,iBAAiB,gBAAgB,sBAAsB,oBAAoB,0CAA0C,YAAY,WAAW,YAAY,SAAS,GAAG;AAC/vB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC,EAAE,gFAAgF;AACnF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,4FAA4F;AAC/F;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sCAAsC;AAC9D;AACA;AACA;AACA,OAAO;AACP;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA,8GAA8G,IAAI;;AAElH,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,yCAAyC;AAC5C;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mCAAmC;AACzD;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,gCAAgC;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC,GAAG;AACJ;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,+GAA+G;AAClH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,mEAAmE;AACtE;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,kEAAkE;AAClE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,+GAA+G;AAClH;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,0LAA0L;AAC7L;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,6HAA6H;AAChI;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,qCAAqC;AACxC;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA,iBAAiB;AACjB,eAAe;AACf,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,mBAAmB;AACnB;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,0HAA0H;AAC7H;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC,EAAE,2FAA2F;AAC9F;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC,EAAE,4BAA4B;AAC/B;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC,EAAE,kCAAkC;AACrC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,kEAAkE;AACrE;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc,EAAE;AACnS,8CAA8C,iCAAiC,OAAO,OAAO,6CAA6C,EAAE,WAAW;;AAEvJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,4MAA4M;AAC/M;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,CAAC;;AAED,CAAC,EAAE,gEAAgE;AACnE;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC,EAAE,6EAA6E;AAChF;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2LAA2L;AAC3L;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,2BAA2B;AAC3B;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB,uBAAuB;AACvB;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,iGAAiG;AACpG;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC,EAAE,8IAA8I;AACjJ;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8KAA8K,kHAAkH;AAChS;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,qFAAqF;AACxF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,6CAA6C,wBAAwB;AACrE,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,4CAA4C;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC,GAAG;AACJ;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,gBAAgB;AACnB;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,YAAY;AACf;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;AAED,CAAC,EAAE,gBAAgB;AACnB;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,mBAAmB;AACtB;AACA;AACA;AACA;;AAEA;;AAEA,kCAAkC,WAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,iUAAiU;AACpU;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,sHAAsH;AACzH;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,6HAA6H;AAChI;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,uBAAuB;AAC1B;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA,CAAC;;AAED,CAAC,EAAE,yDAAyD;AAC5D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,4CAA4C,WAAW;AACvD;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;AAED,CAAC,EAAE,oDAAoD;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,YAAY;AACf;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,kCAAkC;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,uBAAuB;AACvB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA,uBAAuB;AACvB,qBAAqB;AACrB,mBAAmB;AACnB,iBAAiB;AACjB;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,uBAAuB;AACvB;AACA,qBAAqB;AACrB,mBAAmB;AACnB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,6TAA6T;AAChU;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC,4BAA4B,QAAQ;AACpC,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC,EAAE,6BAA6B;AAChC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qDAAqD;AAC3E;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,4BAA4B;AAC/B;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB,iBAAiB;AACjB,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA,CAAC;;AAED,CAAC,EAAE,oOAAoO;AACvO;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,0NAA0N;AAC7N;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,6CAA6C;AAChD;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc,EAAE;AACnS;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,qBAAqB;AACrB,mBAAmB;AACnB;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sCAAsC;AAChE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,oCAAoC;AACpC;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,sCAAsC;AACtC;AACA,iBAAiB;AACjB;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,oTAAoT;AACvT;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4CAA4C;AACpE;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mCAAmC;AACnF;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,mCAAmC;AACvF;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,4BAA4B,WAAW;AACvC;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,0GAA0G;AAC7G;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,kDAAkD;AACrD;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,2DAA2D;AAC9D;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,mIAAmI;AACtI;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC,EAAE,YAAY;AACf;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,uBAAuB;AACvB;AACA,qBAAqB;AACrB,mBAAmB;AACnB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,8TAA8T;AACjU;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc,EAAE;AACnS,8CAA8C,iCAAiC,OAAO,OAAO,6CAA6C,EAAE,WAAW;;AAEvJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,gGAAgG;AACnG;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,mBAAmB,iCAAiC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,gHAAgH;AACnH;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,GAAG;AACJ;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,8JAA8J;AACjK;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD,WAAW;AAC3D;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA,wDAAwD,WAAW;AACnE;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB;AACpB;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,uBAAuB,iCAAiC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C,WAAW;AACzD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,6BAA6B;AAC7B;AACA,2BAA2B;AAC3B;AACA,uBAAuB;AACvB;AACA,mBAAmB;AACnB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,sMAAsM;AACzM;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,oGAAoG;AACvG;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,oGAAoG;AACvG;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,sRAAsR;AACzR;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,OAAO;AACP;AACA,OAAO;AACP;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA,WAAW;AACX,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,2BAA2B;AAC3B;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sKAAsK;AACtK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;;AAEf;;AAEA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB,iBAAiB;AACjB,eAAe;AACf,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,uBAAuB;AACvB;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB,mBAAmB;AACnB;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;;AAET,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sCAAsC,YAAY;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA,CAAC;;AAED,CAAC,EAAE,uLAAuL;AAC1L;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,kDAAkD;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,sDAAsD;AACzD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA4C,4BAA4B;AACxE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,uDAAuD;AACvD,OAAO;AACP;AACA,OAAO;AACP,6CAA6C;AAC7C,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;AAED,CAAC,EAAE,6FAA6F;AAChG;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,mCAAmC;AAC3E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,yBAAyB;AAC5B;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uFAAuF,qHAAqH;AAC5M;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;AAED,CAAC,EAAE,gCAAgC;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,8BAA8B,mCAAmC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB,4CAA4C;AAChE;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,KAAK;AACL;AACA,KAAK;AACL,iDAAiD,6CAA6C;AAC9F;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,wFAAwF;AAC3F;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gCAAgC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,uBAAuB;AACvB,qBAAqB;AACrB;AACA;AACA,mBAAmB;AACnB,iBAAiB;AACjB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,WAAW;AAC3D;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,kDAAkD,WAAW;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,uBAAuB;AACvB;AACA,uBAAuB;AACvB;AACA,qBAAqB;AACrB;AACA;AACA;AACA,uBAAuB;AACvB,qBAAqB;AACrB,mBAAmB;AACnB;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,uBAAuB;AACvB;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB,mBAAmB;AACnB,iBAAiB;AACjB;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,4CAA4C,WAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,2GAA2G;AAC9G;AACA;AACA;;AAEA,CAAC;;AAED,CAAC,GAAG;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,wCAAwC,sCAAsC;AAC9E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,uDAAuD;AAC1D;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,iCAAiC,SAAS;AAC1C;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA,KAAK;AACL,iDAAiD;AACjD;AACA;;AAEA,CAAC;;AAED,CAAC,EAAE,4BAA4B;AAC/B;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB,eAAe;AACf,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA,iBAAiB;AACjB,eAAe;AACf,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,uBAAuB;AACvB;AACA,uBAAuB;AACvB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,qBAAqB;AACrB,mBAAmB;AACnB,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,sJAAsJ;AACzJ;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,mCAAmC;AAC1E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,0GAA0G;AAC7G;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,EAAE,4BAA4B,EAAE;AAC9D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA,CAAC;;AAED,CAAC,EAAE,kEAAkE;AACrE;AACA;AACA;;AAEA;;AAEA,kCAAkC,WAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC,EAAE,wDAAwD;;AAE3D;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;;AAEA,CAAC,EAAE,gDAAgD;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA,kBAAkB,kCAAkC;AACpD,mBAAmB,kCAAkC;;AAErD;AACA,iCAAiC,eAAe;AAChD,UAAU,UAAU;AACpB;;AAEA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,SAAS;AACtC,UAAU,2BAA2B;AACrC;AACA;;AAEA,iDAAiD,gCAAgC;;AAEjF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,SAAS;AAC3B,yBAAyB,SAAS;AAClC,UAAU,UAAU;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,uBAAuB;AACjD,2BAA2B,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,UAAU;AAC1B,6BAA6B,sBAAsB;AACnD,UAAU,0BAA0B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,OAAO,SAAS;AAC3C,yBAAyB,OAAO,QAAQ;AACxC,yBAAyB,OAAO,QAAQ;AACxC,yBAAyB,OAAO,QAAQ;AACxC,yBAAyB,OAAO,QAAQ;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,4CAA4C;AACjF,4BAA4B,iDAAiD;AAC7E;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,wBAAwB;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,6BAA6B;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA,eAAe,SAAS;AACxB;AACA,eAAe,SAAS;;AAExB,yBAAyB,wBAAwB;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,eAAe,cAAc,UAAU;;AAE3D;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,WAAW,qBAAqB,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU,iBAAiB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc,KAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,eAAe,+BAA+B,UAAU;;AAEhF;AACA,qBAAqB,sCAAsC;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,OAAO,SAAS;AAC1C,wBAAwB,OAAO,QAAQ;AACvC,wBAAwB,OAAO,QAAQ;AACvC,wBAAwB,OAAO,QAAQ;AACvC,wBAAwB,OAAO,QAAQ;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,SAAS,QAAQ;AACxC;AACA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,kBAAkB,oBAAoB,oBAAoB;AAC1D,WAAW,cAAc,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC,wBAAwB,2BAA2B;AACnD,2BAA2B,mBAAmB,gBAAgB;AAC9D,yBAAyB,eAAe,gBAAgB;;AAExD;AACA;AACA;AACA;AACA;;AAEA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,+BAA+B;AAC/B,iCAAiC;AACjC,gDAAgD;AAChD;AACA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc,UAAU;AACpD;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB,4BAA4B,eAAe,gBAAgB;;AAE3D,uBAAuB;AACvB,8BAA8B,mBAAmB,gBAAgB;;AAEjE;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,6CAA6C;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW,QAAQ,QAAQ;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,eAAe,gBAAgB,UAAU;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,6CAA6C;;AAExE;AACA,4BAA4B,6CAA6C;;AAEzE;AACA,6BAA6B,iDAAiD;;AAE9E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc,KAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,8BAA8B;AACvD,sBAAsB,oCAAoC;AAC1D,sBAAsB,oCAAoC;;AAE1D;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,YAAY;AACrC,sBAAsB,eAAe,4BAA4B,UAAU;;AAE3E;AACA,wBAAwB,YAAY;AACpC,qBAAqB,eAAe,2BAA2B,UAAU;;AAEzE;AACA,yBAAyB,YAAY;AACrC,sBAAsB,eAAe,4BAA4B,UAAU;;AAE3E;AACA,4BAA4B,aAAa;AACzC,yBAAyB,eAAe,+BAA+B,UAAU;;AAEjF;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;;AAEA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,UAAU,SAAS;AAC7C,wBAAwB,SAAS,QAAQ;AACzC,uBAAuB,SAAS,QAAQ;AACxC,qBAAqB,SAAS,QAAQ;AACtC;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,UAAU,KAAK;AACnC;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,gCAAgC;;AAEzD;AACA,2BAA2B,oCAAoC;;AAE/D;AACA,0BAA0B,iCAAiC;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,eAAe,iBAAiB,UAAU;;AAEhE;AACA,2BAA2B,eAAe,iBAAiB,UAAU;;AAErE;AACA,2BAA2B,eAAe,sBAAsB,UAAU;;AAE1E;AACA,wBAAwB,eAAe,kBAAkB,UAAU;;AAEnE;AACA,yBAAyB,eAAe,yBAAyB,UAAU;;AAE3E;AACA,4BAA4B,eAAe,yBAAyB,UAAU;;AAE9E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,UAAU;AAC/B,2BAA2B,mBAAmB;AAC9C,yBAAyB,eAAe;;AAExC;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,kCAAkC;;AAExD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,6BAA6B,OAAO;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,eAAe,aAAa,gBAAgB,UAAU;AACjE;;AAEA,8BAA8B,UAAU;;AAExC;AACA;AACA;AACA,2BAA2B,kBAAkB,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB,+BAA+B,eAAe,gBAAgB;;AAE9D,oBAAoB;AACpB,iCAAiC,mBAAmB,gBAAgB;;AAEpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,SAAS,KAAK;AACxC,yBAAyB,cAAc,KAAK;AAC5C,gBAAgB;AAChB;AACA;AACA;AACA;AACA,uBAAuB,eAAe,eAAe,QAAQ;AAC7D,iCAAiC,OAAO,OAAO,QAAQ,QAAQ;AAC/D;AACA;;AAEA;AACA,uBAAuB,OAAO,QAAQ;AACtC,sBAAsB,eAAe,KAAK;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,WAAW,OAAO,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB,cAAc;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB,cAAc;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,wCAAwC;AACxC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,eAAe;AAChD,UAAU,UAAU;AACpB;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qCAAqC,4CAA4C;AACjF,4BAA4B,iDAAiD;AAC7E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA,iBAAiB,QAAQ;AACzB,UAAU,4BAA4B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,eAAe;;AAEjE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,YAAY;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC,GAAG;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,8BAA8B;AAC9B;AACA,mDAAmD;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gDAAgD;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;AACH;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,YAAY;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG,0BAA0B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC,WAAW;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC,EAAE,WAAW;AACd;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,uBAAuB,SAAS;AAChC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,KAAK;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC,yJAAyJ;AAC1J,CAAC,EAAE,oDAAoD;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;AACD,CAAC,EAAE,+KAA+K;AAClL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;;AAEhD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;AACD,CAAC,EAAE,wFAAwF;AAC3F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,kDAAkD;AACrD;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA,KAAK;AACL,iBAAiB,YAAY;AAC7B;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH,eAAe,YAAY;AAC3B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,0BAA0B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,OAAO;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC,EAAE,4BAA4B;AAC/B;;AAEA,CAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mDAAmD,YAAY;AAC/D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,CAAC,qDAAqD;;AAEtD,CAAC,GAAG;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,QAAQ,WAAW;;AAEnB;AACA;AACA,QAAQ,UAAU;;AAElB;AACA;;AAEA,CAAC,GAAG;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;AACD,CAAC,EAAE,kDAAkD;AACrD;AACA;;AAEA;AACA,uCAAuC;;AAEvC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA,gBAAgB,eAAe;AAC/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA,CAAC;AACD,CAAC,EAAE,+BAA+B;AAClC;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB,CAAC;AACD,CAAC,EAAE,YAAY;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK,cAAc;AACnB,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,2EAA2E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC,EAAE,eAAe;AAClB;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,idAAid,+BAA+B;AAChf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,YAAY;AAC5B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA,CAAC;AACD,CAAC,EAAE,YAAY;AACf;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC,EAAE,YAAY;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC,EAAE,kDAAkD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC,EAAE,WAAW;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;;AAEA;AACA,YAAY,OAAO,OAAO,YAAY,OAAO,OAAO,OAAO;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,CAAC,EAAE,uBAAuB;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;;;AAGA,CAAC,GAAG;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,CAAC;AACD,CAAC,EAAE,YAAY;AACf;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,YAAY;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,eAAe,SAAS;AACxB;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC,GAAG;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC,GAAG;AACJ;AACA;AACA;;AAEA,CAAC,GAAG;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA,CAAC,GAAG;AACJ;;AAEA,CAAC,EAAE,8BAA8B;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;;AAEA,CAAC;AACD,CAAC,EAAE,iGAAiG;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC,EAAE,2DAA2D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,gBAAgB;AACtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;;AAEA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;;AAEA,CAAC;AACD,CAAC,EAAE,uHAAuH;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,CAAC,EAAE,wDAAwD;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;AACD,CAAC,EAAE,+FAA+F;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD,CAAC,EAAE,YAAY;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,OAAO;AACf;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC,EAAE,YAAY;AACf;;AAEA,CAAC,EAAE,mCAAmC;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC,EAAE,kKAAkK;AACrK;;AAEA,CAAC,EAAE,iCAAiC;AACpC;;AAEA,CAAC,EAAE,gCAAgC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,CAAC,EAAE,sMAAsM;AACzM;AACA,CAAC,GAAG;AACJ;AACA,CAAC,EAAE,qDAAqD;AACxD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,CAAC;;AAED;;AAEA,CAAC,EAAE,WAAW;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC,GAAG;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;AAED,CAAC,EAAE,8BAA8B;AACjC;AACA;AACA;;AAEA;;AAEA;;AAEA,kCAAkC,WAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC,EAAE,8CAA8C;AACjD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,uDAAuD;AACvD;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,4BAA4B;AAC/B,2CAA2C,gCAAgC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC,EAAE,0lBAA0lB;AAC7lB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO,OAAO,UAAU;AAC3C,mBAAmB,OAAO,OAAO,WAAW;AAC5C;AACA;AACA;AACA;AACA,uBAAuB,OAAO,OAAO,aAAa,YAAY;AAC9D,SAAS;AACT,uBAAuB,OAAO,OAAO,aAAa,mBAAmB;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C,mCAAmC;AACnC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,yCAAyC,WAAW,gBAAgB;AACpE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C,+BAA+B;AAC/B,oCAAoC,QAAQ;AAC5C;AACA;AACA,yCAAyC,WAAW,gBAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,iBAAiB,OAAO,YAAY,mBAAmB;AAC1E;AACA,4BAA4B,EAAE;AAC9B;AACA;AACA,iCAAiC;AACjC,kCAAkC,OAAO;AACzC;AACA;AACA;;AAEA;AACA;AACA,YAAY,SAAS,EAAE;AACvB,cAAc,QAAQ;AACtB,gBAAgB,SAAS,EAAE;AAC3B;AACA,gDAAgD;AAChD,oBAAoB,SAAS,EAAE;AAC/B;AACA;;AAEA;AACA,8CAA8C,OAAO;AACrD,sBAAsB,0BAA0B;AAChD;AACA,2BAA2B,uCAAuC,IAAI,KAAK;AAC3E,iCAAiC,cAAc;AAC/C;AACA,uBAAuB,QAAQ,OAAO,aAAa;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C,mCAAmC;AACnC;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,sBAAsB;AACtB;AACA;AACA;AACA,yCAAyC,YAAY,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C,kCAAkC;AAClC,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA,yCAAyC,WAAW,gBAAgB;AACpE;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C,mCAAmC;AACnC;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,gCAAgC,WAAW,gBAAgB;AAC3D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C,kCAAkC;AAClC,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA,gCAAgC,WAAW,gBAAgB;AAC3D;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,6BAA6B,WAAW;AAClE,kBAAkB,2BAA2B,WAAW;AACxD,SAAS;AACT;AACA,gCAAgC,iCAAiC,WAAW;AAC5E,iCAAiC,2BAA2B,WAAW;AACvE,kBAAkB,OAAO,WAAW;AACpC,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC;AAClC,mBAAmB,OAAO,OAAO,WAAW;AAC5C,eAAe,WAAW,OAAO,OAAO;AACxC,YAAY,SAAS,EAAE;AACvB,cAAc,SAAS;AACvB,gBAAgB,SAAS,EAAE;AAC3B;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA,oBAAoB,SAAS,EAAE;AAC/B;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,UAAU,UAAU;AACvD,mCAAmC,UAAU;AAC7C;AACA;AACA,yCAAyC,YAAY;AACrD,sBAAsB,YAAY;AAClC;AACA;AACA,8DAA8D,QAAQ;AACtE,iCAAiC,qBAAqB;AACtD;AACA;AACA;AACA;;AAEA,sBAAsB,eAAe;AACrC,gBAAgB,SAAS,EAAE;AAC3B,kBAAkB,SAAS;AAC3B,oBAAoB,SAAS,EAAE;AAC/B;AACA;AACA,wBAAwB,SAAS,EAAE;AACnC;AACA;;AAEA,uBAAuB,OAAO,OAAO,uBAAuB;AAC5D,mCAAmC,+BAA+B;AAClE,mCAAmC,2BAA2B;AAC9D;;AAEA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA,sCAAsC;AACtC,sBAAsB,OAAO,eAAe;AAC5C;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA,iCAAiC,OAAO;AACxC;AACA,iBAAiB;AACjB,aAAa;AACb,6BAA6B,aAAa;AAC1C;AACA,qBAAqB,6BAA6B;AAClD,cAAc,sCAAsC;AACpD,iBAAiB;AACjB;AACA;;AAEA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA,4CAA4C,oBAAoB;AAChE,iDAAiD,sBAAsB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA,4CAA4C,oBAAoB;AAChE,iDAAiD,sBAAsB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW,OAAO,iBAAiB;AACtD,oBAAoB,OAAO,OAAO,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO,OAAO,UAAU;AACzC,iBAAiB,KAAK,OAAO,mBAAmB;AAChD,sBAAsB,OAAO,OAAO,WAAW,iBAAiB;AAChE,wBAAwB,MAAM;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA,4CAA4C,oBAAoB;AAChE,iDAAiD,sBAAsB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,qBAAqB,KAAK,OAAO,cAAc;AAC/C;AACA,iBAAiB,KAAK,OAAO,iBAAiB;AAC9C;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA,8BAA8B,UAAU;AACxC,8BAA8B,SAAS;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC,EAAE,4BAA4B;AAC/B,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,aAAa;AACb,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA,uBAAuB,KAAK,OAAO;AACnC;AACA;AACA,2BAA2B;AAC3B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA,iBAAiB;AACjB,kDAAkD;AAClD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAkD;AACzE;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,qBAAqB;AACrB,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,oCAAoC;AACpC;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,aAAa,iCAAiC;AAC9C;AACA;AACA,aAAa,iCAAiC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,qDAAqD;AACrD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,wBAAwB;AACxB,qBAAqB,UAAU;AAC/B;AACA;AACA,6BAA6B,OAAO,OAAO,YAAY;AACvD;AACA,iBAAiB;AACjB,6BAA6B,OAAO,OAAO,YAAY,YAAY;AACnE;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,CAAC,EAAE,4JAA4J;AAC/J;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,+BAA+B;AAC/B;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA,qCAAqC,KAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC,EAAE,eAAe;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B;AAC9B;AACA,qDAAqD;AACrD;;AAEA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA,gCAAgC;AAChC;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,8CAA8C;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B,6BAA6B;;AAE7B;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,gBAAgB;AAC7B;;AAEA,gDAAgD;;AAEhD,aAAa,gBAAgB;AAC7B;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA,4BAA4B;AAC5B;AACA,2BAA2B;AAC3B,eAAe,cAAc;AAC7B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,wBAAwB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wBAAwB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,wBAAwB;AAC5E;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;;AAEtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA,uCAAuC,YAAY;;AAEnD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA,iCAAiC,YAAY,EAAE;AAC/C,+CAA+C,cAAc,EAAE;AAC/D;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA,6BAA6B,YAAY,EAAE;AAC3C;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC;AACA;AACA;AACA;AACA,gBAAgB;AAChB,KAAK;AACL,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB,OAAO,oBAAoB;AACzD,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC,mCAAmC,UAAU;AAC7C;AACA;AACA,mBAAmB,2DAA2D;AAC9E;AACA;AACA;AACA,kCAAkC,0BAA0B,EAAE;AAC9D;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA,eAAe,gBAAgB,OAAO,UAAU;AAChD;AACA,kBAAkB,gBAAgB;AAClC;AACA,eAAe,gCAAgC;AAC/C;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,uBAAuB;AACvB;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA,WAAW,MAAM;AACjB;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe,OAAO,aAAa;AAC9C;AACA,gBAAgB,OAAO;AACvB,kBAAkB,YAAY;AAC9B;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,OAAO;AACP,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA,aAAa,gBAAgB;AAC7B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,mBAAmB;AACnB;AACA,oBAAoB,kBAAkB;AACtC,yBAAyB,kBAAkB;AAC3C,wBAAwB,kBAAkB;AAC1C,wBAAwB,kBAAkB;AAC1C,QAAQ,kBAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe,OAAO,aAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB,OAAO,UAAU,EAAE;AAC/C,WAAW,oBAAoB;AAC/B;AACA;AACA,aAAa,iBAAiB,OAAO,gBAAgB,OAAO,EAAE;AAC9D;AACA;AACA;AACA,UAAU,IAAI;AACd;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA,iCAAiC;AACjC;AACA;AACA,gBAAgB,OAAO;AACvB;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC,EAAE,gHAAgH;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC,EAAE,aAAa;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,CAAC,EAAE,+CAA+C;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yCAAyC;AACzC,2CAA2C;AAC3C,2CAA2C;AAC3C;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA,yBAAyB,gDAAgD;AACzE;AACA;AACA;AACA;AACA,kDAAkD,QAAQ,EAAE;AAC5D;AACA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC;AACA;AACA,gCAAgC;AAChC;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,oBAAoB;AACzC;AACA,UAAU,aAAa;AACvB;AACA;AACA;AACA,UAAU,gBAAgB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,CAAC,EAAE,+CAA+C;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC,EAAE,aAAa;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,CAAC,EAAE,gEAAgE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC,EAAE,gCAAgC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA,iCAAiC;AACjC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,CAAC,EAAE,+CAA+C;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB;AACjB,qBAAqB;AACrB,yBAAyB;AACzB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,iBAAiB;AAChC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,CAAC,EAAE,+BAA+B;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ,YAAY,4BAA4B;AAC3E,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uDAAuD,OAAO;AAC9D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,gEAAgE,OAAO;AACvE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA,CAAC,EAAE,4BAA4B;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC,EAAE,aAAa;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,+BAA+B;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,+BAA+B;AAC1C;AACA,WAAW,OAAO;AAClB,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,aAAa,sBAAsB,SAAS,SAAS;AACrD,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,+BAA+B;AAC1C;AACA,WAAW,OAAO;AAClB,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,aAAa;AAC9D,2CAA2C,SAAS;AACpD;AACA,SAAS;AACT;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;;AAEA,CAAC,EAAE,4BAA4B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2BAA2B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA,sDAAsD;AACtD,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS,SAAS;AAC9C,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA,SAAS;AACT,iDAAiD;AACjD;AACA,uBAAuB,YAAY,YAAY;AAC/C;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,uDAAuD;AACvD,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2BAA2B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,wBAAwB,kBAAkB;AAC1C,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA,iDAAiD,aAAa;AAC9D,2CAA2C,SAAS;AACpD;AACA,SAAS;AACT;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;;AAEA,CAAC,EAAE,mIAAmI;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB,gBAAgB;AACjD;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;;AAEA,GAAG,OAAO;AACV;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;;AAEA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG,OAAO;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;;AAEA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,yBAAyB,yBAAyB;AAClD;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;;AAEA,CAAC,EAAE,yLAAyL;AAC5L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC,cAAc;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0BAA0B;AAC5D;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2BAA2B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,SAAS;AAChE;AACA,qBAAqB,uCAAuC;AAC5D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D,iBAAiB,qCAAqC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,CAAC,EAAE,+CAA+C;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qCAAqC;AAC9D;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,CAAC,EAAE,+BAA+B;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc,wBAAwB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,OAAO;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yBAAyB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,MAAM;AAC9B;AACA;AACA;AACA;AACA;AACA,qBAAqB,iCAAiC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,yBAAyB;AACzB,WAAW;AACX,sBAAsB;AACtB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,MAAM;AAC9B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA,2DAA2D;AAC3D,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB,MAAM;AACvB;AACA,mCAAmC,uCAAuC;AAC1E;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA,CAAC,EAAE,gCAAgC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA,qBAAqB;AACrB,+BAA+B;AAC/B,wBAAwB;AACxB,sBAAsB;AACtB,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA,0CAA0C;AAC1C,gDAAgD;AAChD;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA,aAAa,+BAA+B;AAC5C;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,6DAA6D;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,kBAAkB,WAAW;AAC7B;AACA,SAAS,OAAO;AAChB;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,kCAAkC;AAClC,6CAA6C;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC,GAAG;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA,uBAAuB,GAAG;AAC1B;AACA;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,CAAC,EAAE,+CAA+C;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB,YAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;;AAEA;AACA;AACA;;AAEA,CAAC,EAAE,eAAe;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gBAAgB;AACxD,qCAAqC,iBAAiB;AACtD,oCAAoC,kCAAkC;AACtE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA,8BAA8B,qBAAqB;AACnD;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,yBAAyB;AACzB,aAAa;AACb;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,yBAAyB;AACzB,8BAA8B,MAAM;AACpC,uCAAuC;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,eAAe,OAAO;AAC/C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,UAAU;AACjD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB;AACA;;AAEA,CAAC;AACD,CAAC,EAAE,wDAAwD;;AAE3D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH,wBAAwB,UAAU;AAClC;;AAEA;AACA;;AAEA,CAAC,GAAG;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,CAAC,EAAE,kCAAkC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC,GAAG;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC,EAAE,0CAA0C;AAC7C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,CAAC,EAAE,qCAAqC;AACxC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iCAAiC,OAAO;AACxC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,OAAO;AACP;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,CAAC;AACD,CAAC,EAAE,gCAAgC;AACnC;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,kBAAkB,UAAU;;AAE5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,4BAA4B,YAAY;AACxC,qBAAqB,8BAA8B;AACnD;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,KAAK;AACnC;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,KAAK;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC,GAAG;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,CAAC,GAAG;AACJ;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC,GAAG;AACJ;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,eAAe,SAAS;AACxB;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;;AAEA,sBAAsB;AACtB;;;AAGA;AACA,CAAC,GAAG;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;AAChC;;;AAGA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;;AAE1B,mBAAmB;;AAEnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,sBAAsB,qBAAqB,cAAc,EAAE;;;AAG/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B,kBAAkB,UAAU;;AAE5B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,wBAAwB;AACxB,YAAY;AACZ,UAAU;AACV,+BAA+B;AAC/B,gCAAgC;AAChC;AACA;;AAEA,sBAAsB;;AAEtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0BAA0B;;AAE3D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,aAAa;;AAEb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;;AAEnE;AACA,yDAAyD;AACzD;;AAEA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,0DAA0D;AAC1D;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,aAAa;;AAEb;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO,EAAE;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;;AAEA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,mBAAmB;;AAEnB;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO,EAAE;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oEAAoE;AACpE;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,0DAA0D;AAC1D;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,mBAAmB;AACnB,kBAAkB;AAClB,0BAA0B;AAC1B,4BAA4B;AAC5B,uBAAuB;AACvB,mBAAmB;AACnB,gBAAgB;AAChB,qBAAqB;AACrB,mBAAmB;AACnB,2BAA2B;AAC3B,uBAAuB;;AAEvB,kBAAkB;AAClB,kBAAkB;AAClB,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;;AAEnB,iBAAiB;AACjB,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB,sBAAsB;AACtB,2BAA2B;AAC3B,oBAAoB;AACpB,uBAAuB;AACvB,qBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB,oBAAoB;;AAEpB;AACA;;AAEA,sBAAsB;;AAEtB;;AAEA;;AAEA,2CAA2C;AAC3C,6CAA6C;AAC7C,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB,uBAAuB;AACvB,uBAAuB;;AAEvB;AACA;AACA;;AAEA,0BAA0B;AAC1B,2CAA2C;AAC3C;;AAEA,oBAAoB;AACpB,oBAAoB;AACpB;AACA;AACA;;AAEA,4CAA4C;AAC5C;AACA;AACA;;AAEA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB,sBAAsB;AACtB,mBAAmB;AACnB,kBAAkB;;;AAGlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,6BAA6B,uBAAuB;AACpD,8BAA8B,uBAAuB;AACrD;AACA;AACA;;;AAGA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB;;AAErB,sCAAsC;;AAEtC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;;AAEA;AACA;;AAEA,uBAAuB;AACvB,qBAAqB;AACrB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B,2BAA2B,aAAa;AACxC,oBAAoB,qBAAqB;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE,mFAAmF;AACtF;;AAEA;AACA,aAAa;AACb,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,WAAW;AACX,WAAW;AACX,UAAU;AACV,UAAU;AACV;AACA,WAAW;AACX;AACA,YAAY;AACZ,YAAY;AACZ,YAAY;AACZ,aAAa;AACb,WAAW;AACX,WAAW;AACX,YAAY;AACZ,YAAY;AACZ,YAAY;AACZ,YAAY;AACZ,WAAW;AACX,SAAS;AACT;AACA,UAAU;AACV,WAAW;AACX,WAAW;AACX;;;AAGA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,gCAAgC;AAChC;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,mBAAmB;AACnB,qCAAqC;AACrC;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,mBAAmB;AACnB;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,qBAAqB;AACrB,uCAAuC;AACvC;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,mBAAmB;AACnB,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,kBAAkB;AAClB;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC,GAAG;AACJ;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;;AAGA,gBAAgB;AAChB,iBAAiB;AACjB,gBAAgB;AAChB,cAAc;AACd,iBAAiB;AACjB,iBAAiB;AACjB,gBAAgB;AAChB,mBAAmB;AACnB,gBAAgB;AAChB,mBAAmB;AACnB,iBAAiB;AACjB,qBAAqB;AACrB,uBAAuB;AACvB,uBAAuB;AACvB,sBAAsB;AACtB,qBAAqB;AACrB,sBAAsB;AACtB,wBAAwB;AACxB,yBAAyB;AACzB,yBAAyB;AACzB,wBAAwB;AACxB,2BAA2B;AAC3B,yBAAyB;AACzB,4BAA4B;AAC5B,0BAA0B;AAC1B,wBAAwB;AACxB,kBAAkB;AAClB,mBAAmB;AACnB,iBAAiB;AACjB,gBAAgB;AAChB,gBAAgB;AAChB,iBAAiB;;AAEjB;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,gBAAgB;AAChB,oBAAoB;AACpB,gBAAgB;AAChB,wBAAwB;AACxB,iBAAiB;AACjB,gBAAgB;AAChB,iBAAiB;AACjB,iBAAiB;AACjB;AACA,mBAAmB;;AAEnB;AACA,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,qBAAqB;;AAErB;AACA,gBAAgB;AAChB,gBAAgB;;AAEhB;AACA,kBAAkB;AAClB,kBAAkB;;AAElB;AACA,iBAAiB;;AAEjB;AACA,sBAAsB;AACtB,uBAAuB;AACvB,mBAAmB;AACnB,oBAAoB;;AAEpB;AACA,iBAAiB;AACjB,gBAAgB;AAChB,iBAAiB;AACjB,gBAAgB;AAChB,mBAAmB;;AAEnB,mCAAmC;AACnC,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA,yCAAyC;AACzC,qBAAqB;AACrB,sBAAsB;AACtB,gBAAgB;AAChB,gBAAgB;AAChB,eAAe;AACf;;AAEA;AACA;;AAEA,6BAA6B,uBAAuB;AACpD;AACA;AACA,gBAAgB;AAChB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,uBAAuB;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,uBAAuB;AACrC,sBAAsB;;AAEtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;;AAEpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uBAAuB,uBAAuB;AAC9C,uBAAuB,uBAAuB;AAC9C,uBAAuB,uBAAuB;AAC9C,uBAAuB,uBAAuB;;AAE9C,uEAAuE,QAAQ;;AAE/E;AACA;AACA,sBAAsB,uBAAuB;;AAE7C,uEAAuE,QAAQ;;AAE/E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD,sCAAsC,qBAAqB;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB,WAAW;AACX,UAAU;AACV,iBAAiB;AACjB,WAAW;AACX,WAAW;AACX,gBAAgB;AAChB,WAAW;AACX,WAAW;AACX;AACA,eAAe;AACf,mCAAmC;AACnC,aAAa;AACb,mCAAmC;AACnC,UAAU;AACV,UAAU;AACV,+BAA+B;AAC/B;;AAEA,QAAQ;;AAER;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,qBAAqB,EAAE;;;AAGnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC,0BAA0B,aAAa;AACvC,yBAAyB,iBAAiB;AAC1C,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,kEAAkE;AAClE;AACA;AACA;;AAEA,oCAAoC,OAAO;AAC3C;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,OAAO;;AAEtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,+DAA+D;AAC/D;AACA;AACA;;AAEA,gCAAgC,OAAO;AACvC;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,OAAO;AACvD;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iEAAiE;AACjE;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,OAAO;AACvD;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,qBAAqB;AAC3D,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA,aAAa;AACb,qCAAqC,kBAAkB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA,OAAO;AACP,+BAA+B,kBAAkB;AACjD;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,uBAAuB;AACpD;AACA,+BAA+B,uBAAuB;;AAEtD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE,qFAAqF;AACxF;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;;AAEzB,cAAc;AACd,cAAc;AACd,uBAAuB;AACvB,eAAe;AACf,eAAe;AACf,eAAe;AACf,eAAe;AACf,eAAe;AACf,eAAe;AACf,WAAW;AACX,WAAW;AACX,UAAU;AACV,WAAW;AACX,WAAW;AACX,kBAAkB;AAClB;AACA,iBAAiB;AACjB,UAAU;AACV,yCAAyC,eAAe;AACxD,wCAAwC,eAAe;AACvD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA,qBAAqB,UAAU;AAC/B,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA,kBAAkB;AAClB,sCAAsC,2BAA2B;AACjE,uCAAuC;AACvC,wCAAwC;AACxC;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA,eAAe,WAAW;AAC1B,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;;AAEA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG,OAAO;AACV;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX,UAAU;AACV,YAAY;AACZ,qBAAqB;AACrB,cAAc;AACd,WAAW;AACX,WAAW;AACX,mBAAmB;AACnB,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC,EAAE,sBAAsB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG;AACJ;;;AAGA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;;;AAGA,oBAAoB,sBAAsB,qBAAqB,cAAc,EAAE;;AAE/E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA,kCAAkC;AAClC,iCAAiC;AACjC,iCAAiC;AACjC,4BAA4B;AAC5B,iCAAiC;;AAEjC;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA,2BAA2B;AAC3B,oBAAoB;AACpB,6BAA6B;AAC7B;;;;AAIA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,WAAW;AACX,WAAW;AACX,YAAY;AACZ,QAAQ;AACR,mBAAmB;;AAEnB,gBAAgB,kBAAkB;AAClC;AACA;;AAEA;AACA;AACA;AACA,6CAA6C;;AAE7C,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,UAAU,EAAE;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;;AAE/B;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C,uBAAuB;AACvB,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,mBAAmB;AACnB,qBAAqB;AACrB;AACA,wCAAwC;AACxC,eAAe;AACf,WAAW;AACX,QAAQ;;AAER;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,gBAAgB;AAC7B;AACA,oBAAoB,UAAU;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ;AACR,WAAW;AACX,aAAa;AACb,WAAW;AACX,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS,gBAAgB;AACzB;AACA,eAAe,gCAAgC;AAC/C;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,kBAAkB;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA,aAAa,aAAa,QAAQ,+BAA+B;AACjE,aAAa,aAAa,QAAQ,+BAA+B;AACjE,aAAa,cAAc,OAAO,6BAA6B;;AAE/D;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,eAAe;AACf,kBAAkB;AAClB;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,YAAY;AACZ;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;;AAEtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA,WAAW;AACX,SAAS;AACT,aAAa;AACb,WAAW;AACX,YAAY;;AAEZ;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA,OAAO;AACP;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,kCAAkC;AAClC;AACA,eAAe;AACf;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA;AACA,oCAAoC;AACpC;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,oBAAoB;AACpB,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,WAAW;AACxB;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,QAAQ,OAAO,wBAAwB;;AAE9E;AACA;AACA;AACA,eAAe;AACf;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA,8BAA8B;;AAE9B,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,mBAAmB;AACnB;AACA,QAAQ;AACR,mBAAmB;AACnB,aAAa;;AAEb,sCAAsC;;AAEtC,gBAAgB;AAChB,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA,4CAA4C;;AAE5C,aAAa,eAAe;AAC5B;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;;AAEA,KAAK;;AAEL,+BAA+B,kCAAkC;AACjE;;AAEA,KAAK;AACL;;AAEA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,mBAAmB;AACnB;AACA,QAAQ;AACR,mBAAmB;AACnB,aAAa;;AAEb,sCAAsC;;AAEtC,gBAAgB;AAChB,oBAAoB;AACpB,oBAAoB;;AAEpB,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA,aAAa,eAAe;AAC5B;AACA;;AAEA;AACA;;AAEA,KAAK;AACL,UAAU,iCAAiC,EAAE;;AAE7C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,8BAA8B;AAC9B,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;;AAEA,sCAAsC;AACtC;;AAEA,sCAAsC;AACtC;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,IAAI,MAAM,GAAG,MAAM,GAAG;AAChD;AACA;AACA;AACA,SAAS,IAAI,KAAK,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,IAAI,MAAM,IAAI;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iBAAiB;AACjB,WAAW;AACX;AACA,oDAAoD;AACpD,uCAAuC;AACvC;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iBAAiB;AACjB,WAAW;AACX;AACA,4BAA4B;AAC5B,sBAAsB;;AAEtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,wBAAwB;;AAE1D,GAAG;AACH;AACA,4CAA4C;AAC5C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,kBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE,sBAAsB;AACzB;;;AAGA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC,GAAG;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iCAAiC;AAC7E;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,0CAA0C;AACxF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,EAAE,iBAAiB,EAAE;AACxC,mBAAmB,EAAE,eAAe,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,yBAAyB;AAC5B;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,0CAA0C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC,GAAG;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mCAAmC;AACxE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,yCAAyC,mCAAmC;AAC5E;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yCAAyC;AACjE;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sCAAsC;AAC9D;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA,gBAAgB;AAChB;AACA;AACA,4CAA4C,WAAW;AACvD;AACA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,8CAA8C,+BAA+B;AAC7E;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,yCAAyC,mCAAmC;AAC5E;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,4DAA4D;AAC/D;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,WAAW;AACvD;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,yBAAyB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC,GAAG;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,sDAAsD;AACzD;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,yDAAyD;AAC5D;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC,EAAE,0CAA0C;AAC7C;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC,EAAE,0CAA0C;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC,GAAG;AACJ;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yCAAyC;AACnE;AACA;AACA;AACA,6BAA6B,yCAAyC;AACtE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mCAAmC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,CAAC;;AAED,CAAC,EAAE,6BAA6B;AAChC;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,oDAAoD,gDAAgD;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,yEAAyE,mCAAmC;AAC5G;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,8BAA8B;AAC9E;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,+BAA+B;AAClC;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,2DAA2D;AAC9D;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,qDAAqD;AACxD;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6JAA6J;AAC7J;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,uBAAuB;AACvB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,yBAAyB;AACzB;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,2BAA2B;AAC3B;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,6BAA6B;AAC7B;AACA,2BAA2B;AAC3B;AACA,2BAA2B;AAC3B,yBAAyB;AACzB,uBAAuB;AACvB,qBAAqB;AACrB,mBAAmB;AACnB,iBAAiB;AACjB,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,yJAAyJ;AAC5J;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,0HAA0H;AAC7H;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,WAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA;AACA;AACA,mBAAmB;AACnB,iBAAiB;AACjB,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,kNAAkN;AACrN;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,mCAAmC;AACtF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,8DAA8D;AACjE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,uSAAuS;AAC1S;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC,EAAE,kCAAkC;AACrC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,+DAA+D;AAClE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,8GAA8G;AACjH;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,kCAAkC;AACrC;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2CAA2C,YAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,0BAA0B,4CAA4C;AACtE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,0FAA0F;AAC7F;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,sCAAsC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,8FAA8F;AACjG;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,kCAAkC;AACrC;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,iCAAiC;AACpC;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,kCAAkC;AACrC;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oEAAoE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC,wBAAwB,QAAQ;AAChC;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0EAA0E;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC,EAAE,kCAAkC;AACrC;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC,EAAE,iCAAiC;AACpC;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;;AAEA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,YAAY;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC,EAAE,kCAAkC;AACrC;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mCAAmC;AAC7E;AACA;AACA;AACA;AACA;AACA,sCAAsC,sCAAsC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;AAED,CAAC,EAAE,6BAA6B;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,mCAAmC;AACxE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,CAAC;;AAED,CAAC,EAAE,mBAAmB;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qCAAqC,mCAAmC;AACxE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,mCAAmC;AACxE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAA2D;AACnF;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gCAAgC;AAClF;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,4CAA4C,WAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4CAA4C;AAClE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA,CAAC;;AAED,CAAC;AACD,CAAC,EAAE,yBAAyB;AAC5B;AACA;AACA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc;;AAEjS;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;AAED,CAAC,EAAE,mBAAmB;AACtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA,eAAe;AACf;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED,CAAC,EAAE,mBAAmB;AACtB;AACA;AACA;;AAEA,CAAC;;AAED,CAAC,EAAE,uBAAuB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;;AAEA;AACA,wCAAwC,4BAA4B;;AAEpE;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,8CAA8C;AAC9C,8CAA8C;AAC9C,8CAA8C;AAC9C,8CAA8C;AAC9C,8CAA8C;AAC9C;AACA,8CAA8C;AAC9C,8CAA8C;AAC9C,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAsD;AACtD,sDAAsD;AACtD,sDAAsD;AACtD,sDAAsD;AACtD,sDAAsD;AACtD;AACA,sDAAsD;AACtD,sDAAsD;AACtD,sDAAsD;AACtD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;;AAEA;AACA,iBAAiB,QAAQ;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD;;AAEA;AACA;AACA,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA,yBAAyB;AACzB,yBAAyB;;AAEzB;AACA;;AAEA,0BAA0B;AAC1B,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B,0BAA0B;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,OAAO;;AAEpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;AACA;AACA,cAAc,SAAS;AACvB;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;;AAErB;AACA;AACA;AACA;;AAEA,cAAc,QAAQ;AACtB;AACA;;AAEA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;;AAEA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,eAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,eAAe,cAAc;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC,aAAa,gBAAgB;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,KAAK;AACL,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,OAAO;AACP;AACA;AACA,CAAC;;AAED,CAAC,qGAAqG;;AAEtG,CAAC;AACD,CAAC,EAAE,wBAAwB;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,2BAA2B,qBAAqB,qBAAqB;AACrE;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;;AAEA;AACA,wCAAwC,4BAA4B;;AAEpE;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,oCAAoC;;AAExD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO,OAAO,kBAAkB,UAAU;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA,aAAa,QAAQ;;AAErB,aAAa,QAAQ;AACrB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA,eAAe,QAAQ;AACvB;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,GAAG;AACH,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,oBAAoB;AACnC;AACA,cAAc;AACd;AACA,eAAe,QAAQ;AACvB;AACA,iBAAiB,QAAQ;AACzB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA,aAAa,QAAQ;AACrB;AACA;AACA,aAAa,QAAQ;;AAErB,aAAa,QAAQ;AACrB;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA,mBAAmB;AACnB,mBAAmB;AACnB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,yCAAyC;AAC7D,oBAAoB,yCAAyC;AAC7D,oBAAoB,4CAA4C;AAChE,oBAAoB,4CAA4C;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,OAAO;;AAEpB;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,QAAQ;;AAErB;AACA;;AAEA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,QAAQ;;AAErB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;AACA;AACA,cAAc,SAAS;AACvB;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;;AAErB;AACA;AACA;AACA;;AAEA,cAAc,QAAQ;AACtB;AACA;;AAEA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;;AAEA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,eAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,eAAe,cAAc;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC,aAAa,gBAAgB;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,KAAK;AACL,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,OAAO;AACP;AACA;AACA,CAAC;;AAED,CAAC,qGAAqG;;AAEtG,CAAC;AACD,CAAC,EAAE,wBAAwB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE,GAAG;AACT,CAAC;;;;;;;;ACr0kDD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3DA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,sBAAsB,EAAE;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;;;;;;ACzLD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;ACvLtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,KAAK;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,2CAA2C,KAAK;AAChD,0CAA0C,KAAK;AAC/C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,MAAM;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;sDC3tBA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,SAAS;AACrB;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,KAAK;AACL,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;;AAExB,yCAAyC,qBAAqB;;AAE9D;AACA;AACA;AACA;AACA;AACA,kCAAkC,oBAAoB;;AAEtD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc,iBAAiB;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAEA;AACA;AACA;AACA;AACA,GAAG;AAAA;AACH,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA,CAAC;;;;;;;;;ACphBD;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;ACfA;;AAEA;AACA;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpFA;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC;AACA,CAAC,wCAAwC;AACzC;AACA,CAAC,OAAO;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,SAAS,+CAA+C,EAAE;AAC1D,SAAS,gDAAgD,EAAE;AAC3D,SAAS,gDAAgD,EAAE;AAC3D,SAAS,4CAA4C,EAAE;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC,iBAAiB,sCAAsC;;AAEvD;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;;AAEd,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa,iBAAiB;AAC/C;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,0BAA0B,aAAa,iBAAiB;AACxD;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yDAAyD,iBAAiB;AAC1E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA,WAAW,cAAc;AACzB,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,mBAAmB;AAC3F;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,cAAc;AACzB,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS,sBAAsB,WAAW,YAAY;;AAEtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACx4BA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;;;;;;AClKA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc,QAAQ;AACjC,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oDAAoD;AACpE;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yBAAyB;AACtC;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,sCAAsC;AACjD,YAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD;;AAEvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;AC1mBA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnIA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA,GAAG,IAAI;AACP;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtBA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA,GAAG;AACH;AACA;;AAEA,CAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA,KAAK;AACL;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB;;AAElB;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB,4BAA4B;;AAE/C;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,6BAA6B;AAC7B,OAAO,yCAAyC,EAAE,UAAU,EAAE;AAC9D;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB;;AAEpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,OAAO,OAAO;AAClC,oBAAoB,OAAO,OAAO;AAClC,oBAAoB,OAAO,OAAO;AAClC,oBAAoB,OAAO,OAAO;AAClC,oBAAoB,OAAO,OAAO;AAClC,oBAAoB,OAAO,OAAO;AAClC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC","file":"bundle.485023aaf7e26c3886c4.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 485023aaf7e26c3886c4","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 0\n// module chunks = 0","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 1\n// module chunks = 0","/**\n * Check if `obj` is an object.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(obj) {\n  return null !== obj && 'object' === typeof obj;\n}\n\nmodule.exports = isObject;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/superagent/lib/is-object.js\n// module id = 2\n// module chunks = 0","const url = require('url');\nconst request = require('superagent');\nconst randomColor = require('randomcolor');\n//const kbpgp = require(\"imports-loader?auth_sign=./onlykey-api.js,auth_decrypt=./onlykey-api.js!./kbpgp.js\");\nconst urlinputbox = document.getElementById('pgpkeyurl');\nconst urlinputbox2 = document.getElementById('pgpkeyurl2');\nconst messagebox = document.getElementById('message');\nconst button = document.getElementById('onlykey_start');\nvar ring = new kbpgp.keyring.KeyRing;\nvar sender_private_key; //Placeholder key\nvar sender_public_key;\nvar recipient_public_key;\nvar poll_type, poll_delay;\nvar _status;\n\nvar test_pgp_key = `-----BEGIN PGP PRIVATE KEY BLOCK-----\nVersion: TEST KEY v1.0.0\nComment: THIS KEY IS JUST A PLACEHOLDER\n\nxcaGBFms0QoBEAC9hQ0tnhwnSYlLQmVTsvVWyYnnS8woQnLLr0gz9gb2ZSxE\ngh7SMQewx5xff7zsxhcRoID00tarP4KueEOx2sPwFFgbK5jhN1UDEA0zG3oA\n/bkEet6c7Q4Y25wlp0eYRpW2KIEdVH9uzNyUS7S5Phw8QtvxWLI+rudmhrNk\nPvjm4c7kPT1TpfCYDMQmF7RVSaXYDH6vE/gqLKjiD/71LQZmQzDtLkvC2fh4\nfrBhdZUVHmIuZaDZ/8QtcslODovqAe6stBtCsgZ1lEx8otbTpt88PIYbPNGi\nkiHrbjK3CYusoq1Rl4/LN/jFkJnO9J8KpfA5R+lnQ6GfzacQ3BfpkQ7Ib2Tu\nNSwHOe5nSGIpbsujWh6GAmRzo+AOHmbUj6gbuaA8qIdD+VDXNh/O4g26be+l\nRO12pz6VOCk2W+Gmvwmbk789atmNOIk0eUeJ/jPFyXVqM5DMfHuBssydqQr8\n9EoQo+id2ev8glfmx1kT7oiN5d/WCpEq4SSxf7TxNawqIEK5LAgv6dONd8e0\nGsTxibRVxqrTDc8q07dIgXU4nybCBHRrcd1gj785uJcSsuSSB5TnRRmcst+q\nBsunUZbM8iw9g8OUqZj2k70utgIaP5kIIFhMgne9iLYd/g47pMLdoAWcQXdL\npwcHfB3jF8ukuQCpHg1FaKP8oU1jO6Yrk9FHwwARAQAB/gkDCHD+rb/6JEKx\nYOw4tTZ1yyHEQRjSoFuwx2vsi1T96TTF4JlTvncVkaFsbvYrTdybEUjc8e6a\nUuKDZoMKzr3VBJXbXXhtZLZlWhd+LWN4bFixn9wifoGHN9ptNzobMo3dibjA\ncMkNB6ocxWrlbvq44WNYXPezFIloSzf6vb2puZjVcd1nJSLxHY5HaykTdqwi\n2TCQhOTa3EBwlQpNNgUdetA3erf22r+FesfYSVjUt8bO6b7jwaXHUAg0RU9D\nSCLPCrAqz4WY9RUxziMiUY531LeKffpALwoA8Qwt9F4i03ecrBw7XKbHvL9O\nKRcg+3HUNxT9+3P3v4r3Vyqa80g2iYfiA/yd5f6wKWiYbuhaHiHnFljnPqjr\nufSB1hWJoQVfK7Lau/PIZQqZ3vpo3xQJkG7QyYF5hM5ZKlFd9vqxUQhn2mI4\nzC1aOhg/CDLvatspb2J9JxH457YxWsXK4garUl0g6EYTdSZRalLfQ1EHpvzM\njSwwFN8d+UgaqO/X/I3G4oHfnaNRY4YdpIpAZZ1JvKS7v2O/r5ct46bVKQUg\nTKffG+4QI/g9sizhmBzOTFWO2i8wdu5gvVxvl7dnPrgxyPBlZK9lryBW2++l\nYsjQ41TxPmdzZGfzE3MPvQZ+Sni5QXA3icKDWzEcp8Zd8KukVyvKnVJiMM5F\nmpvtcQbhnphpiFFt9aEPO1soid02lNG3qlO97EpS1KExZOW95hF9u2F2q9p/\n0BTcahyxjoE1oinakjg/BEqcF8TgaEmpTtDYoljz87vpRyEHKAOl3IXyiubB\nWMyZfraF6hZ3mRGKofOX8A7hdqFx1j/6myzywf1JsRSa6u8Dp4m38mDKKhcf\nERqDcVWuJafZBWOXPcdxIVBDmopTn7uM8Ii0wEYWBFqgf6dN2p6BprDcm2Om\nqiqhDE3UoqjQXgHqh7Bn8AjpfqSkXFRsrkOhcbyqzYGt+kEbnFPFP1QhyWSj\n60p7eMxW7bG6rJcyOWvq5GZaaVime3+sXTV37vYzuNWc0RQ3FklKbiLvVCjL\nNHbWOUtQpHE/i39UUK31/Rncqzgoenn6ThqXZZZl+LP8FFIOZ80VnlSxM71U\nd7XRqk1wjFE7NBzbtTypaDXbm3Wilq9SJ68kfOxZUC9asAvU5B1teiVshFA2\nQmMTCz0hng8/HldlntUOVQjmh/gC5E52cva6QF0Cu8JKfVGoAC5wEIuV3gVx\nZu+IVEtHWpCA8bOudtYx4QZvKVCbjSaK6Rf1UE+cUfLESCnXt9BHzcPq0q90\nWVMXNVSS0CQ84FCk3zAZgnrZBmOFuiXvXXqrpS8w2k8LFiP5or4ZCYTc0qUp\npSFk8QBnfdX63IXifBQtuaD1Iz49Lf2Vpfxv+F/qXaPQ6Bl3bfv1QY9nNh48\n+OVZBpnMas8W4co/Ke7GiOJKqScpcW/MlaKZVLR2ywthC4vpTjFBiK3epLOF\nJ63bR/0TV5Koj62CdyVENtecbfWce5yx9s5AAdKDoA3Q18mMm13OJb868Nu0\nO2ZlAXb/3PMWp8zS6zd6gP8Aw8q1a+NlZVtyFA7aaBEQyRbHMG/Qeyy6wmlE\nnP/rfuWVuPLmSD7GsS6TkofmLsk/fuWbuAFBnYuoWM+XrRwWX0SOmZJzYELV\nshnhPaTO+71B4vsCbuQVfNcMYBmpt7iAG23Ky1FNnKy8jszwq4S2XPRukT0+\nkKbexsjiSgRLeEeURnbNTVdV22hAm2G/9rj4xWrql/YLKkf9JRVQNIxFHjKk\n0kaoM9l5Ju38Jm02BQqFxlcEBTbNGnRlc3RjcnAzIDx0ZXN0Y3JwM0BjcnAu\ndG8+wsF4BBMBCAAsBQJZrNEKCRAan+C56LYFgQIbAwUJHhM4AAIZAQQLBwkD\nBRUICgIDBBYAAQIAALXZEACyRUJS/eaI6L3LYm13grCU072EFkXjdFapAi8R\n7BaG+5nePCNn+hCzi4FhfNvk8vWfubza8xhwbKwrVJWjA+TZZeeOPOxkkqj3\nkTYxUdKx5VT+b3ifb+Tfn+MtH7ZWC4g9w+4dK0zjf23jBuR6fJxfpo2fBF8h\nQaz2ik8wv0Dn7miCtzC8gxXgUXcG4XWC9lZ7d7fcTQoO8RCmJmdNHG8Jsr12\nRsJUgCHGq2sM4Dcr8ggfoUTBUlobLzkJpHSA7McTz17PMh7FGVHRfGjFZqGs\nb+G8/Ln5HkPHr5SNfHlxqgvYWYWPog1pB9ASf6Aap8tRHijWHedIc3O+i8Hx\nyylcTauusl3qMY6O/AlmI8DqWQYYEUluG9i+sPdAOZDl42tFAP5ZA28OmoJ1\nPFoIvPrO0gBwkEdGDOnmc3RAHZazxyXJDjbGyo1Rexg9UxprZWDR8ySlUTdw\nDFkEMDkwwMZioBwZMR2ZevOwZe6OQYUhpwUNeIfSmvLUAaxEMYnr9peYKswv\nTdCjjkw8ltNi/UGMxKQ2Kbfa2rg+rc3Qn7fqsJRkG6IIqsRsQAthVa5Ychwb\nkxKovp44hEZyFfswRZuBDdO/VCJ+G9gKQVP7JVTeRcx/e5se3XXY3CF5fUg+\nLxGIT2qnqbmCrVwtmR3qr9ZB0/Jvw7bb0J8FkVp8hw37i8fGhgRZrNEKARAA\nyWB602RZce8GwQ8p5qAfd0JAQjZT75prtFW2Snm7BMt1YB7hVaPoxybrOcpe\noiKtz5WolVKh/jwIn8RZhCQCdczIC/jULh1HYbD4285OsJT4b6+0qUq3YkZm\nLN4CDLhvhYy/7d1nP01L0Q2pCjlGzFHARWjbmz2bgvUeTGqkXtzsknzwvkne\nX9A4WzpmfU61nl0n3vlptzf0gEWzPhLqk/c3c7zrpZo0ZjiBhGj8XLG3q+IE\nBi8f477/jYho8qMRnnPQ2PlIG/BUyHixY+B2QWIo71MPOC0BKvVHYWqjC/H0\nok2lXAn90WqHE4OL1e+TX44O6qA2178qERB61Kg42I0oDwZ2/WUMuFGMUuGh\nl8eOSujmXll32Fi/TnEFCkgDaOUbViYkLkIZs7PB4CBtS3UEsSv/unQtvUmz\nLuyOwP+O1ojSnKY934TJmHykSKCu46ema0bIGTGfiGZTZzTUOnELOPkDTfvp\n6FigDdjxNfz9vXDsftLWf1w08Sov9rcPqd8/aVnGTnuDZ8r3+e0Nh5NpcfIP\no11Iym2RKEt7aY5RYVk7YuBtxc9egQQInDsTCMJU2IGIRPcS4KZs42G55Z0F\nhJ/ptqme39FAXNImuWA7r3VMR4F+1knyC8mwpDFITJ2r3t+w7Qmy9kOzgDVm\nSUeMmfz+1r7oBE/HNAcc9yMAEQEAAf4JAwj9HN4KKhQ9xWCLHh5NvkoMaVdA\nVhMtnGD/xwzE+XI0uG3ngkFIaDyDf+xOu6UXF5cWscS2AdNmrChXurx6Qqd9\nPlhAprLwM4qoO/Nf+bZ+liT9fEHdpTbFE0PMAxAU4T74YIYVtyxVgEuzvhPt\nPRijVEfZRa2UzKQp+sPhn5EM/bv+fmbUrIgs58R0i8gcub5+qu/HdbpXqMzy\nJfd+ouYIavew/4stjbhniMJ++8SzMpA8hK7C7C1MA8rU1jt9ORh1HvCBV75v\nGZEuHubTSPSQCmisnDlft6aPv4z1cf1IDl1pKt/tek7h6pI4eHaPLvqwdtLr\nYDLxtH2aNZjL4PugSZhpDfBbeZYlSSz3pMtHpClCGhQp+ekYL3SYBuj8VSXb\n9IjM0Z3ymQjCQVZmuxUrlKISG3CayTwed3vOunCEH2vNoplF2HD7018PE5xZ\nwXCLA9Se27xOaq4K+IKnFSJYKenfqDxEVufXF/aRRN4MGsu40QQq6HGOu4BI\nJk4mde7LhGcl2q0bktwklnEUl9uc7DSQ7xOopQj6A8CCjh+sVhrrGNpIKGQ+\nwLodZXrUrMgVop2cOPcTCZmFGsqQFkx7aKZ7ZhucYptHV2SmMe7zL8DPls3r\nKkHy2eFCyfA+7Px9Kc83RAyrQzlnLmFobw+QXOXu2tj65jGoF5xPeS1uLXR+\nGekZfYu29babcHes75+tT0O/1yTpawQTxi5+3j7DcuHXOa5dAiQWt3fg69Vd\njr9zvlWQSDdfeSXcvY82XIleK91YZDyqe+cRlG5f8RKzU68efETRlHqkxtgD\niCMTbc+9z6wFTsGkSK0vN30KMUCKt4r/x77B69qDxRoAQVVteicE267dWKPF\nPh44n/qbOev7NrGNPR+4i6of1uJ+J7LG505mqgD5sHHcSreCzbB399LrbUBM\nsn1beqThPJSDzUFI9h/wQ14dk06pbdqlWXu8s90o6Or2BIew4K4HDFuQ0ilO\nW7KmXbV5sluY6dQQhf21/T8Rhfz6HUCN9RD+EObJ2KAngAwXm4PB8gi+TM7K\n6jiuXOGQtqi2YIagqGgMbzVPYxe7BZorCAWw0+VxqUZ5YMTIyx5v+OO3wK+e\nagafyTxstArtJTG4OfDHAcCCCZ0GwrLOGbV6rkHqKVZYa7tf4qsKamS0ARbt\nghI2Mp17lMbG/0IIYaCfSkTOyPwGS+9hoCwjPngxXWKMCg46UYQZSFKBEbqw\nyOIBM4hrafLkFf7+IdsNthHMUXV2EiJ/6eE5xS28DbODSxACkBwNfnZX18HY\nvJHtRpIGc0MxT+M/pUH6FhyhoCLh/Z7UdAeiSeiRJsYUtE2fd4n2ViePfYx+\nBwes2nAw1T1+HLzX6K2hY8im9BW6oOcgRlbFLP3AYElI2snT1ShT3Qs06PgM\n/zXDvMkYetyEn5vh/u1x1vT4sxn7sxd/MLyxf/qE7IB97l6BRwXR6Qcegklo\nrspqfWZbf+Q4qiJ8jF7flhp8YMul78nC7i+HnRyPmG5I/aJwMSn0qR5jjBf5\nOEgaGpdONexmWOzcNbTBv6aT1EOSDdkM0epXw7YdT7VftP+L4pnTrhNtpUNH\nhX7bhaYVDebSgqdZGFj6W1TXxFtZWnqWbtbwulUMOZ98a20CTadZYE1qJwWo\nz8ioOPr9LEcmwufHZ/zI0IxKgi9l6pi+bi+HyqIwTTjQx7x/MAhXvClc0FkZ\n+AmNthz5nY/yEqvcVONjPy/Wl2lPx/50P+f8BnWnjt6LiK/t34vM+Zzefjbj\nJw/2Bg/YeYz4wsF1BBgBCAApBQJZrNEKCRAan+C56LYFgQIbDAUJHhM4AAQL\nBwkDBRUICgIDBBYAAQIAALjmEABy83c24kaDfx9QHwETp5Wh3AVW1EcyphXC\nN6C5PLKZ6FobdZbIZbXaNDkRdFzTNl7JnWvb0oyy54/Vc3bcKlNQ+Y/BzFoG\nYIzU8eoqw+a/rT67gENRCxNsdg9BSBplC+hT+7LVKiWNBBokfd0ud7VI2lld\nLPlD+23IMCftrqvdEnom7E+cP45B32Kvbgma+GHHVbtR6O8T1m0iWMSViOO7\n9W954NTS+Y4LEMuQiZlHdl1169E+RTZM1iPiWu8lKxeyNO8zHgU3jQYmR8dY\n4ovwEqQ3biIXDLSAXKgk+ga+Q8pM0CetcKZI/iwcPYtmPnBUrNc8ZswwMmI2\njpRYBRSCriLS6nRmW+pX1Y+5RqUVPEYbUqCfz97NklSSyhVtXhTK/h8pEHZW\n0KZJAwBaR16Opzu2+RpZ6GfvIVvOlYf97xwRHARrvkF4wN66qldwePr2o/N3\nUrnqD/+H1aVo443fmuvquB0FuCtWgCv47Ak4S7c5uk/IdzyGzuj5vCE8ZGDu\nTZ+PdUwKuBikrubuRujQC2sblQ0PxI3zZgd0mPWsqo8+qKu2iO8ZDnB942ce\nW3Uv9O0FAWVecGfcb3FONGskgoaQNMQSr9bITRMB+6BDj8ut4HMnrRzhSANL\nAAuXXx+QEJsopLffeE+9q0owSCwX1E/dydgryRSga90BZT0k/g==\n=ayNx\n-----END PGP PRIVATE KEY BLOCK-----`;\n\nwindow.custom_keyid;\n\nwindow.initok = initok();\n\n//window.auth_sign = auth_sign();\n\n//window.auth_decrypt = auth_decrypt();\n\nwindow.initapp = function(skipBtn) {\n  const val = document.action.select_one.value;\n  _status = val;\n  if (!skipBtn) button.textContent = val;\n  document.action.select_one.forEach(el => el.addEventListener('change', window.initapp.bind(null, false)));\n};\n\nclass Pgp2go {\n    constructor() {\n        document.getElementsByTagName('fieldset')[0].style.backgroundColor = randomColor({\n            luminosity: 'bright',\n            format: 'rgba'\n        });\n    }\n\n\tasync startDecryption() {\n\t\t\tbutton.classList.remove('error');\n\t\t\tbutton.classList.add('working');\n      if (urlinputbox.value == \"\" && _status=='Decrypt and Verify') {\n          this.showError(new Error(\"I need senders's public pgp key to verify :(\"));\n          return;\n      } else if (urlinputbox.value != \"\") {\n        let keyurl = url.parse(urlinputbox.value);\n          if (urlinputbox.value.slice(0,10) != '-----BEGIN') { // Check if its a pasted public key\n              sender_public_key = await this.downloadPublicKey(urlinputbox.value);\n            } else {\n              sender_public_key = urlinputbox.value;\n            }\n          }\n          this.decryptText(sender_public_key, messagebox.value);\n\t}\n\n\tdecryptText(key, ct) {\n      switch (_status) {\n        case 'Decrypt and Verify':\n          this.loadPublic(key);\n          button.textContent = 'Decrypting and verifying message ...';\n          break;\n        case 'Decrypt Only':\n          button.textContent = 'Decrypting message ...';\n          var Decrypt_Only = true;\n          break;\n        default:\n      }\n      this.loadPrivate();\n      kbpgp.unbox({\n              keyfetch: ring,\n              armored: ct\n          }, (err, ct) => {\n          if (err)\n              return void this.showError(err);\n          if (Decrypt_Only) {\n          button.textContent = \"Done :)\";\n          } else {\n            var ds = recipient_public_key = null;\n              ds = ct[0].get_data_signer();\n              if (ds == null) {\n                button.textContent = \"Done :) Message has no signature \";\n              } else {\n                console.log(ds);\n                if (ds) { recipient_public_key = ds.get_key_manager(); }\n                if (recipient_public_key) {\n                  console.log(\"Signed by PGP Key\");\n                  var keyid = recipient_public_key.get_pgp_fingerprint().toString('hex').toUpperCase();\n                  keyid = keyid.slice(24, 40);\n                  var userid = recipient_public_key.userids[0].components.email.split(\"@\")[0];\n                  console.log(keyid);\n                  console.log(userid);\n                  button.textContent = \"Done :)    Signed by \" + userid + \" (Key ID: \" + keyid + \")\";\n              }\n            }\n          }\n          messagebox.value = ct;\n          messagebox.focus();\n          messagebox.select();\n          button.classList.remove(\"working\")\n      });\n  }\n\n  async startEncryption() {\n      if (urlinputbox.value == \"\" && (_status=='Encrypt and Sign' || _status=='Encrypt Only')) {\n          this.showError(new Error(\"I need recipient's public pgp key to encrypt :(\"));\n          return;\n      }\n      if (urlinputbox2.value == \"\" && (_status=='Encrypt and Sign' || _status=='Sign Only')) {\n          this.showError(new Error(\"I need sender's public pgp key to sign :(\"));\n          return;\n      }\n      if (urlinputbox.value.slice(0,10) != '-----BEGIN') { // Check if its a pasted public key\n          console.info(urlinputbox.value.slice(0,10));\n          sender_public_key = await this.downloadPublicKey(urlinputbox.value);\n          console.info(\"sender_public_key\" + sender_public_key);\n          } else {\n            sender_public_key = urlinputbox.value;\n      } if (urlinputbox2.value.slice(0,10) != '-----BEGIN') { // Check if its a pasted public key\n        console.info(urlinputbox2.value.slice(0,10));\n        recipient_public_key = await this.downloadPublicKey(urlinputbox2.value);\n                          console.info(\"recipient_public_key\" + recipient_public_key);\n          } else {\n            recipient_public_key = urlinputbox2.value;\n      }\n        this.encryptText(sender_public_key, recipient_public_key, messagebox.value);\n  }\n\n  downloadPublicKey(url) {\n    return new Promise(resolve => {\n      button.textContent = 'Downloading public key ...';\n      if (url.slice(0,8) != 'https://') {\n        console.info(url);\n        url = 'https://keybase.io/'.concat(url, '/pgp_keys.asc');\n        console.info(url);\n      }\n      request\n          .get(url)\n          .end((err, key) => {\n              if (err) {\n                  err.message += ' Try to directly paste the public PGP key in.';\n                  this.showError(err);\n                  return;\n              }\n              resolve(key.text);\n              return key.text;\n          });\n        });\n  }\n\n  encryptText(key1, key2, msg) {\n    button.classList.remove('error');\n    button.classList.add('working');\n      switch (_status) {\n        case 'Encrypt and Sign':\n          this.loadPublic(key1);\n          this.loadPublicSignerID(key2);\n          this.loadPrivate();\n          var params = {\n            msg: msg,\n            encrypt_for: recipient_public_key,\n            sign_with: sender_private_key\n          };\n          button.textContent = 'Encrypting and signing message ...';\n          break;\n        case 'Encrypt Only':\n          this.loadPublic(key1);\n          var params = {\n            msg: msg,\n            encrypt_for: recipient_public_key\n          };\n          button.textContent = 'Encrypting message ...';\n          break;\n        case 'Sign Only':\n          this.loadPublicSignerID(key2);\n          this.loadPrivate();\n          var params = {\n            msg: msg,\n            sign_with: sender_private_key\n          };\n          button.textContent = 'Signing message ...';\n          break;\n        default:\n      }\n      kbpgp.box(params, (err, results) => {\n          if (err) {\n              this.showError(err);\n              return;\n          }\n          button.textContent = 'Done :)  You can paste encrypted message into an email, IM, whatever.';\n          messagebox.value = results;\n          messagebox.focus();\n          messagebox.select();\n          document.execCommand('SelectAll');\n          document.execCommand(\"Copy\", false, null);\n          button.classList.remove('working');\n      });\n  }\n\nloadPublic(key) {\n  button.textContent = \"Checking recipient's public key...\";\n  if (key == \"\") {\n    this.showError(new Error(\"I need recipient's public pgp key :(\"));\n    return;\n  }\n  kbpgp.KeyManager.import_from_armored_pgp({\n      armored: key\n  }, (error, recipient) => {\n      if (error) {\n          this.showError(error);\n          return;\n      } else {\n          recipient_public_key = recipient;\n          ring.add_key_manager(recipient);\n      }\n  });\n}\n\nloadPublicSignerID(key) {\n  button.textContent = \"Checking sender's public key...\";\n  if (key == \"\") {\n    this.showError(new Error(\"I need sender's public pgp key :(\"));\n    return;\n  }\n  kbpgp.KeyManager.import_from_armored_pgp({\n      armored: key\n  }, (error, sender) => {\n      if (error) {\n          this.showError(error);\n          return;\n      } else {\n          sender_public_key = sender;\n          var keyids = sender_public_key.get_all_pgp_key_ids();\n          if (typeof keyids[2] !== \"undefined\") {\n            poll_delay = 1;  //Assuming RSA 2048\n            var subkey = 2;\n          } else {\n            poll_delay = 8;  //Assuming RSA 4096 or 3072\n            var subkey = 0;\n          }\n          window.custom_keyid = keyids[subkey].toString('hex').toUpperCase();\n          window.custom_keyid = window.custom_keyid.match(/.{2}/g).map(hexStrToDec);\n          console.info(\"custom_keyid\" + window.custom_keyid);\n      }\n  });\n}\n\nloadPrivate() {\n  var _this = this;\n  kbpgp.KeyManager.import_from_armored_pgp({\n      armored: test_pgp_key\n  }, (err, sender) => {\n      if (err)\n          return void this.showError(err);\n\n      if (sender.is_pgp_locked()) {\n          let passphrase = 'test123';\n\n          sender.unlock_pgp({\n              passphrase: passphrase\n          }, err => {\n              if (!err) {\n                  console.log(`Loaded test private key using passphrase ${passphrase}`);\n                  sender_private_key = sender;\n                  ring.add_key_manager(sender);\n              }\n          });\n      } else {\n          console.log(\"Loaded private key w/o passphrase\");\n      }\n  });\n}\n\n\tshowError(error) {\n        console.log(\"error:\", error);\n        button.textContent = error.message;\n        button.classList.remove('working');\n        button.classList.add('error');\n    }\n\n}\n\nlet p2g = new Pgp2go();\n\nbutton.onclick = function () {\n    console.log(\"status:\", _status);\n    switch (_status) {\n        case 'Encrypt and Sign':\n        case 'Encrypt Only':\n        case 'Sign Only':\n            poll_type = 4;\n            p2g.startEncryption();\n            break;\n        case 'Decrypt and Verify':\n        case 'Decrypt Only':\n            poll_type = 3;\n            poll_delay = 1;\n            p2g.startDecryption();\n            break;\n        case 'pending_pin':\n            break;\n    }\n    return false;\n};\n\nurlinputbox.onkeyup = function () {\n    let rows_current = Math.trunc((urlinputbox.value.length * parseFloat(window.getComputedStyle(urlinputbox, null).getPropertyValue('font-size'))) / (urlinputbox.offsetWidth * 1.5)) + 1;\n    urlinputbox.rows = (rows_current > 10) ? 10 : rows_current;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app.js\n// module id = 4\n// module chunks = 0","!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.kbpgp=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, DSA, ECDH, ECDSA, ElGamal, RSA;\n\n  C = require('./const').openpgp.public_key_algorithms;\n\n  RSA = require('./rsa').RSA;\n\n  DSA = require('./dsa').DSA;\n\n  ElGamal = require('./elgamal').ElGamal;\n\n  ECDSA = require('./ecc/ecdsa').ECDSA;\n\n  ECDH = require('./ecc/ecdh').ECDH;\n\n  exports.get_class = function(n) {\n    switch (n) {\n      case C.RSA:\n      case C.RSA_ENCRYPT_ONLY:\n      case C.RSA_SIGN_ONLY:\n        return RSA;\n      case C.ELGAMAL:\n        return ElGamal;\n      case C.DSA:\n        return DSA;\n      case C.ECDSA:\n        return ECDSA;\n      case C.ECDH:\n        return ECDH;\n      default:\n        throw new Error(\"unknown public key system: \" + n);\n    }\n  };\n\n}).call(this);\n\n},{\"./const\":5,\"./dsa\":6,\"./ecc/ecdh\":9,\"./ecc/ecdsa\":10,\"./elgamal\":12,\"./rsa\":67}],2:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var BaseKey, BaseKeyPair, C, K, SHA256, SHA512, SRF, bn, bufeq_secure, iced, konst, __iced_k, __iced_k_noop, _ref;\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  konst = require('./const');\n\n  C = konst.openpgp;\n\n  K = konst.kb;\n\n  _ref = require('./hash'), SHA256 = _ref.SHA256, SHA512 = _ref.SHA512;\n\n  bn = require('./bn');\n\n  bufeq_secure = require('pgp-utils').util.bufeq_secure;\n\n  SRF = require('./rand').SRF;\n\n  exports.BaseKey = BaseKey = (function() {\n    function BaseKey() {}\n\n    BaseKey.alloc = function(klass, raw, d) {\n      var err, o, orig_len, _i, _len, _ref1, _ref2;\n      if (d == null) {\n        d = {};\n      }\n      orig_len = raw.length;\n      err = null;\n      _ref1 = klass.ORDER;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        o = _ref1[_i];\n        if (err == null) {\n          _ref2 = bn.mpi_from_buffer(raw), err = _ref2[0], d[o] = _ref2[1], raw = _ref2[2];\n        }\n      }\n      if (err) {\n        return [err, null];\n      } else {\n        return [null, new klass(d), orig_len - raw.length];\n      }\n    };\n\n    BaseKey.prototype.serialize = function() {\n      var e;\n      return Buffer.concat((function() {\n        var _i, _len, _ref1, _results;\n        _ref1 = this.ORDER;\n        _results = [];\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          e = _ref1[_i];\n          _results.push(this[e].to_mpi_buffer());\n        }\n        return _results;\n      }).call(this));\n    };\n\n    BaseKey.prototype.validity_check = function(cb) {\n      return cb(null);\n    };\n\n    return BaseKey;\n\n  })();\n\n  exports.BaseKeyPair = BaseKeyPair = (function() {\n    function BaseKeyPair(_arg) {\n      this.priv = _arg.priv, this.pub = _arg.pub;\n      this.pub.parent = this;\n      if (this.priv != null) {\n        this.priv.parent = this;\n      }\n    }\n\n    BaseKeyPair.prototype.serialize = function() {\n      return this.pub.serialize();\n    };\n\n    BaseKeyPair.prototype.hash = function() {\n      return SHA256(this.serialize());\n    };\n\n    BaseKeyPair.prototype.ekid = function() {\n      return Buffer.concat([new Buffer([K.kid.version, this.get_type()]), this.hash(), new Buffer([K.kid.trailer])]);\n    };\n\n    BaseKeyPair.prototype.can_sign = function() {\n      return this.priv != null;\n    };\n\n    BaseKeyPair.prototype.can_decrypt = function() {\n      return this.priv != null;\n    };\n\n    BaseKeyPair.prototype.has_private = function() {\n      return this.priv != null;\n    };\n\n    BaseKeyPair.prototype.fulfills_flags = function(flags) {\n      return false;\n    };\n\n    BaseKeyPair.prototype.is_toxic = function() {\n      return false;\n    };\n\n    BaseKeyPair.prototype.nbits = function() {\n      var _ref1;\n      return (_ref1 = this.pub) != null ? _ref1.nbits() : void 0;\n    };\n\n    BaseKeyPair.prototype.good_for_flags = function() {\n      return C.key_flags.encrypt_comm | C.key_flags.encrypt_storage | C.key_flags.certify_keys | C.key_flags.sign_data;\n    };\n\n    BaseKeyPair.prototype.eq = function(k2) {\n      return (this.type === k2.type) && (bufeq_secure(this.serialize(), k2.serialize()));\n    };\n\n    BaseKeyPair.prototype.can_perform = function(ops_mask) {\n      if ((ops_mask & konst.ops.sign) && !this.can_sign()) {\n        return false;\n      } else if ((ops_mask & konst.ops.decrypt) && !this.can_decrypt()) {\n        return false;\n      } else {\n        return true;\n      }\n    };\n\n    BaseKeyPair.parse = function(klass, pub_raw) {\n      var err, key, len, _ref1;\n      _ref1 = klass.Pub.alloc(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];\n      if (key != null) {\n        key = new klass({\n          pub: key\n        });\n      }\n      return [err, key, len];\n    };\n\n    BaseKeyPair.parse_kb = function(klass, pub_raw) {\n      var err, key, len, _ref1;\n      _ref1 = klass.Pub.alloc_kb(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];\n      if (key != null) {\n        key = new klass({\n          pub: key\n        });\n      }\n      return [err, key, len];\n    };\n\n    BaseKeyPair.prototype.add_priv = function(priv_raw) {\n      var err, len, _ref1;\n      _ref1 = Priv.alloc(priv_raw), err = _ref1[0], this.priv = _ref1[1], len = _ref1[2];\n      return [err, len];\n    };\n\n    BaseKeyPair.alloc = function(klass, _arg) {\n      var err, priv, pub, _ref1, _ref2;\n      pub = _arg.pub, priv = _arg.priv;\n      _ref1 = klass.Pub.alloc(pub), err = _ref1[0], pub = _ref1[1];\n      if ((err == null) && (priv != null)) {\n        _ref2 = klass.Priv.alloc(priv, pub), err = _ref2[0], priv = _ref2[1];\n      }\n      if (err != null) {\n        return [err, null];\n      } else {\n        return [\n          null, new klass({\n            priv: priv,\n            pub: pub\n          })\n        ];\n      }\n    };\n\n    BaseKeyPair.prototype.read_priv = function(raw_priv) {\n      var err, _ref1;\n      _ref1 = this.Priv.alloc(raw_priv, this.pub), err = _ref1[0], this.priv = _ref1[1];\n      return err;\n    };\n\n    BaseKeyPair.prototype.find = function(i) {\n      return i.mod(this.max_value());\n    };\n\n    BaseKeyPair.prototype.hide = function(_arg, cb) {\n      var L, err, i, max, n, r, r_bits, ret, slosh, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      i = _arg.i, max = _arg.max, slosh = _arg.slosh;\n      ret = err = null;\n      n = this.max_value();\n      (function(_this) {\n        return (function(__iced_k) {\n          if ((L = n.bitLength()) > max) {\n            return __iced_k(err = new Error(\"Can't hide > \" + max + \" bits; got \" + L));\n          } else {\n            r_bits = (max - L) + slosh;\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/basekeypair.iced\",\n                funcname: \"BaseKeyPair.hide\"\n              });\n              SRF().random_nbit(r_bits, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return r = arguments[0];\n                  };\n                })(),\n                lineno: 127\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return __iced_k(ret = r.multiply(n).add(i));\n            });\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    BaseKeyPair.prototype.validity_check = function(cb) {\n      return this.pub.validity_check(cb);\n    };\n\n    return BaseKeyPair;\n\n  })();\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./bn\":4,\"./const\":5,\"./hash\":14,\"./rand\":65,\"buffer\":80,\"iced-runtime\":118,\"pgp-utils\":163}],3:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var BaseX, BigInteger, base32, base58, buffer_to_ui8a, nbi, nbs, nbv, _ref;\n\n  _ref = require('bn'), nbv = _ref.nbv, nbi = _ref.nbi, BigInteger = _ref.BigInteger;\n\n  nbs = require('./bn').nbs;\n\n  buffer_to_ui8a = require('./util').buffer_to_ui8a;\n\n  BaseX = (function() {\n    function BaseX(alphabet) {\n      var a, i, _i, _len, _ref1;\n      this.alphabet = alphabet;\n      this.base = this.alphabet.length;\n      this.basebn = nbv(this.base);\n      this.lookup = {};\n      _ref1 = this.alphabet;\n      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {\n        a = _ref1[i];\n        this.lookup[a] = i;\n      }\n    }\n\n    BaseX.prototype.encode = function(buffer) {\n      var c, chars, num, pad, q, r, _i, _len;\n      num = nbi().fromBuffer(buffer);\n      chars = (function() {\n        var _ref1, _results;\n        _results = [];\n        while (num.compareTo(BigInteger.ZERO) > 0) {\n          _ref1 = num.divideAndRemainder(this.basebn), q = _ref1[0], r = _ref1[1];\n          c = this.alphabet[r.intValue()];\n          num = q;\n          _results.push(c);\n        }\n        return _results;\n      }).call(this);\n      chars.reverse();\n      pad = [];\n      for (_i = 0, _len = buffer.length; _i < _len; _i++) {\n        c = buffer[_i];\n        if (c === 0) {\n          pad.push(this.alphabet[0]);\n        } else {\n          break;\n        }\n      }\n      return (pad.concat(chars)).join('');\n    };\n\n    BaseX.prototype.decode = function(str) {\n      var base, c, char_index, i, num, pad, start, _i, _j, _len, _ref1;\n      num = BigInteger.ZERO;\n      base = BigInteger.ONE;\n      i = 0;\n      for (i = _i = 0, _len = str.length; _i < _len; i = ++_i) {\n        c = str[i];\n        if (c !== this.alphabet[0]) {\n          break;\n        }\n      }\n      start = i;\n      pad = new Buffer((function() {\n        var _j, _results;\n        _results = [];\n        for (i = _j = 0; 0 <= start ? _j < start : _j > start; i = 0 <= start ? ++_j : --_j) {\n          _results.push(0);\n        }\n        return _results;\n      })());\n      _ref1 = str.slice(start);\n      for (i = _j = _ref1.length - 1; _j >= 0; i = _j += -1) {\n        c = _ref1[i];\n        if ((char_index = this.lookup[c]) == null) {\n          throw new Error('Value passed is not a valid BaseX string.');\n        }\n        num = num.add(base.multiply(nbv(char_index)));\n        base = base.multiply(this.basebn);\n      }\n      return Buffer.concat([pad, new Buffer(num.toByteArray())]);\n    };\n\n    return BaseX;\n\n  })();\n\n  exports.base58 = base58 = new BaseX('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\n\n  exports.base32 = base32 = new BaseX('abcdefghijkmnpqrstuvwxyz23456789');\n\n  exports.base91 = new BaseX(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789`~!@#$%^&*()-_=+{}[]|;:,<>./?\");\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./bn\":4,\"./util\":70,\"bn\":71,\"buffer\":80}],4:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var BigInteger, bn_from_left_n_bits, buffer_shift_right, buffer_to_ui8a, mpi_byte_length, mpi_from_buffer, mpi_to_padded_octets, nbi, nbits, nbs, nbv, toMPI, _ref;\n\n  _ref = require('bn'), nbv = _ref.nbv, nbi = _ref.nbi, BigInteger = _ref.BigInteger, nbits = _ref.nbits;\n\n  buffer_to_ui8a = require('./util').buffer_to_ui8a;\n\n  nbs = function(s, base) {\n    var r;\n    if (base == null) {\n      base = 10;\n    }\n    r = nbi();\n    return r.fromString(s, base);\n  };\n\n  mpi_byte_length = function(bn) {\n    return bn.toByteArray().length;\n  };\n\n  toMPI = function(bn) {\n    var ba, hdr, size;\n    ba = bn.toByteArray();\n    size = (ba.length - 1) * 8 + nbits(ba[0]);\n    hdr = new Buffer(2);\n    hdr.writeUInt16BE(size, 0);\n    return Buffer.concat([hdr, new Buffer(ba)]);\n  };\n\n  mpi_from_buffer = function(raw) {\n    var err, hdr, i, n_bits, n_bytes;\n    err = i = null;\n    if (raw.length < 2) {\n      err = new Error(\"need at least 2 bytes; got \" + raw.length);\n    } else {\n      hdr = new Buffer(raw.slice(0, 2));\n      raw = raw.slice(2);\n      n_bits = hdr.readUInt16BE(0);\n      n_bytes = Math.ceil(n_bits / 8);\n      if (raw.length < n_bytes) {\n        err = new Error(\"MPI said \" + n_bytes + \" bytes but only got \" + raw.length);\n      } else {\n        i = nbi().fromBuffer(raw.slice(0, n_bytes));\n        raw = raw.slice(n_bytes);\n      }\n    }\n    return [err, i, raw, n_bytes + 2];\n  };\n\n  mpi_to_padded_octets = function(bn, base) {\n    var ba, diff, i, n, pad;\n    n = base.mpi_byte_length();\n    ba = bn.toByteArray();\n    diff = n - ba.length;\n    pad = new Buffer((function() {\n      var _i, _results;\n      _results = [];\n      for (i = _i = 0; 0 <= diff ? _i < diff : _i > diff; i = 0 <= diff ? ++_i : --_i) {\n        _results.push(0);\n      }\n      return _results;\n    })());\n    return Buffer.concat([pad, new Buffer(ba)]);\n  };\n\n  buffer_shift_right = function(buf, nbits) {\n    var c, i, l, mask, nbytes, nxt, rem, _i, _ref1;\n    nbytes = nbits >> 3;\n    rem = nbits % 8;\n    buf = buf.slice(0, buf.length - nbytes);\n    l = buf.length;\n    mask = (1 << rem) - 1;\n    for (i = _i = _ref1 = l - 1; _ref1 <= 0 ? _i <= 0 : _i >= 0; i = _ref1 <= 0 ? ++_i : --_i) {\n      c = buf.readUInt8(i) >> rem;\n      if (i > 0) {\n        nxt = buf.readUInt8(i - 1) & mask;\n        c |= nxt << (8 - rem);\n      }\n      buf.writeUInt8(c, i);\n    }\n    return buf;\n  };\n\n  bn_from_left_n_bits = function(raw, bits) {\n    var buf, bytes, rem;\n    rem = bits % 8;\n    bytes = (bits >> 3) + (rem ? 1 : 0);\n    buf = raw.slice(0, bytes);\n    if (rem > 0) {\n      buf = buffer_shift_right(buf, 8 - rem);\n    }\n    return nbi().fromBuffer(buf);\n  };\n\n  exports.toMPI = toMPI;\n\n  exports.nbs = nbs;\n\n  exports.mpi_from_buffer = mpi_from_buffer;\n\n  exports.mpi_to_padded_octets = mpi_to_padded_octets;\n\n  exports.buffer_shift_right = buffer_shift_right;\n\n  exports.bn_from_left_n_bits = bn_from_left_n_bits;\n\n  BigInteger.prototype.to_mpi_buffer = function() {\n    return toMPI(this);\n  };\n\n  BigInteger.prototype.mpi_byte_length = function() {\n    return mpi_byte_length(this);\n  };\n\n  BigInteger.prototype.to_padded_octets = function(base) {\n    return mpi_to_padded_octets(this, base);\n  };\n\n  exports.BigInteger = BigInteger;\n\n  exports.nbi = nbi;\n\n  exports.nbv = nbv;\n\n  exports.nbits = nbits;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./util\":70,\"bn\":71,\"buffer\":80}],5:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var config, k, openpgp, v;\n\n  exports.openpgp = openpgp = {\n    public_key_algorithms: {\n      RSA: 1,\n      RSA_ENCRYPT_ONLY: 2,\n      RSA_SIGN_ONLY: 3,\n      ELGAMAL: 16,\n      DSA: 17,\n      ECDH: 18,\n      ECDSA: 19,\n      ELGAMAL_SIGN_AND_ENCRYPT: 20\n    },\n    symmetric_key_algorithms: {\n      CAST5: 3,\n      AES128: 7,\n      AES192: 8,\n      AES256: 9\n    },\n    hash_algorithms: {\n      MD5: 1,\n      SHA1: 2,\n      RIPEMD160: 3,\n      SHA256: 8,\n      SHA384: 9,\n      SHA512: 10,\n      SHA224: 11\n    },\n    sig_subpacket: {\n      creation_time: 2,\n      expiration_time: 3,\n      exportable_certificate: 4,\n      trust_signature: 5,\n      regular_expression: 6,\n      revocable: 7,\n      key_expiration_time: 9,\n      preferred_symmetric_algorithms: 11,\n      revocation_key: 12,\n      issuer: 16,\n      notation_data: 20,\n      preferred_hash_algorithms: 21,\n      preferred_compression_algorithms: 22,\n      key_server_preferences: 23,\n      preferred_key_server: 24,\n      primary_user_id: 25,\n      policy_uri: 26,\n      key_flags: 27,\n      signers_user_id: 28,\n      reason_for_revocation: 29,\n      features: 30,\n      signature_target: 31,\n      embedded_signature: 32,\n      experimental_low: 101,\n      experimental_high: 110\n    },\n    sig_types: {\n      binary_doc: 0x00,\n      canonical_text: 0x01,\n      issuer: 0x10,\n      persona: 0x11,\n      casual: 0x12,\n      positive: 0x13,\n      subkey_binding: 0x18,\n      primary_binding: 0x19,\n      direct: 0x1f,\n      key_revocation: 0x20,\n      subkey_revocation: 0x28,\n      certificate_revocation: 0x30\n    },\n    message_types: {\n      generic: 0,\n      public_key: 4,\n      private_key: 5,\n      signature: 8,\n      clearsign: 9\n    },\n    s2k: {\n      plain: 0,\n      salt: 1,\n      salt_iter: 3,\n      gnu: 101,\n      gnu_dummy: 1001\n    },\n    s2k_convention: {\n      none: 0,\n      checksum: 255,\n      sha1: 254\n    },\n    ecdh: {\n      param_bytes: 3,\n      version: 1\n    },\n    packet_tags: {\n      PKESK: 1,\n      signature: 2,\n      one_pass_sig: 4,\n      secret_key: 5,\n      public_key: 6,\n      secret_subkey: 7,\n      compressed: 8,\n      literal: 11,\n      public_subkey: 14,\n      userid: 13,\n      user_attribute: 17,\n      SEIPD: 18,\n      MDC: 19\n    },\n    literal_formats: {\n      binary: 0x62,\n      text: 0x74,\n      utf8: 0x75\n    },\n    versions: {\n      PKESK: 3,\n      SEIPD: 1,\n      one_pass_sig: 3,\n      keymaterial: {\n        V4: 4\n      },\n      signature: {\n        V2: 2,\n        V3: 3,\n        V4: 4\n      }\n    },\n    signatures: {\n      key: 0x99,\n      userid: 0xb4,\n      user_attribute: 0xd1\n    },\n    key_flags: {\n      certify_keys: 0x1,\n      sign_data: 0x2,\n      encrypt_comm: 0x4,\n      encrypt_storage: 0x8,\n      private_split: 0x10,\n      auth: 0x20,\n      shared: 0x80\n    },\n    features: {\n      modification_detection: 0x1\n    },\n    key_server_preferences: {\n      no_modify: 0x80\n    },\n    compression: {\n      none: 0,\n      zip: 1,\n      zlib: 2,\n      bzip: 3\n    }\n  };\n\n  exports.kb = {\n    key_encryption: {\n      none: 0,\n      triplesec_v1: 1,\n      triplesec_v2: 2,\n      triplesec_v3: 3\n    },\n    packet_tags: {\n      p3skb: 0x201,\n      signature: 0x202,\n      encryption: 0x203\n    },\n    public_key_algorithms: {\n      NACL_EDDSA: 0x20,\n      NACL_DH: 0x21\n    },\n    versions: {\n      V1: 1\n    },\n    padding: {\n      EMSA_PCKS1_v1_5: 3,\n      RSASSA_PSS: 4\n    },\n    key_defaults: {\n      primary: {\n        expire_in: 0,\n        nbits: {\n          RSA: 4096,\n          ECDSA: 384,\n          DSA: 2048\n        }\n      },\n      sub: {\n        expire_in: 24 * 60 * 60 * 365 * 8,\n        nbits: {\n          RSA: 2048,\n          ECDH: 256,\n          ECDSA: 256,\n          DSA: 2048,\n          ELGAMAL: 2048\n        }\n      }\n    },\n    kid: {\n      version: 1,\n      trailer: 0x0a,\n      algo: 8,\n      len: 32\n    }\n  };\n\n  exports.ops = {\n    encrypt: 0x1,\n    decrypt: 0x2,\n    verify: 0x4,\n    sign: 0x8\n  };\n\n  exports.header = {\n    version: \"Keybase OpenPGP\",\n    comment: \"https://keybase.io/crypto\"\n  };\n\n  config = {\n    default_key_expire_in: 24 * 60 * 60 * 365 * 4\n  };\n\n  for (k in config) {\n    v = config[k];\n    exports[k] = v;\n  }\n\n}).call(this);\n\n},{}],6:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var ASP, BaseKey, BaseKeyPair, BigInteger, C, K, MRF, Pair, Priv, Pub, SRF, bn, bufeq_secure, iced, konst, make_esc, nbits, nbv, __iced_k, __iced_k_noop, _ref, _ref1, _ref2, _ref3,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  bn = require('./bn');\n\n  nbits = bn.nbits, nbv = bn.nbv, BigInteger = bn.BigInteger;\n\n  _ref = require('./rand'), SRF = _ref.SRF, MRF = _ref.MRF;\n\n  _ref1 = require('./util'), bufeq_secure = _ref1.bufeq_secure, ASP = _ref1.ASP;\n\n  make_esc = require('iced-error').make_esc;\n\n  konst = require('./const');\n\n  C = konst.openpgp;\n\n  K = konst.kb;\n\n  _ref2 = require('./basekeypair'), BaseKey = _ref2.BaseKey, BaseKeyPair = _ref2.BaseKeyPair;\n\n  _ref3 = require('./rand'), SRF = _ref3.SRF, MRF = _ref3.MRF;\n\n  Pub = (function(_super) {\n    __extends(Pub, _super);\n\n    Pub.type = C.public_key_algorithms.DSA;\n\n    Pub.prototype.type = Pub.type;\n\n    Pub.ORDER = ['p', 'q', 'g', 'y'];\n\n    Pub.prototype.ORDER = Pub.ORDER;\n\n    function Pub(_arg) {\n      this.p = _arg.p, this.q = _arg.q, this.g = _arg.g, this.y = _arg.y;\n    }\n\n    Pub.alloc = function(raw) {\n      return BaseKey.alloc(Pub, raw);\n    };\n\n    Pub.prototype.trunc_hash = function(h) {\n      return bn.bn_from_left_n_bits(h, this.q.bitLength());\n    };\n\n    Pub.prototype.nbits = function() {\n      var _ref4;\n      return (_ref4 = this.p) != null ? _ref4.bitLength() : void 0;\n    };\n\n    Pub.prototype.verify = function(_arg, h, cb) {\n      var err, hi, r, s, u1, u2, v, w;\n      r = _arg[0], s = _arg[1];\n      err = null;\n      hi = this.trunc_hash(h);\n      w = s.modInverse(this.q);\n      u1 = hi.multiply(w).mod(this.q);\n      u2 = r.multiply(w).mod(this.q);\n      v = this.g.modPow(u1, this.p).multiply(this.y.modPow(u2, this.p)).mod(this.p).mod(this.q);\n      if (!v.equals(r)) {\n        err = new Error(\"verification failed\");\n      }\n      return cb(err);\n    };\n\n    return Pub;\n\n  })(BaseKey);\n\n  Priv = (function(_super) {\n    __extends(Priv, _super);\n\n    Priv.ORDER = ['x'];\n\n    Priv.prototype.ORDER = Priv.ORDER;\n\n    function Priv(_arg) {\n      this.x = _arg.x, this.pub = _arg.pub;\n    }\n\n    Priv.alloc = function(raw, pub) {\n      return BaseKey.alloc(Priv, raw, {\n        pub: pub\n      });\n    };\n\n    Priv.prototype.sign = function(h, cb) {\n      var err, g, hi, k, p, q, r, s, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref4;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = null;\n      _ref4 = this.pub, p = _ref4.p, q = _ref4.q, g = _ref4.g;\n      hi = this.pub.trunc_hash(h);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/dsa.iced\",\n            funcname: \"Priv.sign\"\n          });\n          SRF().random_zn(q.subtract(bn.nbv(2)), __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return k = arguments[0];\n              };\n            })(),\n            lineno: 76\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          k = k.add(bn.BigInteger.ONE);\n          r = g.modPow(k, p).mod(q);\n          s = (k.modInverse(q).multiply(hi.add(_this.x.multiply(r)))).mod(q);\n          return cb([r, s]);\n        };\n      })(this));\n    };\n\n    return Priv;\n\n  })(BaseKey);\n\n  Pair = (function(_super) {\n    __extends(Pair, _super);\n\n    Pair.Pub = Pub;\n\n    Pair.prototype.Pub = Pub;\n\n    Pair.Priv = Priv;\n\n    Pair.prototype.Priv = Priv;\n\n    Pair.type = C.public_key_algorithms.DSA;\n\n    Pair.prototype.type = Pair.type;\n\n    Pair.prototype.get_type = function() {\n      return this.type;\n    };\n\n    Pair.klass_name = \"DSA\";\n\n    function Pair(_arg) {\n      var priv, pub;\n      pub = _arg.pub, priv = _arg.priv;\n      Pair.__super__.constructor.call(this, {\n        pub: pub,\n        priv: priv\n      });\n    }\n\n    Pair.parse = function(pub_raw) {\n      return BaseKeyPair.parse(Pair, pub_raw);\n    };\n\n    Pair.prototype.can_encrypt = function() {\n      return false;\n    };\n\n    Pair.prototype.fulfills_flags = function(flags) {\n      var good_for;\n      good_for = this.good_for_flags();\n      return (flags & good_for) === flags;\n    };\n\n    Pair.prototype.good_for_flags = function() {\n      return C.key_flags.certify_keys | C.key_flags.sign_data;\n    };\n\n    Pair.prototype.verify_unpad_and_check_hash = function(_arg, cb) {\n      var data, err, hash, hasher, sig, v, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref4;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash;\n      err = null;\n      if (Buffer.isBuffer(sig)) {\n        _ref4 = Pair.read_sig_from_buf(sig), err = _ref4[0], sig = _ref4[1];\n      }\n      hash || (hash = hasher(data));\n      (function(_this) {\n        return (function(__iced_k) {\n          if (sig.length !== 2) {\n            return __iced_k(err = new Error(\"Expected 2 Bigints in the signature\"));\n          } else {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/dsa.iced\",\n                funcname: \"Pair.verify_unpad_and_check_hash\"\n              });\n              _this.pub.verify(sig, hash, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return v = arguments[1];\n                  };\n                })(),\n                lineno: 126\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    Pair.prototype.pad_and_sign = function(data, _arg, cb) {\n      var h, hasher, s, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      hasher = _arg.hasher;\n      hasher || (hasher = SHA512);\n      h = hasher(data);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/dsa.iced\",\n            funcname: \"Pair.pad_and_sign\"\n          });\n          _this.priv.sign(h, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return sig = arguments[0];\n              };\n            })(),\n            lineno: 135\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(null, Buffer.concat((function() {\n            var _i, _len, _results;\n            _results = [];\n            for (_i = 0, _len = sig.length; _i < _len; _i++) {\n              s = sig[_i];\n              _results.push(s.to_mpi_buffer());\n            }\n            return _results;\n          })()));\n        };\n      })(this));\n    };\n\n    Pair.parse_sig = function(slice) {\n      var buf, err, n, ret, _ref4;\n      buf = slice.peek_rest_to_buffer();\n      _ref4 = Pair.read_sig_from_buf(buf), err = _ref4[0], ret = _ref4[1], n = _ref4[2];\n      if (err != null) {\n        throw err;\n      }\n      slice.advance(n);\n      return ret;\n    };\n\n    Pair.read_sig_from_buf = function(buf) {\n      var err, n, o, order, orig_len, ret, x;\n      orig_len = buf.length;\n      order = ['r', 's'];\n      err = null;\n      ret = (function() {\n        var _i, _len, _ref4, _results;\n        _results = [];\n        for (_i = 0, _len = order.length; _i < _len; _i++) {\n          o = order[_i];\n          if (!(err == null)) {\n            continue;\n          }\n          _ref4 = bn.mpi_from_buffer(buf), err = _ref4[0], x = _ref4[1], buf = _ref4[2];\n          _results.push(x);\n        }\n        return _results;\n      })();\n      n = orig_len - buf.length;\n      return [err, ret, n];\n    };\n\n    return Pair;\n\n  })(BaseKeyPair);\n\n  exports.DSA = exports.Pair = Pair;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./basekeypair\":2,\"./bn\":4,\"./const\":5,\"./rand\":65,\"./util\":70,\"buffer\":80,\"iced-error\":115,\"iced-runtime\":118}],7:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var BaseEccKey, SlicerBuffer, alloc_by_nbits, alloc_by_oid, iced, __iced_k, __iced_k_noop, _ref;\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  SlicerBuffer = require('../openpgp/buffer').SlicerBuffer;\n\n  _ref = require('./curves'), alloc_by_nbits = _ref.alloc_by_nbits, alloc_by_oid = _ref.alloc_by_oid;\n\n  exports.BaseEccKey = BaseEccKey = (function() {\n    function BaseEccKey(_arg) {\n      this.curve = _arg.curve, this.R = _arg.R;\n    }\n\n    BaseEccKey.prototype.serialize = function() {\n      var oid;\n      oid = this.curve.oid;\n      return Buffer.concat([new Buffer([oid.length]), oid, this.curve.point_to_mpi_buffer(this.R)]);\n    };\n\n    BaseEccKey._alloc = function(klass, raw) {\n      var R, curve, err, l, len, oid, pre, pub, sb, _ref1, _ref2;\n      sb = new SlicerBuffer(raw);\n      pre = sb.rem();\n      l = sb.read_uint8();\n      oid = sb.read_buffer(l);\n      _ref1 = alloc_by_oid(oid), err = _ref1[0], curve = _ref1[1];\n      if (err != null) {\n        throw err;\n      }\n      _ref2 = curve.mpi_point_from_slicer_buffer(sb), err = _ref2[0], R = _ref2[1];\n      if (err != null) {\n        throw err;\n      }\n      pub = new klass({\n        curve: curve,\n        R: R\n      });\n      pub.read_params(sb);\n      len = pre - sb.rem();\n      return [pub, len];\n    };\n\n    BaseEccKey.alloc = function(klass, raw) {\n      var e, err, len, pub, _ref1;\n      pub = len = err = null;\n      try {\n        _ref1 = BaseEccKey._alloc(klass, raw), pub = _ref1[0], len = _ref1[1];\n      } catch (_error) {\n        e = _error;\n        err = e;\n      }\n      return [err, pub, len];\n    };\n\n    BaseEccKey.prototype.validity_check = function(cb) {\n      return cb(null);\n    };\n\n    return BaseEccKey;\n\n  })();\n\n  exports.generate = function(_arg, cb) {\n    var Pair, R, asp, curve, err, nbits, priv, pub, ret, x, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    nbits = _arg.nbits, asp = _arg.asp, Pair = _arg.Pair;\n    ret = null;\n    _ref1 = alloc_by_nbits(nbits), err = _ref1[0], curve = _ref1[1];\n    (function(_this) {\n      return (function(__iced_k) {\n        if (err == null) {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/ecc/base.iced\",\n              funcname: \"generate\"\n            });\n            curve.random_scalar(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return x = arguments[0];\n                };\n              })(),\n              lineno: 55\n            }));\n            __iced_deferrals._fulfill();\n          })(function() {\n            R = curve.G.multiply(x);\n            pub = new Pair.Pub({\n              curve: curve,\n              R: R\n            });\n            priv = new Pair.Priv({\n              pub: pub,\n              x: x\n            });\n            return __iced_k(ret = new Pair({\n              pub: pub,\n              priv: priv\n            }));\n          });\n        } else {\n          return __iced_k();\n        }\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(err, ret);\n      };\n    })(this));\n  };\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../openpgp/buffer\":35,\"./curves\":8,\"buffer\":80,\"iced-runtime\":118}],8:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var BigInteger, Curve, H, OIDS, OID_LOOKUP, SRF, SlicerBuffer, base, bn, iced, k, nist_p256, nist_p384, nist_p521, uint_to_buffer, v, __iced_k, __iced_k_noop,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  BigInteger = require('../bn').BigInteger;\n\n  base = require('keybase-ecurve');\n\n  uint_to_buffer = require('../util').uint_to_buffer;\n\n  SlicerBuffer = require('../openpgp/buffer').SlicerBuffer;\n\n  SRF = require('../rand').SRF;\n\n  bn = require('../bn');\n\n  exports.H = H = function(x) {\n    return BigInteger.fromHex(x.split(/\\s+/).join(''));\n  };\n\n  exports.Curve = Curve = (function(_super) {\n    __extends(Curve, _super);\n\n    function Curve(_arg) {\n      var Gx, Gy, a, b, h, n, p;\n      p = _arg.p, a = _arg.a, b = _arg.b, Gx = _arg.Gx, Gy = _arg.Gy, n = _arg.n, h = _arg.h, this.oid = _arg.oid;\n      h || (h = BigInteger.ONE);\n      Curve.__super__.constructor.call(this, p, a, b, Gx, Gy, n, h);\n    }\n\n    Curve.prototype.mkpoint = function(_arg) {\n      var x, y;\n      x = _arg.x, y = _arg.y;\n      return base.Point.fromAffine(this, x, y);\n    };\n\n    Curve.prototype.nbits = function() {\n      return this.p.bitLength();\n    };\n\n    Curve.prototype.mpi_bit_size = function() {\n      return 2 * this.mpi_coord_bit_size() + 3;\n    };\n\n    Curve.prototype.mpi_coord_byte_size = function() {\n      return Math.ceil(this.nbits() / 8);\n    };\n\n    Curve.prototype.mpi_coord_bit_size = function() {\n      return this.mpi_coord_byte_size() * 8;\n    };\n\n    Curve.prototype._mpi_point_from_slicer_buffer = function(sb) {\n      var b, n_bits, n_bytes, point, x, y, _ref;\n      n_bits = sb.read_uint16();\n      if (n_bits !== (b = this.mpi_bit_size())) {\n        throw new Error(\"Need \" + b + \" bits for this curve; got \" + n_bits);\n      }\n      if (sb.read_uint8() !== 0x4) {\n        throw new Error(\"Can only handle 0x4 prefix for MPI representations\");\n      }\n      n_bytes = this.mpi_coord_byte_size();\n      _ref = [BigInteger.fromBuffer(sb.read_buffer(n_bytes)), BigInteger.fromBuffer(sb.read_buffer(n_bytes))], x = _ref[0], y = _ref[1];\n      point = this.mkpoint({\n        x: x,\n        y: y\n      });\n      if (!this.isOnCurve(point)) {\n        throw new Error(\"Given ECC point isn't on the given curve; data corruption detected.\");\n      }\n      return [null, point];\n    };\n\n    Curve.prototype.mpi_point_from_buffer = function(b) {\n      return this.mpi_point_from_slicer_buffer(new SlicerBuffer(b));\n    };\n\n    Curve.prototype.mpi_point_from_slicer_buffer = function(sb) {\n      var e, err, point, _ref;\n      err = point = null;\n      try {\n        _ref = this._mpi_point_from_slicer_buffer(sb), err = _ref[0], point = _ref[1];\n      } catch (_error) {\n        e = _error;\n        err = e;\n      }\n      return [err, point];\n    };\n\n    Curve.prototype.point_to_mpi_buffer_compact = function(p) {\n      return p.affineX.toBuffer(this.p.byteLength());\n    };\n\n    Curve.prototype.point_to_mpi_buffer = function(p) {\n      var ret, sz;\n      sz = this.mpi_coord_byte_size();\n      ret = Buffer.concat([uint_to_buffer(16, this.mpi_bit_size()), new Buffer([0x4]), p.affineX.toBuffer(sz), p.affineY.toBuffer(sz)]);\n      return ret;\n    };\n\n    Curve.prototype.random_scalar = function(cb) {\n      var k, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/ecc/curves.iced\",\n            funcname: \"Curve.random_scalar\"\n          });\n          SRF().random_zn(_this.n.subtract(bn.nbv(2)), __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return k = arguments[0];\n              };\n            })(),\n            lineno: 97\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          k = k.add(bn.BigInteger.ONE);\n          return cb(k);\n        };\n      })(this));\n    };\n\n    return Curve;\n\n  })(base.Curve);\n\n  exports.nist_p256 = nist_p256 = function() {\n    var Gx, Gy, a, b, n, p;\n    p = H(\"FFFFFFFF 00000001 00000000 00000000 00000000 FFFFFFFF FFFFFFFF FFFFFFFF\");\n    a = H(\"FFFFFFFF 00000001 00000000 00000000 00000000 FFFFFFFF FFFFFFFF FFFFFFFC\");\n    b = H(\"5AC635D8 AA3A93E7 B3EBBD55 769886BC 651D06B0 CC53B0F6 3BCE3C3E 27D2604B\");\n    n = H(\"FFFFFFFF 00000000 FFFFFFFF FFFFFFFF BCE6FAAD A7179E84 F3B9CAC2 FC632551\");\n    Gx = H(\"6B17D1F2 E12C4247 F8BCE6E5 63A440F2 77037D81 2DEB33A0 F4A13945 D898C296\");\n    Gy = H(\"4FE342E2 FE1A7F9B 8EE7EB4A 7C0F9E16 2BCE3357 6B315ECE CBB64068 37BF51F5\");\n    return new Curve({\n      p: p,\n      a: a,\n      b: b,\n      Gx: Gx,\n      Gy: Gy,\n      n: n,\n      oid: OIDS.nist_p256\n    });\n  };\n\n  exports.nist_p384 = nist_p384 = function() {\n    var Gx, Gy, a, b, n, p;\n    p = H('ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff');\n    a = H('ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc');\n    b = H('b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef');\n    n = H('ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973');\n    Gx = H('aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7');\n    Gy = H('3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f');\n    return new Curve({\n      p: p,\n      a: a,\n      b: b,\n      Gx: Gx,\n      Gy: Gy,\n      n: n,\n      oid: OIDS.nist_p384\n    });\n  };\n\n  exports.nist_p521 = nist_p521 = function() {\n    var Gx, Gy, a, b, n, p;\n    p = H('000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff');\n    a = H('000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc');\n    b = H('00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00');\n    n = H('000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409');\n    Gx = H('000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66');\n    Gy = H('00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650');\n    return new Curve({\n      p: p,\n      a: a,\n      b: b,\n      Gx: Gx,\n      Gy: Gy,\n      n: n,\n      oid: OIDS.nist_p521\n    });\n  };\n\n  OIDS = {\n    nist_p256: new Buffer([0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07]),\n    nist_p384: new Buffer([0x2b, 0x81, 0x04, 0x00, 0x22]),\n    nist_p521: new Buffer([0x2b, 0x81, 0x04, 0x00, 0x23])\n  };\n\n  OID_LOOKUP = {};\n\n  for (k in OIDS) {\n    v = OIDS[k];\n    OID_LOOKUP[v.toString('hex')] = exports[k];\n  }\n\n  exports.alloc_by_oid = function(oid) {\n    var curve, err, f;\n    if (Buffer.isBuffer(oid)) {\n      oid = oid.toString('hex');\n    }\n    err = curve = null;\n    if ((f = OID_LOOKUP[oid.toLowerCase()]) != null) {\n      curve = f();\n    } else {\n      err = new Error(\"Unknown curve OID: \" + oid);\n    }\n    return [err, curve];\n  };\n\n  exports.alloc_by_nbits = function(nbits) {\n    var err, f, ret;\n    ret = err = null;\n    nbits || (nbits = 256);\n    f = (function() {\n      switch (nbits) {\n        case 256:\n          return nist_p256;\n        case 384:\n          return nist_p384;\n        case 521:\n          return nist_p521;\n        default:\n          return null;\n      }\n    })();\n    if (f != null) {\n      ret = f();\n    } else {\n      err = new Error(\"No curve for \" + nbits + \" bits\");\n    }\n    return [err, ret];\n  };\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../bn\":4,\"../openpgp/buffer\":35,\"../rand\":65,\"../util\":70,\"buffer\":80,\"iced-runtime\":118,\"keybase-ecurve\":148}],9:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var ASP, BaseEccKey, BaseKey, BaseKeyPair, Const, Output, Pair, Priv, Pub, SlicerBuffer, bufeq_secure, ecc_pkcs5_pad_data, generate, hashmod, iced, konst, make_esc, sym, uint_to_buffer, unwrap, wrap, __iced_k, __iced_k_noop, _ref, _ref1, _ref2, _ref3,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  _ref = require('../util'), uint_to_buffer = _ref.uint_to_buffer, bufeq_secure = _ref.bufeq_secure, ASP = _ref.ASP;\n\n  make_esc = require('iced-error').make_esc;\n\n  konst = require('../const');\n\n  Const = konst.openpgp;\n\n  _ref1 = require('../basekeypair'), BaseKeyPair = _ref1.BaseKeyPair, BaseKey = _ref1.BaseKey;\n\n  ecc_pkcs5_pad_data = require('../pad').ecc_pkcs5_pad_data;\n\n  _ref2 = require('./base'), generate = _ref2.generate, BaseEccKey = _ref2.BaseEccKey;\n\n  hashmod = require('../hash');\n\n  sym = require('../symmetric');\n\n  SlicerBuffer = require('../openpgp/buffer').SlicerBuffer;\n\n  _ref3 = require('../rfc3394'), wrap = _ref3.wrap, unwrap = _ref3.unwrap;\n\n  Pub = (function(_super) {\n    __extends(Pub, _super);\n\n    function Pub() {\n      return Pub.__super__.constructor.apply(this, arguments);\n    }\n\n    Pub.type = Const.public_key_algorithms.ECDH;\n\n    Pub.prototype.type = Pub.type;\n\n    Pub.prototype.apply_defaults = function() {\n      this.cipher || (this.cipher = sym.get_cipher());\n      return this.hasher || (this.hasher = hashmod.SHA512);\n    };\n\n    Pub.prototype.read_params = function(sb) {\n      var n, size, v, val;\n      if ((size = sb.read_uint8()) < (n = Const.ecdh.param_bytes)) {\n        throw new Error(\"Need at least \" + n + \" bytes of params; got \" + size);\n      }\n      if ((val = sb.read_uint8()) !== (v = Const.ecdh.version)) {\n        throw new Error(\"Cannot deal with future extensions, byte=\" + val + \"; wanted \" + v);\n      }\n      this.hasher = hashmod.alloc_or_throw(sb.read_uint8());\n      this.cipher = sym.get_cipher(sb.read_uint8());\n      return sb.advance(size - 3);\n    };\n\n    Pub.alloc = function(raw) {\n      return BaseEccKey.alloc(Pub, raw);\n    };\n\n    Pub.prototype.serialize_params = function() {\n      return Buffer.concat([uint_to_buffer(8, Const.ecdh.param_bytes), uint_to_buffer(8, Const.ecdh.version), uint_to_buffer(8, this.hasher.type), uint_to_buffer(8, this.cipher.type)]);\n    };\n\n    Pub.prototype.serialize = function() {\n      return Buffer.concat([Pub.__super__.serialize.call(this), this.serialize_params()]);\n    };\n\n    Pub.prototype.format_params = function(_arg) {\n      var fingerprint;\n      fingerprint = _arg.fingerprint;\n      return Buffer.concat([uint_to_buffer(8, this.curve.oid.length), this.curve.oid, uint_to_buffer(8, this.type), this.serialize_params(), new Buffer(\"Anonymous Sender    \", \"utf8\"), fingerprint]);\n    };\n\n    Pub.prototype.kdf = function(_arg) {\n      var X, X_compact, buf, hash, o_bytes, params;\n      X = _arg.X, params = _arg.params;\n      o_bytes = this.cipher.key_size;\n      X_compact = this.curve.point_to_mpi_buffer_compact(X);\n      buf = Buffer.concat([new Buffer([0, 0, 0, 1]), X_compact, params]);\n      hash = this.hasher(buf);\n      return hash.slice(0, o_bytes);\n    };\n\n    Pub.prototype.encrypt = function(m, _arg, cb) {\n      var C, G, S, V, fingerprint, key, n, params, v, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref4;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      fingerprint = _arg.fingerprint;\n      _ref4 = this.curve, n = _ref4.n, G = _ref4.G;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/ecc/ecdh.iced\",\n            funcname: \"Pub.encrypt\"\n          });\n          _this.curve.random_scalar(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return v = arguments[0];\n              };\n            })(),\n            lineno: 100\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          V = G.multiply(v);\n          S = _this.R.multiply(v);\n          params = _this.format_params({\n            fingerprint: fingerprint\n          });\n          key = _this.kdf({\n            X: S,\n            params: params\n          });\n          C = wrap({\n            key: key,\n            plaintext: m,\n            cipher: _this.cipher\n          });\n          return cb({\n            V: V,\n            C: C\n          });\n        };\n      })(this));\n    };\n\n    return Pub;\n\n  })(BaseEccKey);\n\n  Priv = (function(_super) {\n    __extends(Priv, _super);\n\n    Priv.ORDER = ['x'];\n\n    Priv.prototype.ORDER = Priv.ORDER;\n\n    function Priv(_arg) {\n      this.x = _arg.x, this.pub = _arg.pub;\n    }\n\n    Priv.prototype.serialize = function() {\n      return this.x.to_mpi_buffer();\n    };\n\n    Priv.alloc = function(raw, pub) {\n      return BaseKey.alloc(Priv, raw, {\n        pub: pub\n      });\n    };\n\n    Priv.prototype.decrypt = function(c, _arg, cb) {\n      var S, V, curve, err, esc, fingerprint, key, params, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      fingerprint = _arg.fingerprint;\n      esc = make_esc(cb, \"Priv::decrypt\");\n      curve = this.pub.curve;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/ecc/ecdh.iced\",\n            funcname: \"Priv.decrypt\"\n          });\n          c.load_V(curve, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return V = arguments[0];\n              };\n            })(),\n            lineno: 141\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          var _ref4;\n          S = V.multiply(_this.x);\n          params = _this.pub.format_params({\n            fingerprint: fingerprint\n          });\n          key = _this.pub.kdf({\n            X: S,\n            params: params\n          });\n          _ref4 = unwrap({\n            key: key,\n            ciphertext: c.C,\n            cipher: _this.pub.cipher\n          }), err = _ref4[0], ret = _ref4[1];\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    return Priv;\n\n  })(BaseKey);\n\n  Pair = (function(_super) {\n    __extends(Pair, _super);\n\n    function Pair() {\n      return Pair.__super__.constructor.apply(this, arguments);\n    }\n\n    Pair.Pub = Pub;\n\n    Pair.prototype.Pub = Pub;\n\n    Pair.Priv = Priv;\n\n    Pair.prototype.Priv = Priv;\n\n    Pair.type = Const.public_key_algorithms.ECDH;\n\n    Pair.prototype.type = Pair.type;\n\n    Pair.klass_name = \"ECDH\";\n\n    Pair.prototype.get_type = function() {\n      return this.type;\n    };\n\n    Pair.prototype.fulfills_flags = function(flags) {\n      var good_for;\n      good_for = Const.key_flags.encrypt_comm | Const.key_flags.encrypt_storage;\n      return (flags & good_for) === flags;\n    };\n\n    Pair.prototype.can_sign = function() {\n      return false;\n    };\n\n    Pair.parse = function(pub_raw) {\n      var ret;\n      ret = BaseKeyPair.parse(Pair, pub_raw);\n      return ret;\n    };\n\n    Pair.prototype.max_value = function() {\n      return this.pub.p;\n    };\n\n    Pair.prototype.pad_and_encrypt = function(data, _arg, cb) {\n      var C, V, err, fingerprint, m, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref4;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      fingerprint = _arg.fingerprint;\n      err = ret = null;\n      _ref4 = ecc_pkcs5_pad_data(data), err = _ref4[0], m = _ref4[1];\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err == null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/ecc/ecdh.iced\",\n                funcname: \"Pair.pad_and_encrypt\"\n              });\n              _this.pub.encrypt(m, {\n                fingerprint: fingerprint\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    C = arguments[0].C;\n                    return V = arguments[0].V;\n                  };\n                })(),\n                lineno: 196\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return __iced_k(ret = _this.export_output({\n                C: C,\n                V: V,\n                curve: _this.pub.curve\n              }));\n            });\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    Pair.prototype.decrypt_and_unpad = function(ciphertext, _arg, cb) {\n      var err, fingerprint, m, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      fingerprint = _arg.fingerprint;\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/ecc/ecdh.iced\",\n            funcname: \"Pair.decrypt_and_unpad\"\n          });\n          _this.priv.decrypt(ciphertext, {\n            fingerprint: fingerprint\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return m = arguments[1];\n              };\n            })(),\n            lineno: 204\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, m, true);\n        };\n      })(this));\n    };\n\n    Pair.parse_output = function(buf) {\n      return Output.parse(buf);\n    };\n\n    Pair.prototype.export_output = function(args) {\n      return new Output(args);\n    };\n\n    Pair.generate = function(_arg, cb) {\n      var asp, err, nbits, pair, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      nbits = _arg.nbits, asp = _arg.asp;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/ecc/ecdh.iced\",\n            funcname: \"Pair.generate\"\n          });\n          generate({\n            nbits: nbits,\n            asp: asp,\n            Pair: Pair\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return pair = arguments[1];\n              };\n            })(),\n            lineno: 215\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (typeof err === \"undefined\" || err === null) {\n            pair.pub.apply_defaults();\n          }\n          return cb(err, pair);\n        };\n      })(this));\n    };\n\n    return Pair;\n\n  })(BaseKeyPair);\n\n  Output = (function() {\n    function Output(_arg) {\n      this.V_buf = _arg.V_buf, this.C = _arg.C, this.V = _arg.V, this.curve = _arg.curve;\n    }\n\n    Output.prototype.load_V = function(curve, cb) {\n      var err, _ref4;\n      this.curve = curve;\n      _ref4 = curve.mpi_point_from_buffer(this.V_buf), err = _ref4[0], this.V = _ref4[1];\n      return cb(err, this.V);\n    };\n\n    Output.parse = function(buf) {\n      var C, V_buf, a, n_bits, n_bytes, ret, sb;\n      sb = new SlicerBuffer(buf);\n      n_bits = sb.read_uint16();\n      n_bytes = Math.ceil(n_bits / 8);\n      V_buf = Buffer.concat([buf.slice(0, 2), sb.read_buffer(n_bytes)]);\n      n_bytes = sb.read_uint8();\n      C = sb.consume_rest_to_buffer();\n      if ((a = C.length) !== n_bytes) {\n        throw new Error(\"bad C input: wanted \" + n_bytes + \" bytes, but got \" + a);\n      }\n      ret = new Output({\n        V_buf: V_buf,\n        C: C\n      });\n      return ret;\n    };\n\n    Output.prototype.get_V_buf = function() {\n      if (this.V_buf == null) {\n        this.V_buf = this.curve.point_to_mpi_buffer(this.V);\n      }\n      return this.V_buf;\n    };\n\n    Output.prototype.hide = function(_arg, cb) {\n      var key, max, slosh;\n      key = _arg.key, max = _arg.max, slosh = _arg.slosh;\n      return cb(null);\n    };\n\n    Output.prototype.find = function(_arg) {\n      var key;\n      key = _arg.key;\n    };\n\n    Output.prototype.good_for_flags = function() {\n      return C.key_flags.encrypt_comm | C.key_flags.encrypt_storage;\n    };\n\n    Output.prototype.output = function() {\n      return Buffer.concat([this.get_V_buf(), uint_to_buffer(8, this.C.length), this.C]);\n    };\n\n    return Output;\n\n  })();\n\n  exports.ECDH = exports.Pair = Pair;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../basekeypair\":2,\"../const\":5,\"../hash\":14,\"../openpgp/buffer\":35,\"../pad\":62,\"../rfc3394\":66,\"../symmetric\":68,\"../util\":70,\"./base\":7,\"buffer\":80,\"iced-error\":115,\"iced-runtime\":118}],10:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var ASP, BaseEccKey, BaseKey, BaseKeyPair, BigInteger, C, ECDH, K, Pair, Priv, Pub, bn, bufeq_secure, generate, iced, konst, make_esc, nbits, nbv, uint_to_buffer, __iced_k, __iced_k_noop, _ref, _ref1, _ref2,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  bn = require('../bn');\n\n  nbits = bn.nbits, nbv = bn.nbv, BigInteger = bn.BigInteger;\n\n  _ref = require('../util'), uint_to_buffer = _ref.uint_to_buffer, bufeq_secure = _ref.bufeq_secure, ASP = _ref.ASP;\n\n  make_esc = require('iced-error').make_esc;\n\n  konst = require('../const');\n\n  C = konst.openpgp;\n\n  K = konst.kb;\n\n  _ref1 = require('../basekeypair'), BaseKeyPair = _ref1.BaseKeyPair, BaseKey = _ref1.BaseKey;\n\n  _ref2 = require('./base'), generate = _ref2.generate, BaseEccKey = _ref2.BaseEccKey;\n\n  ECDH = require('./ecdh').ECDH;\n\n  Pub = (function(_super) {\n    __extends(Pub, _super);\n\n    function Pub() {\n      return Pub.__super__.constructor.apply(this, arguments);\n    }\n\n    Pub.type = C.public_key_algorithms.ECDSA;\n\n    Pub.prototype.type = Pub.type;\n\n    Pub.prototype.nbits = function() {\n      return this.curve.nbits();\n    };\n\n    Pub.prototype.read_params = function(sb) {};\n\n    Pub.prototype.trunc_hash = function(h) {\n      return bn.bn_from_left_n_bits(h, this.nbits());\n    };\n\n    Pub.alloc = function(raw) {\n      return BaseEccKey.alloc(Pub, raw);\n    };\n\n    Pub.prototype.verify = function(_arg, h, cb) {\n      var err, hi, n, p, r, s, u1, u2, v, w;\n      r = _arg[0], s = _arg[1];\n      err = null;\n      hi = this.trunc_hash(h);\n      if ((r.signum() <= 0) || (r.compareTo(this.curve.p) > 0)) {\n        err = new Error(\"bad r\");\n      } else if ((r.signum() <= 0) || (s.compareTo(this.curve.p) > 0)) {\n        err = new Error(\"bad s\");\n      } else {\n        n = this.curve.n;\n        w = s.modInverse(n);\n        u1 = hi.multiply(w).mod(n);\n        u2 = r.multiply(w).mod(n);\n        p = this.curve.G.multiplyTwo(u1, this.R, u2);\n        v = p.affineX.mod(n);\n        if (!v.equals(r)) {\n          err = new Error(\"verification failed\");\n        }\n      }\n      return cb(err);\n    };\n\n    return Pub;\n\n  })(BaseEccKey);\n\n  Priv = (function(_super) {\n    __extends(Priv, _super);\n\n    Priv.ORDER = ['x'];\n\n    Priv.prototype.ORDER = Priv.ORDER;\n\n    function Priv(_arg) {\n      this.x = _arg.x, this.pub = _arg.pub;\n    }\n\n    Priv.alloc = function(raw, pub) {\n      return BaseKey.alloc(Priv, raw, {\n        pub: pub\n      });\n    };\n\n    Priv.prototype.sign = function(h, cb) {\n      var G, Q, err, hi, k, n, r, s, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref3;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = null;\n      _ref3 = this.pub.curve, n = _ref3.n, G = _ref3.G;\n      hi = this.pub.trunc_hash(h);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/ecc/ecdsa.iced\",\n            funcname: \"Priv.sign\"\n          });\n          _this.pub.curve.random_scalar(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return k = arguments[0];\n              };\n            })(),\n            lineno: 79\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          Q = G.multiply(k);\n          r = Q.affineX.mod(n);\n          if (r.signum() === 0) {\n            throw new Error(\"invalid r-value\");\n          }\n          s = k.modInverse(n).multiply(hi.add(_this.x.multiply(r))).mod(n);\n          return cb([r, s]);\n        };\n      })(this));\n    };\n\n    return Priv;\n\n  })(BaseKey);\n\n  Pair = (function(_super) {\n    __extends(Pair, _super);\n\n    Pair.Pub = Pub;\n\n    Pair.prototype.Pub = Pub;\n\n    Pair.Priv = Priv;\n\n    Pair.prototype.Priv = Priv;\n\n    Pair.type = C.public_key_algorithms.ECDSA;\n\n    Pair.prototype.type = Pair.type;\n\n    Pair.klass_name = \"ECDSA\";\n\n    Pair.prototype.get_type = function() {\n      return this.type;\n    };\n\n    function Pair(_arg) {\n      var priv, pub;\n      pub = _arg.pub, priv = _arg.priv;\n      Pair.__super__.constructor.call(this, {\n        pub: pub,\n        priv: priv\n      });\n    }\n\n    Pair.parse = function(pub_raw) {\n      return BaseKeyPair.parse(Pair, pub_raw);\n    };\n\n    Pair.prototype.can_encrypt = function() {\n      return false;\n    };\n\n    Pair.subkey_algo = function(flags) {\n      if (flags & (C.key_flags.certify_keys | C.key_flags.sign_data)) {\n        return Pair;\n      } else {\n        return ECDH;\n      }\n    };\n\n    Pair.prototype.fulfills_flags = function(flags) {\n      var good_for;\n      good_for = C.key_flags.certify_keys | C.key_flags.sign_data;\n      return (flags & good_for) === flags;\n    };\n\n    Pair.prototype.verify_unpad_and_check_hash = function(_arg, cb) {\n      var data, err, hash, hasher, sig, v, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref3;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash;\n      err = null;\n      if (Buffer.isBuffer(sig)) {\n        _ref3 = Pair.read_sig_from_buf(sig), err = _ref3[0], sig = _ref3[1];\n      }\n      hash || (hash = hasher(data));\n      (function(_this) {\n        return (function(__iced_k) {\n          if (sig.length !== 2) {\n            return __iced_k(err = new Error(\"Expected 2 Bigints in the signature\"));\n          } else {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/ecc/ecdsa.iced\",\n                funcname: \"Pair.verify_unpad_and_check_hash\"\n              });\n              _this.pub.verify(sig, hash, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return v = arguments[1];\n                  };\n                })(),\n                lineno: 132\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    Pair.prototype.pad_and_sign = function(data, _arg, cb) {\n      var h, hasher, s, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      hasher = _arg.hasher;\n      hasher || (hasher = SHA512);\n      h = hasher(data);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/ecc/ecdsa.iced\",\n            funcname: \"Pair.pad_and_sign\"\n          });\n          _this.priv.sign(h, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return sig = arguments[0];\n              };\n            })(),\n            lineno: 141\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(null, Buffer.concat((function() {\n            var _i, _len, _results;\n            _results = [];\n            for (_i = 0, _len = sig.length; _i < _len; _i++) {\n              s = sig[_i];\n              _results.push(s.to_mpi_buffer());\n            }\n            return _results;\n          })()));\n        };\n      })(this));\n    };\n\n    Pair.parse_sig = function(slice) {\n      var buf, err, n, ret, _ref3;\n      buf = slice.peek_rest_to_buffer();\n      _ref3 = Pair.read_sig_from_buf(buf), err = _ref3[0], ret = _ref3[1], n = _ref3[2];\n      if (err != null) {\n        throw err;\n      }\n      slice.advance(n);\n      return ret;\n    };\n\n    Pair.read_sig_from_buf = function(buf) {\n      var err, n, o, order, orig_len, ret, x;\n      orig_len = buf.length;\n      order = ['r', 's'];\n      err = null;\n      ret = (function() {\n        var _i, _len, _ref3, _results;\n        _results = [];\n        for (_i = 0, _len = order.length; _i < _len; _i++) {\n          o = order[_i];\n          if (!(err == null)) {\n            continue;\n          }\n          _ref3 = bn.mpi_from_buffer(buf), err = _ref3[0], x = _ref3[1], buf = _ref3[2];\n          _results.push(x);\n        }\n        return _results;\n      })();\n      n = orig_len - buf.length;\n      return [err, ret, n];\n    };\n\n    Pair.prototype.good_for_flags = function() {\n      return C.key_flags.certify_keys | C.key_flags.sign_data;\n    };\n\n    Pair.generate = function(_arg, cb) {\n      var asp, nbits;\n      nbits = _arg.nbits, asp = _arg.asp;\n      return generate({\n        nbits: nbits,\n        asp: asp,\n        Pair: Pair\n      }, cb);\n    };\n\n    return Pair;\n\n  })(BaseKeyPair);\n\n  exports.ECDSA = exports.Pair = Pair;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../basekeypair\":2,\"../bn\":4,\"../const\":5,\"../util\":70,\"./base\":7,\"./ecdh\":9,\"buffer\":80,\"iced-error\":115,\"iced-runtime\":118}],11:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  exports.curves = require('./curves');\n\n  exports.ECDSA = require('./ecdsa').ECDSA;\n\n  exports.ECDH = require('./ecdh').ECDH;\n\n}).call(this);\n\n},{\"./curves\":8,\"./ecdh\":9,\"./ecdsa\":10}],12:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var ASP, BaseKey, BaseKeyPair, C, K, MRF, Output, Pair, Priv, Pub, SRF, bn, bufeq_secure, eme_pkcs1_decode, eme_pkcs1_encode, iced, konst, make_esc, __iced_k, __iced_k_noop, _ref, _ref1, _ref2, _ref3,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  bn = require('./bn');\n\n  _ref = require('./util'), bufeq_secure = _ref.bufeq_secure, ASP = _ref.ASP;\n\n  make_esc = require('iced-error').make_esc;\n\n  konst = require('./const');\n\n  C = konst.openpgp;\n\n  K = konst.kb;\n\n  _ref1 = require('./basekeypair'), BaseKeyPair = _ref1.BaseKeyPair, BaseKey = _ref1.BaseKey;\n\n  _ref2 = require('./rand'), SRF = _ref2.SRF, MRF = _ref2.MRF;\n\n  _ref3 = require('./pad'), eme_pkcs1_encode = _ref3.eme_pkcs1_encode, eme_pkcs1_decode = _ref3.eme_pkcs1_decode;\n\n  Pub = (function(_super) {\n    __extends(Pub, _super);\n\n    Pub.type = C.public_key_algorithms.ELGAMAL;\n\n    Pub.prototype.type = Pub.type;\n\n    Pub.ORDER = ['p', 'g', 'y'];\n\n    Pub.prototype.ORDER = Pub.ORDER;\n\n    function Pub(_arg) {\n      this.p = _arg.p, this.g = _arg.g, this.y = _arg.y;\n    }\n\n    Pub.alloc = function(raw) {\n      return BaseKey.alloc(Pub, raw);\n    };\n\n    Pub.prototype.encrypt = function(m, cb) {\n      var c, k, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/elgamal.iced\",\n            funcname: \"Pub.encrypt\"\n          });\n          SRF().random_zn(_this.p.subtract(bn.nbv(2)), __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return k = arguments[0];\n              };\n            })(),\n            lineno: 35\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          k = k.add(bn.BigInteger.ONE);\n          c = [_this.g.modPow(k, _this.p), _this.y.modPow(k, _this.p).multiply(m).mod(_this.p)];\n          return cb(c);\n        };\n      })(this));\n    };\n\n    return Pub;\n\n  })(BaseKey);\n\n  Priv = (function(_super) {\n    __extends(Priv, _super);\n\n    Priv.ORDER = ['x'];\n\n    Priv.prototype.ORDER = Priv.ORDER;\n\n    function Priv(_arg) {\n      this.x = _arg.x, this.pub = _arg.pub;\n    }\n\n    Priv.prototype.serialize = function() {\n      return this.x.to_mpi_buffer();\n    };\n\n    Priv.alloc = function(raw, pub) {\n      return BaseKey.alloc(Priv, raw, {\n        pub: pub\n      });\n    };\n\n    Priv.prototype.decrypt = function(c, cb) {\n      var p, ret;\n      p = this.pub.p;\n      ret = c[0].modPow(this.x, p).modInverse(p).multiply(c[1]).mod(p);\n      return cb(null, ret);\n    };\n\n    return Priv;\n\n  })(BaseKey);\n\n  Pair = (function(_super) {\n    __extends(Pair, _super);\n\n    Pair.Pub = Pub;\n\n    Pair.prototype.Pub = Pub;\n\n    Pair.Priv = Priv;\n\n    Pair.prototype.Priv = Priv;\n\n    Pair.type = C.public_key_algorithms.ELGAMAL;\n\n    Pair.klass_name = \"ELGAMAL\";\n\n    Pair.prototype.type = Pair.type;\n\n    Pair.prototype.get_type = function() {\n      return this.type;\n    };\n\n    Pair.prototype.fulfills_flags = function(flags) {\n      var good_for;\n      good_for = this.good_for_flags();\n      return (flags & good_for) === flags;\n    };\n\n    Pair.prototype.good_for_flags = function() {\n      return C.key_flags.encrypt_comm | C.key_flags.encrypt_storage;\n    };\n\n    function Pair(_arg) {\n      var priv, pub;\n      pub = _arg.pub, priv = _arg.priv;\n      Pair.__super__.constructor.call(this, {\n        pub: pub,\n        priv: priv\n      });\n    }\n\n    Pair.prototype.can_sign = function() {\n      return false;\n    };\n\n    Pair.parse = function(pub_raw) {\n      var ret;\n      ret = BaseKeyPair.parse(Pair, pub_raw);\n      return ret;\n    };\n\n    Pair.prototype.max_value = function() {\n      return this.pub.p;\n    };\n\n    Pair.prototype.pad_and_encrypt = function(data, params, cb) {\n      var c_mpis, err, m, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/elgamal.iced\",\n            funcname: \"Pair.pad_and_encrypt\"\n          });\n          eme_pkcs1_encode(data, _this.pub.p.mpi_byte_length(), __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return m = arguments[1];\n              };\n            })(),\n            lineno: 112\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            if (err == null) {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/elgamal.iced\",\n                  funcname: \"Pair.pad_and_encrypt\"\n                });\n                _this.pub.encrypt(m, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return c_mpis = arguments[0];\n                    };\n                  })(),\n                  lineno: 114\n                }));\n                __iced_deferrals._fulfill();\n              })(function() {\n                return __iced_k(ret = _this.export_output({\n                  c_mpis: c_mpis\n                }));\n              });\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            return cb(err, ret);\n          });\n        };\n      })(this));\n    };\n\n    Pair.prototype.decrypt_and_unpad = function(ciphertext, params, cb) {\n      var b, err, m, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/elgamal.iced\",\n            funcname: \"Pair.decrypt_and_unpad\"\n          });\n          _this.priv.decrypt(ciphertext.c(), __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return m = arguments[1];\n              };\n            })(),\n            lineno: 122\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          var _ref4;\n          if (err == null) {\n            b = m.to_padded_octets(_this.pub.p);\n            _ref4 = eme_pkcs1_decode(b), err = _ref4[0], ret = _ref4[1];\n          }\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    Pair.parse_output = function(buf) {\n      return Output.parse(buf);\n    };\n\n    Pair.prototype.export_output = function(args) {\n      return new Output(args);\n    };\n\n    return Pair;\n\n  })(BaseKeyPair);\n\n  Output = (function() {\n    function Output(_arg) {\n      this.c_mpis = _arg.c_mpis, this.c_bufs = _arg.c_bufs;\n    }\n\n    Output.parse = function(buf) {\n      var c_mpis, err, i, n, ret;\n      c_mpis = (function() {\n        var _i, _ref4, _results;\n        _results = [];\n        for (i = _i = 0; _i < 2; i = ++_i) {\n          _ref4 = bn.mpi_from_buffer(buf), err = _ref4[0], ret = _ref4[1], buf = _ref4[2], n = _ref4[3];\n          if (err != null) {\n            throw err;\n          }\n          _results.push(ret);\n        }\n        return _results;\n      })();\n      if (buf.length !== 0) {\n        throw new Error(\"junk at the end of input\");\n      }\n      return new Output({\n        c_mpis: c_mpis\n      });\n    };\n\n    Output.prototype.c = function() {\n      return this.c_mpis;\n    };\n\n    Output.prototype.hide = function(_arg, cb) {\n      var c_mpi, err, key, max, new_c_mpis, slosh, tmp, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      key = _arg.key, max = _arg.max, slosh = _arg.slosh;\n      max || (max = 4096);\n      slosh || (slosh = 128);\n      err = null;\n      this.c_bufs = null;\n      new_c_mpis = [];\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _len, _ref4, _results, _while;\n          _ref4 = _this.c_mpis;\n          _len = _ref4.length;\n          _i = 0;\n          _results = [];\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = function() {\n              return __iced_k(_results);\n            };\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++_i;\n                return _while(__iced_k);\n              });\n            };\n            _next = function(__iced_next_arg) {\n              _results.push(__iced_next_arg);\n              return _continue();\n            };\n            if (!(_i < _len)) {\n              return _break();\n            } else {\n              c_mpi = _ref4[_i];\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/elgamal.iced\",\n                  funcname: \"Output.hide\"\n                });\n                key.hide({\n                  i: c_mpi,\n                  max: max,\n                  slosh: slosh\n                }, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return tmp = arguments[1];\n                    };\n                  })(),\n                  lineno: 164\n                }));\n                __iced_deferrals._fulfill();\n              })(function() {\n                new_c_mpis.push(tmp);\n                (function(__iced_k) {\n                  if (err != null) {\n                    (function(__iced_k) {\n_break()\n                    })(__iced_k);\n                  } else {\n                    return __iced_k();\n                  }\n                })(_next);\n              });\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (err == null) {\n            _this.c_mpis = new_c_mpis;\n          }\n          return cb(err);\n        };\n      })(this));\n    };\n\n    Output.prototype.find = function(_arg) {\n      var j, key;\n      key = _arg.key;\n      return this.c_mpis = (function() {\n        var _i, _len, _ref4, _results;\n        _ref4 = this.c_mpis;\n        _results = [];\n        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {\n          j = _ref4[_i];\n          _results.push(key.find(j));\n        }\n        return _results;\n      }).call(this);\n    };\n\n    Output.prototype.get_c_bufs = function() {\n      var i;\n      if (this.c_bufs != null) {\n        return this.c_bufs;\n      } else {\n        return this.c_bufs = (function() {\n          var _i, _len, _ref4, _results;\n          _ref4 = this.c_mpis;\n          _results = [];\n          for (_i = 0, _len = _ref4.length; _i < _len; _i++) {\n            i = _ref4[_i];\n            _results.push(i.to_mpi_buffer());\n          }\n          return _results;\n        }).call(this);\n      }\n    };\n\n    Output.prototype.output = function() {\n      return Buffer.concat(this.get_c_bufs());\n    };\n\n    return Output;\n\n  })();\n\n  exports.ElGamal = exports.Pair = Pair;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./basekeypair\":2,\"./bn\":4,\"./const\":5,\"./pad\":62,\"./rand\":65,\"./util\":70,\"buffer\":80,\"iced-error\":115,\"iced-runtime\":118}],13:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var ASP, BaseKey, BaseKeyPair, C, K, MRF, Pair, Priv, Pub, SRF, bn, bufeq_secure, eme_pkcs1_decode, eme_pkcs1_encode, konst, make_esc, _ref, _ref1, _ref2, _ref3,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  bn = require('./bn');\n\n  _ref = require('./util'), bufeq_secure = _ref.bufeq_secure, ASP = _ref.ASP;\n\n  make_esc = require('iced-error').make_esc;\n\n  konst = require('./const');\n\n  C = konst.openpgp;\n\n  K = konst.kb;\n\n  _ref1 = require('./basekeypair'), BaseKeyPair = _ref1.BaseKeyPair, BaseKey = _ref1.BaseKey;\n\n  _ref2 = require('./rand'), SRF = _ref2.SRF, MRF = _ref2.MRF;\n\n  _ref3 = require('./pad'), eme_pkcs1_encode = _ref3.eme_pkcs1_encode, eme_pkcs1_decode = _ref3.eme_pkcs1_decode;\n\n  Pub = (function(_super) {\n    __extends(Pub, _super);\n\n    Pub.type = C.public_key_algorithms.ELGAMAL_SIGN_AND_ENCRYPT;\n\n    Pub.prototype.type = Pub.type;\n\n    Pub.ORDER = [];\n\n    Pub.prototype.ORDER = Pub.ORDER;\n\n    function Pub(raw) {\n      this.raw = raw;\n    }\n\n    Pub.alloc = function(raw) {\n      return BaseKey.alloc(Pub, raw);\n    };\n\n    Pub.prototype.encrypt = function(m, cb) {\n      return cb(null);\n    };\n\n    return Pub;\n\n  })(BaseKey);\n\n  Priv = (function(_super) {\n    __extends(Priv, _super);\n\n    Priv.ORDER = [];\n\n    Priv.prototype.ORDER = Priv.ORDER;\n\n    function Priv(raw) {\n      this.raw = raw;\n    }\n\n    Priv.prototype.serialize = function() {\n      return null;\n    };\n\n    Priv.alloc = function(raw, pub) {\n      return BaseKey.alloc(Priv, raw, {\n        pub: pub\n      });\n    };\n\n    Priv.prototype.decrypt = function(c, cb) {\n      return cb(null);\n    };\n\n    return Priv;\n\n  })(BaseKey);\n\n  Pair = (function(_super) {\n    __extends(Pair, _super);\n\n    Pair.Pub = Pub;\n\n    Pair.prototype.Pub = Pub;\n\n    Pair.Priv = Priv;\n\n    Pair.prototype.Priv = Priv;\n\n    Pair.type = C.public_key_algorithms.ELGAMAL_SIGN_AND_ENCRYPT;\n\n    Pair.prototype.type = Pair.type;\n\n    Pair.prototype.fulfills_flags = function(flags) {\n      return false;\n    };\n\n    Pair.prototype.is_toxic = function() {\n      return true;\n    };\n\n    function Pair(_arg) {\n      var priv, pub;\n      pub = _arg.pub, priv = _arg.priv;\n      Pair.__super__.constructor.call(this, {\n        pub: pub,\n        priv: priv\n      });\n    }\n\n    Pair.prototype.can_sign = function() {\n      return false;\n    };\n\n    Pair.prototype.can_decrypt = function() {\n      return false;\n    };\n\n    Pair.prototype.err = function() {\n      return new Error(\"refusing to use ElGamal Sign+Encrypt\");\n    };\n\n    Pair.parse = function(pub_raw) {\n      var ret;\n      ret = BaseKeyPair.parse(Pair, pub_raw);\n      return ret;\n    };\n\n    Pair.prototype.pad_and_encrypt = function(data, cb) {\n      return cb(this.err(), null);\n    };\n\n    Pair.prototype.decrypt_and_unpad = function(ciphertext, params, cb) {\n      return cb(this.err(), null);\n    };\n\n    Pair.parse_output = function(buf) {\n      return null;\n    };\n\n    Pair.prototype.export_output = function(args) {\n      return null;\n    };\n\n    return Pair;\n\n  })(BaseKeyPair);\n\n  exports.ElGamalSignEncrypt = exports.Pair = Pair;\n\n}).call(this);\n\n},{\"./basekeypair\":2,\"./bn\":4,\"./const\":5,\"./pad\":62,\"./rand\":65,\"./util\":70,\"iced-error\":115}],14:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, WordArray, algos, alloc, alloc_or_throw, decorate, k, make_hasher, make_streamer, streamers, triplesec, v, _lookup, _ref;\n\n  C = require('./const').openpgp;\n\n  triplesec = require('triplesec');\n\n  WordArray = triplesec.WordArray;\n\n  algos = triplesec.hash;\n\n  decorate = function(f, klass, name, type) {\n    f.type = type;\n    f.algname = name;\n    f.output_length = klass.output_size;\n    f.klass = klass;\n    return f;\n  };\n\n  make_hasher = function(klass, name, type) {\n    var f;\n    if (klass != null) {\n      f = function(x) {\n        return (new klass).bufhash(x);\n      };\n      return decorate(f, klass, name, type);\n    } else {\n      return null;\n    }\n  };\n\n  make_streamer = function(klass, name, type) {\n    return function() {\n      var obj, ret;\n      obj = new klass;\n      ret = function(buf) {\n        return obj.clone().finalize(buf != null ? WordArray.from_buffer(buf) : null).to_buffer();\n      };\n      ret.update = function(buf) {\n        if (buf != null) {\n          obj.update(WordArray.from_buffer(buf));\n        }\n        return this;\n      };\n      return decorate(ret, klass, name, type);\n    };\n  };\n\n  _lookup = {};\n\n  exports.streamers = streamers = {};\n\n  _ref = C.hash_algorithms;\n  for (k in _ref) {\n    v = _ref[k];\n    _lookup[v] = k;\n    exports[k] = make_hasher(algos[k], k, v);\n    streamers[k] = make_streamer(algos[k], k, v);\n  }\n\n  exports.alloc = alloc = function(typ) {\n    var klass, name, ret;\n    ret = null;\n    name = _lookup[typ];\n    if (name != null) {\n      klass = algos[name];\n    }\n    if (klass != null) {\n      ret = make_hasher(klass, name, typ);\n    }\n    return ret;\n  };\n\n  exports.alloc_or_throw = alloc_or_throw = function(typ) {\n    var ret;\n    ret = alloc(typ);\n    if (!ret) {\n      throw new Error(\"unknown hash type: \" + typ);\n    }\n    return ret;\n  };\n\n}).call(this);\n\n},{\"./const\":5,\"triplesec\":181}],15:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, pjs;\n\n  C = require('./const');\n\n  pjs = require('../package.json');\n\n  exports.header = {\n    version: C.header.version + (\" v\" + pjs.version),\n    comment: C.header.comment\n  };\n\n}).call(this);\n\n},{\"../package.json\":202,\"./const\":5}],16:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var K, SHA256, alloc, bufeq_secure, katch, null_hash, obj_extract, pack, purepack, read_base64, seal, unpack, unseal, _ref, _ref1;\n\n  K = require('../const').kb;\n\n  _ref = require('../hash'), alloc = _ref.alloc, SHA256 = _ref.SHA256;\n\n  purepack = require('purepack');\n\n  _ref1 = require('../util'), katch = _ref1.katch, obj_extract = _ref1.obj_extract, bufeq_secure = _ref1.bufeq_secure;\n\n  null_hash = new Buffer(0);\n\n  pack = function(x) {\n    return purepack.pack(x, {\n      sort_keys: true\n    });\n  };\n\n  unpack = function(x) {\n    return purepack.unpack(x);\n  };\n\n  seal = function(_arg) {\n    var dohash, hasher, obj, oo, packed;\n    obj = _arg.obj, dohash = _arg.dohash;\n    hasher = SHA256;\n    oo = {\n      version: K.versions.V1,\n      tag: obj.tag,\n      body: obj.body\n    };\n    if (dohash) {\n      oo.hash = {\n        type: hasher.type,\n        value: null_hash\n      };\n      packed = pack(oo);\n      oo.hash.value = hasher(packed);\n    }\n    return pack(oo);\n  };\n\n  read_base64 = function(raw) {\n    var parts;\n    parts = (raw.split(/\\s+/)).join('');\n    return new Buffer(parts, 'base64');\n  };\n\n  unseal = function(buf) {\n    var h, hasher, hv, oo, t, _ref2;\n    oo = unpack(buf);\n    if ((hv = oo != null ? (_ref2 = oo.hash) != null ? _ref2.value : void 0 : void 0) != null) {\n      oo.hash.value = null_hash;\n      hasher = alloc((t = oo.hash.type));\n      if (hasher == null) {\n        throw new Error(\"unknown hash algo: \" + t);\n      }\n      h = hasher(pack(oo));\n      if (!bufeq_secure(h, hv)) {\n        throw new Error(\"hash mismatch\");\n      }\n      if (oo.version !== K.versions.V1) {\n        throw new Error(\"unknown version\");\n      }\n    }\n    return obj_extract(oo, ['tag', 'body']);\n  };\n\n  exports.seal = seal;\n\n  exports.pack = pack;\n\n  exports.unseal = unseal;\n\n  exports.unpack = unpack;\n\n  exports.read_base64 = read_base64;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../const\":5,\"../hash\":14,\"../util\":70,\"buffer\":80,\"purepack\":169}],17:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, DH, EdDSA, EncKeyManager, Encryption, K, KeyManager, KeyManagerInterface, Signature, SignatureEngine, akatch, alloc, asyncify, base64u, box, buffer_xor, encode, iced, konst, make_esc, unbox, __iced_k, __iced_k_noop, _ref,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  KeyManagerInterface = require('../kmi').KeyManagerInterface;\n\n  make_esc = require('iced-error').make_esc;\n\n  encode = require('./encode');\n\n  _ref = require('../util'), base64u = _ref.base64u, buffer_xor = _ref.buffer_xor, asyncify = _ref.asyncify, akatch = _ref.akatch;\n\n  konst = require('../const');\n\n  alloc = require('./packet/alloc').alloc;\n\n  Signature = require('./packet/signature').Signature;\n\n  Encryption = require('./packet/encryption').Encryption;\n\n  EdDSA = require('../nacl/eddsa').EdDSA;\n\n  DH = require('../nacl/dh').DH;\n\n  K = konst.kb;\n\n  C = konst.openpgp;\n\n  KeyManager = (function(_super) {\n    __extends(KeyManager, _super);\n\n    function KeyManager(_arg) {\n      this.key = _arg.key, this.server_half = _arg.server_half;\n    }\n\n    KeyManager.generate = function(_arg, cb) {\n      var algo, err, key, klass, seed, server_half, split, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      algo = _arg.algo, seed = _arg.seed, split = _arg.split, server_half = _arg.server_half, klass = _arg.klass;\n      algo || (algo = EdDSA);\n      klass || (klass = KeyManager);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\",\n            funcname: \"KeyManager.generate\"\n          });\n          algo.generate({\n            split: split,\n            seed: seed,\n            server_half: server_half\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                key = arguments[1];\n                return server_half = arguments[2];\n              };\n            })(),\n            lineno: 29\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, new klass({\n            key: key,\n            server_half: server_half\n          }));\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.get_mask = function() {\n      return C.key_flags.sign_data | C.key_flags.certify_keys | C.key_flags.auth;\n    };\n\n    KeyManager.prototype.fetch = function(key_ids, flags, cb) {\n      var err, key, mask, s;\n      s = this.key.ekid().toString('hex');\n      key = null;\n      mask = this.get_mask();\n      if ((__indexOf.call(key_ids, s) >= 0) && (flags & mask) === flags) {\n        key = this.key;\n      } else {\n        err = new Error(\"Key not found\");\n      }\n      return cb(err, key);\n    };\n\n    KeyManager.prototype.get_keypair = function() {\n      return this.key;\n    };\n\n    KeyManager.prototype.get_primary_keypair = function() {\n      return this.key;\n    };\n\n    KeyManager.prototype.can_verify = function() {\n      return true;\n    };\n\n    KeyManager.prototype.can_sign = function() {\n      var _ref1;\n      return (_ref1 = this.key) != null ? _ref1.can_sign() : void 0;\n    };\n\n    KeyManager.prototype.eq = function(km2) {\n      return this.key.eq(km2.key);\n    };\n\n    KeyManager.import_public = function(_arg, cb) {\n      var err, hex, key, raw, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      hex = _arg.hex, raw = _arg.raw;\n      err = ret = null;\n      if (hex != null) {\n        raw = new Buffer(hex, 'hex');\n      }\n      _ref1 = EdDSA.parse_kb(raw), err = _ref1[0], key = _ref1[1];\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err != null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\",\n                funcname: \"KeyManager.import_public\"\n              });\n              EncKeyManager.import_public({\n                raw: raw\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return ret = arguments[1];\n                  };\n                })(),\n                lineno: 67\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k(ret = new KeyManager({\n              key: key\n            }));\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.check_public_eq = function(km2) {\n      return this.eq(km2);\n    };\n\n    KeyManager.prototype.export_public = function(_arg, cb) {\n      var asp, regen, ret;\n      asp = _arg.asp, regen = _arg.regen;\n      ret = this.key.ekid().toString('hex');\n      return cb(null, ret);\n    };\n\n    KeyManager.prototype.export_server_half = function() {\n      var _ref1;\n      return (_ref1 = this.server_half) != null ? _ref1.toString('hex') : void 0;\n    };\n\n    KeyManager.prototype.get_ekid = function() {\n      return this.get_keypair().ekid();\n    };\n\n    KeyManager.prototype.get_fp2 = function() {\n      return this.get_ekid();\n    };\n\n    KeyManager.prototype.get_fp2_formatted = function() {\n      return base64u.encode(this.get_fp2());\n    };\n\n    KeyManager.prototype.get_type = function() {\n      return \"kb\";\n    };\n\n    KeyManager.prototype.make_sig_eng = function() {\n      return new SignatureEngine({\n        km: this\n      });\n    };\n\n    return KeyManager;\n\n  })(KeyManagerInterface);\n\n  EncKeyManager = (function(_super) {\n    __extends(EncKeyManager, _super);\n\n    function EncKeyManager() {\n      return EncKeyManager.__super__.constructor.apply(this, arguments);\n    }\n\n    EncKeyManager.generate = function(params, cb) {\n      params.algo = DH;\n      params.klass = EncKeyManager;\n      return KeyManager.generate(params, cb);\n    };\n\n    EncKeyManager.prototype.make_sig_eng = function() {\n      return null;\n    };\n\n    EncKeyManager.prototype.can_sign = function() {\n      return false;\n    };\n\n    EncKeyManager.prototype.can_verify = function() {\n      return false;\n    };\n\n    EncKeyManager.prototype.can_encrypt = function() {\n      return true;\n    };\n\n    EncKeyManager.prototype.can_decrypt = function() {\n      var _ref1;\n      return ((_ref1 = this.key) != null ? _ref1.priv : void 0) != null;\n    };\n\n    EncKeyManager.prototype.get_mask = function() {\n      return C.key_flags.encrypt_comm | C.key_flags.encrypt_storage;\n    };\n\n    EncKeyManager.import_public = function(_arg, cb) {\n      var err, hex, key, raw, ret, _ref1;\n      hex = _arg.hex, raw = _arg.raw;\n      err = ret = null;\n      if (hex != null) {\n        raw = new Buffer(hex, 'hex');\n      }\n      _ref1 = DH.parse_kb(raw), err = _ref1[0], key = _ref1[1];\n      if (err == null) {\n        ret = new EncKeyManager({\n          key: key\n        });\n      }\n      return cb(err, ret);\n    };\n\n    return EncKeyManager;\n\n  })(KeyManager);\n\n  exports.unbox = unbox = function(_arg, cb) {\n    var armored, binary, encrypt_for, esc, packet, rawobj, res, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    armored = _arg.armored, binary = _arg.binary, rawobj = _arg.rawobj, encrypt_for = _arg.encrypt_for;\n    esc = make_esc(cb, \"unbox\");\n    (function(_this) {\n      return (function(__iced_k) {\n        if ((armored == null) && (rawobj == null) && (binary == null)) {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\"\n            });\n            athrow(new Error(\"need either 'armored' or 'binary' or 'rawobj'\"), esc(__iced_deferrals.defer({\n              lineno: 137\n            })));\n            __iced_deferrals._fulfill();\n          })(__iced_k);\n        } else {\n          return __iced_k();\n        }\n      });\n    })(this)((function(_this) {\n      return function() {\n        if (armored != null) {\n          binary = new Buffer(armored, 'base64');\n        }\n        (function(__iced_k) {\n          if (binary != null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\"\n              });\n              akatch((function() {\n                return encode.unseal(binary);\n              }), esc(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return rawobj = arguments[0];\n                  };\n                })(),\n                lineno: 142\n              })));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        })(function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\"\n            });\n            asyncify(alloc(rawobj), esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return packet = arguments[0];\n                };\n              })(),\n              lineno: 144\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\"\n              });\n              packet.unbox({\n                encrypt_for: encrypt_for\n              }, esc(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return res = arguments[0];\n                  };\n                })(),\n                lineno: 145\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              if (res.keypair != null) {\n                res.km = new KeyManager({\n                  key: res.keypair\n                });\n              }\n              if (res.sender_keypair != null) {\n                res.sender_km = new KeyManager({\n                  key: res.sender_keypair\n                });\n              }\n              if (res.receiver_keypair != null) {\n                res.receiver_km = new KeyManager({\n                  key: res.receiver_keypair\n                });\n              }\n              return cb(null, res, binary);\n            });\n          });\n        });\n      };\n    })(this));\n  };\n\n  box = function(_arg, cb) {\n    var anonymous, armored, encrypt_for, esc, msg, packed, packet, sealed, sign_with, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    msg = _arg.msg, sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for, anonymous = _arg.anonymous;\n    esc = make_esc(cb, \"box\");\n    (function(_this) {\n      return (function(__iced_k) {\n        if (encrypt_for != null) {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\"\n            });\n            Encryption.box({\n              sign_with: sign_with,\n              encrypt_for: encrypt_for,\n              plaintext: msg,\n              anonymous: anonymous\n            }, esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return packet = arguments[0];\n                };\n              })(),\n              lineno: 161\n            })));\n            __iced_deferrals._fulfill();\n          })(__iced_k);\n        } else {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\"\n            });\n            Signature.box({\n              km: sign_with,\n              payload: msg\n            }, esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return packet = arguments[0];\n                };\n              })(),\n              lineno: 163\n            })));\n            __iced_deferrals._fulfill();\n          })(__iced_k);\n        }\n      });\n    })(this)((function(_this) {\n      return function() {\n        packed = packet.frame_packet();\n        sealed = encode.seal({\n          obj: packed,\n          dohash: false\n        });\n        armored = sealed.toString('base64');\n        return cb(null, armored, sealed);\n      };\n    })(this));\n  };\n\n  SignatureEngine = (function() {\n    function SignatureEngine(_arg) {\n      this.km = _arg.km;\n    }\n\n    SignatureEngine.prototype.get_km = function() {\n      return this.km;\n    };\n\n    SignatureEngine.prototype.box = function(msg, cb) {\n      var armored, esc, out, raw, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"SignatureEngine::box\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\",\n            funcname: \"SignatureEngine.box\"\n          });\n          box({\n            msg: msg,\n            sign_with: _this.km\n          }, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                armored = arguments[0];\n                return raw = arguments[1];\n              };\n            })(),\n            lineno: 182\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          out = {\n            type: \"kb\",\n            armored: armored,\n            kb: armored,\n            raw: raw\n          };\n          return cb(null, out);\n        };\n      })(this));\n    };\n\n    SignatureEngine.prototype.unbox = function(msg, cb) {\n      var a, arg, b, binary, err, esc, payload, res, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"SignatureEngine::unbox\");\n      err = payload = null;\n      arg = Buffer.isBuffer(msg) ? {\n        binary: msg\n      } : {\n        armored: msg\n      };\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\",\n            funcname: \"SignatureEngine.unbox\"\n          });\n          unbox(arg, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                res = arguments[0];\n                return binary = arguments[1];\n              };\n            })(),\n            lineno: 193\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (!res.km.eq(_this.km)) {\n            a = res.km.get_ekid().toString('hex');\n            b = _this.km.get_ekid().toString('hex');\n            err = new Error(\"Got wrong signing key: \" + a + \" != \" + b);\n          } else {\n            payload = res.payload;\n          }\n          return cb(err, payload, binary);\n        };\n      })(this));\n    };\n\n    return SignatureEngine;\n\n  })();\n\n  module.exports = {\n    box: box,\n    unbox: unbox,\n    KeyManager: KeyManager,\n    EncKeyManager: EncKeyManager\n  };\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../const\":5,\"../kmi\":27,\"../nacl/dh\":30,\"../nacl/eddsa\":31,\"../util\":70,\"./encode\":16,\"./packet/alloc\":18,\"./packet/encryption\":20,\"./packet/signature\":22,\"buffer\":80,\"iced-error\":115,\"iced-runtime\":118}],18:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var Encryption, K, P3SKB, Signature;\n\n  K = require('../../const').kb;\n\n  P3SKB = require('./p3skb').P3SKB;\n\n  Signature = require('./signature').Signature;\n\n  Encryption = require('./encryption').Encryption;\n\n  exports.alloc = function(_arg) {\n    var body, err, ret, tag;\n    tag = _arg.tag, body = _arg.body;\n    ret = err = null;\n    ret = (function() {\n      switch (tag) {\n        case K.packet_tags.p3skb:\n          return P3SKB.alloc({\n            tag: tag,\n            body: body\n          });\n        case K.packet_tags.signature:\n          return Signature.alloc({\n            tag: tag,\n            body: body\n          });\n        case K.packet_tags.encryption:\n          return Encryption.alloc({\n            tag: tag,\n            body: body\n          });\n        default:\n          err = new Error(\"unknown packet tag: \" + tag);\n          return null;\n      }\n    })();\n    return [err, ret];\n  };\n\n}).call(this);\n\n},{\"../../const\":5,\"./encryption\":20,\"./p3skb\":21,\"./signature\":22}],19:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var K, Packet, seal, util;\n\n  util = require('../../util');\n\n  seal = require('../encode').seal;\n\n  K = require('../../const').kb;\n\n  Packet = (function() {\n    function Packet() {}\n\n    Packet.prototype.frame_packet = function() {\n      return {\n        tag: this.tag(),\n        body: this.get_packet_body()\n      };\n    };\n\n    Packet.prototype.frame_packet_armored = function(_arg) {\n      var dohash, obj;\n      dohash = _arg.dohash;\n      obj = this.frame_packet();\n      return seal({\n        obj: obj,\n        dohash: dohash\n      }).toString('base64');\n    };\n\n    Packet.prototype.is_signature = function() {\n      return false;\n    };\n\n    Packet.prototype.is_p3skb = function() {\n      return false;\n    };\n\n    Packet.alloc = function(_arg) {\n      var P3SKB, Signature, body, err, ret, tag;\n      tag = _arg.tag, body = _arg.body;\n      ret = err = null;\n      ret = (function() {\n        switch (tag) {\n          case K.packet_tags.p3skb:\n            P3SKB = require('./p3skb').P3SKB;\n            return P3SKB.alloc({\n              tag: tag,\n              body: body\n            });\n          case K.packet_tags.signature:\n            Signature = require('./signature').Signature;\n            return Signature.alloc({\n              tag: tag,\n              body: body\n            });\n          default:\n            err = new Error(\"unknown packet tag: \" + tag);\n            return null;\n        }\n      })();\n      return [err, ret];\n    };\n\n    Packet.prototype.unbox = function(params, cb) {\n      return cb(new Error(\"unbox() unimplemented for tag=\" + this.tag));\n    };\n\n    return Packet;\n\n  })();\n\n  exports.Packet = Packet;\n\n}).call(this);\n\n},{\"../../const\":5,\"../../util\":70,\"../encode\":16,\"./p3skb\":21,\"./signature\":22}],20:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, Encryption, K, Packet, dh, iced, konst, make_esc, __iced_k, __iced_k_noop,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  konst = require('../../const');\n\n  K = konst.kb;\n\n  C = konst.openpgp;\n\n  Packet = require('./base').Packet;\n\n  make_esc = require('iced-error').make_esc;\n\n  dh = require('../../nacl/main').dh;\n\n  Encryption = (function(_super) {\n    __extends(Encryption, _super);\n\n    Encryption.ENC_TYPE = K.public_key_algorithms.NACL_DH;\n\n    Encryption.tag = function() {\n      return K.packet_tags.encryption;\n    };\n\n    Encryption.prototype.tag = function() {\n      return Encryption.tag();\n    };\n\n    function Encryption(_arg) {\n      this.encrypt_for = _arg.encrypt_for, this.sign_with = _arg.sign_with, this.plaintext = _arg.plaintext, this.ciphertext = _arg.ciphertext, this.sender_key = _arg.sender_key, this.nonce = _arg.nonce, this.anonymous = _arg.anonymous;\n      Encryption.__super__.constructor.call(this);\n      this.emphemeral = false;\n    }\n\n    Encryption.prototype.get_packet_body = function() {\n      var enc_type;\n      enc_type = Encryption.ENC_TYPE;\n      return {\n        sender_key: this.sender_key,\n        ciphertext: this.ciphertext,\n        nonce: this.nonce,\n        enc_type: enc_type,\n        receiver_key: this.receiver_key\n      };\n    };\n\n    Encryption.alloc = function(_arg) {\n      var a, b, body, err, ret, tag;\n      tag = _arg.tag, body = _arg.body;\n      ret = null;\n      err = tag !== Encryption.tag() ? new Error(\"wrong tag found: \" + tag) : (a = body.enc_type) !== (b = Encryption.ENC_TYPE) ? err = new Error(\"Expected Curve25519 DH (type \" + b + \"); got \" + a) : (ret = new Encryption(body), null);\n      if (err != null) {\n        throw err;\n      }\n      return ret;\n    };\n\n    Encryption.prototype.is_signature = function() {\n      return false;\n    };\n\n    Encryption.prototype.get_sender_keypair = function(_arg, cb) {\n      var encrypt, err, ret, sign_with, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      sign_with = _arg.sign_with, encrypt = _arg.encrypt;\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (sign_with != null) {\n            return __iced_k(ret = sign_with.get_keypair());\n          } else {\n            (function(__iced_k) {\n              if (_this.sign_with != null) {\n                return __iced_k(ret = _this.sign_with.get_keypair());\n              } else {\n                (function(__iced_k) {\n                  if (_this.sender_keypair != null) {\n                    return __iced_k(ret = _this.sender_keypair);\n                  } else {\n                    (function(__iced_k) {\n                      var _ref;\n                      if (encrypt) {\n                        (function(__iced_k) {\n                          __iced_deferrals = new iced.Deferrals(__iced_k, {\n                            parent: ___iced_passed_deferral,\n                            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/encryption.iced\",\n                            funcname: \"Encryption.get_sender_keypair\"\n                          });\n                          dh.Pair.generate({}, __iced_deferrals.defer({\n                            assign_fn: (function(__slot_1) {\n                              return function() {\n                                err = arguments[0];\n                                return __slot_1.sender_keypair = arguments[1];\n                              };\n                            })(_this),\n                            lineno: 56\n                          }));\n                          __iced_deferrals._fulfill();\n                        })(function() {\n                          ret = _this.sender_keypair;\n                          return __iced_k(_this.emphemeral = true);\n                        });\n                      } else {\n                        return __iced_k(_this.sender_key != null ? ((_ref = dh.Pair.parse_kb(_this.sender_key), err = _ref[0], _this.sender_keypair = _ref[1], _ref), err == null ? ret = _this.sender_keypair : void 0) : err = new Error(\"Cannot encrypt without a sender keypair\"));\n                      }\n                    })(__iced_k);\n                  }\n                })(__iced_k);\n              }\n            })(__iced_k);\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    Encryption.prototype.encrypt = function(params, cb) {\n      var esc, plaintext, recvr, sender, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"encrypt\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/encryption.iced\",\n            funcname: \"Encryption.encrypt\"\n          });\n          _this.get_sender_keypair({\n            encrypt: true\n          }, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return sender = arguments[0];\n              };\n            })(),\n            lineno: 71\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          recvr = _this.encrypt_for.get_keypair();\n          plaintext = Buffer.concat([_this.plaintext, new Buffer([_this.emphemeral ? 1 : 0])]);\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/encryption.iced\",\n              funcname: \"Encryption.encrypt\"\n            });\n            recvr.encrypt_kb({\n              plaintext: plaintext,\n              sender: sender\n            }, esc(__iced_deferrals.defer({\n              assign_fn: (function(__slot_1, __slot_2) {\n                return function() {\n                  __slot_1.ciphertext = arguments[0].ciphertext;\n                  return __slot_2.nonce = arguments[0].nonce;\n                };\n              })(_this, _this),\n              lineno: 77\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            if (!(_this.anonymous && !_this.emphemeral)) {\n              _this.sender_key = sender.ekid();\n            }\n            if (!_this.anonymous) {\n              _this.receiver_key = recvr.ekid();\n            }\n            return cb(null);\n          });\n        };\n      })(this));\n    };\n\n    Encryption.prototype.decrypt = function(_arg, cb) {\n      var args, encrypt_for, esc, plaintext, recvr, sender, sign_with, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for;\n      esc = make_esc(cb, \"decrypt\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/encryption.iced\",\n            funcname: \"Encryption.decrypt\"\n          });\n          _this.get_sender_keypair({\n            sign_with: sign_with\n          }, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return sender = arguments[0];\n              };\n            })(),\n            lineno: 86\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          args = {\n            ciphertext: _this.ciphertext,\n            nonce: _this.nonce,\n            sender: sender\n          };\n          recvr = encrypt_for.get_keypair();\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/encryption.iced\",\n              funcname: \"Encryption.decrypt\"\n            });\n            recvr.decrypt_kb(args, esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return plaintext = arguments[0];\n                };\n              })(),\n              lineno: 89\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            _this.plaintext = plaintext.slice(0, -1);\n            _this.emphemeral = plaintext.slice(-1)[0];\n            return cb(null, {\n              sender_keypair: sender,\n              plaintext: _this.plaintext,\n              emphemeral: _this.emphemeral,\n              receiver_keypair: recvr\n            });\n          });\n        };\n      })(this));\n    };\n\n    Encryption.prototype.unbox = function(_arg, cb) {\n      var encrypt_for, err, res, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      encrypt_for = _arg.encrypt_for;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/encryption.iced\",\n            funcname: \"Encryption.unbox\"\n          });\n          _this.decrypt({\n            encrypt_for: encrypt_for\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return res = arguments[1];\n              };\n            })(),\n            lineno: 97\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, res);\n        };\n      })(this));\n    };\n\n    Encryption.box = function(_arg, cb) {\n      var anonymous, encrypt_for, err, packet, plaintext, sign_with, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for, plaintext = _arg.plaintext, anonymous = _arg.anonymous;\n      packet = new Encryption({\n        sign_with: sign_with,\n        encrypt_for: encrypt_for,\n        plaintext: plaintext,\n        anonymous: anonymous\n      });\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/encryption.iced\",\n            funcname: \"Encryption.box\"\n          });\n          packet.encrypt({}, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 104\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (typeof err !== \"undefined\" && err !== null) {\n            packet = null;\n          }\n          return cb(err, packet);\n        };\n      })(this));\n    };\n\n    return Encryption;\n\n  })(Packet);\n\n  exports.Encryption = Encryption;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../../const\":5,\"../../nacl/main\":32,\"./base\":19,\"buffer\":80,\"iced-error\":115,\"iced-runtime\":118}],21:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var Decryptor, K, P3SKB, Packet, SHA512, box, bufeq_secure, bufferify, iced, make_esc, native_rng, pack, rsa, triplesec, __iced_k, __iced_k_noop, _ref, _ref1,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  K = require('../../const').kb;\n\n  triplesec = require('triplesec');\n\n  SHA512 = require('../../hash').SHA512;\n\n  Decryptor = triplesec.Decryptor;\n\n  native_rng = triplesec.prng.native_rng;\n\n  Packet = require('./base').Packet;\n\n  _ref = require('../encode'), pack = _ref.pack, box = _ref.box;\n\n  make_esc = require('iced-error').make_esc;\n\n  rsa = require('../../rsa');\n\n  _ref1 = require('../../util'), bufeq_secure = _ref1.bufeq_secure, bufferify = _ref1.bufferify;\n\n  P3SKB = (function(_super) {\n    __extends(P3SKB, _super);\n\n    P3SKB.tag = function() {\n      return K.packet_tags.p3skb;\n    };\n\n    P3SKB.prototype.tag = function() {\n      return P3SKB.tag();\n    };\n\n    function P3SKB(_arg) {\n      var priv, priv_clear;\n      this.pub = _arg.pub, priv_clear = _arg.priv_clear, priv = _arg.priv, this.type = _arg.type;\n      P3SKB.__super__.constructor.call(this);\n      this.priv = priv != null ? priv : priv_clear != null ? {\n        data: priv_clear,\n        encryption: K.key_encryption.none\n      } : void 0;\n    }\n\n    P3SKB.prototype.get_packet_body = function() {\n      var ret;\n      ret = {\n        pub: this.pub,\n        priv: this.priv\n      };\n      if (this.type != null) {\n        ret.type = this.type;\n      }\n      return ret;\n    };\n\n    P3SKB.prototype.lock = function(_arg, cb) {\n      var asp, ct, err, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      asp = _arg.asp, tsenc = _arg.tsenc;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/p3skb.iced\",\n            funcname: \"P3SKB.lock\"\n          });\n          tsenc.run({\n            data: _this.priv.data,\n            progress_hook: asp != null ? asp.progress_hook() : void 0\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return ct = arguments[1];\n              };\n            })(),\n            lineno: 30\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (typeof err === \"undefined\" || err === null) {\n            _this.priv.data = ct;\n            _this.priv.encryption = K.key_encryption.triplesec_v3;\n          }\n          return cb(err);\n        };\n      })(this));\n    };\n\n    P3SKB.prototype.unlock = function(_arg, cb) {\n      var asp, dec, err, progress_hook, raw, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      asp = _arg.asp, tsenc = _arg.tsenc;\n      (function(_this) {\n        return (function(__iced_k) {\n          switch (_this.priv.encryption) {\n            case K.key_encryption.triplesec_v3:\n            case K.key_encryption.triplesec_v2:\n            case K.key_encryption.triplesec_v1:\n              dec = new Decryptor({\n                enc: tsenc\n              });\n              progress_hook = asp != null ? asp.progress_hook() : void 0;\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/p3skb.iced\",\n                  funcname: \"P3SKB.unlock\"\n                });\n                dec.run({\n                  data: _this.priv.data,\n                  progress_hook: progress_hook\n                }, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return raw = arguments[1];\n                    };\n                  })(),\n                  lineno: 41\n                }));\n                __iced_deferrals._fulfill();\n              })(function() {\n                dec.scrub();\n                return __iced_k(typeof err === \"undefined\" || err === null ? (_this.priv.data = raw, _this.priv.encryption = K.key_encryption.none) : void 0);\n              });\n              break;\n            case K.key_encryption.none:\n              return __iced_k();\n            default:\n              return __iced_k(err = new Error(\"Unknown key encryption type: \" + k.encryption));\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    P3SKB.alloc = function(_arg) {\n      var body, tag;\n      tag = _arg.tag, body = _arg.body;\n      if (tag === P3SKB.tag()) {\n        return new P3SKB(body);\n      } else {\n        throw new Error(\"wrong tag found: \" + tag);\n      }\n    };\n\n    P3SKB.prototype.has_private = function() {\n      return this.priv != null;\n    };\n\n    P3SKB.prototype.is_locked = function() {\n      return this.priv.encryption !== K.key_encryption.none;\n    };\n\n    P3SKB.prototype.get_private_data = function() {\n      var _ref2;\n      return (_ref2 = this.priv) != null ? _ref2.data : void 0;\n    };\n\n    P3SKB.prototype.get_public_data = function() {\n      return this.pub;\n    };\n\n    P3SKB.prototype.get_key_type = function() {\n      return this.type;\n    };\n\n    P3SKB.prototype.is_p3skb = function() {\n      return true;\n    };\n\n    return P3SKB;\n\n  })(Packet);\n\n  exports.P3SKB = P3SKB;\n\n}).call(this);\n\n},{\"../../const\":5,\"../../hash\":14,\"../../rsa\":67,\"../../util\":70,\"../encode\":16,\"./base\":19,\"iced-error\":115,\"iced-runtime\":118,\"triplesec\":181}],22:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, K, Packet, Signature, eddsa, iced, konst, make_esc, __iced_k, __iced_k_noop,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  konst = require('../../const');\n\n  K = konst.kb;\n\n  C = konst.openpgp;\n\n  Packet = require('./base').Packet;\n\n  make_esc = require('iced-error').make_esc;\n\n  eddsa = require('../../nacl/main').eddsa;\n\n  Signature = (function(_super) {\n    __extends(Signature, _super);\n\n    Signature.SIG_TYPE = K.public_key_algorithms.NACL_EDDSA;\n\n    Signature.HASH_TYPE = C.hash_algorithms.SHA512;\n\n    Signature.tag = function() {\n      return K.packet_tags.signature;\n    };\n\n    Signature.prototype.tag = function() {\n      return Signature.tag();\n    };\n\n    function Signature(_arg) {\n      this.key = _arg.key, this.payload = _arg.payload, this.sig = _arg.sig, this.detached = _arg.detached;\n      Signature.__super__.constructor.call(this);\n    }\n\n    Signature.prototype.get_packet_body = function() {\n      var hash_type, sig_type;\n      sig_type = Signature.SIG_TYPE;\n      hash_type = Signature.HASH_TYPE;\n      return {\n        key: this.key,\n        payload: this.payload,\n        sig: this.sig,\n        detached: this.detached,\n        sig_type: sig_type,\n        hash_type: hash_type\n      };\n    };\n\n    Signature.alloc = function(_arg) {\n      var a, b, body, err, ret, tag;\n      tag = _arg.tag, body = _arg.body;\n      ret = null;\n      err = tag !== Signature.tag() ? new Error(\"wrong tag found: \" + tag) : (a = body.hash_type) !== (b = Signature.HASH_TYPE) ? new Error(\"Expected SHA512 (type \" + b + \"); got \" + a) : (a = body.sig_type) !== (b = Signature.SIG_TYPE) ? err = new Error(\"Expected EDDSA (type \" + b + \"); got \" + a) : (ret = new Signature(body), null);\n      if (err != null) {\n        throw err;\n      }\n      return ret;\n    };\n\n    Signature.prototype.is_signature = function() {\n      return true;\n    };\n\n    Signature.prototype.verify = function(cb) {\n      var err, esc, km, pair, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"verify\");\n      err = km = null;\n      _ref = eddsa.Pair.parse_kb(this.key), err = _ref[0], pair = _ref[1];\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err == null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/signature.iced\",\n                funcname: \"Signature.verify\"\n              });\n              pair.verify_kb(_this, esc(__iced_deferrals.defer({\n                lineno: 58\n              })));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, {\n            keypair: pair,\n            payload: _this.payload\n          });\n        };\n      })(this));\n    };\n\n    Signature.prototype.unbox = function(params, cb) {\n      var err, res, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/signature.iced\",\n            funcname: \"Signature.unbox\"\n          });\n          _this.verify(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return res = arguments[1];\n              };\n            })(),\n            lineno: 64\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, res);\n        };\n      })(this));\n    };\n\n    Signature.box = function(_arg, cb) {\n      var detached, esc, km, packet, pair, payload, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      km = _arg.km, payload = _arg.payload;\n      esc = make_esc(cb, \"@sign\");\n      pair = km.get_keypair();\n      detached = true;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/signature.iced\",\n            funcname: \"Signature.box\"\n          });\n          pair.sign_kb({\n            payload: payload,\n            detached: detached\n          }, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return sig = arguments[0];\n              };\n            })(),\n            lineno: 73\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          packet = new Signature({\n            key: pair.ekid(),\n            payload: payload,\n            sig: sig,\n            detached: detached\n          });\n          return cb(null, packet);\n        };\n      })(this));\n    };\n\n    return Signature;\n\n  })(Packet);\n\n  exports.Signature = Signature;\n\n  exports.sign = Signature.sign;\n\n}).call(this);\n\n},{\"../../const\":5,\"../../nacl/main\":32,\"./base\":19,\"iced-error\":115,\"iced-runtime\":118}],23:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var SRF, bufxor, genseed, iced, __iced_k, __iced_k_noop;\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  SRF = require('../rand').SRF;\n\n  exports.bufxor = bufxor = function(b1, b2) {\n    var arr, c, i;\n    arr = (function() {\n      var _i, _len, _results;\n      _results = [];\n      for (i = _i = 0, _len = b1.length; _i < _len; i = ++_i) {\n        c = b1[i];\n        _results.push(c ^ b2[i]);\n      }\n      return _results;\n    })();\n    return new Buffer(arr);\n  };\n\n  exports.genseed = genseed = function(_arg, cb) {\n    var err, len, rseed, seed, server_half, split, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    seed = _arg.seed, split = _arg.split, len = _arg.len, server_half = _arg.server_half;\n    err = rseed = null;\n    if (server_half == null) {\n      server_half = null;\n    }\n    (function(_this) {\n      return (function(__iced_k) {\n        if ((seed == null) || (split && (server_half == null))) {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/keybase/util.iced\"\n            });\n            SRF().random_bytes(len, __iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return rseed = arguments[0];\n                };\n              })(),\n              lineno: 16\n            }));\n            __iced_deferrals._fulfill();\n          })(__iced_k);\n        } else {\n          return __iced_k();\n        }\n      });\n    })(this)((function(_this) {\n      return function() {\n        if ((seed != null) && seed.length !== len) {\n          err = new Error(\"Wrong seed length; need \" + len + \" bytes; got \" + seed.length);\n        } else if ((seed != null) && (rseed != null)) {\n          server_half = rseed;\n          seed = bufxor(seed, rseed);\n        } else if ((seed != null) && (server_half != null)) {\n          seed = bufxor(seed, server_half);\n        } else if (seed == null) {\n          seed = rseed;\n        }\n        return cb(err, {\n          seed: seed,\n          server_half: server_half\n        });\n      };\n    })(this));\n  };\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../rand\":65,\"buffer\":80,\"iced-runtime\":118}],24:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var KeyFetcher;\n\n  KeyFetcher = (function() {\n    function KeyFetcher() {}\n\n    KeyFetcher.prototype.fetch = function(ids, ops, cb) {\n      return cb(new Error(\"not implemented\"));\n    };\n\n    return KeyFetcher;\n\n  })();\n\n  exports.KeyFetcher = KeyFetcher;\n\n}).call(this);\n\n},{}],25:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var KeyFetcher, PgpKeyRing, hexkid,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  KeyFetcher = require('./keyfetch').KeyFetcher;\n\n  hexkid = function(k) {\n    return k.toString('hex');\n  };\n\n  PgpKeyRing = (function(_super) {\n    __extends(PgpKeyRing, _super);\n\n    function PgpKeyRing() {\n      this._keys = {};\n      this._kms = {};\n    }\n\n    PgpKeyRing.prototype.add_key_manager = function(km) {\n      var k, keys, kid, _i, _len, _results;\n      keys = km.export_pgp_keys_to_keyring();\n      _results = [];\n      for (_i = 0, _len = keys.length; _i < _len; _i++) {\n        k = keys[_i];\n        kid = hexkid(k.key_material.get_key_id());\n        this._keys[kid] = k;\n        _results.push(this._kms[kid] = km);\n      }\n      return _results;\n    };\n\n    PgpKeyRing.prototype.fetch = function(key_ids, ops, cb) {\n      var err, i, id, k, key_material, km, obj, ret_i, _i, _len, _ref;\n      key_material = err = obj = null;\n      key_ids = (function() {\n        var _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = key_ids.length; _i < _len; _i++) {\n          k = key_ids[_i];\n          _results.push(hexkid(k));\n        }\n        return _results;\n      })();\n      km = null;\n      for (i = _i = 0, _len = key_ids.length; _i < _len; i = ++_i) {\n        id = key_ids[i];\n        k = this._keys[id];\n        if (k != null ? (_ref = k.key) != null ? _ref.can_perform(ops) : void 0 : void 0) {\n          ret_i = i;\n          km = this._kms[id];\n          break;\n        }\n      }\n      if (km == null) {\n        err = new Error(\"key not found: \" + (JSON.stringify(key_ids)));\n      }\n      return cb(err, km, ret_i);\n    };\n\n    PgpKeyRing.prototype.find_best_key = function(_arg, cb) {\n      var err, flags, key, key_id, kid, km;\n      key_id = _arg.key_id, flags = _arg.flags;\n      if ((km = this._kms[(kid = hexkid(key_id))]) == null) {\n        err = new Error(\"Could not find key for fingerprint \" + kid);\n      } else if ((key = km.find_best_pgp_key(flags)) == null) {\n        err = new Error(\"no matching key for flags: \" + flags);\n      }\n      return cb(err, key);\n    };\n\n    PgpKeyRing.prototype.lookup = function(key_id) {\n      return this._keys[hexkid(key_id)];\n    };\n\n    return PgpKeyRing;\n\n  })(KeyFetcher);\n\n  exports.PgpKeyRing = PgpKeyRing;\n\n  exports.KeyRing = PgpKeyRing;\n\n}).call(this);\n\n},{\"./keyfetch\":24}],26:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, KeyWrapper, Lifespan, Primary, Subkey,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  C = require('./const');\n\n  Lifespan = (function() {\n    function Lifespan(_arg) {\n      this.generated = _arg.generated, this.expire_in = _arg.expire_in;\n      if (this.expire_in == null) {\n        this.expire_in = C.default_key_expire_in;\n      }\n    }\n\n    return Lifespan;\n\n  })();\n\n  KeyWrapper = (function() {\n    function KeyWrapper(_arg) {\n      this.key = _arg.key, this.lifespan = _arg.lifespan, this._pgp = _arg._pgp, this._keybase = _arg._keybase, this.flags = _arg.flags;\n    }\n\n    KeyWrapper.prototype.ekid = function() {\n      return this.key.ekid();\n    };\n\n    return KeyWrapper;\n\n  })();\n\n  Subkey = (function(_super) {\n    __extends(Subkey, _super);\n\n    function Subkey(_arg) {\n      var flags, key, lifespan, _keybase, _pgp;\n      key = _arg.key, flags = _arg.flags, _pgp = _arg._pgp, _keybase = _arg._keybase, this.desc = _arg.desc, lifespan = _arg.lifespan, this.primary = _arg.primary;\n      Subkey.__super__.constructor.call(this, {\n        key: key,\n        lifespan: lifespan,\n        flags: flags,\n        _pgp: _pgp,\n        _keybase: _keybase\n      });\n    }\n\n    return Subkey;\n\n  })(KeyWrapper);\n\n  Primary = (function(_super) {\n    __extends(Primary, _super);\n\n    function Primary(_arg) {\n      var flags, key, lifespan, _keybase, _pgp;\n      key = _arg.key, lifespan = _arg.lifespan, flags = _arg.flags, _pgp = _arg._pgp, _keybase = _arg._keybase;\n      Primary.__super__.constructor.call(this, {\n        key: key,\n        lifespan: lifespan,\n        flags: flags,\n        _pgp: _pgp,\n        _keybase: _keybase\n      });\n    }\n\n    return Primary;\n\n  })(KeyWrapper);\n\n  exports.Lifespan = Lifespan;\n\n  exports.Subkey = Subkey;\n\n  exports.Primary = Primary;\n\n}).call(this);\n\n},{\"./const\":5}],27:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var EUI, KeyFetcher, KeyManagerInterface, SignatureEngineInterface,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  KeyFetcher = require('./keyfetch').KeyFetcher;\n\n  EUI = new Error(\"not implemented\");\n\n  exports.KeyManagerInterface = KeyManagerInterface = (function(_super) {\n    __extends(KeyManagerInterface, _super);\n\n    function KeyManagerInterface() {}\n\n    KeyManagerInterface.prototype.get_pgp_fingerprint = function() {\n      return null;\n    };\n\n    KeyManagerInterface.prototype.get_ekid = function() {\n      return null;\n    };\n\n    KeyManagerInterface.prototype.get_fp2 = function() {\n      return null;\n    };\n\n    KeyManagerInterface.prototype.get_fp2_formatted = function() {\n      return null;\n    };\n\n    KeyManagerInterface.prototype.get_type = function() {\n      return null;\n    };\n\n    KeyManagerInterface.prototype.check_public_eq = function(km2) {\n      return this.EUI;\n    };\n\n    KeyManagerInterface.prototype.get_userids = function() {\n      return [];\n    };\n\n    KeyManagerInterface.prototype.get_primary_keypair = function() {\n      return null;\n    };\n\n    KeyManagerInterface.prototype.get_all_pgp_key_materials = function() {\n      return [];\n    };\n\n    KeyManagerInterface.prototype.get_userids_mark_primary = function() {\n      return [];\n    };\n\n    KeyManagerInterface.prototype.make_sig_eng = function() {\n      return null;\n    };\n\n    KeyManagerInterface.prototype.export_public = function(_arg, cb) {\n      var asp, regen;\n      asp = _arg.asp, regen = _arg.regen;\n      return cb(EUI, null);\n    };\n\n    KeyManagerInterface.prototype.can_verify = function() {\n      return false;\n    };\n\n    KeyManagerInterface.prototype.can_sign = function() {\n      return false;\n    };\n\n    KeyManagerInterface.prototype.can_encrypt = function() {\n      return false;\n    };\n\n    KeyManagerInterface.prototype.can_decrypt = function() {\n      return false;\n    };\n\n    return KeyManagerInterface;\n\n  })(KeyFetcher);\n\n  exports.SignatureEngineInterface = SignatureEngineInterface = (function() {\n    function SignatureEngineInterface(_arg) {\n      this.km = _arg.km;\n    }\n\n    SignatureEngineInterface.prototype.get_km = function() {\n      return this.km;\n    };\n\n    SignatureEngineInterface.prototype.box = function(msg, cb) {\n      return cb(EUI);\n    };\n\n    SignatureEngineInterface.prototype.unbox = function(msb, cb) {\n      return cb(EUI);\n    };\n\n    return SignatureEngineInterface;\n\n  })();\n\n}).call(this);\n\n},{\"./keyfetch\":24}],28:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var Lock, NamedLock, Table, iced, __iced_k, __iced_k_noop,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  Lock = (function() {\n    function Lock() {\n      this._open = true;\n      this._waiters = [];\n    }\n\n    Lock.prototype.acquire = function(cb) {\n      if (this._open) {\n        this._open = false;\n        return cb();\n      } else {\n        return this._waiters.push(cb);\n      }\n    };\n\n    Lock.prototype.release = function() {\n      var w;\n      if (this._waiters.length) {\n        w = this._waiters.shift();\n        return w();\n      } else {\n        return this._open = true;\n      }\n    };\n\n    Lock.prototype.open = function() {\n      return this._open;\n    };\n\n    return Lock;\n\n  })();\n\n  NamedLock = (function(_super) {\n    __extends(NamedLock, _super);\n\n    function NamedLock(tab, name) {\n      this.tab = tab;\n      this.name = name;\n      NamedLock.__super__.constructor.call(this);\n      this.refs = 0;\n    }\n\n    NamedLock.prototype.incref = function() {\n      return ++this.refs;\n    };\n\n    NamedLock.prototype.decref = function() {\n      return --this.refs;\n    };\n\n    NamedLock.prototype.release = function() {\n      NamedLock.__super__.release.call(this);\n      if (this.decref() === 0) {\n        return delete this.tab[this.name];\n      }\n    };\n\n    return NamedLock;\n\n  })(Lock);\n\n  Table = (function() {\n    function Table() {\n      this.locks = {};\n    }\n\n    Table.prototype.create = function(name) {\n      var l;\n      l = new NamedLock(this, name);\n      return this.locks[name] = l;\n    };\n\n    Table.prototype.acquire = function(name, cb, wait) {\n      var l, was_open, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      l = this.locks[name] || this.create(name);\n      was_open = l._open;\n      l.incref();\n      (function(_this) {\n        return (function(__iced_k) {\n          if (wait || l._open) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/kbpgp/src/lock.iced\",\n                funcname: \"Table.acquire\"\n              });\n              l.acquire(__iced_deferrals.defer({\n                lineno: 68\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k(l = null);\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(l, was_open);\n        };\n      })(this));\n    };\n\n    Table.prototype.lookup = function(name) {\n      return this.locks[name];\n    };\n\n    return Table;\n\n  })();\n\n  exports.Lock = Lock;\n\n  exports.Table = Table;\n\n}).call(this);\n\n},{\"iced-runtime\":118}],29:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var k, m, mods, util, v, _i, _len;\n\n  mods = [require(\"./openpgp/keymanager\"), require(\"./basex\"), require(\"./openpgp/burner\"), require(\"./openpgp/hilev\"), require(\"./keyfetch\"), require(\"./keyring\")];\n\n  for (_i = 0, _len = mods.length; _i < _len; _i++) {\n    m = mods[_i];\n    for (k in m) {\n      v = m[k];\n      exports[k] = v;\n    }\n  }\n\n  exports.util = util = require('./util');\n\n  exports.ASP = util.ASP;\n\n  exports.rand = require('./rand');\n\n  exports[\"const\"] = require('./const');\n\n  exports.processor = require('./openpgp/processor');\n\n  exports.armor = require('./openpgp/armor');\n\n  exports.keyring = require('./keyring');\n\n  exports.parser = require('./openpgp/parser');\n\n  exports.Buffer = Buffer;\n\n  exports.triplesec = require('triplesec');\n\n  exports.hash = require('./hash');\n\n  exports.ecc = require('./ecc/main');\n\n  exports.nacl = require('./nacl/main');\n\n  exports.kb = require('./keybase/hilev');\n\n  exports.ukm = require('./ukm');\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./basex\":3,\"./const\":5,\"./ecc/main\":11,\"./hash\":14,\"./keybase/hilev\":17,\"./keyfetch\":24,\"./keyring\":25,\"./nacl/main\":32,\"./openpgp/armor\":33,\"./openpgp/burner\":36,\"./openpgp/hilev\":41,\"./openpgp/keymanager\":42,\"./openpgp/parser\":56,\"./openpgp/processor\":57,\"./rand\":65,\"./ukm\":69,\"./util\":70,\"buffer\":80,\"triplesec\":181}],30:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var BaseKey, BaseKeyPair, K, NaclEddsa, Pair, Priv, Pub, SRF, TYPE, b2u, box, bufeq_fast, genseed, iced, konst, u2b, __iced_k, __iced_k_noop, _ref, _ref1, _ref2,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  box = require('tweetnacl').box;\n\n  SRF = require('../rand').SRF;\n\n  konst = require('../const');\n\n  K = konst.kb;\n\n  _ref = require('../util'), genseed = _ref.genseed, bufeq_fast = _ref.bufeq_fast;\n\n  _ref1 = require('../basekeypair'), BaseKey = _ref1.BaseKey, BaseKeyPair = _ref1.BaseKeyPair;\n\n  _ref2 = require('./eddsa'), b2u = _ref2.b2u, u2b = _ref2.u2b;\n\n  NaclEddsa = require('./eddsa').Pair;\n\n  TYPE = K.public_key_algorithms.NACL_DH;\n\n  b2u = function(b) {\n    return new Uint8Array(b);\n  };\n\n  u2b = function(u) {\n    return new Buffer(u);\n  };\n\n  Pub = (function() {\n    Pub.HEADER = new Buffer([K.kid.version, TYPE]);\n\n    Pub.TRAILER = new Buffer([K.kid.trailer]);\n\n    Pub.LEN = Pub.HEADER.length + Pub.TRAILER.length + box.publicKeyLength;\n\n    function Pub(key) {\n      this.key = key;\n    }\n\n    Pub.alloc_kb = function(kid) {\n      var err, key;\n      err = key = null;\n      err = kid.length !== Pub.LEN ? new Error(\"bad key length\") : !bufeq_fast(kid.slice(-1), Pub.TRAILER) ? new Error(\"bad trailing byte\") : !bufeq_fast(kid.slice(0, 2), Pub.HEADER) ? new Error(\"bad header\") : (key = new Pub(kid.slice(2, -1)), null);\n      return [err, key];\n    };\n\n    Pub.prototype.serialize = function() {\n      return this.key;\n    };\n\n    Pub.prototype.nbits = function() {\n      return 255;\n    };\n\n    Pub.prototype.read_params = function(sb) {};\n\n    Pub.prototype.encrypt = function(_arg, cb) {\n      var nonce, plaintext, res, sender, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      plaintext = _arg.plaintext, sender = _arg.sender;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/nacl/dh.iced\",\n            funcname: \"Pub.encrypt\"\n          });\n          SRF().random_bytes(box.nonceLength, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return nonce = arguments[0];\n              };\n            })(),\n            lineno: 49\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          res = box(b2u(plaintext), b2u(nonce), b2u(_this.key), b2u(sender.priv.key));\n          return cb(null, {\n            ciphertext: u2b(res),\n            nonce: nonce\n          });\n        };\n      })(this));\n    };\n\n    return Pub;\n\n  })();\n\n  Priv = (function() {\n    function Priv(key) {\n      this.key = key;\n    }\n\n    Priv.prototype.alloc = function(raw) {\n      var err, key;\n      err = key = null;\n      if (raw.length !== box.secretKeyLength) {\n        err = new Error(\"Bad secret key length\");\n      } else {\n        key = new Priv(raw);\n      }\n      return [err, key];\n    };\n\n    Priv.prototype.decrypt = function(_arg, cb) {\n      var ciphertext, err, nonce, res, sender;\n      ciphertext = _arg.ciphertext, nonce = _arg.nonce, sender = _arg.sender;\n      err = res = null;\n      res = box.open(b2u(ciphertext), b2u(nonce), b2u(sender.pub.key), b2u(this.key));\n      if (res === false) {\n        err = new Error(\"decryption failed\");\n        res = null;\n      } else {\n        res = u2b(res);\n      }\n      return cb(err, res);\n    };\n\n    return Priv;\n\n  })();\n\n  Pair = (function(_super) {\n    __extends(Pair, _super);\n\n    Pair.Pub = Pub;\n\n    Pair.prototype.Pub = Pub;\n\n    Pair.Priv = Priv;\n\n    Pair.prototype.Priv = Priv;\n\n    function Pair(_arg) {\n      var priv, pub;\n      pub = _arg.pub, priv = _arg.priv;\n      Pair.__super__.constructor.call(this, {\n        pub: pub,\n        priv: priv\n      });\n    }\n\n    Pair.type = K.public_key_algorithms.NACL_DH;\n\n    Pair.prototype.type = Pair.type;\n\n    Pair.prototype.get_type = function() {\n      return this.type;\n    };\n\n    Pair.klass_name = \"DH\";\n\n    Pair.prototype.can_encrypt = function() {\n      return true;\n    };\n\n    Pair.prototype.can_sign = function() {\n      return false;\n    };\n\n    Pair.prototype.hash = function() {\n      return this.serialize();\n    };\n\n    Pair.prototype.encrypt_kb = function(_arg, cb) {\n      var plaintext, sender;\n      plaintext = _arg.plaintext, sender = _arg.sender;\n      return this.pub.encrypt({\n        plaintext: plaintext,\n        sender: sender\n      }, cb);\n    };\n\n    Pair.prototype.decrypt_kb = function(_arg, cb) {\n      var ciphertext, err, nonce, plaintex, plaintext, sender, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      ciphertext = _arg.ciphertext, nonce = _arg.nonce, sender = _arg.sender;\n      err = plaintex = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (_this.priv != null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/nacl/dh.iced\",\n                funcname: \"Pair.decrypt_kb\"\n              });\n              _this.priv.decrypt({\n                ciphertext: ciphertext,\n                nonce: nonce,\n                sender: sender\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return plaintext = arguments[1];\n                  };\n                })(),\n                lineno: 117\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k(err = new Error(\"no secret key available\"));\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, plaintext);\n        };\n      })(this));\n    };\n\n    Pair.subkey_algo = function(flags) {\n      if (flags & (C.key_flags.encrypt_comm | C.key_flags.encrypt_storage)) {\n        return Pair;\n      } else {\n        return NaclEddsa;\n      }\n    };\n\n    Pair.prototype.fulfills_flags = function(flags) {\n      var good_for;\n      good_for = C.key_flags.encrypt_comm | C.key_flags.encrypt_storage;\n      return (flags & good_for) === flags;\n    };\n\n    Pair.prototype.verify_unpad_and_check_hash = function(_arg, cb) {\n      var data, hash, hasher, sig;\n      sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash;\n      return cb(new Error(\"verify_unpad_and_check_hash unsupported\"));\n    };\n\n    Pair.prototype.pad_and_sign = function(data, _arg, cb) {\n      var hasher;\n      hasher = _arg.hasher;\n      return cb(new Error(\"pad_and_sign unsupported\"));\n    };\n\n    Pair.parse_kb = function(pub_raw) {\n      return BaseKeyPair.parse_kb(Pair, pub_raw);\n    };\n\n    Pair.parse_sig = function(slice) {\n      var err;\n      err = new Error(\"@parse_sig unsupported\");\n      throw err;\n    };\n\n    Pair.read_sig_from_buf = function(buf) {\n      var err;\n      err = new Error(\"@read_sig_from_buf unsupported\");\n      return [err];\n    };\n\n    Pair.generate = function(_arg, cb) {\n      var arg, err, priv, pub, publicKey, secretKey, seed, server_half, split, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      server_half = _arg.server_half, seed = _arg.seed, split = _arg.split;\n      arg = {\n        seed: seed,\n        split: split,\n        len: box.secretKeyLength,\n        server_half: server_half\n      };\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/nacl/dh.iced\",\n            funcname: \"Pair.generate\"\n          });\n          genseed(arg, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                server_half = arguments[1].server_half;\n                return seed = arguments[1].seed;\n              };\n            })(),\n            lineno: 178\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          var _ref3;\n          if (typeof err === \"undefined\" || err === null) {\n            _ref3 = box.keyPair.fromSecretKey(b2u(seed)), secretKey = _ref3.secretKey, publicKey = _ref3.publicKey;\n            pub = new Pub(u2b(publicKey));\n            priv = new Priv(u2b(secretKey));\n          }\n          return cb(err, new Pair({\n            pub: pub,\n            priv: priv\n          }), server_half);\n        };\n      })(this));\n    };\n\n    return Pair;\n\n  })(BaseKeyPair);\n\n  exports.DH = exports.Pair = Pair;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../basekeypair\":2,\"../const\":5,\"../rand\":65,\"../util\":70,\"./eddsa\":31,\"buffer\":80,\"iced-runtime\":118,\"tweetnacl\":201}],31:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var BaseKey, BaseKeyPair, K, NaclDh, Pair, Priv, Pub, SRF, TYPE, b2u, bufeq_fast, bufeq_secure, genseed, iced, konst, sign, u2b, __iced_k, __iced_k_noop, _ref, _ref1,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  sign = require('tweetnacl/nacl-fast').sign;\n\n  SRF = require('../rand').SRF;\n\n  konst = require('../const');\n\n  K = konst.kb;\n\n  _ref = require('../util'), genseed = _ref.genseed, bufeq_secure = _ref.bufeq_secure, bufeq_fast = _ref.bufeq_fast;\n\n  _ref1 = require('../basekeypair'), BaseKey = _ref1.BaseKey, BaseKeyPair = _ref1.BaseKeyPair;\n\n  NaclDh = require('./dh').Pair;\n\n  TYPE = K.public_key_algorithms.NACL_EDDSA;\n\n  exports.b2u = b2u = function(b) {\n    return new Uint8Array(b);\n  };\n\n  exports.u2b = u2b = function(u) {\n    return new Buffer(u);\n  };\n\n  Pub = (function() {\n    Pub.HEADER = new Buffer([K.kid.version, TYPE]);\n\n    Pub.TRAILER = new Buffer([K.kid.trailer]);\n\n    Pub.LEN = Pub.HEADER.length + Pub.TRAILER.length + sign.publicKeyLength;\n\n    function Pub(key) {\n      this.key = key;\n    }\n\n    Pub.alloc_kb = function(kid) {\n      var err, key;\n      err = key = null;\n      err = kid.length !== Pub.LEN ? new Error(\"bad key length\") : !bufeq_fast(kid.slice(-1), Pub.TRAILER) ? new Error(\"bad trailing byte\") : !bufeq_fast(kid.slice(0, 2), Pub.HEADER) ? new Error(\"bad header\") : (key = new Pub(kid.slice(2, -1)), null);\n      return [err, key];\n    };\n\n    Pub.prototype.serialize = function() {\n      return this.key;\n    };\n\n    Pub.prototype.nbits = function() {\n      return 255;\n    };\n\n    Pub.prototype.read_params = function(sb) {};\n\n    Pub.prototype.verify = function(_arg, cb) {\n      var detached, err, payload, r_payload, sig;\n      payload = _arg.payload, sig = _arg.sig, detached = _arg.detached;\n      if (detached) {\n        if (payload == null) {\n          payload = new Buffer([]);\n        }\n        if (!sign.detached.verify(b2u(payload), b2u(sig), b2u(this.key))) {\n          err = new Error(\"signature didn't verify\");\n        }\n      } else if ((r_payload = sign.open(b2u(sig), b2u(this.key))) == null) {\n        err = new Error(\"signature didn't verify\");\n      } else if ((r_payload = u2b(r_payload)) == null) {\n        err = new Error(\"failed to convert from a Uint8Array to a buffer\");\n      } else if ((payload != null) && !bufeq_secure(r_payload, payload)) {\n        err = new Error(\"got unexpected payload\");\n      } else {\n        payload = r_payload;\n      }\n      return cb(err, payload);\n    };\n\n    return Pub;\n\n  })();\n\n  Priv = (function() {\n    function Priv(key) {\n      this.key = key;\n    }\n\n    Priv.prototype.alloc = function(raw) {\n      var err, key;\n      err = key = null;\n      if (raw.length !== sign.secretKeyLength) {\n        err = new Error(\"Bad secret key length\");\n      } else {\n        key = new Priv(raw);\n      }\n      return [err, key];\n    };\n\n    Priv.prototype.sign = function(_arg, cb) {\n      var detached, f, payload, sig;\n      payload = _arg.payload, detached = _arg.detached;\n      f = detached ? sign.detached : sign;\n      sig = u2b(f(b2u(payload), b2u(this.key)));\n      return cb(sig);\n    };\n\n    return Priv;\n\n  })();\n\n  Pair = (function(_super) {\n    __extends(Pair, _super);\n\n    Pair.Pub = Pub;\n\n    Pair.prototype.Pub = Pub;\n\n    Pair.Priv = Priv;\n\n    Pair.prototype.Priv = Priv;\n\n    Pair.type = K.public_key_algorithms.NACL_EDDSA;\n\n    Pair.prototype.type = Pair.type;\n\n    Pair.prototype.get_type = function() {\n      return this.type;\n    };\n\n    Pair.klass_name = \"EDDSA\";\n\n    function Pair(_arg) {\n      var priv, pub;\n      pub = _arg.pub, priv = _arg.priv;\n      Pair.__super__.constructor.call(this, {\n        pub: pub,\n        priv: priv\n      });\n    }\n\n    Pair.prototype.can_encrypt = function() {\n      return false;\n    };\n\n    Pair.prototype.hash = function() {\n      return this.serialize();\n    };\n\n    Pair.prototype.sign_kb = function(_arg, cb) {\n      var detached, err, payload, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      payload = _arg.payload, detached = _arg.detached;\n      err = sig = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (_this.priv != null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/nacl/eddsa.iced\",\n                funcname: \"Pair.sign_kb\"\n              });\n              _this.priv.sign({\n                payload: payload,\n                detached: detached\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return sig = arguments[0];\n                  };\n                })(),\n                lineno: 119\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k(err = new Error(\"no secret key available\"));\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, sig);\n        };\n      })(this));\n    };\n\n    Pair.prototype.verify_kb = function(_arg, cb) {\n      var detached, payload, sig;\n      payload = _arg.payload, sig = _arg.sig, detached = _arg.detached;\n      return this.pub.verify({\n        payload: payload,\n        sig: sig,\n        detached: detached\n      }, cb);\n    };\n\n    Pair.subkey_algo = function(flags) {\n      if (flags & (C.key_flags.certify_keys | C.key_flags.sign_data)) {\n        return Pair;\n      } else {\n        return NaclDh;\n      }\n    };\n\n    Pair.prototype.fulfills_flags = function(flags) {\n      var good_for;\n      good_for = C.key_flags.certify_keys | C.key_flags.sign_data;\n      return (flags & good_for) === flags;\n    };\n\n    Pair.prototype.verify_unpad_and_check_hash = function(_arg, cb) {\n      var data, hash, hasher, sig;\n      sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash;\n      return cb(new Error(\"verify_unpad_and_check_hash unsupported\"));\n    };\n\n    Pair.prototype.pad_and_sign = function(data, _arg, cb) {\n      var hasher;\n      hasher = _arg.hasher;\n      return cb(new Error(\"pad_and_sign unsupported\"));\n    };\n\n    Pair.parse_kb = function(pub_raw) {\n      return BaseKeyPair.parse_kb(Pair, pub_raw);\n    };\n\n    Pair.parse_sig = function(slice) {\n      var err;\n      err = new Error(\"@parse_sig unsupported\");\n      throw err;\n    };\n\n    Pair.read_sig_from_buf = function(buf) {\n      var err;\n      err = new Error(\"@read_sig_from_buf unsupported\");\n      return [err];\n    };\n\n    Pair.generate = function(_arg, cb) {\n      var arg, err, priv, pub, publicKey, secretKey, seed, server_half, split, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      seed = _arg.seed, split = _arg.split, server_half = _arg.server_half;\n      arg = {\n        seed: seed,\n        split: split,\n        len: sign.seedLength,\n        server_half: server_half\n      };\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/nacl/eddsa.iced\",\n            funcname: \"Pair.generate\"\n          });\n          genseed(arg, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                server_half = arguments[1].server_half;\n                return seed = arguments[1].seed;\n              };\n            })(),\n            lineno: 185\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          var _ref2;\n          if (typeof err === \"undefined\" || err === null) {\n            _ref2 = sign.keyPair.fromSeed(b2u(seed)), secretKey = _ref2.secretKey, publicKey = _ref2.publicKey;\n            pub = new Pub(u2b(publicKey));\n            priv = new Priv(u2b(secretKey));\n          }\n          return cb(err, new Pair({\n            pub: pub,\n            priv: priv\n          }), server_half);\n        };\n      })(this));\n    };\n\n    return Pair;\n\n  })(BaseKeyPair);\n\n  exports.EdDSA = exports.Pair = Pair;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../basekeypair\":2,\"../const\":5,\"../rand\":65,\"../util\":70,\"./dh\":30,\"buffer\":80,\"iced-runtime\":118,\"tweetnacl/nacl-fast\":200}],32:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  exports.eddsa = require('./eddsa');\n\n  exports.dh = require('./dh');\n\n}).call(this);\n\n},{\"./dh\":30,\"./eddsa\":31}],33:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, Ch, Parser, armor, bufeq_fast, decode, katch, uint_to_buffer, _ref,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  _ref = require('../util'), katch = _ref.katch, bufeq_fast = _ref.bufeq_fast, uint_to_buffer = _ref.uint_to_buffer;\n\n  C = require('../const');\n\n  Ch = require('../header');\n\n  armor = require('pgp-utils').armor;\n\n  exports.encode = function(type, data) {\n    var mt;\n    mt = C.openpgp.message_types;\n    type = (function() {\n      switch (type) {\n        case mt.public_key:\n          return \"PUBLIC KEY BLOCK\";\n        case mt.private_key:\n          return \"PRIVATE KEY BLOCK\";\n        case mt.signature:\n          return \"SIGNATURE\";\n        case mt.generic:\n          return \"MESSAGE\";\n        default:\n          throw new Error(\"Cannot encode tag type \" + type);\n      }\n    })();\n    return armor.encode(Ch, type, data);\n  };\n\n  Parser = (function(_super) {\n    __extends(Parser, _super);\n\n    function Parser() {\n      return Parser.__super__.constructor.apply(this, arguments);\n    }\n\n    Parser.prototype.parse_type = function() {\n      var mt;\n      mt = C.openpgp.message_types;\n      this.ret.type = (function() {\n        switch (this.type) {\n          case \"PUBLIC KEY BLOCK\":\n            return mt.public_key;\n          case \"PRIVATE KEY BLOCK\":\n            return mt.private_key;\n          case \"SIGNED MESSAGE\":\n            if (this.ret.clearsign) {\n              return mt.clearsign;\n            } else {\n              throw new Error(\"Signed message, but not clear-signed\");\n            }\n            break;\n          case \"SIGNATURE\":\n            return mt.signature;\n          case \"MESSAGE\":\n            return mt.generic;\n          default:\n            throw new Error(\"Unknown message type: \" + this.type);\n        }\n      }).call(this);\n      return this.ret.fields.type = this.type;\n    };\n\n    return Parser;\n\n  })(armor.Parser);\n\n  exports.Message = armor.Message;\n\n  exports.decode = decode = function(data) {\n    return katch(function() {\n      return (new Parser(data)).parse();\n    });\n  };\n\n  exports.mdecode = decode = function(data) {\n    return katch(function() {\n      return (new Parser(data)).mparse();\n    });\n  };\n\n}).call(this);\n\n},{\"../const\":5,\"../header\":15,\"../util\":70,\"pgp-utils\":163}],34:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var ASP, BaseBurner, iced, make_esc, __iced_k, __iced_k_noop,\n    __slice = [].slice;\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  make_esc = require('iced-error').make_esc;\n\n  ASP = require('pgp-utils').util.ASP;\n\n  exports.BaseBurner = BaseBurner = (function() {\n    function BaseBurner(_arg) {\n      this.sign_with = _arg.sign_with, this.encrypt_for = _arg.encrypt_for, this.signing_key = _arg.signing_key, this.encryption_key = _arg.encryption_key, this.asp = _arg.asp;\n      this.asp = ASP.make(this.asp);\n    }\n\n    BaseBurner.prototype._find_keys = function(cb) {\n      var esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"find_keys\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/baseburner.iced\",\n            funcname: \"BaseBurner._find_keys\"\n          });\n          _this._find_signing_key(esc(__iced_deferrals.defer({\n            lineno: 17\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/kbpgp/src/openpgp/baseburner.iced\",\n              funcname: \"BaseBurner._find_keys\"\n            });\n            _this._find_encryption_key(esc(__iced_deferrals.defer({\n              lineno: 18\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/kbpgp/src/openpgp/baseburner.iced\",\n                funcname: \"BaseBurner._find_keys\"\n              });\n              _this._assert_one(esc(__iced_deferrals.defer({\n                lineno: 19\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return cb(null);\n            });\n          });\n        };\n      })(this));\n    };\n\n    BaseBurner.prototype._assert_one = function(cb) {\n      var err;\n      err = null;\n      if (!(this.signing_key != null) && !(this.encryption_keys != null)) {\n        err = new Error(\"need either an encryption or signing key, or both\");\n      }\n      return cb(err);\n    };\n\n    BaseBurner.prototype._find_signing_key = function(cb) {\n      var err;\n      err = null;\n      if ((this.sign_with != null) && (this.signing_key != null)) {\n        err = new Error(\"specify either `sign_with` or `signing_key` but not both\");\n      } else if ((this.sign_with != null) && ((this.signing_key = this.sign_with.find_signing_pgp_key()) == null)) {\n        err = new Error(\"cannot sign with the given KeyManager\");\n      }\n      return cb(err);\n    };\n\n    BaseBurner.prototype._find_encryption_key = function(cb) {\n      var arrayize, count_true, err, f, i, k, _i, _len, _ref;\n      err = null;\n      count_true = function() {\n        var e, i, v, _i, _len;\n        v = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        i = 0;\n        for (_i = 0, _len = v.length; _i < _len; _i++) {\n          e = v[_i];\n          if (e) {\n            i++;\n          }\n        }\n        return i;\n      };\n      arrayize = function(e) {\n        if (e == null) {\n          return [];\n        } else if (typeof e === 'object' && Array.isArray(e)) {\n          return e;\n        } else {\n          return [e];\n        }\n      };\n      if (count_true(this.encrypt_for != null, this.encryption_key != null, this.encryption_keys != null) > 1) {\n        err = new Error(\"specify only one of `encrypt_for`, `encryption_keys` and `encryption_key`\");\n      } else if (this.encrypt_for != null) {\n        this.encryption_keys = [];\n        _ref = (this.encrypt_for = arrayize(this.encrypt_for));\n        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n          f = _ref[i];\n          if ((k = f.find_crypt_pgp_key()) != null) {\n            this.encryption_keys.push(k);\n          } else {\n            err = new Error(\"cannot encrypt with the given KeyManager (i=\" + i + \")\");\n            break;\n          }\n        }\n      } else if (this.encryption_key != null) {\n        this.encryption_keys = [this.encryption_key];\n      } else if (this.encryption_keys != null) {\n        this.encryption_keys = arrayize(this.encryption_keys);\n      }\n      return cb(err);\n    };\n\n    return BaseBurner;\n\n  })();\n\n}).call(this);\n\n},{\"iced-error\":115,\"iced-runtime\":118,\"pgp-utils\":163}],35:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var SlicerBuffer;\n\n  SlicerBuffer = (function() {\n    function SlicerBuffer(buf, start) {\n      this.buf = buf;\n      this.start = start != null ? start : 0;\n      if (!Buffer.isBuffer(this.buf)) {\n        throw new Error('need a Buffer!');\n      }\n      this.i = this.start;\n      this._end = null;\n    }\n\n    SlicerBuffer.prototype.clamp = function(len) {\n      var ret;\n      ret = this._end;\n      this._end = this.i + len;\n      return ret;\n    };\n\n    SlicerBuffer.prototype.unclamp = function(e) {\n      this.start = this.i;\n      return this._end = e;\n    };\n\n    SlicerBuffer.prototype.len = function() {\n      return this.buf.length - this.start;\n    };\n\n    SlicerBuffer.prototype.rem = function() {\n      return this.buf.length - this.i;\n    };\n\n    SlicerBuffer.prototype.offset = function() {\n      return this.i - this.start;\n    };\n\n    SlicerBuffer.prototype.check = function() {\n      if ((this._end && this.i > this._end) || (this.i > this.buf.length)) {\n        throw new Error(\"read off the end of the packet @\" + this.i + \"/\" + this.buf.length + \"/\" + this._end);\n      }\n    };\n\n    SlicerBuffer.prototype.read_uint8 = function() {\n      var ret;\n      ret = this.buf.readUInt8(this.i++);\n      this.check();\n      return ret;\n    };\n\n    SlicerBuffer.prototype.read_uint16 = function() {\n      var ret;\n      ret = this.buf.readUInt16BE(this.i);\n      this.i += 2;\n      this.check();\n      return ret;\n    };\n\n    SlicerBuffer.prototype.read_uint32 = function() {\n      var ret;\n      ret = this.buf.readUInt32BE(this.i);\n      this.i += 4;\n      this.check();\n      return ret;\n    };\n\n    SlicerBuffer.prototype.read_buffer_at_most = function(l) {\n      return this.read_buffer(Math.min(l, this.rem()));\n    };\n\n    SlicerBuffer.prototype.read_buffer = function(l) {\n      var ret;\n      ret = this.buf.slice(this.i, this.i + l);\n      this.i += l;\n      this.check();\n      return ret;\n    };\n\n    SlicerBuffer.prototype.end = function() {\n      return this._end || this.buf.length;\n    };\n\n    SlicerBuffer.prototype.peek_rest_to_buffer = function() {\n      return this.buf.slice(this.i, this.end());\n    };\n\n    SlicerBuffer.prototype.consume_rest_to_buffer = function() {\n      var ret;\n      ret = this.peek_rest_to_buffer();\n      this.i = this.end();\n      return ret;\n    };\n\n    SlicerBuffer.prototype.advance = function(i) {\n      if (i == null) {\n        i = 1;\n      }\n      return this.i += i;\n    };\n\n    SlicerBuffer.prototype.peek_to_buffer = function(len) {\n      return this.buf.slice(this.i, this.i + len);\n    };\n\n    SlicerBuffer.prototype.peek_uint8 = function() {\n      return this.buf.readUInt8(this.i);\n    };\n\n    SlicerBuffer.prototype.peek_uint16 = function() {\n      return this.buf.readUInt16BE(this.i);\n    };\n\n    SlicerBuffer.prototype.read_string = function() {\n      return this.read_buffer(this.read_uint8());\n    };\n\n    SlicerBuffer.prototype.read_v4_length = function() {\n      var five_byte, len, p;\n      p = this.peek_uint8();\n      five_byte = false;\n      len = p < 192 ? (this.advance(1), p) : p < 224 ? this.read_uint16() - (192 << 8) + 192 : p < 0xff ? (this.advance(1), 1 << (p & 0x1f)) : (this.advance(1), five_byte = true, this.read_uint32());\n      return [len, five_byte];\n    };\n\n    return SlicerBuffer;\n\n  })();\n\n  exports.SlicerBuffer = SlicerBuffer;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":80}],36:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var BaseBurner, Burner, C, Compressed, CreationTime, Issuer, Literal, OnePassSignature, PKESK, SEIPD, SHA512, SRF, Signature, WordArray, clearsign, detachsign, dummy_key_id, encode, export_key_pgp, get_cipher, iced, make_esc, make_simple_literals, scrub_buffer, triplesec, unix_time, __iced_k, __iced_k_noop, _ref, _ref1, _ref2,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  make_esc = require('iced-error').make_esc;\n\n  OnePassSignature = require('./packet/one_pass_sig').OnePassSignature;\n\n  _ref = require('./packet/signature'), Signature = _ref.Signature, CreationTime = _ref.CreationTime, Issuer = _ref.Issuer;\n\n  Compressed = require('./packet/compressed').Compressed;\n\n  Literal = require('./packet/literal').Literal;\n\n  unix_time = require('../util').unix_time;\n\n  SRF = require('../rand').SRF;\n\n  triplesec = require('triplesec');\n\n  _ref1 = require('../symmetric'), export_key_pgp = _ref1.export_key_pgp, get_cipher = _ref1.get_cipher;\n\n  scrub_buffer = triplesec.util.scrub_buffer;\n\n  WordArray = triplesec.WordArray;\n\n  _ref2 = require('./packet/sess'), SEIPD = _ref2.SEIPD, PKESK = _ref2.PKESK;\n\n  C = require('../const').openpgp;\n\n  SHA512 = require('../hash').SHA512;\n\n  encode = require('./armor').encode;\n\n  clearsign = require('./clearsign');\n\n  detachsign = require('./detachsign');\n\n  BaseBurner = require('./baseburner').BaseBurner;\n\n  dummy_key_id = new Buffer((function() {\n    var _i, _results;\n    _results = [];\n    for (_i = 0; _i < 16; _i++) {\n      _results.push(0);\n    }\n    return _results;\n  })());\n\n  Burner = (function(_super) {\n    __extends(Burner, _super);\n\n    function Burner(_arg) {\n      var asp, encrypt_for, encryption_key, sign_with, signing_key;\n      this.literals = _arg.literals, this.opts = _arg.opts, sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for, signing_key = _arg.signing_key, encryption_key = _arg.encryption_key, asp = _arg.asp;\n      Burner.__super__.constructor.call(this, {\n        sign_with: sign_with,\n        encrypt_for: encrypt_for,\n        signing_key: signing_key,\n        encryption_key: encryption_key,\n        asp: asp\n      });\n      this.packets = [];\n      this.opts || (this.opts = {});\n      this.signed_payload = null;\n    }\n\n    Burner.prototype._frame_literals = function(cb) {\n      var esc, l, p, sp, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Burner::_frame_literals\");\n      sp = [];\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _len, _ref3, _results, _while;\n          _ref3 = _this.literals;\n          _len = _ref3.length;\n          _i = 0;\n          _results = [];\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = function() {\n              return __iced_k(_results);\n            };\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++_i;\n                return _while(__iced_k);\n              });\n            };\n            _next = function(__iced_next_arg) {\n              _results.push(__iced_next_arg);\n              return _continue();\n            };\n            if (!(_i < _len)) {\n              return _break();\n            } else {\n              l = _ref3[_i];\n              sp.push(l.to_signature_payload());\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                  funcname: \"Burner._frame_literals\"\n                });\n                l.write(esc(__iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return p = arguments[0];\n                    };\n                  })(),\n                  lineno: 51\n                })));\n                __iced_deferrals._fulfill();\n              })(function() {\n                return _next(_this.packets.push(p));\n              });\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          _this.signed_payload = Buffer.concat(sp);\n          return cb(null);\n        };\n      })(this));\n    };\n\n    Burner.prototype._sign = function(cb) {\n      var esc, fp, ops, ops_framed, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Burner::_sign'\");\n      ops = new OnePassSignature({\n        sig_type: C.sig_types.binary_doc,\n        hasher: SHA512,\n        sig_klass: this.signing_key.get_klass(),\n        key_id: this.signing_key.get_key_id(),\n        is_final: 1\n      });\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n            funcname: \"Burner._sign\"\n          });\n          ops.write(esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return ops_framed = arguments[0];\n              };\n            })(),\n            lineno: 67\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          sig = new Signature({\n            type: C.sig_types.binary_doc,\n            key: _this.signing_key.key,\n            hashed_subpackets: [new CreationTime(unix_time())],\n            unhashed_subpackets: [new Issuer(_this.signing_key.get_key_id())]\n          });\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n              funcname: \"Burner._sign\"\n            });\n            _this.asp.progress({\n              what: 'sign',\n              i: 0,\n              total: 1\n            }, esc(__iced_deferrals.defer({\n              lineno: 74\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                funcname: \"Burner._sign\"\n              });\n              sig.write(_this.signed_payload, esc(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return fp = arguments[0];\n                  };\n                })(),\n                lineno: 75\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                  funcname: \"Burner._sign\"\n                });\n                _this.asp.progress({\n                  what: 'sign',\n                  i: 1,\n                  total: 1\n                }, esc(__iced_deferrals.defer({\n                  lineno: 76\n                })));\n                __iced_deferrals._fulfill();\n              })(function() {\n                _this.packets.unshift(ops_framed);\n                _this.packets.push(fp);\n                return cb(null);\n              });\n            });\n          });\n        };\n      })(this));\n    };\n\n    Burner.prototype.collect_packets = function() {\n      var ret;\n      ret = Buffer.concat(this.packets);\n      this.packets = [];\n      return ret;\n    };\n\n    Burner.prototype._compress = function(cb) {\n      var esc, inflated, opkt, pkt, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Burner::_compress\");\n      inflated = this.collect_packets();\n      pkt = new Compressed({\n        algo: C.compression.zlib,\n        inflated: inflated\n      });\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n            funcname: \"Burner._compress\"\n          });\n          _this.asp.progress({\n            what: 'compress',\n            i: 0,\n            total: 1\n          }, esc(__iced_deferrals.defer({\n            lineno: 94\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n              funcname: \"Burner._compress\"\n            });\n            pkt.write(esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return opkt = arguments[0];\n                };\n              })(),\n              lineno: 95\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                funcname: \"Burner._compress\"\n              });\n              _this.asp.progress({\n                what: 'compress',\n                i: 1,\n                total: 1\n              }, esc(__iced_deferrals.defer({\n                lineno: 96\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              _this.packets.push(opkt);\n              return cb(null);\n            });\n          });\n        };\n      })(this));\n    };\n\n    Burner.prototype._make_session_key = function(cb) {\n      var ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      this._cipher_algo = C.symmetric_key_algorithms.AES256;\n      this._cipher_info = get_cipher(this._cipher_algo);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n            funcname: \"Burner._make_session_key\"\n          });\n          SRF().random_bytes(_this._cipher_info.key_size, __iced_deferrals.defer({\n            assign_fn: (function(__slot_1) {\n              return function() {\n                return __slot_1._session_key = arguments[0];\n              };\n            })(_this),\n            lineno: 105\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          _this._cipher = new _this._cipher_info.klass(WordArray.from_buffer(_this._session_key));\n          return cb(null);\n        };\n      })(this));\n    };\n\n    Burner.prototype.scrub = function() {\n      if (this._cipher != null) {\n        this._cipher.scrub();\n      }\n      if (this._session_key != null) {\n        return scrub_buffer(this._session_key);\n      }\n    };\n\n    Burner.prototype._encrypt_session_key_once = function(encryption_key, cb) {\n      var ekey, esc, fingerprint, key_id, payload, pkesk, pkt, pub_k, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"_encrypt_session_key_once\");\n      payload = export_key_pgp(this._cipher_algo, this._session_key);\n      pub_k = encryption_key.key;\n      fingerprint = encryption_key.get_fingerprint();\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n            funcname: \"Burner._encrypt_session_key_once\"\n          });\n          _this.asp.progress({\n            what: 'session key encrypt',\n            i: 0,\n            total: 1\n          }, esc(__iced_deferrals.defer({\n            lineno: 122\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n              funcname: \"Burner._encrypt_session_key_once\"\n            });\n            pub_k.pad_and_encrypt(payload, {\n              fingerprint: fingerprint\n            }, esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return ekey = arguments[0];\n                };\n              })(),\n              lineno: 123\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                funcname: \"Burner._encrypt_session_key_once\"\n              });\n              _this.asp.progress({\n                what: 'session key encrypt',\n                i: 1,\n                total: 1\n              }, esc(__iced_deferrals.defer({\n                lineno: 124\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              (function(__iced_k) {\n                if (_this.opts.hide) {\n                  key_id = dummy_key_id;\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                      funcname: \"Burner._encrypt_session_key_once\"\n                    });\n                    _this.asp.progress({\n                      what: 'hide encryption',\n                      i: 0,\n                      total: 1\n                    }, esc(__iced_deferrals.defer({\n                      lineno: 127\n                    })));\n                    __iced_deferrals._fulfill();\n                  })(function() {\n                    (function(__iced_k) {\n                      var _ref3, _ref4;\n                      __iced_deferrals = new iced.Deferrals(__iced_k, {\n                        parent: ___iced_passed_deferral,\n                        filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                        funcname: \"Burner._encrypt_session_key_once\"\n                      });\n                      ekey.hide({\n                        max: (_ref3 = _this.opts.hide) != null ? _ref3.max : void 0,\n                        slosh: (_ref4 = _this.opts.hide) != null ? _ref4.slosh : void 0,\n                        key: pub_k\n                      }, esc(__iced_deferrals.defer({\n                        lineno: 128\n                      })));\n                      __iced_deferrals._fulfill();\n                    })(function() {\n                      (function(__iced_k) {\n                        __iced_deferrals = new iced.Deferrals(__iced_k, {\n                          parent: ___iced_passed_deferral,\n                          filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                          funcname: \"Burner._encrypt_session_key_once\"\n                        });\n                        _this.asp.progress({\n                          what: 'hide encryption',\n                          i: 1,\n                          total: 1\n                        }, esc(__iced_deferrals.defer({\n                          lineno: 129\n                        })));\n                        __iced_deferrals._fulfill();\n                      })(__iced_k);\n                    });\n                  });\n                } else {\n                  return __iced_k(key_id = encryption_key.get_key_id());\n                }\n              })(function() {\n                pkt = new PKESK({\n                  crypto_type: pub_k.type,\n                  key_id: key_id,\n                  ekey: ekey\n                });\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                    funcname: \"Burner._encrypt_session_key_once\"\n                  });\n                  pkt.write(esc(__iced_deferrals.defer({\n                    assign_fn: (function() {\n                      return function() {\n                        return pkesk = arguments[0];\n                      };\n                    })(),\n                    lineno: 137\n                  })));\n                  __iced_deferrals._fulfill();\n                })(function() {\n                  return cb(null, pkesk);\n                });\n              });\n            });\n          });\n        };\n      })(this));\n    };\n\n    Burner.prototype._encrypt_session_key = function(cb) {\n      var esc, k, pkesk, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"_encrypt_session_key\");\n      this._pkesks = [];\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _len, _ref3, _results, _while;\n          _ref3 = _this.encryption_keys;\n          _len = _ref3.length;\n          _i = 0;\n          _results = [];\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = function() {\n              return __iced_k(_results);\n            };\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++_i;\n                return _while(__iced_k);\n              });\n            };\n            _next = function(__iced_next_arg) {\n              _results.push(__iced_next_arg);\n              return _continue();\n            };\n            if (!(_i < _len)) {\n              return _break();\n            } else {\n              k = _ref3[_i];\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                  funcname: \"Burner._encrypt_session_key\"\n                });\n                _this._encrypt_session_key_once(k, esc(__iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return pkesk = arguments[0];\n                    };\n                  })(),\n                  lineno: 146\n                })));\n                __iced_deferrals._fulfill();\n              })(function() {\n                return _next(_this._pkesks.push(pkesk));\n              });\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(null);\n        };\n      })(this));\n    };\n\n    Burner.prototype._encrypt_payload = function(cb) {\n      var asp, esc, pkt, plaintext, prefixrandom, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Burner::_encrypt_payload\");\n      plaintext = this.collect_packets();\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n            funcname: \"Burner._encrypt_payload\"\n          });\n          SRF().random_bytes(_this._cipher.blockSize, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return prefixrandom = arguments[0];\n              };\n            })(),\n            lineno: 155\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          pkt = new SEIPD({});\n          asp = _this.asp.section('encrypt payload');\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n              funcname: \"Burner._encrypt_payload\"\n            });\n            pkt.encrypt({\n              cipher: _this._cipher,\n              plaintext: plaintext,\n              prefixrandom: prefixrandom,\n              asp: asp\n            }, esc(__iced_deferrals.defer({\n              lineno: 158\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                funcname: \"Burner._encrypt_payload\"\n              });\n              pkt.write(esc(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return pkt = arguments[0];\n                  };\n                })(),\n                lineno: 159\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              scrub_buffer(plaintext);\n              _this.packets = _this._pkesks.concat([pkt]);\n              return cb(null);\n            });\n          });\n        };\n      })(this));\n    };\n\n    Burner.prototype._encrypt = function(cb) {\n      var esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Burner::_encrypt\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n            funcname: \"Burner._encrypt\"\n          });\n          _this._make_session_key(esc(__iced_deferrals.defer({\n            lineno: 168\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n              funcname: \"Burner._encrypt\"\n            });\n            _this._encrypt_session_key(esc(__iced_deferrals.defer({\n              lineno: 169\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                funcname: \"Burner._encrypt\"\n              });\n              _this._encrypt_payload(esc(__iced_deferrals.defer({\n                lineno: 170\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return cb(null);\n            });\n          });\n        };\n      })(this));\n    };\n\n    Burner.prototype.scrub = function() {};\n\n    Burner.prototype.burn = function(cb) {\n      var esc, output, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Burner::burn\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n            funcname: \"Burner.burn\"\n          });\n          _this._find_keys(esc(__iced_deferrals.defer({\n            lineno: 181\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n              funcname: \"Burner.burn\"\n            });\n            _this._frame_literals(esc(__iced_deferrals.defer({\n              lineno: 182\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              if (_this.signing_key != null) {\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                    funcname: \"Burner.burn\"\n                  });\n                  _this._sign(esc(__iced_deferrals.defer({\n                    lineno: 184\n                  })));\n                  __iced_deferrals._fulfill();\n                })(__iced_k);\n              } else {\n                return __iced_k();\n              }\n            })(function() {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                  funcname: \"Burner.burn\"\n                });\n                _this._compress(esc(__iced_deferrals.defer({\n                  lineno: 185\n                })));\n                __iced_deferrals._fulfill();\n              })(function() {\n                (function(__iced_k) {\n                  if (_this.encryption_keys != null) {\n                    (function(__iced_k) {\n                      __iced_deferrals = new iced.Deferrals(__iced_k, {\n                        parent: ___iced_passed_deferral,\n                        filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                        funcname: \"Burner.burn\"\n                      });\n                      _this._encrypt(esc(__iced_deferrals.defer({\n                        lineno: 187\n                      })));\n                      __iced_deferrals._fulfill();\n                    })(__iced_k);\n                  } else {\n                    return __iced_k();\n                  }\n                })(function() {\n                  output = Buffer.concat(_this.packets);\n                  return cb(null, output);\n                });\n              });\n            });\n          });\n        };\n      })(this));\n    };\n\n    return Burner;\n\n  })(BaseBurner);\n\n  exports.Burner = Burner;\n\n  exports.make_simple_literals = make_simple_literals = function(msg) {\n    return [\n      new Literal({\n        data: new Buffer(msg),\n        format: C.literal_formats.utf8,\n        date: unix_time()\n      })\n    ];\n  };\n\n  exports.clearsign = clearsign.sign;\n\n  exports.detachsign = detachsign.sign;\n\n  exports.burn = function(_arg, cb) {\n    var aout, asp, b, encrypt_for, encryption_key, err, literals, msg, opts, raw, sign_with, signing_key, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    msg = _arg.msg, literals = _arg.literals, sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for, signing_key = _arg.signing_key, encryption_key = _arg.encryption_key, asp = _arg.asp, opts = _arg.opts;\n    if ((msg != null) && (literals == null)) {\n      literals = make_simple_literals(msg);\n    }\n    b = new Burner({\n      literals: literals,\n      sign_with: sign_with,\n      encrypt_for: encrypt_for,\n      signing_key: signing_key,\n      encryption_key: encryption_key,\n      asp: asp,\n      opts: opts\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/home/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n          funcname: \"burn\"\n        });\n        b.burn(__iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              err = arguments[0];\n              return raw = arguments[1];\n            };\n          })(),\n          lineno: 247\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        b.scrub();\n        if ((typeof raw !== \"undefined\" && raw !== null) && (typeof err === \"undefined\" || err === null)) {\n          aout = encode(C.message_types.generic, raw);\n        }\n\n        if (typeof cb === 'function') {\n          return cb(err, aout, raw);\n        } else {\n          return OnlyKeyConnector.replaceSelectedText(aout);\n        }\n      };\n    })(this));\n  };\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../const\":5,\"../hash\":14,\"../rand\":65,\"../symmetric\":68,\"../util\":70,\"./armor\":33,\"./baseburner\":34,\"./clearsign\":39,\"./detachsign\":40,\"./packet/compressed\":46,\"./packet/literal\":49,\"./packet/one_pass_sig\":50,\"./packet/sess\":52,\"./packet/signature\":53,\"buffer\":80,\"iced-error\":115,\"iced-runtime\":118,\"triplesec\":181}],37:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var CAST5, G, Global, WordArray, ui32a_to_ui8a, ui8a_to_ui32a, _ref;\n\n  WordArray = require('triplesec').WordArray;\n\n  _ref = require('../util'), ui8a_to_ui32a = _ref.ui8a_to_ui32a, ui32a_to_ui8a = _ref.ui32a_to_ui8a;\n\n  Global = (function() {\n    function Global() {\n      this.init_schedule();\n      this.init_sbox();\n    }\n\n    Global.prototype.init_schedule = function() {\n      var scheduleA, scheduleB;\n      scheduleA = new Array(4);\n      scheduleA[0] = new Array(4);\n      scheduleA[0][0] = new Uint8Array([4, 0, 0xd, 0xf, 0xc, 0xe, 0x8]);\n      scheduleA[0][1] = new Uint8Array([5, 2, 16 + 0, 16 + 2, 16 + 1, 16 + 3, 0xa]);\n      scheduleA[0][2] = new Uint8Array([6, 3, 16 + 7, 16 + 6, 16 + 5, 16 + 4, 9]);\n      scheduleA[0][3] = new Uint8Array([7, 1, 16 + 0xa, 16 + 9, 16 + 0xb, 16 + 8, 0xb]);\n      scheduleA[1] = new Array(4);\n      scheduleA[1][0] = new Uint8Array([0, 6, 16 + 5, 16 + 7, 16 + 4, 16 + 6, 16 + 0]);\n      scheduleA[1][1] = new Uint8Array([1, 4, 0, 2, 1, 3, 16 + 2]);\n      scheduleA[1][2] = new Uint8Array([2, 5, 7, 6, 5, 4, 16 + 1]);\n      scheduleA[1][3] = new Uint8Array([3, 7, 0xa, 9, 0xb, 8, 16 + 3]);\n      scheduleA[2] = new Array(4);\n      scheduleA[2][0] = new Uint8Array([4, 0, 0xd, 0xf, 0xc, 0xe, 8]);\n      scheduleA[2][1] = new Uint8Array([5, 2, 16 + 0, 16 + 2, 16 + 1, 16 + 3, 0xa]);\n      scheduleA[2][2] = new Uint8Array([6, 3, 16 + 7, 16 + 6, 16 + 5, 16 + 4, 9]);\n      scheduleA[2][3] = new Uint8Array([7, 1, 16 + 0xa, 16 + 9, 16 + 0xb, 16 + 8, 0xb]);\n      scheduleA[3] = new Array(4);\n      scheduleA[3][0] = new Uint8Array([0, 6, 16 + 5, 16 + 7, 16 + 4, 16 + 6, 16 + 0]);\n      scheduleA[3][1] = new Uint8Array([1, 4, 0, 2, 1, 3, 16 + 2]);\n      scheduleA[3][2] = new Uint8Array([2, 5, 7, 6, 5, 4, 16 + 1]);\n      scheduleA[3][3] = new Uint8Array([3, 7, 0xa, 9, 0xb, 8, 16 + 3]);\n      scheduleB = new Array(4);\n      scheduleB[0] = new Array(4);\n      scheduleB[0][0] = new Uint8Array([16 + 8, 16 + 9, 16 + 7, 16 + 6, 16 + 2]);\n      scheduleB[0][1] = new Uint8Array([16 + 0xa, 16 + 0xb, 16 + 5, 16 + 4, 16 + 6]);\n      scheduleB[0][2] = new Uint8Array([16 + 0xc, 16 + 0xd, 16 + 3, 16 + 2, 16 + 9]);\n      scheduleB[0][3] = new Uint8Array([16 + 0xe, 16 + 0xf, 16 + 1, 16 + 0, 16 + 0xc]);\n      scheduleB[1] = new Array(4);\n      scheduleB[1][0] = new Uint8Array([3, 2, 0xc, 0xd, 8]);\n      scheduleB[1][1] = new Uint8Array([1, 0, 0xe, 0xf, 0xd]);\n      scheduleB[1][2] = new Uint8Array([7, 6, 8, 9, 3]);\n      scheduleB[1][3] = new Uint8Array([5, 4, 0xa, 0xb, 7]);\n      scheduleB[2] = new Array(4);\n      scheduleB[2][0] = new Uint8Array([16 + 3, 16 + 2, 16 + 0xc, 16 + 0xd, 16 + 9]);\n      scheduleB[2][1] = new Uint8Array([16 + 1, 16 + 0, 16 + 0xe, 16 + 0xf, 16 + 0xc]);\n      scheduleB[2][2] = new Uint8Array([16 + 7, 16 + 6, 16 + 8, 16 + 9, 16 + 2]);\n      scheduleB[2][3] = new Uint8Array([16 + 5, 16 + 4, 16 + 0xa, 16 + 0xb, 16 + 6]);\n      scheduleB[3] = new Array(4);\n      scheduleB[3][0] = new Uint8Array([8, 9, 7, 6, 3]);\n      scheduleB[3][1] = new Uint8Array([0xa, 0xb, 5, 4, 7]);\n      scheduleB[3][2] = new Uint8Array([0xc, 0xd, 3, 2, 8]);\n      scheduleB[3][3] = new Uint8Array([0xe, 0xf, 1, 0, 0xd]);\n      this.scheduleA = scheduleA;\n      return this.scheduleB = scheduleB;\n    };\n\n    Global.prototype.init_sbox = function() {\n      var sBox;\n      sBox = new Array(8);\n      sBox[0] = new Uint32Array([0x30fb40d4, 0x9fa0ff0b, 0x6beccd2f, 0x3f258c7a, 0x1e213f2f, 0x9c004dd3, 0x6003e540, 0xcf9fc949, 0xbfd4af27, 0x88bbbdb5, 0xe2034090, 0x98d09675, 0x6e63a0e0, 0x15c361d2, 0xc2e7661d, 0x22d4ff8e, 0x28683b6f, 0xc07fd059, 0xff2379c8, 0x775f50e2, 0x43c340d3, 0xdf2f8656, 0x887ca41a, 0xa2d2bd2d, 0xa1c9e0d6, 0x346c4819, 0x61b76d87, 0x22540f2f, 0x2abe32e1, 0xaa54166b, 0x22568e3a, 0xa2d341d0, 0x66db40c8, 0xa784392f, 0x004dff2f, 0x2db9d2de, 0x97943fac, 0x4a97c1d8, 0x527644b7, 0xb5f437a7, 0xb82cbaef, 0xd751d159, 0x6ff7f0ed, 0x5a097a1f, 0x827b68d0, 0x90ecf52e, 0x22b0c054, 0xbc8e5935, 0x4b6d2f7f, 0x50bb64a2, 0xd2664910, 0xbee5812d, 0xb7332290, 0xe93b159f, 0xb48ee411, 0x4bff345d, 0xfd45c240, 0xad31973f, 0xc4f6d02e, 0x55fc8165, 0xd5b1caad, 0xa1ac2dae, 0xa2d4b76d, 0xc19b0c50, 0x882240f2, 0x0c6e4f38, 0xa4e4bfd7, 0x4f5ba272, 0x564c1d2f, 0xc59c5319, 0xb949e354, 0xb04669fe, 0xb1b6ab8a, 0xc71358dd, 0x6385c545, 0x110f935d, 0x57538ad5, 0x6a390493, 0xe63d37e0, 0x2a54f6b3, 0x3a787d5f, 0x6276a0b5, 0x19a6fcdf, 0x7a42206a, 0x29f9d4d5, 0xf61b1891, 0xbb72275e, 0xaa508167, 0x38901091, 0xc6b505eb, 0x84c7cb8c, 0x2ad75a0f, 0x874a1427, 0xa2d1936b, 0x2ad286af, 0xaa56d291, 0xd7894360, 0x425c750d, 0x93b39e26, 0x187184c9, 0x6c00b32d, 0x73e2bb14, 0xa0bebc3c, 0x54623779, 0x64459eab, 0x3f328b82, 0x7718cf82, 0x59a2cea6, 0x04ee002e, 0x89fe78e6, 0x3fab0950, 0x325ff6c2, 0x81383f05, 0x6963c5c8, 0x76cb5ad6, 0xd49974c9, 0xca180dcf, 0x380782d5, 0xc7fa5cf6, 0x8ac31511, 0x35e79e13, 0x47da91d0, 0xf40f9086, 0xa7e2419e, 0x31366241, 0x051ef495, 0xaa573b04, 0x4a805d8d, 0x548300d0, 0x00322a3c, 0xbf64cddf, 0xba57a68e, 0x75c6372b, 0x50afd341, 0xa7c13275, 0x915a0bf5, 0x6b54bfab, 0x2b0b1426, 0xab4cc9d7, 0x449ccd82, 0xf7fbf265, 0xab85c5f3, 0x1b55db94, 0xaad4e324, 0xcfa4bd3f, 0x2deaa3e2, 0x9e204d02, 0xc8bd25ac, 0xeadf55b3, 0xd5bd9e98, 0xe31231b2, 0x2ad5ad6c, 0x954329de, 0xadbe4528, 0xd8710f69, 0xaa51c90f, 0xaa786bf6, 0x22513f1e, 0xaa51a79b, 0x2ad344cc, 0x7b5a41f0, 0xd37cfbad, 0x1b069505, 0x41ece491, 0xb4c332e6, 0x032268d4, 0xc9600acc, 0xce387e6d, 0xbf6bb16c, 0x6a70fb78, 0x0d03d9c9, 0xd4df39de, 0xe01063da, 0x4736f464, 0x5ad328d8, 0xb347cc96, 0x75bb0fc3, 0x98511bfb, 0x4ffbcc35, 0xb58bcf6a, 0xe11f0abc, 0xbfc5fe4a, 0xa70aec10, 0xac39570a, 0x3f04442f, 0x6188b153, 0xe0397a2e, 0x5727cb79, 0x9ceb418f, 0x1cacd68d, 0x2ad37c96, 0x0175cb9d, 0xc69dff09, 0xc75b65f0, 0xd9db40d8, 0xec0e7779, 0x4744ead4, 0xb11c3274, 0xdd24cb9e, 0x7e1c54bd, 0xf01144f9, 0xd2240eb1, 0x9675b3fd, 0xa3ac3755, 0xd47c27af, 0x51c85f4d, 0x56907596, 0xa5bb15e6, 0x580304f0, 0xca042cf1, 0x011a37ea, 0x8dbfaadb, 0x35ba3e4a, 0x3526ffa0, 0xc37b4d09, 0xbc306ed9, 0x98a52666, 0x5648f725, 0xff5e569d, 0x0ced63d0, 0x7c63b2cf, 0x700b45e1, 0xd5ea50f1, 0x85a92872, 0xaf1fbda7, 0xd4234870, 0xa7870bf3, 0x2d3b4d79, 0x42e04198, 0x0cd0ede7, 0x26470db8, 0xf881814c, 0x474d6ad7, 0x7c0c5e5c, 0xd1231959, 0x381b7298, 0xf5d2f4db, 0xab838653, 0x6e2f1e23, 0x83719c9e, 0xbd91e046, 0x9a56456e, 0xdc39200c, 0x20c8c571, 0x962bda1c, 0xe1e696ff, 0xb141ab08, 0x7cca89b9, 0x1a69e783, 0x02cc4843, 0xa2f7c579, 0x429ef47d, 0x427b169c, 0x5ac9f049, 0xdd8f0f00, 0x5c8165bf]);\n      sBox[1] = new Uint32Array([0x1f201094, 0xef0ba75b, 0x69e3cf7e, 0x393f4380, 0xfe61cf7a, 0xeec5207a, 0x55889c94, 0x72fc0651, 0xada7ef79, 0x4e1d7235, 0xd55a63ce, 0xde0436ba, 0x99c430ef, 0x5f0c0794, 0x18dcdb7d, 0xa1d6eff3, 0xa0b52f7b, 0x59e83605, 0xee15b094, 0xe9ffd909, 0xdc440086, 0xef944459, 0xba83ccb3, 0xe0c3cdfb, 0xd1da4181, 0x3b092ab1, 0xf997f1c1, 0xa5e6cf7b, 0x01420ddb, 0xe4e7ef5b, 0x25a1ff41, 0xe180f806, 0x1fc41080, 0x179bee7a, 0xd37ac6a9, 0xfe5830a4, 0x98de8b7f, 0x77e83f4e, 0x79929269, 0x24fa9f7b, 0xe113c85b, 0xacc40083, 0xd7503525, 0xf7ea615f, 0x62143154, 0x0d554b63, 0x5d681121, 0xc866c359, 0x3d63cf73, 0xcee234c0, 0xd4d87e87, 0x5c672b21, 0x071f6181, 0x39f7627f, 0x361e3084, 0xe4eb573b, 0x602f64a4, 0xd63acd9c, 0x1bbc4635, 0x9e81032d, 0x2701f50c, 0x99847ab4, 0xa0e3df79, 0xba6cf38c, 0x10843094, 0x2537a95e, 0xf46f6ffe, 0xa1ff3b1f, 0x208cfb6a, 0x8f458c74, 0xd9e0a227, 0x4ec73a34, 0xfc884f69, 0x3e4de8df, 0xef0e0088, 0x3559648d, 0x8a45388c, 0x1d804366, 0x721d9bfd, 0xa58684bb, 0xe8256333, 0x844e8212, 0x128d8098, 0xfed33fb4, 0xce280ae1, 0x27e19ba5, 0xd5a6c252, 0xe49754bd, 0xc5d655dd, 0xeb667064, 0x77840b4d, 0xa1b6a801, 0x84db26a9, 0xe0b56714, 0x21f043b7, 0xe5d05860, 0x54f03084, 0x066ff472, 0xa31aa153, 0xdadc4755, 0xb5625dbf, 0x68561be6, 0x83ca6b94, 0x2d6ed23b, 0xeccf01db, 0xa6d3d0ba, 0xb6803d5c, 0xaf77a709, 0x33b4a34c, 0x397bc8d6, 0x5ee22b95, 0x5f0e5304, 0x81ed6f61, 0x20e74364, 0xb45e1378, 0xde18639b, 0x881ca122, 0xb96726d1, 0x8049a7e8, 0x22b7da7b, 0x5e552d25, 0x5272d237, 0x79d2951c, 0xc60d894c, 0x488cb402, 0x1ba4fe5b, 0xa4b09f6b, 0x1ca815cf, 0xa20c3005, 0x8871df63, 0xb9de2fcb, 0x0cc6c9e9, 0x0beeff53, 0xe3214517, 0xb4542835, 0x9f63293c, 0xee41e729, 0x6e1d2d7c, 0x50045286, 0x1e6685f3, 0xf33401c6, 0x30a22c95, 0x31a70850, 0x60930f13, 0x73f98417, 0xa1269859, 0xec645c44, 0x52c877a9, 0xcdff33a6, 0xa02b1741, 0x7cbad9a2, 0x2180036f, 0x50d99c08, 0xcb3f4861, 0xc26bd765, 0x64a3f6ab, 0x80342676, 0x25a75e7b, 0xe4e6d1fc, 0x20c710e6, 0xcdf0b680, 0x17844d3b, 0x31eef84d, 0x7e0824e4, 0x2ccb49eb, 0x846a3bae, 0x8ff77888, 0xee5d60f6, 0x7af75673, 0x2fdd5cdb, 0xa11631c1, 0x30f66f43, 0xb3faec54, 0x157fd7fa, 0xef8579cc, 0xd152de58, 0xdb2ffd5e, 0x8f32ce19, 0x306af97a, 0x02f03ef8, 0x99319ad5, 0xc242fa0f, 0xa7e3ebb0, 0xc68e4906, 0xb8da230c, 0x80823028, 0xdcdef3c8, 0xd35fb171, 0x088a1bc8, 0xbec0c560, 0x61a3c9e8, 0xbca8f54d, 0xc72feffa, 0x22822e99, 0x82c570b4, 0xd8d94e89, 0x8b1c34bc, 0x301e16e6, 0x273be979, 0xb0ffeaa6, 0x61d9b8c6, 0x00b24869, 0xb7ffce3f, 0x08dc283b, 0x43daf65a, 0xf7e19798, 0x7619b72f, 0x8f1c9ba4, 0xdc8637a0, 0x16a7d3b1, 0x9fc393b7, 0xa7136eeb, 0xc6bcc63e, 0x1a513742, 0xef6828bc, 0x520365d6, 0x2d6a77ab, 0x3527ed4b, 0x821fd216, 0x095c6e2e, 0xdb92f2fb, 0x5eea29cb, 0x145892f5, 0x91584f7f, 0x5483697b, 0x2667a8cc, 0x85196048, 0x8c4bacea, 0x833860d4, 0x0d23e0f9, 0x6c387e8a, 0x0ae6d249, 0xb284600c, 0xd835731d, 0xdcb1c647, 0xac4c56ea, 0x3ebd81b3, 0x230eabb0, 0x6438bc87, 0xf0b5b1fa, 0x8f5ea2b3, 0xfc184642, 0x0a036b7a, 0x4fb089bd, 0x649da589, 0xa345415e, 0x5c038323, 0x3e5d3bb9, 0x43d79572, 0x7e6dd07c, 0x06dfdf1e, 0x6c6cc4ef, 0x7160a539, 0x73bfbe70, 0x83877605, 0x4523ecf1]);\n      sBox[2] = new Uint32Array([0x8defc240, 0x25fa5d9f, 0xeb903dbf, 0xe810c907, 0x47607fff, 0x369fe44b, 0x8c1fc644, 0xaececa90, 0xbeb1f9bf, 0xeefbcaea, 0xe8cf1950, 0x51df07ae, 0x920e8806, 0xf0ad0548, 0xe13c8d83, 0x927010d5, 0x11107d9f, 0x07647db9, 0xb2e3e4d4, 0x3d4f285e, 0xb9afa820, 0xfade82e0, 0xa067268b, 0x8272792e, 0x553fb2c0, 0x489ae22b, 0xd4ef9794, 0x125e3fbc, 0x21fffcee, 0x825b1bfd, 0x9255c5ed, 0x1257a240, 0x4e1a8302, 0xbae07fff, 0x528246e7, 0x8e57140e, 0x3373f7bf, 0x8c9f8188, 0xa6fc4ee8, 0xc982b5a5, 0xa8c01db7, 0x579fc264, 0x67094f31, 0xf2bd3f5f, 0x40fff7c1, 0x1fb78dfc, 0x8e6bd2c1, 0x437be59b, 0x99b03dbf, 0xb5dbc64b, 0x638dc0e6, 0x55819d99, 0xa197c81c, 0x4a012d6e, 0xc5884a28, 0xccc36f71, 0xb843c213, 0x6c0743f1, 0x8309893c, 0x0feddd5f, 0x2f7fe850, 0xd7c07f7e, 0x02507fbf, 0x5afb9a04, 0xa747d2d0, 0x1651192e, 0xaf70bf3e, 0x58c31380, 0x5f98302e, 0x727cc3c4, 0x0a0fb402, 0x0f7fef82, 0x8c96fdad, 0x5d2c2aae, 0x8ee99a49, 0x50da88b8, 0x8427f4a0, 0x1eac5790, 0x796fb449, 0x8252dc15, 0xefbd7d9b, 0xa672597d, 0xada840d8, 0x45f54504, 0xfa5d7403, 0xe83ec305, 0x4f91751a, 0x925669c2, 0x23efe941, 0xa903f12e, 0x60270df2, 0x0276e4b6, 0x94fd6574, 0x927985b2, 0x8276dbcb, 0x02778176, 0xf8af918d, 0x4e48f79e, 0x8f616ddf, 0xe29d840e, 0x842f7d83, 0x340ce5c8, 0x96bbb682, 0x93b4b148, 0xef303cab, 0x984faf28, 0x779faf9b, 0x92dc560d, 0x224d1e20, 0x8437aa88, 0x7d29dc96, 0x2756d3dc, 0x8b907cee, 0xb51fd240, 0xe7c07ce3, 0xe566b4a1, 0xc3e9615e, 0x3cf8209d, 0x6094d1e3, 0xcd9ca341, 0x5c76460e, 0x00ea983b, 0xd4d67881, 0xfd47572c, 0xf76cedd9, 0xbda8229c, 0x127dadaa, 0x438a074e, 0x1f97c090, 0x081bdb8a, 0x93a07ebe, 0xb938ca15, 0x97b03cff, 0x3dc2c0f8, 0x8d1ab2ec, 0x64380e51, 0x68cc7bfb, 0xd90f2788, 0x12490181, 0x5de5ffd4, 0xdd7ef86a, 0x76a2e214, 0xb9a40368, 0x925d958f, 0x4b39fffa, 0xba39aee9, 0xa4ffd30b, 0xfaf7933b, 0x6d498623, 0x193cbcfa, 0x27627545, 0x825cf47a, 0x61bd8ba0, 0xd11e42d1, 0xcead04f4, 0x127ea392, 0x10428db7, 0x8272a972, 0x9270c4a8, 0x127de50b, 0x285ba1c8, 0x3c62f44f, 0x35c0eaa5, 0xe805d231, 0x428929fb, 0xb4fcdf82, 0x4fb66a53, 0x0e7dc15b, 0x1f081fab, 0x108618ae, 0xfcfd086d, 0xf9ff2889, 0x694bcc11, 0x236a5cae, 0x12deca4d, 0x2c3f8cc5, 0xd2d02dfe, 0xf8ef5896, 0xe4cf52da, 0x95155b67, 0x494a488c, 0xb9b6a80c, 0x5c8f82bc, 0x89d36b45, 0x3a609437, 0xec00c9a9, 0x44715253, 0x0a874b49, 0xd773bc40, 0x7c34671c, 0x02717ef6, 0x4feb5536, 0xa2d02fff, 0xd2bf60c4, 0xd43f03c0, 0x50b4ef6d, 0x07478cd1, 0x006e1888, 0xa2e53f55, 0xb9e6d4bc, 0xa2048016, 0x97573833, 0xd7207d67, 0xde0f8f3d, 0x72f87b33, 0xabcc4f33, 0x7688c55d, 0x7b00a6b0, 0x947b0001, 0x570075d2, 0xf9bb88f8, 0x8942019e, 0x4264a5ff, 0x856302e0, 0x72dbd92b, 0xee971b69, 0x6ea22fde, 0x5f08ae2b, 0xaf7a616d, 0xe5c98767, 0xcf1febd2, 0x61efc8c2, 0xf1ac2571, 0xcc8239c2, 0x67214cb8, 0xb1e583d1, 0xb7dc3e62, 0x7f10bdce, 0xf90a5c38, 0x0ff0443d, 0x606e6dc6, 0x60543a49, 0x5727c148, 0x2be98a1d, 0x8ab41738, 0x20e1be24, 0xaf96da0f, 0x68458425, 0x99833be5, 0x600d457d, 0x282f9350, 0x8334b362, 0xd91d1120, 0x2b6d8da0, 0x642b1e31, 0x9c305a00, 0x52bce688, 0x1b03588a, 0xf7baefd5, 0x4142ed9c, 0xa4315c11, 0x83323ec5, 0xdfef4636, 0xa133c501, 0xe9d3531c, 0xee353783]);\n      sBox[3] = new Uint32Array([0x9db30420, 0x1fb6e9de, 0xa7be7bef, 0xd273a298, 0x4a4f7bdb, 0x64ad8c57, 0x85510443, 0xfa020ed1, 0x7e287aff, 0xe60fb663, 0x095f35a1, 0x79ebf120, 0xfd059d43, 0x6497b7b1, 0xf3641f63, 0x241e4adf, 0x28147f5f, 0x4fa2b8cd, 0xc9430040, 0x0cc32220, 0xfdd30b30, 0xc0a5374f, 0x1d2d00d9, 0x24147b15, 0xee4d111a, 0x0fca5167, 0x71ff904c, 0x2d195ffe, 0x1a05645f, 0x0c13fefe, 0x081b08ca, 0x05170121, 0x80530100, 0xe83e5efe, 0xac9af4f8, 0x7fe72701, 0xd2b8ee5f, 0x06df4261, 0xbb9e9b8a, 0x7293ea25, 0xce84ffdf, 0xf5718801, 0x3dd64b04, 0xa26f263b, 0x7ed48400, 0x547eebe6, 0x446d4ca0, 0x6cf3d6f5, 0x2649abdf, 0xaea0c7f5, 0x36338cc1, 0x503f7e93, 0xd3772061, 0x11b638e1, 0x72500e03, 0xf80eb2bb, 0xabe0502e, 0xec8d77de, 0x57971e81, 0xe14f6746, 0xc9335400, 0x6920318f, 0x081dbb99, 0xffc304a5, 0x4d351805, 0x7f3d5ce3, 0xa6c866c6, 0x5d5bcca9, 0xdaec6fea, 0x9f926f91, 0x9f46222f, 0x3991467d, 0xa5bf6d8e, 0x1143c44f, 0x43958302, 0xd0214eeb, 0x022083b8, 0x3fb6180c, 0x18f8931e, 0x281658e6, 0x26486e3e, 0x8bd78a70, 0x7477e4c1, 0xb506e07c, 0xf32d0a25, 0x79098b02, 0xe4eabb81, 0x28123b23, 0x69dead38, 0x1574ca16, 0xdf871b62, 0x211c40b7, 0xa51a9ef9, 0x0014377b, 0x041e8ac8, 0x09114003, 0xbd59e4d2, 0xe3d156d5, 0x4fe876d5, 0x2f91a340, 0x557be8de, 0x00eae4a7, 0x0ce5c2ec, 0x4db4bba6, 0xe756bdff, 0xdd3369ac, 0xec17b035, 0x06572327, 0x99afc8b0, 0x56c8c391, 0x6b65811c, 0x5e146119, 0x6e85cb75, 0xbe07c002, 0xc2325577, 0x893ff4ec, 0x5bbfc92d, 0xd0ec3b25, 0xb7801ab7, 0x8d6d3b24, 0x20c763ef, 0xc366a5fc, 0x9c382880, 0x0ace3205, 0xaac9548a, 0xeca1d7c7, 0x041afa32, 0x1d16625a, 0x6701902c, 0x9b757a54, 0x31d477f7, 0x9126b031, 0x36cc6fdb, 0xc70b8b46, 0xd9e66a48, 0x56e55a79, 0x026a4ceb, 0x52437eff, 0x2f8f76b4, 0x0df980a5, 0x8674cde3, 0xedda04eb, 0x17a9be04, 0x2c18f4df, 0xb7747f9d, 0xab2af7b4, 0xefc34d20, 0x2e096b7c, 0x1741a254, 0xe5b6a035, 0x213d42f6, 0x2c1c7c26, 0x61c2f50f, 0x6552daf9, 0xd2c231f8, 0x25130f69, 0xd8167fa2, 0x0418f2c8, 0x001a96a6, 0x0d1526ab, 0x63315c21, 0x5e0a72ec, 0x49bafefd, 0x187908d9, 0x8d0dbd86, 0x311170a7, 0x3e9b640c, 0xcc3e10d7, 0xd5cad3b6, 0x0caec388, 0xf73001e1, 0x6c728aff, 0x71eae2a1, 0x1f9af36e, 0xcfcbd12f, 0xc1de8417, 0xac07be6b, 0xcb44a1d8, 0x8b9b0f56, 0x013988c3, 0xb1c52fca, 0xb4be31cd, 0xd8782806, 0x12a3a4e2, 0x6f7de532, 0x58fd7eb6, 0xd01ee900, 0x24adffc2, 0xf4990fc5, 0x9711aac5, 0x001d7b95, 0x82e5e7d2, 0x109873f6, 0x00613096, 0xc32d9521, 0xada121ff, 0x29908415, 0x7fbb977f, 0xaf9eb3db, 0x29c9ed2a, 0x5ce2a465, 0xa730f32c, 0xd0aa3fe8, 0x8a5cc091, 0xd49e2ce7, 0x0ce454a9, 0xd60acd86, 0x015f1919, 0x77079103, 0xdea03af6, 0x78a8565e, 0xdee356df, 0x21f05cbe, 0x8b75e387, 0xb3c50651, 0xb8a5c3ef, 0xd8eeb6d2, 0xe523be77, 0xc2154529, 0x2f69efdf, 0xafe67afb, 0xf470c4b2, 0xf3e0eb5b, 0xd6cc9876, 0x39e4460c, 0x1fda8538, 0x1987832f, 0xca007367, 0xa99144f8, 0x296b299e, 0x492fc295, 0x9266beab, 0xb5676e69, 0x9bd3ddda, 0xdf7e052f, 0xdb25701c, 0x1b5e51ee, 0xf65324e6, 0x6afce36c, 0x0316cc04, 0x8644213e, 0xb7dc59d0, 0x7965291f, 0xccd6fd43, 0x41823979, 0x932bcdf6, 0xb657c34d, 0x4edfd282, 0x7ae5290c, 0x3cb9536b, 0x851e20fe, 0x9833557e, 0x13ecf0b0, 0xd3ffb372, 0x3f85c5c1, 0x0aef7ed2]);\n      sBox[4] = new Uint32Array([0x7ec90c04, 0x2c6e74b9, 0x9b0e66df, 0xa6337911, 0xb86a7fff, 0x1dd358f5, 0x44dd9d44, 0x1731167f, 0x08fbf1fa, 0xe7f511cc, 0xd2051b00, 0x735aba00, 0x2ab722d8, 0x386381cb, 0xacf6243a, 0x69befd7a, 0xe6a2e77f, 0xf0c720cd, 0xc4494816, 0xccf5c180, 0x38851640, 0x15b0a848, 0xe68b18cb, 0x4caadeff, 0x5f480a01, 0x0412b2aa, 0x259814fc, 0x41d0efe2, 0x4e40b48d, 0x248eb6fb, 0x8dba1cfe, 0x41a99b02, 0x1a550a04, 0xba8f65cb, 0x7251f4e7, 0x95a51725, 0xc106ecd7, 0x97a5980a, 0xc539b9aa, 0x4d79fe6a, 0xf2f3f763, 0x68af8040, 0xed0c9e56, 0x11b4958b, 0xe1eb5a88, 0x8709e6b0, 0xd7e07156, 0x4e29fea7, 0x6366e52d, 0x02d1c000, 0xc4ac8e05, 0x9377f571, 0x0c05372a, 0x578535f2, 0x2261be02, 0xd642a0c9, 0xdf13a280, 0x74b55bd2, 0x682199c0, 0xd421e5ec, 0x53fb3ce8, 0xc8adedb3, 0x28a87fc9, 0x3d959981, 0x5c1ff900, 0xfe38d399, 0x0c4eff0b, 0x062407ea, 0xaa2f4fb1, 0x4fb96976, 0x90c79505, 0xb0a8a774, 0xef55a1ff, 0xe59ca2c2, 0xa6b62d27, 0xe66a4263, 0xdf65001f, 0x0ec50966, 0xdfdd55bc, 0x29de0655, 0x911e739a, 0x17af8975, 0x32c7911c, 0x89f89468, 0x0d01e980, 0x524755f4, 0x03b63cc9, 0x0cc844b2, 0xbcf3f0aa, 0x87ac36e9, 0xe53a7426, 0x01b3d82b, 0x1a9e7449, 0x64ee2d7e, 0xcddbb1da, 0x01c94910, 0xb868bf80, 0x0d26f3fd, 0x9342ede7, 0x04a5c284, 0x636737b6, 0x50f5b616, 0xf24766e3, 0x8eca36c1, 0x136e05db, 0xfef18391, 0xfb887a37, 0xd6e7f7d4, 0xc7fb7dc9, 0x3063fcdf, 0xb6f589de, 0xec2941da, 0x26e46695, 0xb7566419, 0xf654efc5, 0xd08d58b7, 0x48925401, 0xc1bacb7f, 0xe5ff550f, 0xb6083049, 0x5bb5d0e8, 0x87d72e5a, 0xab6a6ee1, 0x223a66ce, 0xc62bf3cd, 0x9e0885f9, 0x68cb3e47, 0x086c010f, 0xa21de820, 0xd18b69de, 0xf3f65777, 0xfa02c3f6, 0x407edac3, 0xcbb3d550, 0x1793084d, 0xb0d70eba, 0x0ab378d5, 0xd951fb0c, 0xded7da56, 0x4124bbe4, 0x94ca0b56, 0x0f5755d1, 0xe0e1e56e, 0x6184b5be, 0x580a249f, 0x94f74bc0, 0xe327888e, 0x9f7b5561, 0xc3dc0280, 0x05687715, 0x646c6bd7, 0x44904db3, 0x66b4f0a3, 0xc0f1648a, 0x697ed5af, 0x49e92ff6, 0x309e374f, 0x2cb6356a, 0x85808573, 0x4991f840, 0x76f0ae02, 0x083be84d, 0x28421c9a, 0x44489406, 0x736e4cb8, 0xc1092910, 0x8bc95fc6, 0x7d869cf4, 0x134f616f, 0x2e77118d, 0xb31b2be1, 0xaa90b472, 0x3ca5d717, 0x7d161bba, 0x9cad9010, 0xaf462ba2, 0x9fe459d2, 0x45d34559, 0xd9f2da13, 0xdbc65487, 0xf3e4f94e, 0x176d486f, 0x097c13ea, 0x631da5c7, 0x445f7382, 0x175683f4, 0xcdc66a97, 0x70be0288, 0xb3cdcf72, 0x6e5dd2f3, 0x20936079, 0x459b80a5, 0xbe60e2db, 0xa9c23101, 0xeba5315c, 0x224e42f2, 0x1c5c1572, 0xf6721b2c, 0x1ad2fff3, 0x8c25404e, 0x324ed72f, 0x4067b7fd, 0x0523138e, 0x5ca3bc78, 0xdc0fd66e, 0x75922283, 0x784d6b17, 0x58ebb16e, 0x44094f85, 0x3f481d87, 0xfcfeae7b, 0x77b5ff76, 0x8c2302bf, 0xaaf47556, 0x5f46b02a, 0x2b092801, 0x3d38f5f7, 0x0ca81f36, 0x52af4a8a, 0x66d5e7c0, 0xdf3b0874, 0x95055110, 0x1b5ad7a8, 0xf61ed5ad, 0x6cf6e479, 0x20758184, 0xd0cefa65, 0x88f7be58, 0x4a046826, 0x0ff6f8f3, 0xa09c7f70, 0x5346aba0, 0x5ce96c28, 0xe176eda3, 0x6bac307f, 0x376829d2, 0x85360fa9, 0x17e3fe2a, 0x24b79767, 0xf5a96b20, 0xd6cd2595, 0x68ff1ebf, 0x7555442c, 0xf19f06be, 0xf9e0659a, 0xeeb9491d, 0x34010718, 0xbb30cab8, 0xe822fe15, 0x88570983, 0x750e6249, 0xda627e55, 0x5e76ffa8, 0xb1534546, 0x6d47de08, 0xefe9e7d4]);\n      sBox[5] = new Uint32Array([0xf6fa8f9d, 0x2cac6ce1, 0x4ca34867, 0xe2337f7c, 0x95db08e7, 0x016843b4, 0xeced5cbc, 0x325553ac, 0xbf9f0960, 0xdfa1e2ed, 0x83f0579d, 0x63ed86b9, 0x1ab6a6b8, 0xde5ebe39, 0xf38ff732, 0x8989b138, 0x33f14961, 0xc01937bd, 0xf506c6da, 0xe4625e7e, 0xa308ea99, 0x4e23e33c, 0x79cbd7cc, 0x48a14367, 0xa3149619, 0xfec94bd5, 0xa114174a, 0xeaa01866, 0xa084db2d, 0x09a8486f, 0xa888614a, 0x2900af98, 0x01665991, 0xe1992863, 0xc8f30c60, 0x2e78ef3c, 0xd0d51932, 0xcf0fec14, 0xf7ca07d2, 0xd0a82072, 0xfd41197e, 0x9305a6b0, 0xe86be3da, 0x74bed3cd, 0x372da53c, 0x4c7f4448, 0xdab5d440, 0x6dba0ec3, 0x083919a7, 0x9fbaeed9, 0x49dbcfb0, 0x4e670c53, 0x5c3d9c01, 0x64bdb941, 0x2c0e636a, 0xba7dd9cd, 0xea6f7388, 0xe70bc762, 0x35f29adb, 0x5c4cdd8d, 0xf0d48d8c, 0xb88153e2, 0x08a19866, 0x1ae2eac8, 0x284caf89, 0xaa928223, 0x9334be53, 0x3b3a21bf, 0x16434be3, 0x9aea3906, 0xefe8c36e, 0xf890cdd9, 0x80226dae, 0xc340a4a3, 0xdf7e9c09, 0xa694a807, 0x5b7c5ecc, 0x221db3a6, 0x9a69a02f, 0x68818a54, 0xceb2296f, 0x53c0843a, 0xfe893655, 0x25bfe68a, 0xb4628abc, 0xcf222ebf, 0x25ac6f48, 0xa9a99387, 0x53bddb65, 0xe76ffbe7, 0xe967fd78, 0x0ba93563, 0x8e342bc1, 0xe8a11be9, 0x4980740d, 0xc8087dfc, 0x8de4bf99, 0xa11101a0, 0x7fd37975, 0xda5a26c0, 0xe81f994f, 0x9528cd89, 0xfd339fed, 0xb87834bf, 0x5f04456d, 0x22258698, 0xc9c4c83b, 0x2dc156be, 0x4f628daa, 0x57f55ec5, 0xe2220abe, 0xd2916ebf, 0x4ec75b95, 0x24f2c3c0, 0x42d15d99, 0xcd0d7fa0, 0x7b6e27ff, 0xa8dc8af0, 0x7345c106, 0xf41e232f, 0x35162386, 0xe6ea8926, 0x3333b094, 0x157ec6f2, 0x372b74af, 0x692573e4, 0xe9a9d848, 0xf3160289, 0x3a62ef1d, 0xa787e238, 0xf3a5f676, 0x74364853, 0x20951063, 0x4576698d, 0xb6fad407, 0x592af950, 0x36f73523, 0x4cfb6e87, 0x7da4cec0, 0x6c152daa, 0xcb0396a8, 0xc50dfe5d, 0xfcd707ab, 0x0921c42f, 0x89dff0bb, 0x5fe2be78, 0x448f4f33, 0x754613c9, 0x2b05d08d, 0x48b9d585, 0xdc049441, 0xc8098f9b, 0x7dede786, 0xc39a3373, 0x42410005, 0x6a091751, 0x0ef3c8a6, 0x890072d6, 0x28207682, 0xa9a9f7be, 0xbf32679d, 0xd45b5b75, 0xb353fd00, 0xcbb0e358, 0x830f220a, 0x1f8fb214, 0xd372cf08, 0xcc3c4a13, 0x8cf63166, 0x061c87be, 0x88c98f88, 0x6062e397, 0x47cf8e7a, 0xb6c85283, 0x3cc2acfb, 0x3fc06976, 0x4e8f0252, 0x64d8314d, 0xda3870e3, 0x1e665459, 0xc10908f0, 0x513021a5, 0x6c5b68b7, 0x822f8aa0, 0x3007cd3e, 0x74719eef, 0xdc872681, 0x073340d4, 0x7e432fd9, 0x0c5ec241, 0x8809286c, 0xf592d891, 0x08a930f6, 0x957ef305, 0xb7fbffbd, 0xc266e96f, 0x6fe4ac98, 0xb173ecc0, 0xbc60b42a, 0x953498da, 0xfba1ae12, 0x2d4bd736, 0x0f25faab, 0xa4f3fceb, 0xe2969123, 0x257f0c3d, 0x9348af49, 0x361400bc, 0xe8816f4a, 0x3814f200, 0xa3f94043, 0x9c7a54c2, 0xbc704f57, 0xda41e7f9, 0xc25ad33a, 0x54f4a084, 0xb17f5505, 0x59357cbe, 0xedbd15c8, 0x7f97c5ab, 0xba5ac7b5, 0xb6f6deaf, 0x3a479c3a, 0x5302da25, 0x653d7e6a, 0x54268d49, 0x51a477ea, 0x5017d55b, 0xd7d25d88, 0x44136c76, 0x0404a8c8, 0xb8e5a121, 0xb81a928a, 0x60ed5869, 0x97c55b96, 0xeaec991b, 0x29935913, 0x01fdb7f1, 0x088e8dfa, 0x9ab6f6f5, 0x3b4cbf9f, 0x4a5de3ab, 0xe6051d35, 0xa0e1d855, 0xd36b4cf1, 0xf544edeb, 0xb0e93524, 0xbebb8fbd, 0xa2d762cf, 0x49c92f54, 0x38b5f331, 0x7128a454, 0x48392905, 0xa65b1db8, 0x851c97bd, 0xd675cf2f]);\n      sBox[6] = new Uint32Array([0x85e04019, 0x332bf567, 0x662dbfff, 0xcfc65693, 0x2a8d7f6f, 0xab9bc912, 0xde6008a1, 0x2028da1f, 0x0227bce7, 0x4d642916, 0x18fac300, 0x50f18b82, 0x2cb2cb11, 0xb232e75c, 0x4b3695f2, 0xb28707de, 0xa05fbcf6, 0xcd4181e9, 0xe150210c, 0xe24ef1bd, 0xb168c381, 0xfde4e789, 0x5c79b0d8, 0x1e8bfd43, 0x4d495001, 0x38be4341, 0x913cee1d, 0x92a79c3f, 0x089766be, 0xbaeeadf4, 0x1286becf, 0xb6eacb19, 0x2660c200, 0x7565bde4, 0x64241f7a, 0x8248dca9, 0xc3b3ad66, 0x28136086, 0x0bd8dfa8, 0x356d1cf2, 0x107789be, 0xb3b2e9ce, 0x0502aa8f, 0x0bc0351e, 0x166bf52a, 0xeb12ff82, 0xe3486911, 0xd34d7516, 0x4e7b3aff, 0x5f43671b, 0x9cf6e037, 0x4981ac83, 0x334266ce, 0x8c9341b7, 0xd0d854c0, 0xcb3a6c88, 0x47bc2829, 0x4725ba37, 0xa66ad22b, 0x7ad61f1e, 0x0c5cbafa, 0x4437f107, 0xb6e79962, 0x42d2d816, 0x0a961288, 0xe1a5c06e, 0x13749e67, 0x72fc081a, 0xb1d139f7, 0xf9583745, 0xcf19df58, 0xbec3f756, 0xc06eba30, 0x07211b24, 0x45c28829, 0xc95e317f, 0xbc8ec511, 0x38bc46e9, 0xc6e6fa14, 0xbae8584a, 0xad4ebc46, 0x468f508b, 0x7829435f, 0xf124183b, 0x821dba9f, 0xaff60ff4, 0xea2c4e6d, 0x16e39264, 0x92544a8b, 0x009b4fc3, 0xaba68ced, 0x9ac96f78, 0x06a5b79a, 0xb2856e6e, 0x1aec3ca9, 0xbe838688, 0x0e0804e9, 0x55f1be56, 0xe7e5363b, 0xb3a1f25d, 0xf7debb85, 0x61fe033c, 0x16746233, 0x3c034c28, 0xda6d0c74, 0x79aac56c, 0x3ce4e1ad, 0x51f0c802, 0x98f8f35a, 0x1626a49f, 0xeed82b29, 0x1d382fe3, 0x0c4fb99a, 0xbb325778, 0x3ec6d97b, 0x6e77a6a9, 0xcb658b5c, 0xd45230c7, 0x2bd1408b, 0x60c03eb7, 0xb9068d78, 0xa33754f4, 0xf430c87d, 0xc8a71302, 0xb96d8c32, 0xebd4e7be, 0xbe8b9d2d, 0x7979fb06, 0xe7225308, 0x8b75cf77, 0x11ef8da4, 0xe083c858, 0x8d6b786f, 0x5a6317a6, 0xfa5cf7a0, 0x5dda0033, 0xf28ebfb0, 0xf5b9c310, 0xa0eac280, 0x08b9767a, 0xa3d9d2b0, 0x79d34217, 0x021a718d, 0x9ac6336a, 0x2711fd60, 0x438050e3, 0x069908a8, 0x3d7fedc4, 0x826d2bef, 0x4eeb8476, 0x488dcf25, 0x36c9d566, 0x28e74e41, 0xc2610aca, 0x3d49a9cf, 0xbae3b9df, 0xb65f8de6, 0x92aeaf64, 0x3ac7d5e6, 0x9ea80509, 0xf22b017d, 0xa4173f70, 0xdd1e16c3, 0x15e0d7f9, 0x50b1b887, 0x2b9f4fd5, 0x625aba82, 0x6a017962, 0x2ec01b9c, 0x15488aa9, 0xd716e740, 0x40055a2c, 0x93d29a22, 0xe32dbf9a, 0x058745b9, 0x3453dc1e, 0xd699296e, 0x496cff6f, 0x1c9f4986, 0xdfe2ed07, 0xb87242d1, 0x19de7eae, 0x053e561a, 0x15ad6f8c, 0x66626c1c, 0x7154c24c, 0xea082b2a, 0x93eb2939, 0x17dcb0f0, 0x58d4f2ae, 0x9ea294fb, 0x52cf564c, 0x9883fe66, 0x2ec40581, 0x763953c3, 0x01d6692e, 0xd3a0c108, 0xa1e7160e, 0xe4f2dfa6, 0x693ed285, 0x74904698, 0x4c2b0edd, 0x4f757656, 0x5d393378, 0xa132234f, 0x3d321c5d, 0xc3f5e194, 0x4b269301, 0xc79f022f, 0x3c997e7e, 0x5e4f9504, 0x3ffafbbd, 0x76f7ad0e, 0x296693f4, 0x3d1fce6f, 0xc61e45be, 0xd3b5ab34, 0xf72bf9b7, 0x1b0434c0, 0x4e72b567, 0x5592a33d, 0xb5229301, 0xcfd2a87f, 0x60aeb767, 0x1814386b, 0x30bcc33d, 0x38a0c07d, 0xfd1606f2, 0xc363519b, 0x589dd390, 0x5479f8e6, 0x1cb8d647, 0x97fd61a9, 0xea7759f4, 0x2d57539d, 0x569a58cf, 0xe84e63ad, 0x462e1b78, 0x6580f87e, 0xf3817914, 0x91da55f4, 0x40a230f3, 0xd1988f35, 0xb6e318d2, 0x3ffa50bc, 0x3d40f021, 0xc3c0bdae, 0x4958c24c, 0x518f36b2, 0x84b1d370, 0x0fedce83, 0x878ddada, 0xf2a279c7, 0x94e01be8, 0x90716f4b, 0x954b8aa3]);\n      sBox[7] = new Uint32Array([0xe216300d, 0xbbddfffc, 0xa7ebdabd, 0x35648095, 0x7789f8b7, 0xe6c1121b, 0x0e241600, 0x052ce8b5, 0x11a9cfb0, 0xe5952f11, 0xece7990a, 0x9386d174, 0x2a42931c, 0x76e38111, 0xb12def3a, 0x37ddddfc, 0xde9adeb1, 0x0a0cc32c, 0xbe197029, 0x84a00940, 0xbb243a0f, 0xb4d137cf, 0xb44e79f0, 0x049eedfd, 0x0b15a15d, 0x480d3168, 0x8bbbde5a, 0x669ded42, 0xc7ece831, 0x3f8f95e7, 0x72df191b, 0x7580330d, 0x94074251, 0x5c7dcdfa, 0xabbe6d63, 0xaa402164, 0xb301d40a, 0x02e7d1ca, 0x53571dae, 0x7a3182a2, 0x12a8ddec, 0xfdaa335d, 0x176f43e8, 0x71fb46d4, 0x38129022, 0xce949ad4, 0xb84769ad, 0x965bd862, 0x82f3d055, 0x66fb9767, 0x15b80b4e, 0x1d5b47a0, 0x4cfde06f, 0xc28ec4b8, 0x57e8726e, 0x647a78fc, 0x99865d44, 0x608bd593, 0x6c200e03, 0x39dc5ff6, 0x5d0b00a3, 0xae63aff2, 0x7e8bd632, 0x70108c0c, 0xbbd35049, 0x2998df04, 0x980cf42a, 0x9b6df491, 0x9e7edd53, 0x06918548, 0x58cb7e07, 0x3b74ef2e, 0x522fffb1, 0xd24708cc, 0x1c7e27cd, 0xa4eb215b, 0x3cf1d2e2, 0x19b47a38, 0x424f7618, 0x35856039, 0x9d17dee7, 0x27eb35e6, 0xc9aff67b, 0x36baf5b8, 0x09c467cd, 0xc18910b1, 0xe11dbf7b, 0x06cd1af8, 0x7170c608, 0x2d5e3354, 0xd4de495a, 0x64c6d006, 0xbcc0c62c, 0x3dd00db3, 0x708f8f34, 0x77d51b42, 0x264f620f, 0x24b8d2bf, 0x15c1b79e, 0x46a52564, 0xf8d7e54e, 0x3e378160, 0x7895cda5, 0x859c15a5, 0xe6459788, 0xc37bc75f, 0xdb07ba0c, 0x0676a3ab, 0x7f229b1e, 0x31842e7b, 0x24259fd7, 0xf8bef472, 0x835ffcb8, 0x6df4c1f2, 0x96f5b195, 0xfd0af0fc, 0xb0fe134c, 0xe2506d3d, 0x4f9b12ea, 0xf215f225, 0xa223736f, 0x9fb4c428, 0x25d04979, 0x34c713f8, 0xc4618187, 0xea7a6e98, 0x7cd16efc, 0x1436876c, 0xf1544107, 0xbedeee14, 0x56e9af27, 0xa04aa441, 0x3cf7c899, 0x92ecbae6, 0xdd67016d, 0x151682eb, 0xa842eedf, 0xfdba60b4, 0xf1907b75, 0x20e3030f, 0x24d8c29e, 0xe139673b, 0xefa63fb8, 0x71873054, 0xb6f2cf3b, 0x9f326442, 0xcb15a4cc, 0xb01a4504, 0xf1e47d8d, 0x844a1be5, 0xbae7dfdc, 0x42cbda70, 0xcd7dae0a, 0x57e85b7a, 0xd53f5af6, 0x20cf4d8c, 0xcea4d428, 0x79d130a4, 0x3486ebfb, 0x33d3cddc, 0x77853b53, 0x37effcb5, 0xc5068778, 0xe580b3e6, 0x4e68b8f4, 0xc5c8b37e, 0x0d809ea2, 0x398feb7c, 0x132a4f94, 0x43b7950e, 0x2fee7d1c, 0x223613bd, 0xdd06caa2, 0x37df932b, 0xc4248289, 0xacf3ebc3, 0x5715f6b7, 0xef3478dd, 0xf267616f, 0xc148cbe4, 0x9052815e, 0x5e410fab, 0xb48a2465, 0x2eda7fa4, 0xe87b40e4, 0xe98ea084, 0x5889e9e1, 0xefd390fc, 0xdd07d35b, 0xdb485694, 0x38d7e5b2, 0x57720101, 0x730edebc, 0x5b643113, 0x94917e4f, 0x503c2fba, 0x646f1282, 0x7523d24a, 0xe0779695, 0xf9c17a8f, 0x7a5b2121, 0xd187b896, 0x29263a4d, 0xba510cdf, 0x81f47c9f, 0xad1163ed, 0xea7b5965, 0x1a00726e, 0x11403092, 0x00da6d77, 0x4a0cdd61, 0xad1f4603, 0x605bdfb0, 0x9eedc364, 0x22ebe6a8, 0xcee7d28a, 0xa0e736a0, 0x5564a6b9, 0x10853209, 0xc7eb8f37, 0x2de705ca, 0x8951570f, 0xdf09822b, 0xbd691a6c, 0xaa12e4f2, 0x87451c0f, 0xe0f6a27a, 0x3ada4819, 0x4cf1764f, 0x0d771c2b, 0x67cdb156, 0x350d8384, 0x5938fa0f, 0x42399ef3, 0x36997b07, 0x0e84093d, 0x4aa93e61, 0x8360d87b, 0x1fa98b0c, 0x1149382c, 0xe97625a5, 0x0614d1b7, 0x0e25244b, 0x0c768347, 0x589e8d82, 0x0d2059d1, 0xa466bb1e, 0xf8da0a82, 0x04f19130, 0xba6e4ec0, 0x99265164, 0x1ee7230d, 0x50b2ad80, 0xeaee6801, 0x8db2a283, 0xea8bf59e]);\n      return this.sBox = sBox;\n    };\n\n    return Global;\n\n  })();\n\n  G = new Global();\n\n  CAST5 = (function() {\n    CAST5.blockSize = 8;\n\n    CAST5.prototype.blockSize = CAST5.blockSize;\n\n    CAST5.keySize = 16;\n\n    CAST5.prototype.keySize = CAST5.keySize;\n\n    function CAST5(key) {\n      var n;\n      this.masking = new Array(16);\n      this.rotate = new Array(16);\n      this.reset();\n      if (key.sigBytes !== (n = this.keySize)) {\n        throw new Error(\"key must be \" + n + \" bytes\");\n      }\n      this.keySchedule(key);\n    }\n\n    CAST5.prototype.reset = function() {\n      var i, _i, _results;\n      _results = [];\n      for (i = _i = 0; _i < 16; i = ++_i) {\n        this.masking[i] = 0;\n        _results.push(this.rotate[i] = 0);\n      }\n      return _results;\n    };\n\n    CAST5.prototype.encryptBlock = function(words, offset) {\n      var bytes, res;\n      if (offset == null) {\n        offset = 0;\n      }\n      bytes = ui32a_to_ui8a(words);\n      res = this._encrypt_ui8a(bytes);\n      return ui8a_to_ui32a(res, words);\n    };\n\n    CAST5.prototype.decryptBlock = function(words, offset) {\n      var bytes, res;\n      if (offset == null) {\n        offset = 0;\n      }\n      bytes = ui32a_to_ui8a(words);\n      res = this._decrypt_ui8a(bytes);\n      return ui8a_to_ui32a(res, words);\n    };\n\n    CAST5.prototype._encrypt_ui8a = function(src) {\n      var dst, i, l, len, r, t, _i;\n      len = src.length;\n      dst = new Uint8Array(len);\n      for (i = _i = 0; _i < len; i = _i += 8) {\n        l = src[i] << 24 | src[i + 1] << 16 | src[i + 2] << 8 | src[i + 3];\n        r = src[i + 4] << 24 | src[i + 5] << 16 | src[i + 6] << 8 | src[i + 7];\n        t = r;\n        r = l ^ this.f1(r, this.masking[0], this.rotate[0]);\n        l = t;\n        t = r;\n        r = l ^ this.f2(r, this.masking[1], this.rotate[1]);\n        l = t;\n        t = r;\n        r = l ^ this.f3(r, this.masking[2], this.rotate[2]);\n        l = t;\n        t = r;\n        r = l ^ this.f1(r, this.masking[3], this.rotate[3]);\n        l = t;\n        t = r;\n        r = l ^ this.f2(r, this.masking[4], this.rotate[4]);\n        l = t;\n        t = r;\n        r = l ^ this.f3(r, this.masking[5], this.rotate[5]);\n        l = t;\n        t = r;\n        r = l ^ this.f1(r, this.masking[6], this.rotate[6]);\n        l = t;\n        t = r;\n        r = l ^ this.f2(r, this.masking[7], this.rotate[7]);\n        l = t;\n        t = r;\n        r = l ^ this.f3(r, this.masking[8], this.rotate[8]);\n        l = t;\n        t = r;\n        r = l ^ this.f1(r, this.masking[9], this.rotate[9]);\n        l = t;\n        t = r;\n        r = l ^ this.f2(r, this.masking[10], this.rotate[10]);\n        l = t;\n        t = r;\n        r = l ^ this.f3(r, this.masking[11], this.rotate[11]);\n        l = t;\n        t = r;\n        r = l ^ this.f1(r, this.masking[12], this.rotate[12]);\n        l = t;\n        t = r;\n        r = l ^ this.f2(r, this.masking[13], this.rotate[13]);\n        l = t;\n        t = r;\n        r = l ^ this.f3(r, this.masking[14], this.rotate[14]);\n        l = t;\n        t = r;\n        r = l ^ this.f1(r, this.masking[15], this.rotate[15]);\n        l = t;\n        dst[i] = (r >>> 24) & 255;\n        dst[i + 1] = (r >>> 16) & 255;\n        dst[i + 2] = (r >>> 8) & 255;\n        dst[i + 3] = r & 255;\n        dst[i + 4] = (l >>> 24) & 255;\n        dst[i + 5] = (l >>> 16) & 255;\n        dst[i + 6] = (l >>> 8) & 255;\n        dst[i + 7] = l & 255;\n      }\n      return dst;\n    };\n\n    CAST5.prototype._decrypt_ui8a = function(src) {\n      var dst, i, l, len, r, t, _i;\n      len = src.length;\n      dst = new Uint8Array(len);\n      for (i = _i = 0; _i < len; i = _i += 8) {\n        l = src[i] << 24 | src[i + 1] << 16 | src[i + 2] << 8 | src[i + 3];\n        r = src[i + 4] << 24 | src[i + 5] << 16 | src[i + 6] << 8 | src[i + 7];\n        t = r;\n        r = l ^ this.f1(r, this.masking[15], this.rotate[15]);\n        l = t;\n        t = r;\n        r = l ^ this.f3(r, this.masking[14], this.rotate[14]);\n        l = t;\n        t = r;\n        r = l ^ this.f2(r, this.masking[13], this.rotate[13]);\n        l = t;\n        t = r;\n        r = l ^ this.f1(r, this.masking[12], this.rotate[12]);\n        l = t;\n        t = r;\n        r = l ^ this.f3(r, this.masking[11], this.rotate[11]);\n        l = t;\n        t = r;\n        r = l ^ this.f2(r, this.masking[10], this.rotate[10]);\n        l = t;\n        t = r;\n        r = l ^ this.f1(r, this.masking[9], this.rotate[9]);\n        l = t;\n        t = r;\n        r = l ^ this.f3(r, this.masking[8], this.rotate[8]);\n        l = t;\n        t = r;\n        r = l ^ this.f2(r, this.masking[7], this.rotate[7]);\n        l = t;\n        t = r;\n        r = l ^ this.f1(r, this.masking[6], this.rotate[6]);\n        l = t;\n        t = r;\n        r = l ^ this.f3(r, this.masking[5], this.rotate[5]);\n        l = t;\n        t = r;\n        r = l ^ this.f2(r, this.masking[4], this.rotate[4]);\n        l = t;\n        t = r;\n        r = l ^ this.f1(r, this.masking[3], this.rotate[3]);\n        l = t;\n        t = r;\n        r = l ^ this.f3(r, this.masking[2], this.rotate[2]);\n        l = t;\n        t = r;\n        r = l ^ this.f2(r, this.masking[1], this.rotate[1]);\n        l = t;\n        t = r;\n        r = l ^ this.f1(r, this.masking[0], this.rotate[0]);\n        l = t;\n        dst[i] = (r >>> 24) & 255;\n        dst[i + 1] = (r >>> 16) & 255;\n        dst[i + 2] = (r >>> 8) & 255;\n        dst[i + 3] = r & 255;\n        dst[i + 4] = (l >>> 24) & 255;\n        dst[i + 5] = (l >> 16) & 255;\n        dst[i + 6] = (l >> 8) & 255;\n        dst[i + 7] = l & 255;\n      }\n      return dst;\n    };\n\n    CAST5.prototype.keySchedule = function(key) {\n      var a, b, half, i, j, k, ki, kw, round, t, w, x, _i, _j, _k, _l, _m, _results;\n      t = (function() {\n        var _i, _len, _ref1, _results;\n        _ref1 = key.words;\n        _results = [];\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          kw = _ref1[_i];\n          _results.push(kw);\n        }\n        return _results;\n      })();\n      k = new Array(32);\n      x = [6, 7, 4, 5];\n      ki = 0;\n      for (half = _i = 0; _i < 2; half = ++_i) {\n        for (round = _j = 0; _j < 4; round = ++_j) {\n          for (j = _k = 0; _k < 4; j = ++_k) {\n            a = G.scheduleA[round][j];\n            w = t[a[1]];\n            w ^= G.sBox[4][(t[a[2] >>> 2] >>> (24 - 8 * (a[2] & 3))) & 0xff];\n            w ^= G.sBox[5][(t[a[3] >>> 2] >>> (24 - 8 * (a[3] & 3))) & 0xff];\n            w ^= G.sBox[6][(t[a[4] >>> 2] >>> (24 - 8 * (a[4] & 3))) & 0xff];\n            w ^= G.sBox[7][(t[a[5] >>> 2] >>> (24 - 8 * (a[5] & 3))) & 0xff];\n            w ^= G.sBox[x[j]][(t[a[6] >>> 2] >>> (24 - 8 * (a[6] & 3))) & 0xff];\n            t[a[0]] = w;\n          }\n          for (j = _l = 0; _l < 4; j = ++_l) {\n            b = G.scheduleB[round][j];\n            w = G.sBox[4][(t[b[0] >>> 2] >>> (24 - 8 * (b[0] & 3))) & 0xff];\n            w ^= G.sBox[5][(t[b[1] >>> 2] >>> (24 - 8 * (b[1] & 3))) & 0xff];\n            w ^= G.sBox[6][(t[b[2] >>> 2] >>> (24 - 8 * (b[2] & 3))) & 0xff];\n            w ^= G.sBox[7][(t[b[3] >>> 2] >>> (24 - 8 * (b[3] & 3))) & 0xff];\n            w ^= G.sBox[4 + j][(t[b[4] >>> 2] >>> (24 - 8 * (b[4] & 3))) & 0xff];\n            k[ki] = w;\n            ki++;\n          }\n        }\n      }\n      _results = [];\n      for (i = _m = 0; _m < 16; i = ++_m) {\n        this.masking[i] = k[i];\n        _results.push(this.rotate[i] = k[16 + i] & 0x1f);\n      }\n      return _results;\n    };\n\n    CAST5.prototype.f1 = function(d, m, r) {\n      var I, t;\n      t = m + d;\n      I = (t << r) | (t >>> (32 - r));\n      return ((G.sBox[0][I >>> 24] ^ G.sBox[1][(I >>> 16) & 255]) - G.sBox[2][(I >>> 8) & 255]) + G.sBox[3][I & 255];\n    };\n\n    CAST5.prototype.f2 = function(d, m, r) {\n      var I, t;\n      t = m ^ d;\n      I = (t << r) | (t >>> (32 - r));\n      return ((G.sBox[0][I >>> 24] - G.sBox[1][(I >>> 16) & 255]) + G.sBox[2][(I >>> 8) & 255]) ^ G.sBox[3][I & 255];\n    };\n\n    CAST5.prototype.f3 = function(d, m, r) {\n      var I, t;\n      t = m - d;\n      I = (t << r) | (t >>> (32 - r));\n      return ((G.sBox[0][I >>> 24] + G.sBox[1][(I >>> 16) & 255]) ^ G.sBox[2][(I >>> 8) & 255]) - G.sBox[3][I & 255];\n    };\n\n    return CAST5;\n\n  })();\n\n  exports.CAST5 = CAST5;\n\n}).call(this);\n\n},{\"../util\":70,\"triplesec\":181}],38:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var AES, WordArray, ciphers, decrypt, encrypt, _ref;\n\n  _ref = require('triplesec'), ciphers = _ref.ciphers, WordArray = _ref.WordArray;\n\n  AES = ciphers.AES;\n\n  encrypt = function(_arg) {\n    var block_cipher_class, block_size, c, cipher, e, iv, key, list, out, plaintext, pos;\n    block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, plaintext = _arg.plaintext, iv = _arg.iv;\n    block_cipher_class || (block_cipher_class = AES);\n    cipher || (cipher = new block_cipher_class(WordArray.from_buffer(key)));\n    block_size = cipher.blockSize;\n    c = WordArray.from_buffer(iv.slice(0, block_size));\n    pos = 0;\n    list = (function() {\n      var _results;\n      _results = [];\n      while (plaintext.length > pos) {\n        cipher.encryptBlock(c.words, 0);\n        e = c;\n        c = WordArray.from_buffer(plaintext.slice(pos, pos + block_size));\n        e.xor(c, {\n          n_words: c.words.length\n        });\n        pos += block_size;\n        c = e;\n        _results.push(e.to_buffer());\n      }\n      return _results;\n    })();\n    out = Buffer.concat(list);\n    return out.slice(0, plaintext.length);\n  };\n\n  decrypt = function(_arg) {\n    var b, block_cipher_class, block_size, cipher, ciphertext, d, i, iv, key, list, out, pos;\n    block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, ciphertext = _arg.ciphertext, iv = _arg.iv;\n    block_cipher_class || (block_cipher_class = AES);\n    cipher || (cipher = new block_cipher_class(WordArray.from_buffer(key)));\n    block_size = cipher.blockSize;\n    iv || (iv = new Buffer((function() {\n      var _i, _results;\n      _results = [];\n      for (i = _i = 0; 0 <= block_size ? _i < block_size : _i > block_size; i = 0 <= block_size ? ++_i : --_i) {\n        _results.push(0);\n      }\n      return _results;\n    })()));\n    b = WordArray.from_buffer(iv.slice(0, block_size));\n    pos = 0;\n    list = (function() {\n      var _results;\n      _results = [];\n      while (ciphertext.length > pos) {\n        cipher.encryptBlock(b.words, 0);\n        d = b;\n        b = WordArray.from_buffer(ciphertext.slice(pos, pos + block_size));\n        d.xor(b, {});\n        pos += block_size;\n        _results.push(d.to_buffer());\n      }\n      return _results;\n    })();\n    out = Buffer.concat(list);\n    return out.slice(out, ciphertext.length);\n  };\n\n  exports.encrypt = encrypt;\n\n  exports.decrypt = decrypt;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":80,\"triplesec\":181}],39:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, Ch, ClearSigner, CreationTime, Issuer, Literal, SHA512, SRF, Signature, Verifier, VerifierBase, WordArray, bufferify, clearsign_header, clearsign_to_sign, dash_escape, dash_unescape_line, dash_unescape_lines, encode, export_key_pgp, get_cipher, hashmod, iced, input_to_cleartext, input_to_cleartext_display, input_to_cleartext_sign, konst, make_esc, scrub_buffer, triplesec, unix_time, whitespace_strip, __iced_k, __iced_k_noop, _ref, _ref1, _ref2,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  make_esc = require('iced-error').make_esc;\n\n  _ref = require('./packet/signature'), Signature = _ref.Signature, CreationTime = _ref.CreationTime, Issuer = _ref.Issuer;\n\n  _ref1 = require('../util'), bufferify = _ref1.bufferify, unix_time = _ref1.unix_time;\n\n  SRF = require('../rand').SRF;\n\n  triplesec = require('triplesec');\n\n  _ref2 = require('../symmetric'), export_key_pgp = _ref2.export_key_pgp, get_cipher = _ref2.get_cipher;\n\n  scrub_buffer = triplesec.util.scrub_buffer;\n\n  WordArray = triplesec.WordArray;\n\n  konst = require('../const');\n\n  C = konst.openpgp;\n\n  Ch = require('../header');\n\n  hashmod = require('../hash');\n\n  SHA512 = hashmod.SHA512;\n\n  encode = require('./armor').encode;\n\n  clearsign_header = require('pgp-utils').armor.clearsign_header;\n\n  Literal = require(\"./packet/literal\").Literal;\n\n  VerifierBase = require('./verifier').Base;\n\n  exports.input_to_cleartext = input_to_cleartext = function(raw) {\n    var lines, ret;\n    lines = raw.split(/\\n/);\n    ret = {\n      show: bufferify(input_to_cleartext_display(lines)),\n      sign: bufferify(input_to_cleartext_sign(lines))\n    };\n    return ret;\n  };\n\n  exports.dash_escape = dash_escape = function(line) {\n    if (line.length >= 1 && line[0] === '-') {\n      return \"- \" + line;\n    } else {\n      return line;\n    }\n  };\n\n  exports.dash_unescape_line = dash_unescape_line = function(line) {\n    var m, out, warn, _ref3;\n    warn = false;\n    out = (m = line.match(/^-( )?(.*?)$/)) != null ? (((_ref3 = m[1]) != null ? _ref3.length : void 0) !== 1 ? warn = true : void 0, m[2]) : line;\n    return [out, warn];\n  };\n\n  exports.dash_unescape_lines = dash_unescape_lines = function(lines, warnings) {\n    var i, l, line, ret, warn;\n    if (warnings == null) {\n      warnings = null;\n    }\n    ret = (function() {\n      var _i, _len, _ref3, _results;\n      _results = [];\n      for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {\n        line = lines[i];\n        _ref3 = dash_unescape_line(line), l = _ref3[0], warn = _ref3[1];\n        if (warn) {\n          if (warnings != null) {\n            warnings.push(\"Bad dash-encoding on line \" + (i + 1));\n          }\n        }\n        _results.push(l);\n      }\n      return _results;\n    })();\n    return ret;\n  };\n\n  exports.input_to_cleartext_display = input_to_cleartext_display = function(lines) {\n    var line, out;\n    out = (function() {\n      var _i, _len, _results;\n      _results = [];\n      for (_i = 0, _len = lines.length; _i < _len; _i++) {\n        line = lines[_i];\n        _results.push(dash_escape(line));\n      }\n      return _results;\n    })();\n    if (lines.length === 0 || lines.slice(-1)[0] !== '') {\n      out.push('');\n    }\n    return out.join(\"\\n\");\n  };\n\n  exports.clearsign_to_sign = clearsign_to_sign = function(lines, warnings) {\n    lines = dash_unescape_lines(lines, warnings);\n    return input_to_cleartext_sign(lines);\n  };\n\n  exports.input_to_cleartext_sign = input_to_cleartext_sign = function(lines) {\n    var line, num_trailing_newlines, t, tmp, _i;\n    tmp = (function() {\n      var _i, _len, _results;\n      _results = [];\n      for (_i = 0, _len = lines.length; _i < _len; _i++) {\n        line = lines[_i];\n        _results.push(whitespace_strip(line));\n      }\n      return _results;\n    })();\n    num_trailing_newlines = 0;\n    for (_i = tmp.length - 1; _i >= 0; _i += -1) {\n      t = tmp[_i];\n      if (t === '') {\n        num_trailing_newlines++;\n      } else {\n        break;\n      }\n    }\n    if (num_trailing_newlines > 0) {\n      tmp.pop();\n    }\n    return tmp.join(\"\\r\\n\");\n  };\n\n  exports.whitespace_strip = whitespace_strip = function(line) {\n    var m;\n    line = line.replace(/\\r/g, '');\n    if ((m = line.match(/^(.*?)([ \\t]*)$/))) {\n      return m[1];\n    } else {\n      return line;\n    }\n  };\n\n  ClearSigner = (function() {\n    function ClearSigner(_arg) {\n      this.msg = _arg.msg, this.signing_key = _arg.signing_key;\n    }\n\n    ClearSigner.prototype._fix_msg = function(cb) {\n      this._cleartext = input_to_cleartext(this.msg.toString('utf8'));\n      return cb(null);\n    };\n\n    ClearSigner.prototype._sign_msg = function(cb) {\n      var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      this.sig = new Signature({\n        sig_type: C.sig_types.canonical_text,\n        key: this.signing_key.key,\n        hashed_subpackets: [new CreationTime(unix_time())],\n        unhashed_subpackets: [new Issuer(this.signing_key.get_key_id())]\n      });\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n            funcname: \"ClearSigner._sign_msg\"\n          });\n          _this.sig.write(_this._cleartext.sign, __iced_deferrals.defer({\n            assign_fn: (function(__slot_1) {\n              return function() {\n                err = arguments[0];\n                return __slot_1._sig_output = arguments[1];\n              };\n            })(_this),\n            lineno: 117\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, _this._sig_output);\n        };\n      })(this));\n    };\n\n    ClearSigner.prototype.scrub = function() {};\n\n    ClearSigner.prototype.hasher_name = function() {\n      return this.sig.hasher.algname;\n    };\n\n    ClearSigner.prototype._encode = function(cb) {\n      var body, hdr;\n      hdr = clearsign_header(Ch, this._cleartext.show, this.hasher_name());\n      body = encode(C.message_types.signature, this._sig_output);\n      return cb(null, hdr + body);\n    };\n\n    ClearSigner.prototype.run = function(cb) {\n      var encoded, esc, signature, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"ClearSigner::run\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n            funcname: \"ClearSigner.run\"\n          });\n          _this._fix_msg(esc(__iced_deferrals.defer({\n            lineno: 139\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n              funcname: \"ClearSigner.run\"\n            });\n            _this._sign_msg(esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return signature = arguments[0];\n                };\n              })(),\n              lineno: 140\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n                funcname: \"ClearSigner.run\"\n              });\n              _this._encode(esc(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return encoded = arguments[0];\n                  };\n                })(),\n                lineno: 141\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return cb(null, encoded, signature);\n            });\n          });\n        };\n      })(this));\n    };\n\n    return ClearSigner;\n\n  })();\n\n  Verifier = (function(_super) {\n    __extends(Verifier, _super);\n\n    function Verifier(_arg) {\n      var keyfetch, packets;\n      packets = _arg.packets, this.clearsign = _arg.clearsign, keyfetch = _arg.keyfetch;\n      Verifier.__super__.constructor.call(this, {\n        packets: packets,\n        keyfetch: keyfetch\n      });\n    }\n\n    Verifier.prototype._reformat_text = function(cb) {\n      var data;\n      data = bufferify(clearsign_to_sign(this.clearsign.lines));\n      this._literal = new Literal({\n        data: data,\n        format: C.literal_formats.utf8,\n        date: unix_time()\n      });\n      return cb(null);\n    };\n\n    Verifier.prototype._make_hasher = function(cb) {\n      var err, h;\n      err = null;\n      h = this.clearsign.headers.hash || 'MD5';\n      if ((this._sig.hasher = hashmod[h]) == null) {\n        err = new Error(\"Unknown hash algorithm: \" + h);\n      }\n      return cb(err);\n    };\n\n    Verifier.prototype._verify = function(cb) {\n      var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n            funcname: \"Verifier._verify\"\n          });\n          _this._sig.verify([_this._literal], __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 182\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    Verifier.prototype._check_headers = function(cb) {\n      var err, k, v, _ref3;\n      err = null;\n      _ref3 = this.clearsign.headers;\n      for (k in _ref3) {\n        v = _ref3[k];\n        if (k !== 'hash') {\n          err = new Error(\"Unallowed header: \" + k);\n          break;\n        }\n      }\n      return cb(err);\n    };\n\n    Verifier.prototype.run = function(cb) {\n      var esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Verifier::run\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n            funcname: \"Verifier.run\"\n          });\n          _this._check_headers(esc(__iced_deferrals.defer({\n            lineno: 199\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n              funcname: \"Verifier.run\"\n            });\n            _this._find_signature(esc(__iced_deferrals.defer({\n              lineno: 200\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n                funcname: \"Verifier.run\"\n              });\n              _this._reformat_text(esc(__iced_deferrals.defer({\n                lineno: 201\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n                  funcname: \"Verifier.run\"\n                });\n                _this._fetch_key(esc(__iced_deferrals.defer({\n                  lineno: 202\n                })));\n                __iced_deferrals._fulfill();\n              })(function() {\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/home/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n                    funcname: \"Verifier.run\"\n                  });\n                  _this._make_hasher(esc(__iced_deferrals.defer({\n                    lineno: 203\n                  })));\n                  __iced_deferrals._fulfill();\n                })(function() {\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/home/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n                      funcname: \"Verifier.run\"\n                    });\n                    _this._verify(esc(__iced_deferrals.defer({\n                      lineno: 204\n                    })));\n                    __iced_deferrals._fulfill();\n                  })(function() {\n                    return cb(null, _this._literal);\n                  });\n                });\n              });\n            });\n          });\n        };\n      })(this));\n    };\n\n    return Verifier;\n\n  })(VerifierBase);\n\n  exports.sign = function(_arg, cb) {\n    var b, encoded, err, msg, signature, signing_key, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    msg = _arg.msg, signing_key = _arg.signing_key;\n    b = new ClearSigner({\n      msg: msg,\n      signing_key: signing_key\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/home/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n          funcname: \"sign\"\n        });\n        b.run(__iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              err = arguments[0];\n              encoded = arguments[1];\n              return signature = arguments[2];\n            };\n          })(),\n          lineno: 215\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        b.scrub();\n        return cb(err, encoded, signature);\n      };\n    })(this));\n  };\n\n  exports.verify = function(_arg, cb) {\n    var clearsign, err, keyfetch, literal, packets, v, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    packets = _arg.packets, clearsign = _arg.clearsign, keyfetch = _arg.keyfetch;\n    v = new Verifier({\n      packets: packets,\n      clearsign: clearsign,\n      keyfetch: keyfetch\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/home/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n          funcname: \"verify\"\n        });\n        v.run(__iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              err = arguments[0];\n              return literal = arguments[1];\n            };\n          })(),\n          lineno: 223\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(err, literal);\n      };\n    })(this));\n  };\n\n}).call(this);\n\n},{\"../const\":5,\"../hash\":14,\"../header\":15,\"../rand\":65,\"../symmetric\":68,\"../util\":70,\"./armor\":33,\"./packet/literal\":49,\"./packet/signature\":53,\"./verifier\":61,\"iced-error\":115,\"iced-runtime\":118,\"pgp-utils\":163,\"triplesec\":181}],40:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, Ch, CreationTime, Issuer, Literal, Signature, Signer, Verifier, VerifierBase, WordArray, encode, hash_obj_to_fn, iced, konst, make_esc, packetsigs, streamers, unix_time, __iced_k, __iced_k_noop, _ref,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  make_esc = require('iced-error').make_esc;\n\n  _ref = require('./packet/signature'), Signature = _ref.Signature, CreationTime = _ref.CreationTime, Issuer = _ref.Issuer;\n\n  unix_time = require('../util').unix_time;\n\n  WordArray = require('triplesec').WordArray;\n\n  konst = require('../const');\n\n  C = konst.openpgp;\n\n  Ch = require('../header');\n\n  streamers = require('../hash').streamers;\n\n  encode = require('./armor').encode;\n\n  Literal = require(\"./packet/literal\").Literal;\n\n  VerifierBase = require('./verifier').Base;\n\n  packetsigs = require('./packet/packetsigs');\n\n  hash_obj_to_fn = function(obj) {\n    var fn;\n    fn = function(buf) {\n      return obj.finalize(WordArray.from_buffer(buf)).to_buffer();\n    };\n    return fn.algname = buf.algname;\n  };\n\n  Signer = (function() {\n    function Signer(_arg) {\n      this.data = _arg.data, this.hash_streamer = _arg.hash_streamer, this.signing_key = _arg.signing_key;\n    }\n\n    Signer.prototype.run = function(cb) {\n      var encoded, esc, signature, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Signer::run\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n            funcname: \"Signer.run\"\n          });\n          _this._run_hash(esc(__iced_deferrals.defer({\n            lineno: 39\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n              funcname: \"Signer.run\"\n            });\n            _this._sign(esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return signature = arguments[0];\n                };\n              })(),\n              lineno: 40\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n                funcname: \"Signer.run\"\n              });\n              _this._encode(esc(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return encoded = arguments[0];\n                  };\n                })(),\n                lineno: 41\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return cb(null, encoded, signature);\n            });\n          });\n        };\n      })(this));\n    };\n\n    Signer.prototype.scrub = function() {};\n\n    Signer.prototype._sign = function(cb) {\n      var emptybuf, err, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      this.sig = new Signature({\n        sig_type: C.sig_types.canonical_text,\n        key: this.signing_key.key,\n        hashed_subpackets: [new CreationTime(unix_time())],\n        unhashed_subpackets: [new Issuer(this.signing_key.get_key_id())],\n        hasher: this.hash_streamer\n      });\n      emptybuf = new Buffer([]);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n            funcname: \"Signer._sign\"\n          });\n          _this.sig.write(emptybuf, __iced_deferrals.defer({\n            assign_fn: (function(__slot_1) {\n              return function() {\n                err = arguments[0];\n                return __slot_1._sig_output = arguments[1];\n              };\n            })(_this),\n            lineno: 60\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, _this._sig_output);\n        };\n      })(this));\n    };\n\n    Signer.prototype._encode = function(cb) {\n      var err, ret;\n      err = null;\n      ret = encode(C.message_types.signature, this._sig_output);\n      return cb(err, ret);\n    };\n\n    Signer.prototype._run_hash = function(cb) {\n      var err;\n      err = null;\n      if (this.hash_streamer != null) {\n\n      } else if (this.data != null) {\n        this.hash_streamer = streamers.SHA512();\n        this.hash_streamer.update(this.data);\n      } else {\n        err = new Error(\"Need either a hasher or data\");\n      }\n      return cb(err);\n    };\n\n    return Signer;\n\n  })();\n\n  Verifier = (function(_super) {\n    __extends(Verifier, _super);\n\n    function Verifier(_arg) {\n      var keyfetch, packets;\n      packets = _arg.packets, this.data = _arg.data, this.data_fn = _arg.data_fn, keyfetch = _arg.keyfetch;\n      Verifier.__super__.constructor.call(this, {\n        packets: packets,\n        keyfetch: keyfetch\n      });\n    }\n\n    Verifier.prototype._consume_data = function(cb) {\n      var buf_hasher, done, err, go, klass, streamer, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (_this.data_fn != null) {\n            err = null;\n            klass = _this._sig.hasher.klass;\n            streamer = streamers[_this._sig.hasher.algname]();\n            buf_hasher = function(buf) {\n              return streamer.update(buf);\n            };\n            go = true;\n            (function(__iced_k) {\n              var _results, _while;\n              _results = [];\n              _while = function(__iced_k) {\n                var _break, _continue, _next;\n                _break = function() {\n                  return __iced_k(_results);\n                };\n                _continue = function() {\n                  return iced.trampoline(function() {\n                    return _while(__iced_k);\n                  });\n                };\n                _next = function(__iced_next_arg) {\n                  _results.push(__iced_next_arg);\n                  return _continue();\n                };\n                if (!go) {\n                  return _break();\n                } else {\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n                      funcname: \"Verifier._consume_data\"\n                    });\n                    _this.data_fn(buf_hasher, __iced_deferrals.defer({\n                      assign_fn: (function() {\n                        return function() {\n                          err = arguments[0];\n                          return done = arguments[1];\n                        };\n                      })(),\n                      lineno: 102\n                    }));\n                    __iced_deferrals._fulfill();\n                  })(function() {\n                    return _next((err != null) || done ? go = false : void 0);\n                  });\n                }\n              };\n              _while(__iced_k);\n            })(function() {\n              return __iced_k(_this._sig.hasher = streamer);\n            });\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    Verifier.prototype._verify = function(cb) {\n      var data, err, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      data = this.data ? [\n        new Literal({\n          data: this.data\n        })\n      ] : [];\n      this.literals = data;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n            funcname: \"Verifier._verify\"\n          });\n          _this._sig.verify(data, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 113\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    Verifier.prototype._make_literals = function(cb) {\n      if (!this.literals.length) {\n        this.literals.push(new Literal({\n          data: new Buffer([])\n        }));\n      }\n      this.literals[0].push_sig(new packetsigs.Data({\n        sig: this._sig\n      }));\n      return cb(null);\n    };\n\n    Verifier.prototype.run = function(cb) {\n      var esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Verifier::run\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n            funcname: \"Verifier.run\"\n          });\n          _this._find_signature(esc(__iced_deferrals.defer({\n            lineno: 128\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n              funcname: \"Verifier.run\"\n            });\n            _this._fetch_key(esc(__iced_deferrals.defer({\n              lineno: 129\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n                funcname: \"Verifier.run\"\n              });\n              _this._consume_data(esc(__iced_deferrals.defer({\n                lineno: 130\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n                  funcname: \"Verifier.run\"\n                });\n                _this._verify(esc(__iced_deferrals.defer({\n                  lineno: 131\n                })));\n                __iced_deferrals._fulfill();\n              })(function() {\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n                    funcname: \"Verifier.run\"\n                  });\n                  _this._make_literals(esc(__iced_deferrals.defer({\n                    lineno: 132\n                  })));\n                  __iced_deferrals._fulfill();\n                })(function() {\n                  return cb(null, _this.literals);\n                });\n              });\n            });\n          });\n        };\n      })(this));\n    };\n\n    return Verifier;\n\n  })(VerifierBase);\n\n  exports.sign = function(_arg, cb) {\n    var data, encoded, err, hash_streamer, s, signature, signing_key, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    data = _arg.data, hash_streamer = _arg.hash_streamer, signing_key = _arg.signing_key;\n    s = new Signer({\n      data: data,\n      hash_streamer: hash_streamer,\n      signing_key: signing_key\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n          funcname: \"sign\"\n        });\n        s.run(__iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              err = arguments[0];\n              encoded = arguments[1];\n              return signature = arguments[2];\n            };\n          })(),\n          lineno: 139\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        s.scrub();\n        return cb(err, encoded, signature);\n      };\n    })(this));\n  };\n\n  exports.verify = function(_arg, cb) {\n    var data, data_fn, err, keyfetch, literals, packets, v, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    data = _arg.data, data_fn = _arg.data_fn, packets = _arg.packets, keyfetch = _arg.keyfetch;\n    v = new Verifier({\n      data: data,\n      data_fn: data_fn,\n      packets: packets,\n      keyfetch: keyfetch\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n          funcname: \"verify\"\n        });\n        v.run(__iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              err = arguments[0];\n              return literals = arguments[1];\n            };\n          })(),\n          lineno: 147\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(err, literals);\n      };\n    })(this));\n  };\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../const\":5,\"../hash\":14,\"../header\":15,\"../util\":70,\"./armor\":33,\"./packet/literal\":49,\"./packet/packetsigs\":51,\"./packet/signature\":53,\"./verifier\":61,\"buffer\":80,\"iced-error\":115,\"iced-runtime\":118,\"triplesec\":181}],41:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var SignatureEngine, burn, processor;\n\n  burn = require('./burner').burn;\n\n  processor = require('./processor');\n\n  SignatureEngine = require('./sigeng').SignatureEngine;\n\n  exports.box = burn;\n\n  exports.unbox = processor.do_message;\n\n}).call(this);\n\n},{\"./burner\":36,\"./processor\":57,\"./sigeng\":59}],42:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var ASP, C, ECDSA, Encryptor, Engine, K, KeyBlock, KeyFetched, KeyFetcher, KeyManager, KeyManagerInterface, Lifespan, Message, P3SKB, PgpEngine, Primary, RSA, SignatureEngine, Subkey, assert_no_nulls, athrow, bufeq_secure, bufferify, decode, encode, format_pgp_fingerprint_2, iced, katch, make_esc, opkts, ops_to_keyflags, parse, read_base64, unix_time, unseal, __iced_k, __iced_k_noop, _ref, _ref1, _ref2, _ref3, _ref4,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    __slice = [].slice;\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  RSA = require('../rsa').RSA;\n\n  ECDSA = require('../ecc/ecdsa').ECDSA;\n\n  K = require('../const').kb;\n\n  C = require('../const').openpgp;\n\n  make_esc = require('iced-error').make_esc;\n\n  _ref = require('../util'), format_pgp_fingerprint_2 = _ref.format_pgp_fingerprint_2, athrow = _ref.athrow, assert_no_nulls = _ref.assert_no_nulls, ASP = _ref.ASP, katch = _ref.katch, bufeq_secure = _ref.bufeq_secure, unix_time = _ref.unix_time, bufferify = _ref.bufferify;\n\n  ops_to_keyflags = require('./util').ops_to_keyflags;\n\n  _ref1 = require('../keywrapper'), Lifespan = _ref1.Lifespan, Subkey = _ref1.Subkey, Primary = _ref1.Primary;\n\n  _ref2 = require('./armor'), Message = _ref2.Message, encode = _ref2.encode, decode = _ref2.decode;\n\n  parse = require('./parser').parse;\n\n  KeyBlock = require('./processor').KeyBlock;\n\n  opkts = require('./packet/all');\n\n  _ref3 = require('../keybase/encode'), read_base64 = _ref3.read_base64, unseal = _ref3.unseal;\n\n  P3SKB = require('../keybase/packet/p3skb').P3SKB;\n\n  _ref4 = require('../keyfetch'), KeyFetcher = _ref4.KeyFetcher, KeyFetched = _ref4.KeyFetched;\n\n  SignatureEngine = require('./sigeng').SignatureEngine;\n\n  Encryptor = require('triplesec').Encryptor;\n\n  KeyManagerInterface = require('../kmi').KeyManagerInterface;\n\n  Engine = (function() {\n    function Engine(_arg) {\n      var k, _i, _len, _ref5;\n      this.primary = _arg.primary, this.subkeys = _arg.subkeys, this.userids = _arg.userids, this.key_manager = _arg.key_manager;\n      this.packets = [];\n      this.messages = [];\n      this._allocate_key_packets();\n      _ref5 = this.subkeys;\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        k = _ref5[_i];\n        k.primary = this.primary;\n      }\n      this._index_keys();\n      true;\n    }\n\n    Engine.prototype._index_keys = function() {\n      var k, _i, _len, _ref5, _results;\n      this._index = {};\n      _ref5 = this._all_keys();\n      _results = [];\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        k = _ref5[_i];\n        _results.push(this._index[this.ekid(k)] = k);\n      }\n      return _results;\n    };\n\n    Engine.prototype.ekid = function(k) {\n      return this.key(k).ekid();\n    };\n\n    Engine.prototype._allocate_key_packets = function() {\n      var key, _i, _len, _ref5, _results;\n      this._v_allocate_key_packet(this.primary, {\n        subkey: false\n      });\n      _ref5 = this.subkeys;\n      _results = [];\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        key = _ref5[_i];\n        _results.push(this._v_allocate_key_packet(key, {\n          subkey: true\n        }));\n      }\n      return _results;\n    };\n\n    Engine.prototype._all_keys = function() {\n      return [this.primary].concat(this.subkeys);\n    };\n\n    Engine.prototype.self_sign_primary = function(args, cb) {\n      return this._v_self_sign_primary(args, cb);\n    };\n\n    Engine.prototype.get_all_key_materials = function() {\n      var k;\n      return [[this.key(this.primary), true]].concat((function() {\n        var _i, _len, _ref5, _results;\n        _ref5 = this.subkeys;\n        _results = [];\n        for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n          k = _ref5[_i];\n          _results.push([this.key(k), false]);\n        }\n        return _results;\n      }).call(this));\n    };\n\n    Engine.prototype.sign_subkeys = function(_arg, cb) {\n      var asp, err, subkey, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      asp = _arg.asp;\n      err = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _len, _ref5, _results, _while;\n          _ref5 = _this.subkeys;\n          _len = _ref5.length;\n          _i = 0;\n          _results = [];\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = function() {\n              return __iced_k(_results);\n            };\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++_i;\n                return _while(__iced_k);\n              });\n            };\n            _next = function(__iced_next_arg) {\n              _results.push(__iced_next_arg);\n              return _continue();\n            };\n            if (!(_i < _len)) {\n              return _break();\n            } else {\n              subkey = _ref5[_i];\n              if (err == null) {\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n                    funcname: \"Engine.sign_subkeys\"\n                  });\n                  _this._v_sign_subkey({\n                    asp: asp,\n                    subkey: subkey\n                  }, __iced_deferrals.defer({\n                    assign_fn: (function() {\n                      return function() {\n                        return err = arguments[0];\n                      };\n                    })(),\n                    lineno: 73\n                  }));\n                  __iced_deferrals._fulfill();\n                })(_next);\n              } else {\n                return _continue();\n              }\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    Engine.prototype.get_subkey_materials = function() {\n      var k, _i, _len, _ref5, _results;\n      _ref5 = this.subkeys;\n      _results = [];\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        k = _ref5[_i];\n        _results.push(this.key(k));\n      }\n      return _results;\n    };\n\n    Engine.prototype.is_locked = function() {\n      var i, k, _i, _len, _ref5;\n      _ref5 = this._all_keys();\n      for (i = _i = 0, _len = _ref5.length; _i < _len; i = ++_i) {\n        k = _ref5[i];\n        if (this.key(k).is_locked()) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    Engine.prototype.has_private = function() {\n      var k, _i, _len, _ref5;\n      _ref5 = this._all_keys();\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        k = _ref5[_i];\n        if (this.key(k).has_private()) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    Engine.prototype.sign = function(_arg, cb) {\n      var asp, err, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      asp = _arg.asp;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"Engine.sign\"\n          });\n          _this.self_sign_primary({\n            asp: asp\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 97\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            if (typeof err === \"undefined\" || err === null) {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n                  funcname: \"Engine.sign\"\n                });\n                _this.sign_subkeys({\n                  asp: asp\n                }, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return err = arguments[0];\n                    };\n                  })(),\n                  lineno: 98\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            return cb(err);\n          });\n        };\n      })(this));\n    };\n\n    Engine.prototype.check_eq = function(eng2) {\n      var err, i, key, _i, _len, _ref5;\n      err = null;\n      if (!this.primary.key.eq(eng2.primary.key)) {\n        err = new Error(\"Primary keys don't match\");\n      } else if (this.subkeys.length !== eng2.subkeys.length) {\n        err = new Error(\"different # of subkeys\");\n      } else {\n        _ref5 = this.subkeys;\n        for (i = _i = 0, _len = _ref5.length; _i < _len; i = ++_i) {\n          key = _ref5[i];\n          if (this.err == null) {\n            if (!key.key.eq(eng2.subkeys[i].key)) {\n              err = new Error(\"subkey \" + i + \" doesn't match\");\n            }\n          }\n        }\n      }\n      return err;\n    };\n\n    Engine.prototype.merge_private = function(eng2) {\n      var err, i, k, _i, _len, _ref5;\n      err = this._merge_private_primary(eng2);\n      if (err == null) {\n        _ref5 = eng2.subkeys;\n        for (i = _i = 0, _len = _ref5.length; _i < _len; i = ++_i) {\n          k = _ref5[i];\n          if ((err = this._merge_private_subkey(k, i)) != null) {\n            break;\n          }\n        }\n      }\n      return err;\n    };\n\n    Engine.prototype._merge_private_primary = function(eng2) {\n      var err;\n      err = !this.key(eng2.primary).has_secret_key_material() ? null : this._merge_1_private(this.primary, eng2.primary) ? null : new Error(\"primary public key doesn't match private key\");\n      return err;\n    };\n\n    Engine.prototype._merge_private_subkey = function(k2, i) {\n      var ekid, err, k;\n      err = !this.key(k2).has_secret_key_material() ? null : (ekid = this.ekid(k2)) == null ? new Error(\"Subkey \" + i + \" is malformed\") : (k = this._index[ekid]) == null ? new Error(\"Subkey \" + i + \" wasn't found in public key\") : this._merge_1_private(k, k2) ? null : new Error(\"subkey \" + i + \" can't be merged\");\n      return err;\n    };\n\n    Engine.prototype.unlock_keys = function(_arg, cb) {\n      var asp, esc, i, passphrase, subkey, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      asp = _arg.asp, passphrase = _arg.passphrase, tsenc = _arg.tsenc;\n      esc = make_esc(cb, \"Engine::unlock_keys\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"Engine.unlock_keys\"\n          });\n          _this.key(_this.primary).unlock({\n            asp: asp,\n            tsenc: tsenc,\n            passphrase: passphrase\n          }, esc(__iced_deferrals.defer({\n            lineno: 146\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            var _i, _len, _ref5, _results, _while;\n            _ref5 = _this.subkeys;\n            _len = _ref5.length;\n            i = 0;\n            _results = [];\n            _while = function(__iced_k) {\n              var _break, _continue, _next;\n              _break = function() {\n                return __iced_k(_results);\n              };\n              _continue = function() {\n                return iced.trampoline(function() {\n                  ++i;\n                  return _while(__iced_k);\n                });\n              };\n              _next = function(__iced_next_arg) {\n                _results.push(__iced_next_arg);\n                return _continue();\n              };\n              if (!(i < _len)) {\n                return _break();\n              } else {\n                subkey = _ref5[i];\n                if (_this.key(subkey).has_private()) {\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n                      funcname: \"Engine.unlock_keys\"\n                    });\n                    _this.key(subkey).unlock({\n                      asp: asp,\n                      tsenc: tsenc,\n                      passphrase: passphrase\n                    }, esc(__iced_deferrals.defer({\n                      lineno: 148\n                    })));\n                    __iced_deferrals._fulfill();\n                  })(_next);\n                } else {\n                  return _continue();\n                }\n              }\n            };\n            _while(__iced_k);\n          })(function() {\n            return cb(null);\n          });\n        };\n      })(this));\n    };\n\n    Engine.prototype.export_keys_to_keyring = function(km) {\n      var k, x;\n      x = (function(_this) {\n        return function(key_wrapper, is_primary) {\n          return {\n            km: km,\n            is_primary: is_primary,\n            key_wrapper: key_wrapper,\n            key_material: _this.key(key_wrapper),\n            key: _this.key(key_wrapper).key\n          };\n        };\n      })(this);\n      return [x(this.primary, true)].concat((function() {\n        var _i, _len, _ref5, _results;\n        _ref5 = this.subkeys;\n        _results = [];\n        for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n          k = _ref5[_i];\n          _results.push(x(k, false));\n        }\n        return _results;\n      }).call(this));\n    };\n\n    Engine.prototype._merge_1_private = function(k1, k2) {\n      if (bufeq_secure(this.ekid(k1), this.ekid(k2))) {\n        this.key(k1).merge_private(this.key(k2));\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    return Engine;\n\n  })();\n\n  PgpEngine = (function(_super) {\n    __extends(PgpEngine, _super);\n\n    function PgpEngine(_arg) {\n      var key_manager, primary, subkeys, userids;\n      primary = _arg.primary, subkeys = _arg.subkeys, userids = _arg.userids, this.user_attributes = _arg.user_attributes, key_manager = _arg.key_manager;\n      PgpEngine.__super__.constructor.call(this, {\n        primary: primary,\n        subkeys: subkeys,\n        userids: userids,\n        key_manager: key_manager\n      });\n    }\n\n    PgpEngine.prototype.key = function(k) {\n      return k._pgp;\n    };\n\n    PgpEngine.prototype._v_allocate_key_packet = function(key, opts) {\n      if (key._pgp == null) {\n        return key._pgp = new opkts.KeyMaterial({\n          key: key.key,\n          timestamp: key.lifespan.generated,\n          flags: key.flags,\n          opts: opts\n        });\n      }\n    };\n\n    PgpEngine.prototype._v_self_sign_primary = function(_arg, cb) {\n      var asp, err, raw_payload, sigs, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      asp = _arg.asp, raw_payload = _arg.raw_payload;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"PgpEngine._v_self_sign_primary\"\n          });\n          _this.key(_this.primary).self_sign_key({\n            lifespan: _this.primary.lifespan,\n            userids: _this.userids,\n            raw_payload: raw_payload\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return sigs = arguments[1];\n              };\n            })(),\n            lineno: 198\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, sigs);\n        };\n      })(this));\n    };\n\n    PgpEngine.prototype._v_sign_subkey = function(_arg, cb) {\n      var asp, err, subkey, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      asp = _arg.asp, subkey = _arg.subkey;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"PgpEngine._v_sign_subkey\"\n          });\n          _this.key(_this.primary).sign_subkey({\n            subkey: _this.key(subkey),\n            lifespan: subkey.lifespan\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 204\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    PgpEngine.prototype.set_passphrase = function(pp) {\n      var k, _i, _len, _ref5, _results;\n      this.primary.passphrase = pp;\n      _ref5 = this.subkeys;\n      _results = [];\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        k = _ref5[_i];\n        _results.push(k.passphrase = pp);\n      }\n      return _results;\n    };\n\n    PgpEngine.prototype._export_keys_to_binary = function(opts) {\n      var packets, subkey, userid, _i, _j, _len, _len1, _ref5, _ref6;\n      packets = [this.key(this.primary).export_framed(opts)];\n      _ref5 = this.userids;\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        userid = _ref5[_i];\n        packets.push(userid.write(), userid.get_framed_signature_output());\n      }\n      opts.subkey = true;\n      _ref6 = this.subkeys;\n      for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {\n        subkey = _ref6[_j];\n        packets.push(this.key(subkey).export_framed(opts), this.key(subkey).get_subkey_binding_signature_output());\n      }\n      assert_no_nulls(packets);\n      return Buffer.concat(packets);\n    };\n\n    PgpEngine.prototype.export_keys = function(opts) {\n      var msg, mt, type;\n      mt = C.message_types;\n      type = opts[\"private\"] ? mt.private_key : mt.public_key;\n      msg = this._export_keys_to_binary(opts);\n      return encode(type, msg);\n    };\n\n    PgpEngine.prototype.export_to_p3skb = function() {\n      var priv_clear, pub;\n      pub = this._export_keys_to_binary({\n        \"private\": false\n      });\n      priv_clear = this._export_keys_to_binary({\n        \"private\": true\n      });\n      return new P3SKB({\n        pub: pub,\n        priv_clear: priv_clear\n      });\n    };\n\n    PgpEngine.prototype.find_key = function(key_id) {\n      var k, _i, _len, _ref5;\n      _ref5 = this._all_keys();\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        k = _ref5[_i];\n        if (bufeq_secure(this.key(k).get_key_id(), key_id)) {\n          return k;\n        }\n      }\n      return null;\n    };\n\n    PgpEngine.prototype.find_key_material = function(key_id) {\n      var key;\n      key = this.find_key(key_id);\n      if (key != null) {\n        return this.key(key);\n      } else {\n        return null;\n      }\n    };\n\n    PgpEngine.prototype.get_key_id = function() {\n      return this.key(this.primary).get_key_id();\n    };\n\n    PgpEngine.prototype.get_short_key_id = function() {\n      return this.key(this.primary).get_short_key_id();\n    };\n\n    PgpEngine.prototype.get_fingerprint = function() {\n      return this.key(this.primary).get_fingerprint();\n    };\n\n    PgpEngine.prototype.get_ekid = function() {\n      return this.key(this.primary).ekid();\n    };\n\n    PgpEngine.prototype.get_all_key_ids = function() {\n      var k, _i, _len, _ref5, _results;\n      _ref5 = this._all_keys();\n      _results = [];\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        k = _ref5[_i];\n        _results.push(this.key(k).get_key_id());\n      }\n      return _results;\n    };\n\n    PgpEngine.prototype.validity_check = function(cb) {\n      var err, k, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _len, _ref5, _results, _while;\n          _ref5 = _this._all_keys();\n          _len = _ref5.length;\n          _i = 0;\n          _results = [];\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = function() {\n              return __iced_k(_results);\n            };\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++_i;\n                return _while(__iced_k);\n              });\n            };\n            _next = function(__iced_next_arg) {\n              _results.push(__iced_next_arg);\n              return _continue();\n            };\n            if (!(_i < _len)) {\n              return _break();\n            } else {\n              k = _ref5[_i];\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n                  funcname: \"PgpEngine.validity_check\"\n                });\n                _this.key(k).validity_check(__iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return err = arguments[0];\n                    };\n                  })(),\n                  lineno: 267\n                }));\n                __iced_deferrals._fulfill();\n              })(function() {\n                (function(__iced_k) {\n                  if (err != null) {\n                    (function(__iced_k) {\n_break()\n                    })(__iced_k);\n                  } else {\n                    return __iced_k();\n                  }\n                })(_next);\n              });\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    PgpEngine.prototype.find_best_key = function(flags, need_priv) {\n      var check, k, wrapper, _i, _len, _ref5;\n      if (need_priv == null) {\n        need_priv = false;\n      }\n      wrapper = null;\n      check = (function(_this) {\n        return function(k) {\n          var km, ok1, ok2;\n          km = _this.key(k);\n          ok1 = km.fulfills_flags(flags) || ((k.flags & flags) === flags);\n          ok2 = !need_priv || km.has_private();\n          return ok1 && ok2;\n        };\n      })(this);\n      _ref5 = this.subkeys;\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        k = _ref5[_i];\n        if (wrapper == null) {\n          if (check(k)) {\n            wrapper = k;\n          }\n        }\n      }\n      if ((wrapper == null) && check(this.primary)) {\n        wrapper = this.primary;\n      }\n      return (wrapper != null ? this.key(wrapper) : null);\n    };\n\n    PgpEngine.prototype.fetch = function(key_ids, op_mask, cb) {\n      var err, flags, i, key, kid, ret, ret_i, _i, _len;\n      flags = ops_to_keyflags(op_mask);\n      err = key = ret = null;\n      key = null;\n      ret_i = null;\n      for (i = _i = 0, _len = key_ids.length; _i < _len; i = ++_i) {\n        kid = key_ids[i];\n        if (!(key == null)) {\n          continue;\n        }\n        key = this.find_key(kid);\n        if (key != null) {\n          ret_i = i;\n        }\n      }\n      if (key == null) {\n        err = new Error(\"No keys match the given fingerprint\");\n      } else if (!this.key(key).fulfills_flags(flags)) {\n        err = new Error(\"We don't have a key for the requested PGP ops (flags = \" + flags + \")\");\n      } else {\n        ret = this.key(key);\n      }\n      return cb(err, this.key_manager, ret_i);\n    };\n\n    return PgpEngine;\n\n  })(Engine);\n\n  KeyManager = (function(_super) {\n    __extends(KeyManager, _super);\n\n    function KeyManager(_arg) {\n      this.primary = _arg.primary, this.subkeys = _arg.subkeys, this.userids = _arg.userids, this.armored_pgp_public = _arg.armored_pgp_public, this.armored_pgp_private = _arg.armored_pgp_private, this.user_attributes = _arg.user_attributes;\n      this.pgp = new PgpEngine({\n        primary: this.primary,\n        subkeys: this.subkeys,\n        userids: this.userids,\n        user_attributes: this.user_attributes,\n        key_manager: this\n      });\n      this.engines = [this.pgp];\n      this._signed = false;\n      this.p3skb = null;\n    }\n\n    KeyManager.generate = function(_arg, cb) {\n      var F, KEY_FLAGS_PRIMARY, KEY_FLAGS_STD, asp, bundle, ecc, err, esc, expire_in, flags, gen, generated, i, nbits, nsubs, primary, primary_flags, s, sub_flags, subkey, subkeys, subkeys_out, u, userid, userids, ___iced_passed_deferral, __iced_deferrals, __iced_k, _i, _len;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      asp = _arg.asp, userid = _arg.userid, userids = _arg.userids, primary = _arg.primary, subkeys = _arg.subkeys, ecc = _arg.ecc, sub_flags = _arg.sub_flags, nsubs = _arg.nsubs, primary_flags = _arg.primary_flags, nbits = _arg.nbits, expire_in = _arg.expire_in;\n      asp = ASP.make(asp);\n      F = C.key_flags;\n      KEY_FLAGS_STD = F.sign_data | F.encrypt_comm | F.encrypt_storage | F.auth;\n      KEY_FLAGS_PRIMARY = KEY_FLAGS_STD | F.certify_keys;\n      primary || (primary = {});\n      primary.flags || (primary.flags = primary_flags || KEY_FLAGS_PRIMARY);\n      primary.expire_in || (primary.expire_in = (expire_in != null ? expire_in.primary : void 0) || K.key_defaults.primary.expire_in);\n      primary.algo || (primary.algo = (ecc ? ECDSA : RSA));\n      primary.nbits || (primary.nbits = nbits || K.key_defaults.primary.nbits[primary.algo.klass_name]);\n      if ((nsubs != null) && (sub_flags == null)) {\n        sub_flags = (function() {\n          var _i, _results;\n          _results = [];\n          for (i = _i = 0; 0 <= nsubs ? _i < nsubs : _i > nsubs; i = 0 <= nsubs ? ++_i : --_i) {\n            _results.push(KEY_FLAGS_STD);\n          }\n          return _results;\n        })();\n      }\n      subkeys || (subkeys = (function() {\n        var _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = sub_flags.length; _i < _len; _i++) {\n          flags = sub_flags[_i];\n          _results.push({\n            flags: flags\n          });\n        }\n        return _results;\n      })());\n      for (_i = 0, _len = subkeys.length; _i < _len; _i++) {\n        subkey = subkeys[_i];\n        subkey.expire_in || (subkey.expire_in = (expire_in != null ? expire_in.subkey : void 0) || K.key_defaults.sub.expire_in);\n        subkey.flags || (subkey.flags = KEY_FLAGS_STD);\n        subkey.algo || (subkey.algo = primary.algo.subkey_algo(subkey.flags));\n        subkey.nbits || (subkey.nbits = nbits || K.key_defaults.sub.nbits[subkey.algo.klass_name]);\n      }\n      generated = unix_time();\n      esc = make_esc(cb, \"KeyManager::generate\");\n      if (userid != null) {\n        userids = [userid];\n      }\n      (function(_this) {\n        return (function(__iced_k) {\n          if ((userids != null) && Array.isArray(userids)) {\n            return __iced_k(userids = (function() {\n              var _j, _len1, _results;\n              _results = [];\n              for (_j = 0, _len1 = userids.length; _j < _len1; _j++) {\n                u = userids[_j];\n                _results.push(new opkts.UserID(u));\n              }\n              return _results;\n            })());\n          } else {\n            err = new Error(\"Need either 'userid' or 'userids' specified as an array\");\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n                funcname: \"KeyManager.generate\"\n              });\n              athrow(err, esc(__iced_deferrals.defer({\n                lineno: 391\n              })));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          gen = function(_arg1, cb) {\n            var err, key, klass, lifespan, params, primary, section, wrapper, ___iced_passed_deferral1, __iced_deferrals, __iced_k;\n            __iced_k = __iced_k_noop;\n            ___iced_passed_deferral1 = iced.findDeferral(arguments);\n            klass = _arg1.klass, section = _arg1.section, params = _arg1.params, primary = _arg1.primary;\n            asp.section(section);\n            (function(_this) {\n              return (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral1,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\"\n                });\n                params.algo.generate({\n                  asp: asp,\n                  nbits: params.nbits\n                }, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return key = arguments[1];\n                    };\n                  })(),\n                  lineno: 395\n                }));\n                __iced_deferrals._fulfill();\n              });\n            })(this)((function(_this) {\n              return function() {\n                if (typeof err === \"undefined\" || err === null) {\n                  lifespan = new Lifespan({\n                    generated: generated,\n                    expire_in: params.expire_in\n                  });\n                  wrapper = new klass({\n                    key: key,\n                    lifespan: lifespan,\n                    flags: params.flags,\n                    primary: primary\n                  });\n                }\n                return cb(err, wrapper);\n              };\n            })(this));\n          };\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n              funcname: \"KeyManager.generate\"\n            });\n            gen({\n              klass: Primary,\n              section: \"primary\",\n              params: primary\n            }, esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return primary = arguments[0];\n                };\n              })(),\n              lineno: 401\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            subkeys_out = [];\n            (function(__iced_k) {\n              var _j, _len1, _ref5, _results, _while;\n              _ref5 = subkeys;\n              _len1 = _ref5.length;\n              i = 0;\n              _results = [];\n              _while = function(__iced_k) {\n                var _break, _continue, _next;\n                _break = function() {\n                  return __iced_k(_results);\n                };\n                _continue = function() {\n                  return iced.trampoline(function() {\n                    ++i;\n                    return _while(__iced_k);\n                  });\n                };\n                _next = function(__iced_next_arg) {\n                  _results.push(__iced_next_arg);\n                  return _continue();\n                };\n                if (!(i < _len1)) {\n                  return _break();\n                } else {\n                  subkey = _ref5[i];\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n                      funcname: \"KeyManager.generate\"\n                    });\n                    gen({\n                      klass: Subkey,\n                      section: \"subkey \" + (i + 1),\n                      params: subkey,\n                      primary: primary\n                    }, esc(__iced_deferrals.defer({\n                      assign_fn: (function() {\n                        return function() {\n                          return s = arguments[0];\n                        };\n                      })(),\n                      lineno: 404\n                    })));\n                    __iced_deferrals._fulfill();\n                  })(function() {\n                    return _next(subkeys_out.push(s));\n                  });\n                }\n              };\n              _while(__iced_k);\n            })(function() {\n              bundle = new KeyManager({\n                primary: primary,\n                subkeys: subkeys_out,\n                userids: userids\n              });\n              return cb(null, bundle);\n            });\n          });\n        };\n      })(this));\n    };\n\n    KeyManager.generate_rsa = function(_arg, cb) {\n      var F, asp, primary, subkeys, userid, userids;\n      asp = _arg.asp, userid = _arg.userid, userids = _arg.userids;\n      F = C.key_flags;\n      primary = {\n        flags: F.certify_keys,\n        nbits: 4096\n      };\n      subkeys = [\n        {\n          flags: F.encrypt_storage | F.encrypt_comm,\n          nbits: 2048\n        }, {\n          flags: F.sign_data | F.auth,\n          nbits: 2048\n        }\n      ];\n      return KeyManager.generate({\n        asp: asp,\n        userid: userid,\n        userids: userids,\n        primary: primary,\n        subkeys: subkeys\n      }, cb);\n    };\n\n    KeyManager.generate_ecc = function(_arg, cb) {\n      var F, asp, primary, subkeys, userid, userids;\n      asp = _arg.asp, userid = _arg.userid, userids = _arg.userids;\n      F = C.key_flags;\n      primary = {\n        flags: F.certify_keys,\n        nbits: 384,\n        algo: ECDSA\n      };\n      subkeys = [\n        {\n          flags: F.encrypt_storage | F.encrypt_comm,\n          nbits: 256\n        }, {\n          flags: F.sign_data | F.auth,\n          nbits: 256\n        }\n      ];\n      return KeyManager.generate({\n        asp: asp,\n        userid: userid,\n        userids: userids,\n        primary: primary,\n        subkeys: subkeys\n      }, cb);\n    };\n\n    KeyManager.prototype.set_enc = function(e) {\n      return this.tsenc = e;\n    };\n\n    KeyManager.import_from_armored_pgp = function(_arg, cb) {\n      var armored, asp, binary, err, msg, opts, raw, ret, warnings, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref5, _ref6;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      armored = _arg.armored, raw = _arg.raw, binary = _arg.binary, asp = _arg.asp, opts = _arg.opts;\n      msg = binary;\n      err = null;\n      if (msg == null) {\n        raw || (raw = armored);\n        asp = ASP.make(asp);\n        warnings = null;\n        ret = null;\n        _ref5 = decode(raw), err = _ref5[0], msg = _ref5[1];\n        if (err == null) {\n          if (!((_ref6 = msg.type) === C.message_types.public_key || _ref6 === C.message_types.private_key)) {\n            err = new Error(\"Wanted a public or private key; got: \" + msg.type);\n          }\n        }\n      }\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err == null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n                funcname: \"KeyManager.import_from_armored_pgp\"\n              });\n              KeyManager.import_from_pgp_message({\n                msg: msg,\n                asp: asp,\n                opts: opts\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    ret = arguments[1];\n                    return warnings = arguments[2];\n                  };\n                })(),\n                lineno: 482\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            if (!(err != null)) {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n                  funcname: \"KeyManager.import_from_armored_pgp\"\n                });\n                ret.simple_unlock({}, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return err = arguments[0];\n                    };\n                  })(),\n                  lineno: 488\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            return cb(err, ret, warnings);\n          });\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.simple_unlock = function(opts, cb) {\n      var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (_this.has_pgp_private() && !_this.is_pgp_locked()) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n                funcname: \"KeyManager.simple_unlock\"\n              });\n              _this.unlock_pgp({}, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return err = arguments[0];\n                  };\n                })(),\n                lineno: 500\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    KeyManager.import_from_p3skb = function(_arg, cb) {\n      var armored, asp, err, km, msg, p3skb, raw, warnings, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref5;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      raw = _arg.raw, armored = _arg.armored, asp = _arg.asp;\n      armored || (armored = raw);\n      asp = ASP.make(asp);\n      km = null;\n      warnings = null;\n      _ref5 = katch(function() {\n        return P3SKB.alloc(unseal(read_base64(armored)));\n      }), err = _ref5[0], p3skb = _ref5[1];\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err == null) {\n            msg = new Message({\n              body: p3skb.pub,\n              type: C.message_types.public_key\n            });\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n                funcname: \"KeyManager.import_from_p3skb\"\n              });\n              KeyManager.import_from_pgp_message({\n                msg: msg,\n                asp: asp\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    km = arguments[1];\n                    return warnings = arguments[2];\n                  };\n                })(),\n                lineno: 515\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return __iced_k(km != null ? km.p3skb = p3skb : void 0);\n            });\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, km, warnings);\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.unlock_p3skb = function(_arg, cb) {\n      var asp, err, km, msg, passphrase, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      asp = _arg.asp, tsenc = _arg.tsenc, passphrase = _arg.passphrase;\n      asp = ASP.make(asp);\n      if ((tsenc == null) && (passphrase != null)) {\n        tsenc = new Encryptor({\n          key: bufferify(passphrase)\n        });\n      }\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"KeyManager.unlock_p3skb\"\n          });\n          _this.p3skb.unlock({\n            tsenc: tsenc,\n            asp: asp\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 525\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            if (err == null) {\n              msg = new Message({\n                body: _this.p3skb.priv.data,\n                type: C.message_types.private_key\n              });\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n                  funcname: \"KeyManager.unlock_p3skb\"\n                });\n                KeyManager.import_from_pgp_message({\n                  msg: msg,\n                  asp: asp\n                }, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return km = arguments[1];\n                    };\n                  })(),\n                  lineno: 528\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            if (typeof err === \"undefined\" || err === null) {\n              err = _this.pgp.merge_private(km.pgp);\n            }\n            (function(__iced_k) {\n              if (err == null) {\n                passphrase = new Buffer([]);\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n                    funcname: \"KeyManager.unlock_p3skb\"\n                  });\n                  _this.unlock_pgp({\n                    passphrase: passphrase\n                  }, __iced_deferrals.defer({\n                    assign_fn: (function() {\n                      return function() {\n                        return err = arguments[0];\n                      };\n                    })(),\n                    lineno: 537\n                  }));\n                  __iced_deferrals._fulfill();\n                })(__iced_k);\n              } else {\n                return __iced_k();\n              }\n            })(function() {\n              return cb(err);\n            });\n          });\n        };\n      })(this));\n    };\n\n    KeyManager.import_from_pgp_message = function(_arg, cb) {\n      var asp, bundle, err, k, kb, msg, opts, packets, warnings, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref5;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      msg = _arg.msg, asp = _arg.asp, opts = _arg.opts;\n      asp = ASP.make(asp);\n      bundle = null;\n      warnings = null;\n      if (typeof err === \"undefined\" || err === null) {\n        _ref5 = parse(msg.body), err = _ref5[0], packets = _ref5[1];\n      }\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err == null) {\n            kb = new KeyBlock(packets, opts);\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n                funcname: \"KeyManager.import_from_pgp_message\"\n              });\n              kb.process(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return err = arguments[0];\n                  };\n                })(),\n                lineno: 552\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return __iced_k(warnings = kb.warnings);\n            });\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (err == null) {\n            bundle = new KeyManager({\n              primary: KeyManager._wrap_pgp(Primary, kb.primary),\n              subkeys: (function() {\n                var _i, _len, _ref6, _results;\n                _ref6 = kb.subkeys;\n                _results = [];\n                for (_i = 0, _len = _ref6.length; _i < _len; _i++) {\n                  k = _ref6[_i];\n                  _results.push(KeyManager._wrap_pgp(Subkey, k));\n                }\n                return _results;\n              })(),\n              armored_pgp_public: msg.raw(),\n              user_attributes: kb.user_attributes,\n              userids: kb.userids\n            });\n          }\n          (function(__iced_k) {\n            if (err == null) {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n                  funcname: \"KeyManager.import_from_pgp_message\"\n                });\n                bundle.check_pgp_validity(__iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return err = arguments[0];\n                    };\n                  })(),\n                  lineno: 562\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            return cb(err, bundle, warnings);\n          });\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.merge_pgp_private = function(_arg, cb) {\n      var armored, asp, b2, err, esc, raw, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      armored = _arg.armored, raw = _arg.raw, asp = _arg.asp;\n      asp = ASP.make(asp);\n      esc = make_esc(cb, \"merge_pgp_private\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"KeyManager.merge_pgp_private\"\n          });\n          KeyManager.import_from_armored_pgp({\n            armored: armored,\n            raw: raw,\n            asp: asp\n          }, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return b2 = arguments[0];\n              };\n            })(),\n            lineno: 573\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          err = _this.pgp.merge_private(b2.pgp);\n          (function(__iced_k) {\n            if (err == null) {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n                  funcname: \"KeyManager.merge_pgp_private\"\n                });\n                _this.simple_unlock({}, esc(__iced_deferrals.defer({\n                  lineno: 575\n                })));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            return cb(err);\n          });\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.check_pgp_public_eq = function(km2) {\n      return this.pgp.check_eq(km2.pgp);\n    };\n\n    KeyManager.prototype.unlock_pgp = function(_arg, cb) {\n      var err, passphrase, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      passphrase = _arg.passphrase;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"KeyManager.unlock_pgp\"\n          });\n          _this.pgp.unlock_keys({\n            passphrase: passphrase\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 588\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.is_pgp_locked = function() {\n      return this.pgp.is_locked();\n    };\n\n    KeyManager.prototype.is_keybase_locked = function() {\n      return this.keybase.is_locked();\n    };\n\n    KeyManager.prototype.has_pgp_private = function() {\n      return this.pgp.has_private();\n    };\n\n    KeyManager.prototype.has_p3skb_private = function() {\n      var _ref5;\n      return (_ref5 = this.p3skb) != null ? _ref5.has_private() : void 0;\n    };\n\n    KeyManager.prototype.has_keybase_private = function() {\n      return this.keybase.has_private();\n    };\n\n    KeyManager.prototype.is_p3skb_locked = function() {\n      var _ref5;\n      return (_ref5 = this.p3skb) != null ? _ref5.is_locked() : void 0;\n    };\n\n    KeyManager.prototype.unlock_keybase = function(_arg, cb) {\n      var asp, err, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      tsenc = _arg.tsenc, asp = _arg.asp;\n      asp = ASP.make(asp);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"KeyManager.unlock_keybase\"\n          });\n          _this.keybase.unlock_keys({\n            tsenc: tsenc,\n            asp: asp\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 606\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.export_private_to_server = function(_arg, cb) {\n      var asp, err, p3skb, ret, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      tsenc = _arg.tsenc, asp = _arg.asp;\n      asp = ASP.make(asp);\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          if ((err = _this._assert_signed()) == null) {\n            p3skb = _this.pgp.export_to_p3skb();\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n                funcname: \"KeyManager.export_private_to_server\"\n              });\n              p3skb.lock({\n                tsenc: tsenc,\n                asp: asp\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return err = arguments[0];\n                  };\n                })(),\n                lineno: 619\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (err == null) {\n            ret = p3skb.frame_packet_armored({\n              dohash: true\n            });\n          }\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.export_pgp_private_to_client = function(_arg, cb) {\n      var asp, err, msg, passphrase, regen;\n      passphrase = _arg.passphrase, asp = _arg.asp, regen = _arg.regen;\n      asp = ASP.make(asp);\n      err = msg = null;\n      if (passphrase != null) {\n        passphrase = bufferify(passphrase);\n      }\n      if (!regen && (msg = this.armored_pgp_private)) {\n\n      } else if ((err = this._assert_signed()) == null) {\n        msg = this.pgp.export_keys({\n          \"private\": true,\n          passphrase: passphrase\n        });\n      }\n      return cb(err, msg);\n    };\n\n    KeyManager.prototype.export_pgp_private = function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return this.export_pgp_private_to_client.apply(this, args);\n    };\n\n    KeyManager.prototype.export_pgp_public = function(_arg, cb) {\n      var asp, err, msg, regen;\n      asp = _arg.asp, regen = _arg.regen;\n      asp = ASP.make(asp);\n      err = null;\n      if ((err = this._assert_signed()) == null) {\n        if (!regen) {\n          msg = this.armored_pgp_public;\n        }\n        if (msg == null) {\n          msg = this.pgp.export_keys({\n            \"private\": false\n          });\n        }\n      }\n      return cb(err, msg);\n    };\n\n    KeyManager.prototype.export_public = function(_arg, cb) {\n      var asp, err, msg, regen, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      asp = _arg.asp, regen = _arg.regen;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"KeyManager.export_public\"\n          });\n          _this.export_pgp_public({\n            asp: asp,\n            regen: regen\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return msg = arguments[1];\n              };\n            })(),\n            lineno: 654\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, msg);\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.export_private = function(_arg, cb) {\n      var asp, err, p3skb, passphrase, res, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      passphrase = _arg.passphrase, p3skb = _arg.p3skb, asp = _arg.asp;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (p3skb) {\n            tsenc = new Encryptor({\n              key: bufferify(passphrase)\n            });\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n                funcname: \"KeyManager.export_private\"\n              });\n              _this.export_private_to_server({\n                tsenc: tsenc,\n                asp: asp\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return res = arguments[1];\n                  };\n                })(),\n                lineno: 662\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n                funcname: \"KeyManager.export_private\"\n              });\n              _this.export_pgp_private_to_client({\n                passphrase: passphrase,\n                asp: asp\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return res = arguments[1];\n                  };\n                })(),\n                lineno: 664\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, res);\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.sign_pgp = function(_arg, cb) {\n      var asp;\n      asp = _arg.asp;\n      return this.pgp.sign({\n        asp: asp\n      }, cb);\n    };\n\n    KeyManager.prototype.sign = function(_arg, cb) {\n      var asp, err, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      asp = _arg.asp;\n      asp = ASP.make(asp);\n      asp.section(\"sign\");\n      asp.progress({\n        what: \"sign PGP\",\n        total: 1,\n        i: 0\n      });\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"KeyManager.sign\"\n          });\n          _this.sign_pgp({\n            asp: asp\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 677\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          asp.progress({\n            what: \"sign PGP\",\n            total: 1,\n            i: 1\n          });\n          if (typeof err === \"undefined\" || err === null) {\n            _this._signed = true;\n          }\n          return cb(err);\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.get_userids = function() {\n      return this.userids;\n    };\n\n    KeyManager.prototype.get_userids_mark_primary = function() {\n      var do_insert, i, k, max, max_s, mymax, obj, pair, prev, primary_time, ret, s, tab, userid, _i, _len, _ref5;\n      max = null;\n      max_s = null;\n      tab = {};\n      mymax = function(a, b) {\n        if ((a == null) && (b == null)) {\n          return null;\n        } else if (a == null) {\n          return b;\n        } else if (b == null) {\n          return a;\n        } else if (a > b) {\n          return a;\n        } else {\n          return b;\n        }\n      };\n      _ref5 = this.userids;\n      for (i = _i = 0, _len = _ref5.length; _i < _len; i = ++_i) {\n        userid = _ref5[i];\n        if (!(userid != null)) {\n          continue;\n        }\n        s = userid.utf8();\n        pair = userid.time_primary_pair();\n        obj = {\n          userid: userid,\n          pair: pair,\n          i: i\n        };\n        do_insert = false;\n        if ((prev = tab[s]) != null) {\n          primary_time = mymax(prev.pair[1], pair[1]);\n          if (!(prev.pair[0] != null) || (pair[0] && prev.pair[0] < pair[0])) {\n            do_insert = true;\n          }\n        } else {\n          primary_time = pair[1];\n          do_insert = true;\n        }\n        if (do_insert) {\n          tab[s] = obj;\n        }\n        if ((primary_time != null) && ((max == null) || max < primary_time)) {\n          max_s = s;\n          max = primary_time;\n        }\n      }\n      if (max_s != null) {\n        tab[max_s].userid.primary = true;\n      }\n      ret = [];\n      for (k in tab) {\n        obj = tab[k];\n        obj.userid.most_recent_sig = obj.pair[0];\n        ret.push(obj.userid);\n      }\n      return ret;\n    };\n\n    KeyManager.prototype.fetch = function(key_ids, flags, cb) {\n      return this.pgp.fetch(key_ids, flags, cb);\n    };\n\n    KeyManager.prototype.find_pgp_key = function(key_id) {\n      return this.pgp.find_key(key_id);\n    };\n\n    KeyManager.prototype.find_pgp_key_material = function(key_id) {\n      return this.pgp.find_key_material(key_id);\n    };\n\n    KeyManager.prototype.find_best_pgp_key = function(flags, need_priv) {\n      return this.pgp.find_best_key(flags, need_priv);\n    };\n\n    KeyManager.prototype.find_signing_pgp_key = function() {\n      return this.find_best_pgp_key(C.key_flags.sign_data, true);\n    };\n\n    KeyManager.prototype.find_verifying_pgp_key = function() {\n      return this.find_best_pgp_key(C.key_flags.sign_data, false);\n    };\n\n    KeyManager.prototype.find_crypt_pgp_key = function(need_priv) {\n      if (need_priv == null) {\n        need_priv = false;\n      }\n      return this.find_best_pgp_key(C.key_flags.encrypt_comm, need_priv);\n    };\n\n    KeyManager.prototype.can_verify = function() {\n      return this.find_verifying_pgp_key() != null;\n    };\n\n    KeyManager.prototype.can_sign = function() {\n      return this.find_signing_pgp_key() != null;\n    };\n\n    KeyManager.prototype.can_encrypt = function() {\n      return this.find_crypt_pgp_key(false) != null;\n    };\n\n    KeyManager.prototype.can_decrypt = function() {\n      return this.find_crypt_pgp_key(true) != null;\n    };\n\n    KeyManager.prototype.get_primary_keypair = function() {\n      return this.primary.key;\n    };\n\n    KeyManager.prototype.get_all_pgp_key_materials = function() {\n      return this.pgp.get_all_key_materials();\n    };\n\n    KeyManager.prototype.export_pgp_keys_to_keyring = function() {\n      return this.pgp.export_keys_to_keyring(this);\n    };\n\n    KeyManager.prototype.get_pgp_key_id = function() {\n      return this.pgp.get_key_id();\n    };\n\n    KeyManager.prototype.get_pgp_short_key_id = function() {\n      return this.pgp.get_short_key_id();\n    };\n\n    KeyManager.prototype.get_pgp_fingerprint = function() {\n      return this.pgp.get_fingerprint();\n    };\n\n    KeyManager.prototype.get_pgp_fingerprint_str = function() {\n      var _ref5;\n      return (_ref5 = this.get_pgp_fingerprint()) != null ? _ref5.toString('hex') : void 0;\n    };\n\n    KeyManager.prototype.get_ekid = function() {\n      return this.pgp.get_ekid();\n    };\n\n    KeyManager.prototype.get_all_pgp_key_ids = function() {\n      return this.pgp.get_all_key_ids();\n    };\n\n    KeyManager.prototype.get_ekid_b64_str = function() {\n      var k;\n      if ((k = this.get_ekid()) != null) {\n        return base64u.encode(k);\n      } else {\n        return null;\n      }\n    };\n\n    KeyManager.prototype.get_fp2 = function() {\n      return this.get_pgp_fingerprint();\n    };\n\n    KeyManager.prototype.get_fp2_formatted = function(opts) {\n      var p;\n      if ((p = this.get_fp2()) != null) {\n        return format_pgp_fingerprint_2(p, opts);\n      } else {\n        return null;\n      }\n    };\n\n    KeyManager.prototype.get_type = function() {\n      return \"pgp\";\n    };\n\n    KeyManager.prototype.check_pgp_validity = function(cb) {\n      return this.pgp.validity_check(cb);\n    };\n\n    KeyManager.prototype.make_sig_eng = function() {\n      return new SignatureEngine({\n        km: this\n      });\n    };\n\n    KeyManager.prototype._apply_to_engines = function(_arg, cb) {\n      var args, e, err, meth, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      args = _arg.args, meth = _arg.meth;\n      err = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _len, _ref5, _results, _while;\n          _ref5 = _this.engines;\n          _len = _ref5.length;\n          _i = 0;\n          _results = [];\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = function() {\n              return __iced_k(_results);\n            };\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++_i;\n                return _while(__iced_k);\n              });\n            };\n            _next = function(__iced_next_arg) {\n              _results.push(__iced_next_arg);\n              return _continue();\n            };\n            if (!(_i < _len)) {\n              return _break();\n            } else {\n              e = _ref5[_i];\n              if (!err) {\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/keymanager.iced\",\n                    funcname: \"KeyManager._apply_to_engines\"\n                  });\n                  meth.call(e, args, __iced_deferrals.defer({\n                    assign_fn: (function() {\n                      return function() {\n                        return err = arguments[0];\n                      };\n                    })(),\n                    lineno: 806\n                  }));\n                  __iced_deferrals._fulfill();\n                })(_next);\n              } else {\n                return _continue();\n              }\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    KeyManager.prototype._assert_signed = function() {\n      if (this._signed) {\n        return null;\n      } else {\n        return new Error(\"need to sign before export\");\n      }\n    };\n\n    KeyManager._wrap_pgp = function(klass, kmp) {\n      return new klass({\n        key: kmp.key,\n        lifespan: new Lifespan({\n          generated: kmp.timestamp\n        }),\n        _pgp: kmp\n      });\n    };\n\n    return KeyManager;\n\n  })(KeyManagerInterface);\n\n  exports.KeyManager = KeyManager;\n\n  exports.opkts = opkts;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../const\":5,\"../ecc/ecdsa\":10,\"../keybase/encode\":16,\"../keybase/packet/p3skb\":21,\"../keyfetch\":24,\"../keywrapper\":26,\"../kmi\":27,\"../rsa\":67,\"../util\":70,\"./armor\":33,\"./packet/all\":44,\"./parser\":56,\"./processor\":57,\"./sigeng\":59,\"./util\":60,\"buffer\":80,\"iced-error\":115,\"iced-runtime\":118,\"triplesec\":181}],43:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var AES, ASP, Base, Decryptor, Encryptor, SlicerBuffer, WordArray, decrypt, encrypt, iced, make_esc, repeat, rng, test, triplesec, __iced_k, __iced_k_noop,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  WordArray = require('triplesec').WordArray;\n\n  SlicerBuffer = require('./buffer').SlicerBuffer;\n\n  triplesec = require('triplesec');\n\n  AES = triplesec.ciphers.AES;\n\n  ASP = require('pgp-utils').util.ASP;\n\n  make_esc = require('iced-error').make_esc;\n\n  repeat = function(b, n) {\n    return Buffer.concat([b, b.slice(b.length - n)]);\n  };\n\n  Base = (function() {\n    function Base(_arg) {\n      var asp, key;\n      this.block_cipher_class = _arg.block_cipher_class, key = _arg.key, this.cipher = _arg.cipher, this.resync = _arg.resync, asp = _arg.asp;\n      this.block_cipher_class || (this.block_cipher_class = AES);\n      this.cipher || (this.cipher = new this.block_cipher_class(WordArray.from_buffer(key)));\n      this.block_size = this.cipher.blockSize;\n      this.out_bufs = [];\n      this.asp = ASP.make(asp);\n    }\n\n    Base.prototype.compact = function() {\n      var b;\n      b = Buffer.concat(this.out_bufs);\n      this.out_bufs = [b];\n      return b;\n    };\n\n    return Base;\n\n  })();\n\n  Encryptor = (function(_super) {\n    __extends(Encryptor, _super);\n\n    function Encryptor(_arg) {\n      var asp, block_cipher_class, cipher, key, prefixrandom, resync;\n      block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, prefixrandom = _arg.prefixrandom, resync = _arg.resync, asp = _arg.asp;\n      Encryptor.__super__.constructor.call(this, {\n        block_cipher_class: block_cipher_class,\n        key: key,\n        cipher: cipher,\n        resync: resync,\n        asp: asp\n      });\n      this._init(prefixrandom);\n    }\n\n    Encryptor.prototype._enc = function() {\n      this.FRE = WordArray.from_buffer(this.FR);\n      return this.cipher.encryptBlock(this.FRE.words, 0);\n    };\n\n    Encryptor.prototype._emit_sb = function(sb) {\n      var buf, deficit, i, pad;\n      buf = (deficit = this.block_size - sb.rem()) > 0 ? (pad = new Buffer((function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; 0 <= deficit ? _i < deficit : _i > deficit; i = 0 <= deficit ? ++_i : --_i) {\n          _results.push(0);\n        }\n        return _results;\n      })()), Buffer.concat([sb.consume_rest_to_buffer(), pad])) : sb.read_buffer(this.block_size);\n      return this._emit_buf(buf);\n    };\n\n    Encryptor.prototype._emit_buf = function(buf) {\n      var wa;\n      wa = WordArray.from_buffer(buf.slice(0, this.block_size));\n      wa.xor(this.FRE, {\n        n_words: Math.min(wa.words.length, this.FRE.words.length)\n      });\n      buf = wa.to_buffer();\n      this.out_bufs.push(buf);\n      return this.FR = new Buffer(buf);\n    };\n\n    Encryptor.prototype._init = function(prefixrandom) {\n      var b, canary, ct, i, offset;\n      this.FR = new Buffer((function() {\n        var _i, _ref, _results;\n        _results = [];\n        for (i = _i = 0, _ref = this.block_size; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n          _results.push(0);\n        }\n        return _results;\n      }).call(this));\n      prefixrandom = repeat(prefixrandom, 2);\n      this._enc();\n      this._emit_buf(prefixrandom);\n      this._enc();\n      b = this.FRE.to_buffer();\n      canary = new Buffer((function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; _i < 2; i = ++_i) {\n          _results.push(b.readUInt8(i) ^ prefixrandom.readUInt8(this.block_size + i));\n        }\n        return _results;\n      }).call(this));\n      this.out_bufs.push(canary);\n      offset = this.resync ? 2 : 0;\n      ct = this.compact();\n      ct.copy(this.FR, 0, offset, offset + this.block_size);\n      return this._enc();\n    };\n\n    Encryptor.prototype.enc = function(plaintext, cb) {\n      var buf, ct, esc, j, n_wanted, ret, sb, total, wa, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      sb = new SlicerBuffer(plaintext);\n      esc = make_esc(cb, \"Encryptor::enc\");\n      if (this.resync) {\n        this._emit_sb(sb);\n      } else {\n        buf = Buffer.concat([new Buffer([0, 0]), sb.read_buffer(this.block_size - 2)]);\n        wa = WordArray.from_buffer(buf);\n        wa.xor(this.FRE, {});\n        buf = wa.to_buffer().slice(2);\n        this.out_bufs.push(buf);\n        ct = this.compact();\n        ct.copy(this.FR, 0, ct.length - this.block_size, ct.length);\n      }\n      total = sb.rem();\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/ocfb.iced\",\n            funcname: \"Encryptor.enc\"\n          });\n          _this.asp.progress({\n            what: \"ofcb encryption\",\n            i: 0,\n            total: total\n          }, esc(__iced_deferrals.defer({\n            lineno: 168\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            var _results, _while;\n            _results = [];\n            _while = function(__iced_k) {\n              var _break, _continue, _i, _next;\n              _break = function() {\n                return __iced_k(_results);\n              };\n              _continue = function() {\n                return iced.trampoline(function() {\n                  return _while(__iced_k);\n                });\n              };\n              _next = function(__iced_next_arg) {\n                _results.push(__iced_next_arg);\n                return _continue();\n              };\n              if (!(j = sb.rem())) {\n                return _break();\n              } else {\n                for (_i = 0; _i < 4096; _i++) {\n                  _this._enc();\n                  _this._emit_sb(sb);\n                  if (!(j = sb.rem())) {\n                    break;\n                  }\n                }\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/home/max/src/keybase/kbpgp/src/openpgp/ocfb.iced\",\n                    funcname: \"Encryptor.enc\"\n                  });\n                  _this.asp.progress({\n                    what: \"ofcb encryption\",\n                    i: total - j,\n                    total: total\n                  }, esc(__iced_deferrals.defer({\n                    lineno: 177\n                  })));\n                  __iced_deferrals._fulfill();\n                })(_next);\n              }\n            };\n            _while(__iced_k);\n          })(function() {\n            ret = _this.compact();\n            n_wanted = plaintext.length + _this.block_size + 2;\n            ret = ret.slice(0, n_wanted);\n            return cb(null, ret);\n          });\n        };\n      })(this));\n    };\n\n    return Encryptor;\n\n  })(Base);\n\n  Decryptor = (function(_super) {\n    __extends(Decryptor, _super);\n\n    function Decryptor(_arg) {\n      var asp, block_cipher_class, cipher, key, prefixrandom, resync;\n      block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, prefixrandom = _arg.prefixrandom, resync = _arg.resync, this.ciphertext = _arg.ciphertext, asp = _arg.asp;\n      Decryptor.__super__.constructor.call(this, {\n        block_cipher_class: block_cipher_class,\n        key: key,\n        cipher: cipher,\n        resync: resync,\n        asp: asp\n      });\n      this._init();\n    }\n\n    Decryptor.prototype._init = function() {\n      return this.reset();\n    };\n\n    Decryptor.prototype.reset = function() {\n      return this.sb = new SlicerBuffer(this.ciphertext);\n    };\n\n    Decryptor.prototype.next_block = function() {\n      return WordArray.from_buffer(this.sb.read_buffer_at_most(this.block_size));\n    };\n\n    Decryptor.prototype.get_prefix = function() {\n      return this._prefix;\n    };\n\n    Decryptor.prototype.check = function(cb) {\n      var ablock, err, i, iblock, lhs, rhs;\n      this.reset();\n      iblock = new WordArray((function() {\n        var _i, _ref, _results;\n        _results = [];\n        for (i = _i = 0, _ref = this.block_size / 4; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n          _results.push(0);\n        }\n        return _results;\n      }).call(this));\n      this.cipher.encryptBlock(iblock.words, 0);\n      ablock = this.next_block();\n      iblock.xor(ablock, {});\n      this._prefix = iblock.to_buffer();\n      this.cipher.encryptBlock(ablock.words, 0);\n      lhs = iblock.words.slice(-1)[0] & 0xffff;\n      rhs = (ablock.words[0] >>> 16) ^ (this.sb.peek_uint16());\n      err = lhs === rhs ? null : new Error(\"Canary block mismatch: \" + lhs + \" != \" + rhs);\n      return cb(err);\n    };\n\n    Decryptor.prototype.dec = function(cb) {\n      var ablock, esc, iblock, j, out, total, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      this.reset();\n      if (this.resync) {\n        this.sb.advance(2);\n      }\n      iblock = this.next_block();\n      esc = make_esc(cb, \"Decryption::dec\");\n      total = this.sb.rem();\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/ocfb.iced\",\n            funcname: \"Decryptor.dec\"\n          });\n          _this.asp.progress({\n            what: \"ofcb decrypt\",\n            i: 0,\n            total: total\n          }, esc(__iced_deferrals.defer({\n            lineno: 239\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            var _results, _while;\n            _results = [];\n            _while = function(__iced_k) {\n              var _break, _continue, _i, _next;\n              _break = function() {\n                return __iced_k(_results);\n              };\n              _continue = function() {\n                return iced.trampoline(function() {\n                  return _while(__iced_k);\n                });\n              };\n              _next = function(__iced_next_arg) {\n                _results.push(__iced_next_arg);\n                return _continue();\n              };\n              if (!(j = _this.sb.rem())) {\n                return _break();\n              } else {\n                for (_i = 0; _i < 4096; _i++) {\n                  ablock = iblock;\n                  _this.cipher.encryptBlock(ablock.words, 0);\n                  iblock = _this.next_block();\n                  ablock.xor(iblock, {});\n                  _this.out_bufs.push(ablock.to_buffer().slice(0, iblock.sigBytes));\n                  if (!(j = _this.sb.rem())) {\n                    break;\n                  }\n                }\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/home/max/src/keybase/kbpgp/src/openpgp/ocfb.iced\",\n                    funcname: \"Decryptor.dec\"\n                  });\n                  _this.asp.progress({\n                    what: \"ofcb decrypt\",\n                    i: total - j,\n                    total: total\n                  }, esc(__iced_deferrals.defer({\n                    lineno: 251\n                  })));\n                  __iced_deferrals._fulfill();\n                })(_next);\n              }\n            };\n            _while(__iced_k);\n          })(function() {\n            out = _this.compact();\n            if (!_this.resync) {\n              out = out.slice(2);\n            }\n            return cb(null, out);\n          });\n        };\n      })(this));\n    };\n\n    return Decryptor;\n\n  })(Base);\n\n  encrypt = function(_arg, cb) {\n    var asp, block_cipher_class, cipher, eng, key, plaintext, prefixrandom, resync;\n    block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, prefixrandom = _arg.prefixrandom, resync = _arg.resync, plaintext = _arg.plaintext, asp = _arg.asp;\n    eng = new Encryptor({\n      block_cipher_class: block_cipher_class,\n      key: key,\n      cipher: cipher,\n      prefixrandom: prefixrandom,\n      resync: resync,\n      asp: asp\n    });\n    return eng.enc(plaintext, cb);\n  };\n\n  decrypt = function(_arg, cb) {\n    var asp, block_cipher_class, cipher, ciphertext, eng, err, key, pt, resync, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, resync = _arg.resync, ciphertext = _arg.ciphertext, asp = _arg.asp;\n    eng = new Decryptor({\n      block_cipher_class: block_cipher_class,\n      key: key,\n      cipher: cipher,\n      resync: resync,\n      ciphertext: ciphertext,\n      asp: asp\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/home/max/src/keybase/kbpgp/src/openpgp/ocfb.iced\"\n        });\n        eng.check(__iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              return err = arguments[0];\n            };\n          })(),\n          lineno: 267\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        (function(__iced_k) {\n          if (typeof err === \"undefined\" || err === null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/kbpgp/src/openpgp/ocfb.iced\"\n              });\n              eng.dec(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return pt = arguments[1];\n                  };\n                })(),\n                lineno: 268\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        })(function() {\n          return cb(err, pt);\n        });\n      };\n    })(this));\n  };\n\n  exports.encrypt = encrypt;\n\n  exports.decrypt = decrypt;\n\n  exports.Decryptor = Decryptor;\n\n  rng = require('crypto').rng;\n\n  test = function() {\n    var block_cipher_class, ct, key, plaintext, prefixrandom, pt;\n    plaintext = new Buffer(\"a man a plan a canal panama. and you know the rest\");\n    key = rng(32);\n    prefixrandom = new Buffer([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n    block_cipher_class = AES;\n    ct = encrypt({\n      block_cipher_class: block_cipher_class,\n      key: key,\n      prefixrandom: prefixrandom,\n      plaintext: plaintext\n    });\n    console.log(ct.toString('hex'));\n    pt = decrypt({\n      block_cipher_class: block_cipher_class,\n      key: key,\n      prefixrandom: prefixrandom,\n      ciphertext: ct\n    });\n    return console.log(pt.toString('utf8'));\n  };\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./buffer\":35,\"buffer\":80,\"crypto\":86,\"iced-error\":115,\"iced-runtime\":118,\"pgp-utils\":163,\"triplesec\":181}],44:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  exports.KeyMaterial = require('./keymaterial').KeyMaterial;\n\n  exports.Signature = require('./signature').Signature;\n\n  exports.UserID = require('./userid').UserID;\n\n}).call(this);\n\n},{\"./keymaterial\":48,\"./signature\":53,\"./userid\":55}],45:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, Packet, packetsigs, util;\n\n  util = require('../util');\n\n  C = require('../../const').openpgp;\n\n  packetsigs = require('./packetsigs');\n\n  Packet = (function() {\n    function Packet() {\n      this._psc = new packetsigs.Collection();\n    }\n\n    Packet.prototype.frame_packet = function(tag, body) {\n      var bufs;\n      bufs = [new Buffer([0xc0 | tag]), util.encode_length(body.length), body];\n      return Buffer.concat(bufs);\n    };\n\n    Packet.prototype.set = function(d) {\n      var k, v, _results;\n      _results = [];\n      for (k in d) {\n        v = d[k];\n        _results.push(this[k] = v);\n      }\n      return _results;\n    };\n\n    Packet.prototype.is_signature = function() {\n      return false;\n    };\n\n    Packet.prototype.is_key_material = function() {\n      return false;\n    };\n\n    Packet.prototype.is_duplicate_primary = function() {\n      return false;\n    };\n\n    Packet.prototype.to_userid = function() {\n      return null;\n    };\n\n    Packet.prototype.to_user_attribute = function() {\n      return null;\n    };\n\n    Packet.prototype.to_literal = function() {\n      return null;\n    };\n\n    Packet.prototype.to_esk_packet = function() {\n      return null;\n    };\n\n    Packet.prototype.to_enc_data_packet = function() {\n      return null;\n    };\n\n    Packet.prototype.replay = function() {\n      return this.frame_packet(this.tag, this.raw);\n    };\n\n    Packet.prototype.inflate = function(cb) {\n      return cb(null, null);\n    };\n\n    Packet.prototype.push_sig = function(packetsig) {\n      return this._psc.push(packetsig);\n    };\n\n    Packet.prototype.get_psc = function() {\n      return this._psc;\n    };\n\n    Packet.prototype.get_data_signer = function() {\n      return this.get_psc().get_data_signer();\n    };\n\n    Packet.prototype.get_data_signers = function() {\n      return this.get_psc().get_data_signers();\n    };\n\n    Packet.prototype.get_signed_userids = function() {\n      return [];\n    };\n\n    Packet.prototype.get_subkey_binding = function() {\n      return null;\n    };\n\n    Packet.prototype.is_self_signed = function() {\n      return false;\n    };\n\n    return Packet;\n\n  })();\n\n  exports.Packet = Packet;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../../const\":5,\"../util\":60,\"./packetsigs\":51,\"buffer\":80}],46:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, Compressed, CompressionParser, Packet, asymmetric, bzip_inflate, compressjs, fake_zip_inflate, fix_zip_deflate, iced, uint_to_buffer, zlib, __iced_k, __iced_k_noop,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  Packet = require('./base').Packet;\n\n  C = require('../../const').openpgp;\n\n  asymmetric = require('../../asymmetric');\n\n  zlib = require('zlib');\n\n  uint_to_buffer = require('../../util').uint_to_buffer;\n\n  compressjs = require('keybase-compressjs');\n\n  fake_zip_inflate = function(buf, cb) {\n    var bufs, call_end, err, inflater, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    buf = Buffer.concat([new Buffer([0x78, 0x9c]), buf]);\n    inflater = zlib.createInflate({\n      flush: zlib.Z_FULL_FLUSH\n    });\n    bufs = [];\n    call_end = function(err) {\n      var ret, tmp;\n      if ((tmp = cb) != null) {\n        if ((err != null) && err.code === \"Z_BUF_ERROR\") {\n          err = null;\n        }\n        cb = null;\n        if (err != null) {\n          ret = null;\n        } else {\n          ret = Buffer.concat(bufs);\n        }\n        return tmp(err, ret);\n      }\n    };\n    inflater.on('readable', function() {\n      var read_buf;\n      read_buf = inflater.read();\n      if (read_buf != null) {\n        return bufs.push(read_buf);\n      }\n    });\n    inflater.on('end', function() {\n      return call_end(null);\n    });\n    inflater.on('error', function(e) {\n      return call_end(e);\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/compressed.iced\"\n        });\n        inflater.write(buf, __iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              return err = arguments[0];\n            };\n          })(),\n          lineno: 53\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        (function(__iced_k) {\n          if (typeof err === \"undefined\" || err === null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/compressed.iced\"\n              });\n              inflater.end(err);\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        })(function() {\n          if (typeof err !== \"undefined\" && err !== null) {\n            return call_end(err);\n          }\n        });\n      };\n    })(this));\n  };\n\n  fix_zip_deflate = function(buf, cb) {\n    var err, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/compressed.iced\"\n        });\n        zlib.deflate(buf, __iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              err = arguments[0];\n              return ret = arguments[1];\n            };\n          })(),\n          lineno: 62\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(err, ret);\n      };\n    })(this));\n  };\n\n  bzip_inflate = function(buf, cb) {\n    var e, err, ret;\n    err = null;\n    try {\n      ret = compressjs.Bzip2.decompressFile(buf);\n      if (ret != null) {\n        ret = new Buffer(ret);\n      }\n    } catch (_error) {\n      e = _error;\n      err = e;\n    }\n    return cb(err, ret);\n  };\n\n  Compressed = (function(_super) {\n    __extends(Compressed, _super);\n\n    function Compressed(_arg) {\n      this.algo = _arg.algo, this.compressed = _arg.compressed, this.inflated = _arg.inflated;\n    }\n\n    Compressed.parse = function(slice) {\n      return (new CompressionParser(slice)).parse();\n    };\n\n    Compressed.prototype.inflate = function(cb) {\n      var err, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          switch (_this.algo) {\n            case C.compression.none:\n              return __iced_k(ret = _this.compressed);\n            case C.compression.zlib:\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/compressed.iced\",\n                  funcname: \"Compressed.inflate\"\n                });\n                zlib.inflate(_this.compressed, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return ret = arguments[1];\n                    };\n                  })(),\n                  lineno: 96\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n              break;\n            case C.compression.zip:\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/compressed.iced\",\n                  funcname: \"Compressed.inflate\"\n                });\n                fake_zip_inflate(_this.compressed, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return ret = arguments[1];\n                    };\n                  })(),\n                  lineno: 98\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n              break;\n            case C.compression.bzip:\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/compressed.iced\",\n                  funcname: \"Compressed.inflate\"\n                });\n                bzip_inflate(_this.compressed, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return ret = arguments[1];\n                    };\n                  })(),\n                  lineno: 100\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n              break;\n            default:\n              return __iced_k(err = new Error(\"no known inflation -- algo: \" + _this.algo));\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    Compressed.prototype.deflate = function(cb) {\n      var err, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          switch (_this.algo) {\n            case C.compression.none:\n              return __iced_k(ret = _this.inflated);\n            case C.compression.zlib:\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/compressed.iced\",\n                  funcname: \"Compressed.deflate\"\n                });\n                zlib.deflate(_this.inflated, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return ret = arguments[1];\n                    };\n                  })(),\n                  lineno: 112\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n              break;\n            case C.compression.zip:\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/compressed.iced\",\n                  funcname: \"Compressed.deflate\"\n                });\n                fake_zip_deflate(_this.inflated, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return ret = arguments[1];\n                    };\n                  })(),\n                  lineno: 114\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n              break;\n            default:\n              return __iced_k(err = new Error(\"no known deflation -- algo: \" + _this.algo));\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    Compressed.prototype.write_unframed = function(cb) {\n      var bufs, err, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/compressed.iced\",\n            funcname: \"Compressed.write_unframed\"\n          });\n          _this.deflate(__iced_deferrals.defer({\n            assign_fn: (function(__slot_1) {\n              return function() {\n                err = arguments[0];\n                return __slot_1.compressed = arguments[1];\n              };\n            })(_this),\n            lineno: 123\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (err == null) {\n            bufs = [uint_to_buffer(8, _this.algo), _this.compressed];\n            ret = Buffer.concat(bufs);\n          }\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    Compressed.prototype.write = function(cb) {\n      var err, ret, unframed, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/compressed.iced\",\n            funcname: \"Compressed.write\"\n          });\n          _this.write_unframed(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return unframed = arguments[1];\n              };\n            })(),\n            lineno: 133\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (err == null) {\n            ret = _this.frame_packet(C.packet_tags.compressed, unframed);\n          }\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    return Compressed;\n\n  })(Packet);\n\n  CompressionParser = (function() {\n    function CompressionParser(slice) {\n      this.slice = slice;\n    }\n\n    CompressionParser.prototype.parse = function() {\n      var algo, compressed;\n      algo = this.slice.read_uint8();\n      compressed = this.slice.consume_rest_to_buffer();\n      return new Compressed({\n        algo: algo,\n        compressed: compressed\n      });\n    };\n\n    return CompressionParser;\n\n  })();\n\n  exports.Compressed = Compressed;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../../asymmetric\":1,\"../../const\":5,\"../../util\":70,\"./base\":45,\"buffer\":80,\"iced-runtime\":118,\"keybase-compressjs\":120,\"zlib\":79}],47:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var Generic, Packet,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  Packet = require('./base').Packet;\n\n  Generic = (function(_super) {\n    __extends(Generic, _super);\n\n    function Generic(type, body) {\n      this.type = type;\n      this.body = body;\n    }\n\n    return Generic;\n\n  })(Packet);\n\n  exports.Generic = Generic;\n\n}).call(this);\n\n},{\"./base\":45}],48:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var AES, C, DSA, ECDH, ECDSA, ElGamal, ElGamalSE, KeyMaterial, Packet, Parser, RSA, S, S2K, SHA1, SHA256, SecretKeyMaterial, Signature, bufeq_secure, bufferify, calc_checksum, decrypt, encode, encrypt, iced, katch, make_time_packet, native_rng, packetsigs, symmetric, triplesec, uint_to_buffer, unix_time, util, __iced_k, __iced_k_noop, _ref, _ref1, _ref2, _ref3,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  C = require('../../const').openpgp;\n\n  triplesec = require('triplesec');\n\n  _ref = triplesec.hash, SHA1 = _ref.SHA1, SHA256 = _ref.SHA256;\n\n  RSA = require('../../rsa').Pair;\n\n  DSA = require('../../dsa').Pair;\n\n  ElGamal = require('../../elgamal').Pair;\n\n  ElGamalSE = require('../../elgamalse').Pair;\n\n  ECDSA = require('../../ecc/ecdsa').Pair;\n\n  ECDH = require('../../ecc/ecdh').Pair;\n\n  AES = triplesec.ciphers.AES;\n\n  native_rng = triplesec.prng.native_rng;\n\n  calc_checksum = require('../util').calc_checksum;\n\n  _ref1 = require('../../util'), bufferify = _ref1.bufferify, unix_time = _ref1.unix_time, bufeq_secure = _ref1.bufeq_secure, katch = _ref1.katch, make_time_packet = _ref1.make_time_packet, uint_to_buffer = _ref1.uint_to_buffer;\n\n  _ref2 = require('../cfb'), decrypt = _ref2.decrypt, encrypt = _ref2.encrypt;\n\n  Packet = require('./base').Packet;\n\n  S = require('./signature');\n\n  Signature = S.Signature;\n\n  encode = require('../armor').encode;\n\n  _ref3 = require('../s2k'), S2K = _ref3.S2K, SecretKeyMaterial = _ref3.SecretKeyMaterial;\n\n  symmetric = require('../../symmetric');\n\n  util = require('util');\n\n  packetsigs = require('./packetsigs');\n\n  KeyMaterial = (function(_super) {\n    __extends(KeyMaterial, _super);\n\n    function KeyMaterial(_arg) {\n      this.key = _arg.key, this.timestamp = _arg.timestamp, this.passphrase = _arg.passphrase, this.skm = _arg.skm, this.opts = _arg.opts, this.flags = _arg.flags;\n      this.opts || (this.opts = {});\n      this.flags || (this.flags = 0);\n      this._is_duplicate_primary = false;\n      KeyMaterial.__super__.constructor.call(this);\n    }\n\n    KeyMaterial.prototype._write_private_enc = function(bufs, priv, pp) {\n      var c, ct, iv, ivlen, k, ks, plaintext, salt, sha1hash;\n      bufs.push(new Buffer([C.s2k_convention.sha1, C.symmetric_key_algorithms.AES256, C.s2k.salt_iter, C.hash_algorithms.SHA256]));\n      sha1hash = (new SHA1).bufhash(priv);\n      salt = native_rng(8);\n      bufs.push(salt);\n      c = 96;\n      bufs.push(new Buffer([c]));\n      ks = AES.keySize;\n      k = (new S2K).write(pp, salt, c, ks);\n      ivlen = AES.blockSize;\n      iv = native_rng(ivlen);\n      bufs.push(iv);\n      plaintext = Buffer.concat([priv, sha1hash]);\n      ct = encrypt({\n        block_cipher_class: AES,\n        key: k,\n        plaintext: plaintext,\n        iv: iv\n      });\n      return bufs.push(ct);\n    };\n\n    KeyMaterial.prototype._write_private_clear = function(bufs, priv) {\n      return bufs.push(new Buffer([C.s2k_convention.none]), priv, uint_to_buffer(16, calc_checksum(priv)));\n    };\n\n    KeyMaterial.prototype._write_public = function(bufs) {\n      var pub;\n      pub = this.key.serialize();\n      return bufs.push(new Buffer([C.versions.keymaterial.V4]), uint_to_buffer(32, this.timestamp), new Buffer([this.key.type]), pub);\n    };\n\n    KeyMaterial.prototype._write_dummy = function(bufs) {\n      return bufs.push(new Buffer([C.s2k_convention.sha1, C.symmetric_key_algorithms.AES256, C.s2k.gnu, 0x2]), new Buffer(\"GNU\", \"utf8\"), new Buffer([0x1]));\n    };\n\n    KeyMaterial.prototype.add_flags = function(v) {\n      return this.flags |= v;\n    };\n\n    KeyMaterial.prototype.private_body = function(opts) {\n      var bufs, p, pp, priv, ret;\n      bufs = [];\n      this._write_public(bufs);\n      priv = (p = this.key.priv) != null ? p.serialize() : null;\n      pp = opts.passphrase || this.passphrase;\n      if (priv == null) {\n        this._write_dummy(bufs);\n      } else if (pp != null) {\n        this._write_private_enc(bufs, priv, pp);\n      } else {\n        this._write_private_clear(bufs, priv);\n      }\n      ret = Buffer.concat(bufs);\n      return ret;\n    };\n\n    KeyMaterial.prototype.private_framed = function(opts) {\n      var T, body, tag;\n      body = this.private_body(opts);\n      T = C.packet_tags;\n      tag = opts.subkey ? T.secret_subkey : T.secret_key;\n      return this.frame_packet(tag, body);\n    };\n\n    KeyMaterial.prototype.public_body = function() {\n      var bufs;\n      bufs = [];\n      this._write_public(bufs);\n      return Buffer.concat(bufs);\n    };\n\n    KeyMaterial.prototype.get_fingerprint = function() {\n      var data;\n      data = this.public_body();\n      return (new SHA1).bufhash(Buffer.concat([new Buffer([C.signatures.key]), uint_to_buffer(16, data.length), data]));\n    };\n\n    KeyMaterial.prototype.get_key_id = function() {\n      return this.get_fingerprint().slice(12, 20);\n    };\n\n    KeyMaterial.prototype.get_short_key_id = function() {\n      return this.get_key_id().slice(-4).toString('hex').toUpperCase();\n    };\n\n    KeyMaterial.prototype.get_klass = function() {\n      return this.key.constructor;\n    };\n\n    KeyMaterial.prototype.export_framed = function(opts) {\n      if (opts == null) {\n        opts = {};\n      }\n      if (opts[\"private\"]) {\n        return this.private_framed(opts);\n      } else {\n        return this.public_framed(opts);\n      }\n    };\n\n    KeyMaterial.prototype.public_framed = function(opts) {\n      var T, body, tag;\n      if (opts == null) {\n        opts = {};\n      }\n      body = this.public_body();\n      T = C.packet_tags;\n      tag = opts.subkey ? T.public_subkey : T.public_key;\n      return this.frame_packet(tag, body);\n    };\n\n    KeyMaterial.prototype.to_signature_payload = function() {\n      var pk;\n      pk = this.public_body();\n      return Buffer.concat([new Buffer([C.signatures.key]), uint_to_buffer(16, pk.length), pk]);\n    };\n\n    KeyMaterial.prototype.self_sign_key = function(_arg, cb) {\n      var err, lifespan, primary, raw_payload, sig, sigs, userid, userids, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      userids = _arg.userids, lifespan = _arg.lifespan, raw_payload = _arg.raw_payload;\n      err = null;\n      sigs = [];\n      primary = true;\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _len, _ref4, _results, _while;\n          _ref4 = userids;\n          _len = _ref4.length;\n          _i = 0;\n          _results = [];\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = function() {\n              return __iced_k(_results);\n            };\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++_i;\n                return _while(__iced_k);\n              });\n            };\n            _next = function(__iced_next_arg) {\n              _results.push(__iced_next_arg);\n              return _continue();\n            };\n            if (!(_i < _len)) {\n              return _break();\n            } else {\n              userid = _ref4[_i];\n              if (err == null) {\n                sig = null;\n                (function(__iced_k) {\n                  if (_this.key.can_sign() || raw_payload) {\n                    (function(__iced_k) {\n                      __iced_deferrals = new iced.Deferrals(__iced_k, {\n                        parent: ___iced_passed_deferral,\n                        filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced\",\n                        funcname: \"KeyMaterial.self_sign_key\"\n                      });\n                      _this._self_sign_key({\n                        userid: userid,\n                        lifespan: lifespan,\n                        raw_payload: raw_payload,\n                        primary: primary\n                      }, __iced_deferrals.defer({\n                        assign_fn: (function() {\n                          return function() {\n                            err = arguments[0];\n                            return sig = arguments[1];\n                          };\n                        })(),\n                        lineno: 193\n                      }));\n                      __iced_deferrals._fulfill();\n                    })(__iced_k);\n                  } else {\n                    return __iced_k((sig = userid.get_framed_signature_output()) == null ? err = new Error(\"Cannot sign key --- don't have a private key, and can't replay\") : void 0);\n                  }\n                })(function() {\n                  primary = false;\n                  return _next(sigs.push(sig));\n                });\n              } else {\n                return _continue();\n              }\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, sig);\n        };\n      })(this));\n    };\n\n    KeyMaterial.prototype._self_sign_key = function(_arg, cb) {\n      var err, hsp, lifespan, payload, primary, ps, raw_payload, sig, type, userid, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      userid = _arg.userid, lifespan = _arg.lifespan, raw_payload = _arg.raw_payload, primary = _arg.primary;\n      payload = Buffer.concat([this.to_signature_payload(), userid.to_signature_payload()]);\n      type = C.sig_types.positive;\n      hsp = [new S.CreationTime(lifespan.generated), new S.KeyFlags([this.flags]), new S.PreferredSymmetricAlgorithms([C.symmetric_key_algorithms.AES256, C.symmetric_key_algorithms.AES128]), new S.PreferredHashAlgorithms([C.hash_algorithms.SHA512, C.hash_algorithms.SHA256]), new S.Features([C.features.modification_detection]), new S.KeyServerPreferences([C.key_server_preferences.no_modify])];\n      if (primary) {\n        hsp.push(new S.PrimaryUserId(1));\n      }\n      if (lifespan.expire_in) {\n        hsp.push(new S.KeyExpirationTime(lifespan.expire_in));\n      }\n      sig = new Signature({\n        type: type,\n        key: this.key,\n        hashed_subpackets: hsp,\n        unhashed_subpackets: [new S.Issuer(this.get_key_id())]\n      });\n      (function(_this) {\n        return (function(__iced_k) {\n          if (raw_payload) {\n            return __iced_k(sig = payload);\n          } else {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced\",\n                funcname: \"KeyMaterial._self_sign_key\"\n              });\n              sig.write(payload, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return err = arguments[0];\n                  };\n                })(),\n                lineno: 235\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              ps = new packetsigs.SelfSig({\n                userid: userid,\n                type: type,\n                sig: sig,\n                options: _this.flags\n              });\n              userid.push_sig(ps);\n              return __iced_k(_this.push_sig(ps));\n            });\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, sig);\n        };\n      })(this));\n    };\n\n    KeyMaterial.prototype.sign_subkey = function(_arg, cb) {\n      var err, lifespan, sig, subkey, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      subkey = _arg.subkey, lifespan = _arg.lifespan;\n      err = sig = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          var _ref4, _ref5;\n          if (_this.key.can_sign()) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced\",\n                funcname: \"KeyMaterial.sign_subkey\"\n              });\n              _this._sign_subkey({\n                subkey: subkey,\n                lifespan: lifespan\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return err = arguments[0];\n                  };\n                })(),\n                lineno: 248\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k(!((_ref4 = subkey.get_subkey_binding()) != null ? (_ref5 = _ref4.sig) != null ? _ref5.get_framed_output() : void 0 : void 0) ? err = new Error(\"Cannot sign with subkey --- don't have private key and can't replay\") : void 0);\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    KeyMaterial.prototype._sign_subkey = function(_arg, cb) {\n      var SKB, err, lifespan, primary_binding, ps, sig, subkey, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      subkey = _arg.subkey, lifespan = _arg.lifespan;\n      sig = err = primary_binding = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (subkey.can_sign()) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced\",\n                funcname: \"KeyMaterial._sign_subkey\"\n              });\n              subkey._sign_primary_with_subkey({\n                primary: _this,\n                lifespan: lifespan\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return primary_binding = arguments[1];\n                  };\n                })(),\n                lineno: 260\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            if (err == null) {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced\",\n                  funcname: \"KeyMaterial._sign_subkey\"\n                });\n                _this._sign_subkey_with_primary({\n                  subkey: subkey,\n                  lifespan: lifespan,\n                  primary_binding: primary_binding\n                }, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return sig = arguments[1];\n                    };\n                  })(),\n                  lineno: 262\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            if (err == null) {\n              SKB = packetsigs.SubkeyBinding;\n              ps = new SKB({\n                primary: _this,\n                sig: sig,\n                direction: SKB.DOWN\n              });\n              subkey.push_sig(ps);\n            }\n            return cb(err);\n          });\n        };\n      })(this));\n    };\n\n    KeyMaterial.prototype._sign_primary_with_subkey = function(_arg, cb) {\n      var err, lifespan, payload, primary, sig, sig_unframed, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      primary = _arg.primary, lifespan = _arg.lifespan;\n      payload = Buffer.concat([primary.to_signature_payload(), this.to_signature_payload()]);\n      sig = new Signature({\n        type: C.sig_types.primary_binding,\n        key: this.key,\n        hashed_subpackets: [new S.CreationTime(lifespan.generated)],\n        unhashed_subpackets: [new S.Issuer(this.get_key_id())]\n      });\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced\",\n            funcname: \"KeyMaterial._sign_primary_with_subkey\"\n          });\n          sig.write_unframed(payload, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return sig_unframed = arguments[1];\n              };\n            })(),\n            lineno: 286\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, sig_unframed);\n        };\n      })(this));\n    };\n\n    KeyMaterial.prototype._sign_subkey_with_primary = function(_arg, cb) {\n      var err, lifespan, payload, primary_binding, sig, subkey, unhashed_subpackets, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      subkey = _arg.subkey, lifespan = _arg.lifespan, primary_binding = _arg.primary_binding;\n      payload = Buffer.concat([this.to_signature_payload(), subkey.to_signature_payload()]);\n      unhashed_subpackets = [new S.Issuer(this.get_key_id())];\n      if (primary_binding != null) {\n        unhashed_subpackets.push(new S.EmbeddedSignature({\n          rawsig: primary_binding\n        }));\n      }\n      sig = new Signature({\n        type: C.sig_types.subkey_binding,\n        key: this.key,\n        hashed_subpackets: [new S.CreationTime(lifespan.generated), new S.KeyExpirationTime(lifespan.expire_in), new S.KeyFlags([subkey.flags])],\n        unhashed_subpackets: unhashed_subpackets\n      });\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced\",\n            funcname: \"KeyMaterial._sign_subkey_with_primary\"\n          });\n          sig.write(payload, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 310\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, sig);\n        };\n      })(this));\n    };\n\n    KeyMaterial.prototype.merge_private = function(k2) {\n      return this.skm = k2.skm;\n    };\n\n    KeyMaterial.parse_public_key = function(slice, opts) {\n      return (new Parser(slice)).parse_public_key(opts);\n    };\n\n    KeyMaterial.parse_private_key = function(slice, opts) {\n      return (new Parser(slice)).parse_private_key(opts);\n    };\n\n    KeyMaterial.prototype.is_key_material = function() {\n      return true;\n    };\n\n    KeyMaterial.prototype.is_primary = function() {\n      var _ref4;\n      return !((_ref4 = this.opts) != null ? _ref4.subkey : void 0);\n    };\n\n    KeyMaterial.prototype.is_duplicate_primary = function() {\n      return this._is_duplicate_primary;\n    };\n\n    KeyMaterial.prototype.set_duplicate_primary = function() {\n      return this._is_duplicate_primary = true;\n    };\n\n    KeyMaterial.prototype.ekid = function() {\n      return this.key.ekid();\n    };\n\n    KeyMaterial.prototype.can_sign = function() {\n      return this.key.can_sign();\n    };\n\n    KeyMaterial.prototype.is_locked = function() {\n      return (!this.key.has_private()) && (this.skm != null) && this.skm.is_locked();\n    };\n\n    KeyMaterial.prototype.has_private = function() {\n      return this.has_unlocked_private() || this.has_locked_private();\n    };\n\n    KeyMaterial.prototype.has_locked_private = function() {\n      return this.skm && this.skm.has_private();\n    };\n\n    KeyMaterial.prototype.has_unlocked_private = function() {\n      return this.key.has_private();\n    };\n\n    KeyMaterial.prototype.has_secret_key_material = function() {\n      return this.skm != null;\n    };\n\n    KeyMaterial.prototype.validity_check = function(cb) {\n      var err, msg, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced\",\n            funcname: \"KeyMaterial.validity_check\"\n          });\n          _this.key.validity_check(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 344\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (typeof err !== \"undefined\" && err !== null) {\n            msg = \"In key \" + (_this.get_fingerprint().toString('hex')) + \": \" + err.message;\n            err = new Error(err);\n          }\n          return cb(err);\n        };\n      })(this));\n    };\n\n    KeyMaterial.prototype.is_signed_subkey_of = function(primary) {\n      return (!this.primary_flag) && this.get_psc().is_signed_subkey_of(primary);\n    };\n\n    KeyMaterial.prototype.get_subkey_binding = function() {\n      if (this.opts.subkey) {\n        return this.get_psc().get_subkey_binding();\n      } else {\n        return null;\n      }\n    };\n\n    KeyMaterial.prototype.get_subkey_binding_signature_output = function() {\n      var _ref4, _ref5;\n      return (_ref4 = this.get_subkey_binding()) != null ? (_ref5 = _ref4.sig) != null ? _ref5.get_framed_output() : void 0 : void 0;\n    };\n\n    KeyMaterial.prototype.equal = function(k2) {\n      return bufeq_secure(this.ekid(), k2.ekid());\n    };\n\n    KeyMaterial.prototype.unlock = function(_arg, cb) {\n      var c1, c2, end, err, h1, h2, key, passphrase, pt;\n      passphrase = _arg.passphrase;\n      if (passphrase != null) {\n        passphrase = bufferify(passphrase);\n      }\n      err = null;\n      if (this.skm == null) {\n        err = new Error(\"Cannot unlock secret key -- no material!\");\n        return cb(err);\n      }\n      pt = this.skm.s2k_convention === C.s2k_convention.none ? this.skm.payload : this.skm.s2k.type === C.s2k.gnu_dummy ? null : passphrase == null ? (err = new Error(\"Key was locked, but no passphrase given\"), null) : (key = this.skm.s2k.produce_key(passphrase, this.skm.cipher.key_size), decrypt({\n        ciphertext: this.skm.payload,\n        block_cipher_class: this.skm.cipher.klass,\n        iv: this.skm.iv,\n        key: key\n      }));\n      if (pt) {\n        switch (this.skm.s2k_convention) {\n          case C.s2k_convention.sha1:\n            end = pt.length - SHA1.output_size;\n            h1 = pt.slice(end);\n            pt = pt.slice(0, end);\n            h2 = (new SHA1).bufhash(pt);\n            if (!bufeq_secure(h1, h2)) {\n              err = new Error(\"bad private key passphrase (hash mismatch)\");\n            }\n            break;\n          case C.s2k_convention.checksum:\n          case C.s2k_convention.none:\n            end = pt.length - 2;\n            c1 = pt.readUInt16BE(end);\n            pt = pt.slice(0, end);\n            c2 = calc_checksum(pt);\n            if (c1 !== c2) {\n              err = new Error(\"bad private key passphrase (checksum mismatch)\");\n            }\n        }\n        if (err == null) {\n          err = this.key.read_priv(pt);\n        }\n      }\n      return cb(err);\n    };\n\n    KeyMaterial.prototype.get_all_key_flags = function() {\n      return this._psc.get_all_key_flags();\n    };\n\n    KeyMaterial.prototype.add_flags = function(v) {\n      return this.flags |= v;\n    };\n\n    KeyMaterial.prototype.fulfills_flags = function(flags) {\n      var akf, ret;\n      if (this.is_revoked()) {\n        return false;\n      }\n      akf = this.get_all_key_flags();\n      ret = ((akf & flags) === flags) || this.key.fulfills_flags(flags) || (this.is_primary() && (akf === 0) && ((this.key.good_for_flags() & flags) === flags));\n      return ret;\n    };\n\n    KeyMaterial.prototype.get_signed_userids = function() {\n      return this.get_psc().get_signed_userids();\n    };\n\n    KeyMaterial.prototype.get_signed_user_attributes = function() {\n      return this.get_psc().get_signed_user_attributes();\n    };\n\n    KeyMaterial.prototype.is_self_signed = function() {\n      return this.get_psc().is_self_signed();\n    };\n\n    KeyMaterial.prototype.push_sig = function(packetsig) {\n      this.add_flags(packetsig.sig.get_key_flags());\n      return KeyMaterial.__super__.push_sig.call(this, packetsig);\n    };\n\n    KeyMaterial.prototype.mark_revoked = function(sig) {\n      return this.revocation = sig;\n    };\n\n    KeyMaterial.prototype.is_revoked = function() {\n      return this.revocation != null;\n    };\n\n    return KeyMaterial;\n\n  })(Packet);\n\n  Parser = (function() {\n    function Parser(slice) {\n      this.slice = slice;\n      this.key = null;\n    }\n\n    Parser.prototype.parse_public_key_v3 = function() {\n      this.timestamp = this.slice.read_uint32();\n      this.expiration = this.slice.read_uint16();\n      return this.parse_public_key_mpis();\n    };\n\n    Parser.prototype.parse_public_key_v4 = function() {\n      this.timestamp = this.slice.read_uint32();\n      return this.parse_public_key_mpis();\n    };\n\n    Parser.prototype.parse_public_key_mpis = function() {\n      var A, err, key, klass, len, _ref4;\n      this.algorithm = this.slice.read_uint8();\n      A = C.public_key_algorithms;\n      klass = (function() {\n        switch (this.algorithm) {\n          case A.RSA:\n          case A.RSA_ENCRYPT_ONLY:\n          case A.RSA_SIGN_ONLY:\n            return RSA;\n          case A.DSA:\n            return DSA;\n          case A.ELGAMAL:\n            return ElGamal;\n          case A.ELGAMAL_SIGN_AND_ENCRYPT:\n            return ElGamalSE;\n          case A.ECDSA:\n            return ECDSA;\n          case A.ECDH:\n            return ECDH;\n          default:\n            throw new Error(\"Unknown key type: \" + this.algorithm);\n        }\n      }).call(this);\n      _ref4 = klass.parse(this.slice.peek_rest_to_buffer()), err = _ref4[0], key = _ref4[1], len = _ref4[2];\n      if (err != null) {\n        throw err;\n      }\n      this.slice.advance(len);\n      return key;\n    };\n\n    Parser.prototype._parse_public_key = function() {\n      var version;\n      switch ((version = this.slice.read_uint8())) {\n        case C.versions.keymaterial.V3:\n          return this.parse_public_key_v3();\n        case C.versions.keymaterial.V4:\n          return this.parse_public_key_v4();\n        default:\n          throw new Error(\"Unknown public key version: \" + version);\n      }\n    };\n\n    Parser.prototype.parse_public_key = function(opts) {\n      var key;\n      key = this._parse_public_key();\n      return new KeyMaterial({\n        key: key,\n        timestamp: this.timestamp,\n        opts: opts\n      });\n    };\n\n    Parser.prototype.parse_private_key = function(opts) {\n      var encrypted_private_key, iv_len, key, skm, sym_enc_alg, _ref4;\n      skm = new SecretKeyMaterial();\n      key = this._parse_public_key();\n      encrypted_private_key = true;\n      sym_enc_alg = null;\n      if ((skm.s2k_convention = this.slice.read_uint8()) === C.s2k_convention.none) {\n        encrypted_private_key = false;\n      } else {\n        if ((_ref4 = skm.s2k_convention) === C.s2k_convention.sha1 || _ref4 === C.s2k_convention.checksum) {\n          sym_enc_alg = this.slice.read_uint8();\n          skm.s2k = (new S2K).read(this.slice);\n        } else {\n          sym_enc_alg = skm.s2k_convention;\n        }\n      }\n      if ((skm.s2k_convention !== C.s2k_convention.none) && (skm.s2k.type === C.s2k.gnu_dummy)) {\n        skm.payload = null;\n      } else {\n        if (sym_enc_alg) {\n          skm.cipher = symmetric.get_cipher(sym_enc_alg);\n          iv_len = skm.cipher.klass.blockSize;\n          skm.iv = this.slice.read_buffer(iv_len);\n        }\n        skm.payload = this.slice.consume_rest_to_buffer();\n      }\n      return new KeyMaterial({\n        key: key,\n        skm: skm,\n        timestamp: this.timestamp,\n        opts: opts\n      });\n    };\n\n    return Parser;\n\n  })();\n\n  exports.KeyMaterial = KeyMaterial;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../../const\":5,\"../../dsa\":6,\"../../ecc/ecdh\":9,\"../../ecc/ecdsa\":10,\"../../elgamal\":12,\"../../elgamalse\":13,\"../../rsa\":67,\"../../symmetric\":68,\"../../util\":70,\"../armor\":33,\"../cfb\":38,\"../s2k\":58,\"../util\":60,\"./base\":45,\"./packetsigs\":51,\"./signature\":53,\"buffer\":80,\"iced-runtime\":118,\"triplesec\":181,\"util\":114}],49:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, Literal, LiteralParser, Packet, asymmetric, iced, uint_to_buffer, __iced_k, __iced_k_noop,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  Packet = require('./base').Packet;\n\n  C = require('../../const').openpgp;\n\n  asymmetric = require('../../asymmetric');\n\n  uint_to_buffer = require('../../util').uint_to_buffer;\n\n  Literal = (function(_super) {\n    __extends(Literal, _super);\n\n    function Literal(_arg) {\n      this.format = _arg.format, this.filename = _arg.filename, this.date = _arg.date, this.data = _arg.data;\n      Literal.__super__.constructor.call(this);\n    }\n\n    Literal.parse = function(slice) {\n      return (new LiteralParser(slice)).parse();\n    };\n\n    Literal.prototype.toString = function(encoding) {\n      if (encoding == null) {\n        encoding = null;\n      }\n      return this.data.toString(encoding || this.buffer_format());\n    };\n\n    Literal.prototype.toBuffer = function() {\n      return this.data;\n    };\n\n    Literal.prototype.buffer_format = function() {\n      switch (this.format) {\n        case C.literal_formats.text:\n          return 'ascii';\n        case C.literal_formats.utf8:\n          return 'utf8';\n        default:\n          return 'binary';\n      }\n    };\n\n    Literal.prototype.to_signature_payload = function() {\n      return Buffer.concat([this.data]);\n    };\n\n    Literal.prototype.write_unframed = function(cb) {\n      var bufs, ret;\n      this.filename || (this.filename = new Buffer([]));\n      bufs = [new Buffer([this.format]), uint_to_buffer(8, this.filename.length), this.filename, uint_to_buffer(32, this.date), this.data];\n      ret = Buffer.concat(bufs);\n      return cb(null, ret);\n    };\n\n    Literal.prototype.write = function(cb) {\n      var err, raw, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/packet/literal.iced\",\n            funcname: \"Literal.write\"\n          });\n          _this.write_unframed(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return raw = arguments[1];\n              };\n            })(),\n            lineno: 41\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (err == null) {\n            ret = _this.frame_packet(C.packet_tags.literal, raw);\n          }\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    Literal.prototype.to_literal = function() {\n      return this;\n    };\n\n    return Literal;\n\n  })(Packet);\n\n  LiteralParser = (function() {\n    function LiteralParser(slice) {\n      this.slice = slice;\n    }\n\n    LiteralParser.prototype.parse = function() {\n      var data, date, filename, format, k, known_formats, v;\n      known_formats = (function() {\n        var _ref, _results;\n        _ref = C.literal_formats;\n        _results = [];\n        for (k in _ref) {\n          v = _ref[k];\n          _results.push(v);\n        }\n        return _results;\n      })();\n      format = this.slice.read_uint8();\n      if (__indexOf.call(known_formats, format) < 0) {\n        throw new Error(\"unknwon format: \" + format);\n      }\n      filename = this.slice.read_string();\n      date = this.slice.read_uint32();\n      data = this.slice.consume_rest_to_buffer();\n      return new Literal({\n        format: format,\n        filename: filename,\n        date: date,\n        data: data\n      });\n    };\n\n    return LiteralParser;\n\n  })();\n\n  exports.Literal = Literal;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../../asymmetric\":1,\"../../const\":5,\"../../util\":70,\"./base\":45,\"buffer\":80,\"iced-runtime\":118}],50:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, OPS_Parser, OnePassSignature, Packet, asymmetric, hash, iced, uint_to_buffer, __iced_k, __iced_k_noop,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  Packet = require('./base').Packet;\n\n  C = require('../../const').openpgp;\n\n  asymmetric = require('../../asymmetric');\n\n  hash = require('../../hash');\n\n  uint_to_buffer = require('../../util').uint_to_buffer;\n\n  OnePassSignature = (function(_super) {\n    __extends(OnePassSignature, _super);\n\n    function OnePassSignature(_arg) {\n      this.sig_type = _arg.sig_type, this.hasher = _arg.hasher, this.sig_klass = _arg.sig_klass, this.key_id = _arg.key_id, this.is_final = _arg.is_final;\n    }\n\n    OnePassSignature.parse = function(slice) {\n      return (new OPS_Parser(slice)).parse();\n    };\n\n    OnePassSignature.prototype.write_unframed = function(cb) {\n      var bufs, unframed, vals, x;\n      vals = [C.versions.one_pass_sig, this.sig_type, this.hasher.type, this.sig_klass.type];\n      bufs = (function() {\n        var _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = vals.length; _i < _len; _i++) {\n          x = vals[_i];\n          _results.push(uint_to_buffer(8, x));\n        }\n        return _results;\n      })();\n      if (window.custom_keyid) {\n        for (i = 0; i <= window.custom_keyid.length; i++) {\n            this.key_id[i] = window.custom_keyid[i];\n        }\n      }\n      bufs.push(this.key_id);\n      bufs.push(uint_to_buffer(8, this.is_final));\n      console.info(\"buffs final\", bufs);\n      unframed = Buffer.concat(bufs);\n      return cb(null, unframed);\n    };\n\n    OnePassSignature.prototype.write = function(cb) {\n      var err, framed, unframed, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/packet/one_pass_sig.iced\",\n            funcname: \"OnePassSignature.write\"\n          });\n          _this.write_unframed(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return unframed = arguments[1];\n              };\n            })(),\n            lineno: 38\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          framed = _this.frame_packet(C.packet_tags.one_pass_sig, unframed);\n          return cb(err, framed);\n        };\n      })(this));\n    };\n\n    return OnePassSignature;\n\n  })(Packet);\n\n  OPS_Parser = (function() {\n    function OPS_Parser(slice) {\n      this.slice = slice;\n    }\n\n    OPS_Parser.prototype.parse = function() {\n      var hasher, is_final, key_id, sig_klass, sig_type, v;\n      if ((v = this.slice.read_uint8()) !== C.versions.one_pass_sig) {\n        throw new Error(\"Unknown OnePassSignature version \" + v);\n      }\n      sig_type = this.slice.read_uint8();\n      hasher = hash.alloc_or_throw(this.slice.read_uint8());\n      sig_klass = asymmetric.get_class(this.slice.read_uint8());\n      key_id = this.slice.read_buffer(8);\n      is_final = this.slice.read_uint8();\n      return new OnePassSignature({\n        sig_type: sig_type,\n        hasher: hasher,\n        sig_klass: sig_klass,\n        key_id: key_id,\n        is_final: is_final\n      });\n    };\n\n    return OPS_Parser;\n\n  })();\n\n  exports.OnePassSignature = OnePassSignature;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../../asymmetric\":1,\"../../const\":5,\"../../hash\":14,\"../../util\":70,\"./base\":45,\"buffer\":80,\"iced-runtime\":118}],51:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var Base, Collection, Data, SelfSig, SubkeyBinding,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  Base = (function() {\n    function Base(_arg) {\n      this.sig = _arg.sig;\n    }\n\n    Base.prototype.typ = function() {\n      return \"none\";\n    };\n\n    Base.prototype.get_key_flags = function() {\n      return this.sig.get_key_flags();\n    };\n\n    return Base;\n\n  })();\n\n  SelfSig = (function(_super) {\n    __extends(SelfSig, _super);\n\n    function SelfSig(_arg) {\n      var sig;\n      this.userid = _arg.userid, this.user_attribute = _arg.user_attribute, this.type = _arg.type, sig = _arg.sig, this.options = _arg.options;\n      SelfSig.__super__.constructor.call(this, {\n        sig: sig\n      });\n    }\n\n    SelfSig.prototype.typ = function() {\n      return \"self_sig\";\n    };\n\n    return SelfSig;\n\n  })(Base);\n\n  SubkeyBinding = (function(_super) {\n    __extends(SubkeyBinding, _super);\n\n    SubkeyBinding.UP = 1;\n\n    SubkeyBinding.DOWN = 2;\n\n    function SubkeyBinding(_arg) {\n      var sig;\n      this.primary = _arg.primary, sig = _arg.sig, this.direction = _arg.direction;\n      SubkeyBinding.__super__.constructor.call(this, {\n        sig: sig\n      });\n    }\n\n    SubkeyBinding.prototype.typ = function() {\n      return \"subkey_binding\";\n    };\n\n    SubkeyBinding.prototype.is_down = function() {\n      return this.direction === SubkeyBinding.DOWN;\n    };\n\n    return SubkeyBinding;\n\n  })(Base);\n\n  Data = (function(_super) {\n    __extends(Data, _super);\n\n    function Data(_arg) {\n      var sig;\n      this.key = _arg.key, sig = _arg.sig;\n      Data.__super__.constructor.call(this, {\n        sig: sig\n      });\n    }\n\n    Data.prototype.typ = function() {\n      return \"data\";\n    };\n\n    Data.prototype.get_key_manager = function() {\n      var _ref;\n      return (_ref = this.sig) != null ? _ref.key_manager : void 0;\n    };\n\n    return Data;\n\n  })(Base);\n\n  Collection = (function() {\n    function Collection() {\n      this.all = [];\n      this.lookup = {\n        self_sig: [],\n        subkey_binding: [],\n        data: []\n      };\n    }\n\n    Collection.prototype.push = function(ps) {\n      this.all.push(ps);\n      return this.lookup[ps.typ()].push(ps);\n    };\n\n    Collection.prototype.is_signed_subkey_of = function(primary) {\n      var skb, _i, _len, _ref;\n      _ref = this.lookup.subkey_binding;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        skb = _ref[_i];\n        if (skb.primary.equal(primary) && skb.is_down()) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    Collection.prototype.get_all_key_flags = function() {\n      var p, ret, _i, _len, _ref;\n      ret = 0;\n      _ref = this.all;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        p = _ref[_i];\n        ret |= p.get_key_flags();\n      }\n      return ret;\n    };\n\n    Collection.prototype.get_signed_userids = function() {\n      var p, u, _i, _len, _ref, _results;\n      _ref = this.lookup.self_sig;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        p = _ref[_i];\n        if ((u = p.userid) != null) {\n          _results.push(u);\n        }\n      }\n      return _results;\n    };\n\n    Collection.prototype.get_signed_user_attributes = function() {\n      var p, u, _i, _len, _ref, _results;\n      _ref = this.lookup.self_sig;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        p = _ref[_i];\n        if ((u = p.user_attribute) != null) {\n          _results.push(u);\n        }\n      }\n      return _results;\n    };\n\n    Collection.prototype.get_self_sig = function() {\n      if (this.lookup.self_sig.length) {\n        return this.lookup.self_sig[0];\n      } else {\n        return null;\n      }\n    };\n\n    Collection.prototype.get_self_sigs = function() {\n      return this.lookup.self_sig;\n    };\n\n    Collection.prototype.is_self_signed = function() {\n      return this.get_signed_userids().length > 0;\n    };\n\n    Collection.prototype.get_data_signer = function() {\n      if (this.lookup.data.length > 0) {\n        return this.lookup.data[0];\n      } else {\n        return null;\n      }\n    };\n\n    Collection.prototype.get_data_signers = function() {\n      return this.lookup.data;\n    };\n\n    Collection.prototype.get_subkey_binding = function() {\n      if (this.lookup.subkey_binding.length) {\n        return this.lookup.subkey_binding[0];\n      } else {\n        return null;\n      }\n    };\n\n    return Collection;\n\n  })();\n\n  exports.SelfSig = SelfSig;\n\n  exports.SubkeyBinding = SubkeyBinding;\n\n  exports.Data = Data;\n\n  exports.Collection = Collection;\n\n}).call(this);\n\n},{}],52:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var ASP, C, Decryptor, MDC, MDC_Parser, PKESK, PKESK_Parser, Packet, SEIPD, SEIPD_Parser, SHA1, asymmetric, bufeq_fast, bufeq_secure, encrypt, iced, make_esc, streamers, uint_to_buffer, __iced_k, __iced_k_noop, _ref, _ref1, _ref2,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  Packet = require('./base').Packet;\n\n  C = require('../../const').openpgp;\n\n  asymmetric = require('../../asymmetric');\n\n  _ref = require('../../hash'), SHA1 = _ref.SHA1, streamers = _ref.streamers;\n\n  _ref1 = require('../../util'), uint_to_buffer = _ref1.uint_to_buffer, bufeq_secure = _ref1.bufeq_secure, bufeq_fast = _ref1.bufeq_fast;\n\n  _ref2 = require('../ocfb'), encrypt = _ref2.encrypt, Decryptor = _ref2.Decryptor;\n\n  ASP = require('pgp-utils').util.ASP;\n\n  make_esc = require('iced-error').make_esc;\n\n  PKESK = (function(_super) {\n    __extends(PKESK, _super);\n\n    function PKESK(_arg) {\n      this.crypto_type = _arg.crypto_type, this.key_id = _arg.key_id, this.ekey = _arg.ekey;\n    }\n\n    PKESK.parse = function(slice) {\n      return (new PKESK_Parser(slice)).parse();\n    };\n\n    PKESK.prototype.to_esk_packet = function() {\n      return this;\n    };\n\n    PKESK.prototype.get_key_id = function() {\n      return this.key_id;\n    };\n\n    PKESK.prototype.write_unframed = function(cb) {\n      var bufs, err, ret;\n      bufs = [uint_to_buffer(8, C.versions.PKESK), this.key_id, uint_to_buffer(8, this.crypto_type), this.ekey.output()];\n      ret = Buffer.concat(bufs);\n      err = null;\n      return cb(err, ret);\n    };\n\n    PKESK.prototype.write = function(cb) {\n      var err, ret, unframed, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced\",\n            funcname: \"PKESK.write\"\n          });\n          _this.write_unframed(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return unframed = arguments[1];\n              };\n            })(),\n            lineno: 36\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (typeof err === \"undefined\" || err === null) {\n            ret = _this.frame_packet(C.packet_tags.PKESK, unframed);\n          }\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    return PKESK;\n\n  })(Packet);\n\n  SEIPD = (function(_super) {\n    __extends(SEIPD, _super);\n\n    function SEIPD(_arg) {\n      this.ciphertext = _arg.ciphertext;\n    }\n\n    SEIPD.parse = function(slice) {\n      return (new SEIPD_Parser(slice)).parse();\n    };\n\n    SEIPD.prototype.to_enc_data_packet = function() {\n      return this;\n    };\n\n    SEIPD.prototype.check = function() {};\n\n    SEIPD.prototype.decrypt = function(_arg, cb) {\n      var asp, cipher, eng, err, esc, mdc, plaintext, prefix, pt, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      cipher = _arg.cipher, asp = _arg.asp;\n      eng = new Decryptor({\n        cipher: cipher,\n        ciphertext: this.ciphertext,\n        asp: asp\n      });\n      esc = make_esc(cb, \"SEIPD::decrypt\");\n      asp = ASP.make(asp);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced\",\n            funcname: \"SEIPD.decrypt\"\n          });\n          eng.check(esc(__iced_deferrals.defer({\n            lineno: 63\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced\",\n              funcname: \"SEIPD.decrypt\"\n            });\n            eng.dec(esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return pt = arguments[0];\n                };\n              })(),\n              lineno: 64\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            var _ref3;\n            _ref3 = MDC.parse(pt), mdc = _ref3[0], plaintext = _ref3[1];\n            prefix = eng.get_prefix();\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced\",\n                funcname: \"SEIPD.decrypt\"\n              });\n              mdc.compute({\n                prefix: prefix,\n                plaintext: plaintext,\n                asp: asp\n              }, esc(__iced_deferrals.defer({\n                lineno: 70\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              err = mdc.check() ? null : new Error(\"MDC mismatch\");\n              return cb(err, plaintext);\n            });\n          });\n        };\n      })(this));\n    };\n\n    SEIPD.prototype.encrypt = function(_arg, cb) {\n      var asp, cipher, esc, mdc, mdc_buf, plaintext, prefixrandom, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      cipher = _arg.cipher, plaintext = _arg.plaintext, prefixrandom = _arg.prefixrandom, asp = _arg.asp;\n      mdc = new MDC({});\n      esc = make_esc(cb, \"SEIPD::encrypt\");\n      asp = ASP.make(asp);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced\",\n            funcname: \"SEIPD.encrypt\"\n          });\n          mdc.compute({\n            plaintext: plaintext,\n            prefix: prefixrandom,\n            asp: asp\n          }, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return mdc_buf = arguments[0];\n              };\n            })(),\n            lineno: 81\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          plaintext = Buffer.concat([plaintext, MDC.header, mdc_buf]);\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced\",\n              funcname: \"SEIPD.encrypt\"\n            });\n            encrypt({\n              cipher: cipher,\n              plaintext: plaintext,\n              prefixrandom: prefixrandom\n            }, esc(__iced_deferrals.defer({\n              assign_fn: (function(__slot_1) {\n                return function() {\n                  return __slot_1.ciphertext = arguments[0];\n                };\n              })(_this),\n              lineno: 83\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            return cb(null);\n          });\n        };\n      })(this));\n    };\n\n    SEIPD.prototype.write_unframed = function(cb) {\n      var err, ret;\n      err = ret = null;\n      ret = Buffer.concat([uint_to_buffer(8, C.versions.SEIPD), this.ciphertext]);\n      return cb(err, ret);\n    };\n\n    SEIPD.prototype.write = function(cb) {\n      var err, ret, unframed, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      ret = err = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced\",\n            funcname: \"SEIPD.write\"\n          });\n          _this.write_unframed(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return unframed = arguments[1];\n              };\n            })(),\n            lineno: 97\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (err == null) {\n            ret = _this.frame_packet(C.packet_tags.SEIPD, unframed);\n          }\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    return SEIPD;\n\n  })(Packet);\n\n  MDC = (function(_super) {\n    __extends(MDC, _super);\n\n    MDC.header = new Buffer([0xc0 | C.packet_tags.MDC, SHA1.output_length]);\n\n    MDC.prototype.header = MDC.header;\n\n    function MDC(_arg) {\n      this.digest = _arg.digest;\n    }\n\n    MDC.parse = function(buf) {\n      return (new MDC_Parser(buf)).parse();\n    };\n\n    MDC.prototype.compute = function(_arg, cb) {\n      var asp, esc, hasher, i, plaintext, prefix, step, ___iced_passed_deferral, __iced_deferrals, __iced_k, _begin, _end, _positive;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      plaintext = _arg.plaintext, prefix = _arg.prefix, asp = _arg.asp;\n      asp = ASP.make(asp);\n      hasher = streamers.SHA1();\n      hasher.update(Buffer.concat([prefix, prefix.slice(-2)]));\n      esc = make_esc(cb, \"MDC::compute\");\n      step = 0x100000;\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _results, _while;\n          i = 0;\n          _begin = 0;\n          _end = plaintext.length;\n          _positive = _end > _begin;\n          _results = [];\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = function() {\n              return __iced_k(_results);\n            };\n            _continue = function() {\n              return iced.trampoline(function() {\n                if (_positive) {\n                  i += step;\n                } else {\n                  i -= step;\n                }\n                return _while(__iced_k);\n              });\n            };\n            _next = function(__iced_next_arg) {\n              _results.push(__iced_next_arg);\n              return _continue();\n            };\n            if (!!((_positive === true && i >= plaintext.length) || (_positive === false && i <= plaintext.length))) {\n              return _break();\n            } else {\n\n              hasher.update(plaintext.slice(i, i + step));\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced\",\n                  funcname: \"MDC.compute\"\n                });\n                asp.progress({\n                  what: \"MDC\",\n                  total: plaintext.length,\n                  i: i\n                }, esc(__iced_deferrals.defer({\n                  lineno: 122\n                })));\n                __iced_deferrals._fulfill();\n              })(_next);\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          hasher.update(_this.header);\n          _this.computed = hasher();\n          return cb(null, _this.computed);\n        };\n      })(this));\n    };\n\n    MDC.prototype.check = function() {\n      return bufeq_secure(this.digest, this.computed);\n    };\n\n    return MDC;\n\n  })(Packet);\n\n  MDC_Parser = (function() {\n    function MDC_Parser(buf) {\n      this.buf = buf;\n    }\n\n    MDC_Parser.prototype.parse = function() {\n      var chunk, digest, hl, len, rem;\n      hl = MDC.header.length;\n      len = SHA1.output_length + hl;\n      rem = this.buf.slice(0, -len);\n      chunk = this.buf.slice(-len);\n      if (!bufeq_fast(chunk.slice(0, hl), MDC.header)) {\n        throw new Error('Missing MDC header');\n      }\n      digest = chunk.slice(hl);\n      return [\n        new MDC({\n          digest: digest\n        }), rem\n      ];\n    };\n\n    return MDC_Parser;\n\n  })();\n\n  SEIPD_Parser = (function() {\n    function SEIPD_Parser(slice) {\n      this.slice = slice;\n    }\n\n    SEIPD_Parser.prototype.payload_split = function(raw) {};\n\n    SEIPD_Parser.prototype.parse = function() {\n      var ciphertext, v;\n      if ((v = this.slice.read_uint8()) !== C.versions.SEIPD) {\n        throw new Error(\"Unknown SEIPD version \" + v);\n      }\n      ciphertext = this.slice.consume_rest_to_buffer();\n      return new SEIPD({\n        ciphertext: ciphertext\n      });\n    };\n\n    return SEIPD_Parser;\n\n  })();\n\n  PKESK_Parser = (function() {\n    function PKESK_Parser(slice) {\n      this.slice = slice;\n    }\n\n    PKESK_Parser.prototype.parse = function() {\n      var crypto_type, ekey, key_id, klass, v;\n      if ((v = this.slice.read_uint8()) !== C.versions.PKESK) {\n        throw new Error(\"Unknown PKESK version: \" + v);\n      }\n      key_id = this.slice.read_buffer(8);\n      crypto_type = this.slice.read_uint8();\n      klass = asymmetric.get_class(crypto_type);\n      ekey = klass.parse_output(this.slice.consume_rest_to_buffer());\n      return new PKESK({\n        crypto_type: crypto_type,\n        key_id: key_id,\n        ekey: ekey\n      });\n    };\n\n    return PKESK_Parser;\n\n  })();\n\n  exports.SEIPD = SEIPD;\n\n  exports.PKESK = PKESK;\n\n  exports.MDC = MDC;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../../asymmetric\":1,\"../../const\":5,\"../../hash\":14,\"../../util\":70,\"../ocfb\":43,\"./base\":45,\"buffer\":80,\"iced-error\":115,\"iced-runtime\":118,\"pgp-utils\":163}],53:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, CreationTime, EmbeddedSignature, Experimental, ExpirationTime, Exportable, Features, Issuer, KeyExpirationTime, KeyFlags, KeyServerPreferences, NotationData, Packet, Parser, PolicyURI, Preference, PreferredCompressionAlgorithms, PreferredHashAlgorithms, PreferredKeyServer, PreferredSymmetricAlgorithms, PrimaryUserId, ReasonForRevocation, RegularExpression, Revocable, RevocationKey, S, SHA1, SHA512, Signature, SignatureTarget, Signature_v2, Signature_v2_or_v3, Signature_v3, SignersUserID, SlicerBuffer, SubPacket, Time, Trust, alloc_or_throw, assert, asymmetric, encode_length, iced, make_esc, make_time_packet, packetsigs, uint_to_buffer, unix_time, util, __iced_k, __iced_k_noop, _ref, _ref1, _ref2,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  Packet = require('./base').Packet;\n\n  C = require('../../const').openpgp;\n\n  S = C.sig_subpacket;\n\n  _ref = require('../util'), encode_length = _ref.encode_length, make_time_packet = _ref.make_time_packet;\n\n  _ref1 = require('../../util'), unix_time = _ref1.unix_time, uint_to_buffer = _ref1.uint_to_buffer;\n\n  _ref2 = require('../../hash'), alloc_or_throw = _ref2.alloc_or_throw, SHA512 = _ref2.SHA512, SHA1 = _ref2.SHA1;\n\n  asymmetric = require('../../asymmetric');\n\n  util = require('util');\n\n  packetsigs = require('./packetsigs');\n\n  assert = require('assert');\n\n  SlicerBuffer = require('../buffer').SlicerBuffer;\n\n  make_esc = require('iced-error').make_esc;\n\n  Signature_v2_or_v3 = (function(_super) {\n    __extends(Signature_v2_or_v3, _super);\n\n    function Signature_v2_or_v3(_arg) {\n      this.key = _arg.key, this.hasher = _arg.hasher, this.key_id = _arg.key_id, this.sig_data = _arg.sig_data, this.public_key_class = _arg.public_key_class, this.signed_hash_value_hash = _arg.signed_hash_value_hash, this.time = _arg.time, this.sig = _arg.sig, this.type = _arg.type, this.version = _arg.version;\n      if (this.hasher == null) {\n        this.hasher = SHA512;\n      }\n      this._framed_output = null;\n    }\n\n    Signature_v2_or_v3.prototype.is_signature = function() {\n      return true;\n    };\n\n    Signature_v2_or_v3.prototype.get_key_id = function() {\n      return this.key_id;\n    };\n\n    Signature_v2_or_v3.prototype.get_issuer_key_id = function() {\n      return this.key_id;\n    };\n\n    Signature_v2_or_v3.prototype.when_generated = function() {\n      return this.time;\n    };\n\n    Signature_v2_or_v3.prototype.time_of_primary_uid_sig = function() {\n      return null;\n    };\n\n    Signature_v2_or_v3.prototype.gen_prefix = function() {\n      return Buffer.concat([new Buffer([C.versions.signature.V3, this.type], uint_to_buffer(32, this.time), this.key_id, new Buffer([this.key.type, this.hasher.type]))]);\n    };\n\n    Signature_v2_or_v3.prototype.prepare_payload = function(data_packets) {\n      var bufs, dp;\n      bufs = (function() {\n        var _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = data_packets.length; _i < _len; _i++) {\n          dp = data_packets[_i];\n          _results.push(dp.to_signature_payload());\n        }\n        return _results;\n      })();\n      bufs.push(new Buffer([this.type]), uint_to_buffer(32, this.time));\n      return Buffer.concat(bufs);\n    };\n\n    Signature_v2_or_v3.prototype.verify = function(data_packets, cb) {\n      var T, b, d, err, hash, payload, s, v, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      payload = this.prepare_payload(data_packets);\n      hash = this.hasher(payload);\n      s = new SlicerBuffer(hash);\n      v = s.read_uint16();\n      T = C.sig_types;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (v !== (b = _this.signed_hash_value_hash)) {\n            return __iced_k(err = new Error(\"quick hash check failed: \" + v + \" != \" + b));\n          } else {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/signature.iced\",\n                funcname: \"Signature_v2_or_v3.verify\"\n              });\n              _this.key.verify_unpad_and_check_hash({\n                hash: hash,\n                hasher: _this.hasher,\n                sig: _this.sig\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return err = arguments[0];\n                  };\n                })(),\n                lineno: 76\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              var _i, _len, _ref3;\n              if ((err == null) && ((_ref3 = _this.type) === T.binary_doc || _ref3 === T.canonical_text)) {\n                for (_i = 0, _len = data_packets.length; _i < _len; _i++) {\n                  d = data_packets[_i];\n                  d.push_sig(new packetsigs.Data({\n                    sig: _this\n                  }));\n                }\n              }\n              return __iced_k();\n            });\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    return Signature_v2_or_v3;\n\n  })(Packet);\n\n  Signature_v2 = (function(_super) {\n    __extends(Signature_v2, _super);\n\n    function Signature_v2() {\n      return Signature_v2.__super__.constructor.apply(this, arguments);\n    }\n\n    return Signature_v2;\n\n  })(Signature_v2_or_v3);\n\n  Signature_v3 = (function(_super) {\n    __extends(Signature_v3, _super);\n\n    function Signature_v3() {\n      return Signature_v3.__super__.constructor.apply(this, arguments);\n    }\n\n    return Signature_v3;\n\n  })(Signature_v2_or_v3);\n\n  Signature = (function(_super) {\n    __extends(Signature, _super);\n\n    function Signature(_arg) {\n      this.key = _arg.key, this.hasher = _arg.hasher, this.key_id = _arg.key_id, this.sig_data = _arg.sig_data, this.public_key_class = _arg.public_key_class, this.signed_hash_value_hash = _arg.signed_hash_value_hash, this.hashed_subpackets = _arg.hashed_subpackets, this.time = _arg.time, this.sig = _arg.sig, this.type = _arg.type, this.unhashed_subpackets = _arg.unhashed_subpackets, this.version = _arg.version;\n      if (this.hasher == null) {\n        this.hasher = SHA512;\n      }\n      if (this.hashed_subpackets == null) {\n        this.hashed_subpackets = [];\n      }\n      if (this.unhashed_subpackets == null) {\n        this.unhashed_subpackets = [];\n      }\n      this.subpacket_index = this._make_subpacket_index();\n      this._framed_output = null;\n    }\n\n    Signature.prototype.get_key_id = function() {\n      var _ref3;\n      if (this.key_id) {\n        return this.key_id;\n      } else {\n        return (_ref3 = this.subpacket_index.all[S.issuer]) != null ? _ref3.id : void 0;\n      }\n    };\n\n    Signature.prototype._make_subpacket_index = function() {\n      var p, ret, _i, _j, _len, _len1, _ref3, _ref4;\n      ret = {\n        hashed: {},\n        unhashed: {},\n        all: {}\n      };\n      _ref3 = this.hashed_subpackets;\n      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n        p = _ref3[_i];\n        ret.hashed[p.type] = p;\n        ret.all[p.type] = p;\n      }\n      _ref4 = this.unhashed_subpackets;\n      for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {\n        p = _ref4[_j];\n        ret.unhashed[p.type] = p;\n        ret.all[p.type] = p;\n      }\n      return ret;\n    };\n\n    Signature.prototype.prepare_payload = function(data) {\n      var flatsp, hvalue, payload, prefix, s, trailer;\n      flatsp = Buffer.concat((function() {\n        var _i, _len, _ref3, _results;\n        _ref3 = this.hashed_subpackets;\n        _results = [];\n        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n          s = _ref3[_i];\n          _results.push(s.to_buffer());\n        }\n        return _results;\n      }).call(this));\n      prefix = Buffer.concat([new Buffer([C.versions.signature.V4, this.type, this.key.type, this.hasher.type]), uint_to_buffer(16, flatsp.length), flatsp]);\n      trailer = Buffer.concat([new Buffer([C.versions.signature.V4, 0xff]), uint_to_buffer(32, prefix.length)]);\n      payload = Buffer.concat([data, prefix, trailer]);\n      hvalue = this.hasher(payload);\n      return {\n        prefix: prefix,\n        payload: payload,\n        hvalue: hvalue\n      };\n    };\n\n    Signature.prototype.write_unframed = function(data, cb) {\n      var esc, hvalue, payload, prefix, result2, results, s, sig, uhsp, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref3;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"write_unframed\");\n      uhsp = Buffer.concat((function() {\n        var _i, _len, _ref3, _results;\n        _ref3 = this.unhashed_subpackets;\n        _results = [];\n        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n          s = _ref3[_i];\n          _results.push(s.to_buffer());\n        }\n        return _results;\n      }).call(this));\n      _ref3 = this.prepare_payload(data), prefix = _ref3.prefix, payload = _ref3.payload, hvalue = _ref3.hvalue;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/signature.iced\",\n            funcname: \"Signature.write_unframed\"\n          });\n          _this.key.pad_and_sign(payload, {\n            hasher: _this.hasher\n          }, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return sig = arguments[0];\n              };\n            })(),\n            lineno: 154\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          console.info(\"uhsp\" + uhsp.toString('hex'));\n          if (window.custom_keyid) {\n            console.info(\"custom_keyid\" + window.custom_keyid.toString('hex'));\n            for (i = 0; i <= window.custom_keyid.length; i++) {\n                uhsp[i+2] = window.custom_keyid[i];\n            }\n            console.info(\"custom uhsp\" + uhsp.toString('hex'));\n          }\n          result2 = Buffer.concat([uint_to_buffer(16, uhsp.length), uhsp, new Buffer([hvalue.readUInt8(0), hvalue.readUInt8(1)]), sig]);\n          results = Buffer.concat([prefix, result2]);\n          console.info(\"results\" + results.toString('hex'));\n          return cb(null, results);\n        };\n      })(this));\n    };\n\n    Signature.prototype.write = function(data, cb) {\n      var err, ret, unframed, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/signature.iced\",\n            funcname: \"Signature.write\"\n          });\n          _this.write_unframed(data, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return unframed = arguments[1];\n              };\n            })(),\n            lineno: 167\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (typeof err === \"undefined\" || err === null) {\n            _this._framed_output = ret = _this.frame_packet(C.packet_tags.signature, unframed);\n          }\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    Signature.prototype.get_framed_output = function() {\n      return this._framed_output || this.replay();\n    };\n\n    Signature.parse = function(slice) {\n      return (new Parser(slice)).parse();\n    };\n\n    Signature.prototype.extract_key = function(data_packets) {\n      var p, _i, _len, _results;\n      _results = [];\n      for (_i = 0, _len = data_packets.length; _i < _len; _i++) {\n        p = data_packets[_i];\n        if (p.key != null) {\n          this.key = p.key;\n          break;\n        } else {\n          _results.push(void 0);\n        }\n      }\n      return _results;\n    };\n\n    Signature.prototype.verify = function(data_packets, cb, opts) {\n      var err, p, s, subkey, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/signature.iced\",\n            funcname: \"Signature.verify\"\n          });\n          _this._verify(data_packets, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 196\n          }), opts);\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            var _i, _len, _ref3, _results, _while;\n            _ref3 = _this.unhashed_subpackets;\n            _len = _ref3.length;\n            _i = 0;\n            _results = [];\n            _while = function(__iced_k) {\n              var _break, _continue, _next;\n              _break = function() {\n                return __iced_k(_results);\n              };\n              _continue = function() {\n                return iced.trampoline(function() {\n                  ++_i;\n                  return _while(__iced_k);\n                });\n              };\n              _next = function(__iced_next_arg) {\n                _results.push(__iced_next_arg);\n                return _continue();\n              };\n              if (!(_i < _len)) {\n                return _break();\n              } else {\n                p = _ref3[_i];\n                if ((typeof err === \"undefined\" || err === null) && ((s = p.to_sig()) != null)) {\n                  (function(__iced_k) {\n                    if (s.type !== C.sig_types.primary_binding) {\n                      return __iced_k(err = new Error(\"unknown subpacket signature type: \" + s.type));\n                    } else {\n                      (function(__iced_k) {\n                        if (data_packets.length !== 1) {\n                          return __iced_k(err = new Error(\"Needed 1 data packet for a primary_binding signature\"));\n                        } else {\n                          subkey = data_packets[0];\n                          s.primary = _this.primary;\n                          s.key = subkey.key;\n                          (function(__iced_k) {\n                            __iced_deferrals = new iced.Deferrals(__iced_k, {\n                              parent: ___iced_passed_deferral,\n                              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/signature.iced\",\n                              funcname: \"Signature.verify\"\n                            });\n                            s._verify([subkey], __iced_deferrals.defer({\n                              assign_fn: (function() {\n                                return function() {\n                                  return err = arguments[0];\n                                };\n                              })(),\n                              lineno: 206\n                            }), opts);\n                            __iced_deferrals._fulfill();\n                          })(__iced_k);\n                        }\n                      })(__iced_k);\n                    }\n                  })(_next);\n                } else {\n                  return _continue();\n                }\n              }\n            };\n            _while(__iced_k);\n          })(function() {\n            return cb(err);\n          });\n        };\n      })(this));\n    };\n\n    Signature.prototype._verify = function(data_packets, cb, opts) {\n      var SKB, T, buffers, d, data, dp, err, hvalue, n, packets, payload, ps, sig, subkey, user_attribute, userid, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = null;\n      T = C.sig_types;\n      subkey = null;\n      this.data_packets = (function() {\n        switch (this.type) {\n          case T.binary_doc:\n          case T.canonical_text:\n            return data_packets;\n          case T.issuer:\n          case T.personal:\n          case T.casual:\n          case T.positive:\n          case T.certificate_revocation:\n            if ((n = data_packets.length) !== 1) {\n              err = new Error(\"Only expecting one UserID-style packet in a self-sig (got \" + n + \")\");\n              return [];\n            } else {\n              return [this.primary].concat(data_packets);\n            }\n            break;\n          case T.subkey_binding:\n          case T.primary_binding:\n          case T.subkey_revocation:\n            packets = [];\n            if (data_packets.length !== 1) {\n              err = new Error(\"Wrong number of data packets; expected only 1\");\n            } else if (this.primary == null) {\n              err = new Error(\"Need a primary key for subkey signature\");\n            } else {\n              subkey = data_packets[0];\n              packets = [this.primary, subkey];\n            }\n            return packets;\n          case T.direct:\n            return [this.primary].concat(data_packets);\n          default:\n            err = new Error(\"cannot verify sigtype \" + this.type);\n            return [];\n        }\n      }).call(this);\n      (function(_this) {\n        return (function(__iced_k) {\n          var _ref3;\n          if (err == null) {\n            buffers = (function() {\n              var _i, _len, _ref3, _results;\n              _ref3 = this.data_packets;\n              _results = [];\n              for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n                dp = _ref3[_i];\n                _results.push(dp.to_signature_payload());\n              }\n              return _results;\n            }).call(_this);\n            data = Buffer.concat(buffers);\n            _ref3 = _this.prepare_payload(data), payload = _ref3.payload, hvalue = _ref3.hvalue;\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/signature.iced\",\n                funcname: \"Signature._verify\"\n              });\n              _this.key.verify_unpad_and_check_hash({\n                sig: _this.sig,\n                hash: hvalue,\n                hasher: _this.hasher\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return err = arguments[0];\n                  };\n                })(),\n                lineno: 256\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          var _i, _len, _ref3;\n          if (err == null) {\n            err = _this._check_key_sig_expiration(opts);\n          }\n          sig = _this;\n          if (err == null) {\n            SKB = packetsigs.SubkeyBinding;\n            switch (_this.type) {\n              case T.binary_doc:\n              case T.canonical_text:\n                _ref3 = _this.data_packets;\n                for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n                  d = _ref3[_i];\n                  d.push_sig(new packetsigs.Data({\n                    sig: sig\n                  }));\n                }\n                break;\n              case T.issuer:\n              case T.personal:\n              case T.casual:\n              case T.positive:\n                ps = null;\n                if ((userid = _this.data_packets[1].to_userid()) != null) {\n                  ps = new packetsigs.SelfSig({\n                    type: _this.type,\n                    userid: userid,\n                    sig: sig\n                  });\n                  userid.push_sig(ps);\n                } else if ((user_attribute = _this.data_packets[1].to_user_attribute()) != null) {\n                  ps = new packetsigs.SelfSig({\n                    type: _this.type,\n                    user_attribute: user_attribute,\n                    sig: sig\n                  });\n                  user_attribute.push_sig(ps);\n                }\n                if (ps) {\n                  _this.primary.push_sig(ps);\n                }\n                break;\n              case T.subkey_binding:\n                subkey.push_sig(new SKB({\n                  primary: _this.primary,\n                  sig: sig,\n                  direction: SKB.DOWN\n                }));\n                break;\n              case T.primary_binding:\n                subkey.push_sig(new SKB({\n                  primary: _this.primary,\n                  sig: sig,\n                  direction: SKB.UP\n                }));\n                break;\n              case T.subkey_revocation:\n                subkey.mark_revoked(sig);\n            }\n          }\n          return cb(err);\n        };\n      })(this));\n    };\n\n    Signature.prototype.is_signature = function() {\n      return true;\n    };\n\n    Signature.prototype.when_generated = function() {\n      var _ref3;\n      return (_ref3 = this.subpacket_index.hashed[S.creation_time]) != null ? _ref3.time : void 0;\n    };\n\n    Signature.prototype.time_primary_pair = function() {\n      var T, _ref3, _ref4;\n      T = C.sig_types;\n      if ((_ref3 = this.type) === T.issuer || _ref3 === T.personal || _ref3 === T.casual || _ref3 === T.positive) {\n        return [this.when_generated(), !!((_ref4 = this.subpacket_index.hashed[S.primary_user_id]) != null ? _ref4.flag : void 0)];\n      } else {\n        return null;\n      }\n    };\n\n    Signature.prototype._check_key_sig_expiration = function(opts) {\n      var T, creation, err, expiration, n, now, _ref3;\n      err = null;\n      T = C.sig_types;\n      if ((_ref3 = this.type) === T.issuer || _ref3 === T.personal || _ref3 === T.casual || _ref3 === T.positive || _ref3 === T.subkey_binding || _ref3 === T.primary_binding) {\n        creation = this.subpacket_index.hashed[S.creation_time];\n        expiration = this.subpacket_index.hashed[S.key_expiration_time];\n        now = (n = opts != null ? opts.now : void 0) != null ? n : unix_time();\n        if ((creation != null) && (expiration != null)) {\n          expiration = creation.time + expiration.time;\n          if ((now > expiration) && expiration !== 0) {\n            err = new Error(\"Key expired \" + (now - expiration) + \"s ago\");\n          }\n        }\n        if ((err == null) && ((expiration = this.subpacket_index.hashed[S.expiration_time]) != null) && (now > expiration.time) && expiration.time !== 0) {\n          err = new Error(\"Signature expired \" + (now - expiration.time) + \"s ago\");\n        }\n      }\n      return err;\n    };\n\n    Signature.prototype.get_key_flags = function() {\n      var _ref3, _ref4, _ref5;\n      return ((_ref3 = this.subpacket_index) != null ? (_ref4 = _ref3.hashed) != null ? (_ref5 = _ref4[C.sig_subpacket.key_flags]) != null ? _ref5.all_flags() : void 0 : void 0 : void 0) || 0;\n    };\n\n    Signature.prototype.get_issuer_key_id = function() {\n      var _ref3, _ref4;\n      return (_ref3 = this.subpacket_index) != null ? (_ref4 = _ref3.all[C.sig_subpacket.issuer]) != null ? _ref4.id : void 0 : void 0;\n    };\n\n    return Signature;\n\n  })(Packet);\n\n  SubPacket = (function() {\n    function SubPacket(type) {\n      this.type = type;\n      this.critical = false;\n      this.five_byte_len = false;\n    }\n\n    SubPacket.prototype.set_opts = function(d) {\n      var k, v;\n      for (k in d) {\n        v = d[k];\n        this[k] = v;\n      }\n      return true;\n    };\n\n    SubPacket.prototype.to_buffer = function() {\n      var inner;\n      inner = this._v_to_buffer();\n      return Buffer.concat([encode_length(inner.length + 1, this.five_byte_len), uint_to_buffer(8, this.type | (this.critical ? 0x80 : 0x00)), inner]);\n    };\n\n    SubPacket.prototype.to_sig = function() {\n      return null;\n    };\n\n    SubPacket.prototype.export_to_option = function() {\n      return null;\n    };\n\n    return SubPacket;\n\n  })();\n\n  Experimental = (function(_super) {\n    __extends(Experimental, _super);\n\n    function Experimental(buf, type) {\n      this.buf = buf;\n      this.type = type;\n    }\n\n    Experimental.parse = function(slice, type) {\n      return new Experimental(slice.consume_rest_to_buffer(), type);\n    };\n\n    Experimental.prototype._v_to_buffer = function() {\n      return this.buf;\n    };\n\n    return Experimental;\n\n  })(SubPacket);\n\n  Time = (function(_super) {\n    __extends(Time, _super);\n\n    function Time(type, time) {\n      this.time = time;\n      this.never_expires = this.time === 0;\n      Time.__super__.constructor.call(this, type);\n    }\n\n    Time.parse = function(slice, klass) {\n      return new klass(slice.read_uint32());\n    };\n\n    Time.prototype._v_to_buffer = function() {\n      return uint_to_buffer(32, this.time);\n    };\n\n    return Time;\n\n  })(SubPacket);\n\n  Preference = (function(_super) {\n    __extends(Preference, _super);\n\n    function Preference(type, v) {\n      var e, _i, _len, _ref3;\n      this.v = v;\n      Preference.__super__.constructor.call(this, type);\n      _ref3 = this.v;\n      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n        e = _ref3[_i];\n        assert(e != null);\n      }\n    }\n\n    Preference.parse = function(slice, klass) {\n      var c, v;\n      v = (function() {\n        var _i, _len, _ref3, _results;\n        _ref3 = slice.consume_rest_to_buffer();\n        _results = [];\n        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n          c = _ref3[_i];\n          _results.push(c);\n        }\n        return _results;\n      })();\n      return new klass(v);\n    };\n\n    Preference.prototype._v_to_buffer = function() {\n      var e;\n      return new Buffer((function() {\n        var _i, _len, _ref3, _results;\n        _ref3 = this.v;\n        _results = [];\n        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n          e = _ref3[_i];\n          _results.push(e);\n        }\n        return _results;\n      }).call(this));\n    };\n\n    return Preference;\n\n  })(SubPacket);\n\n  CreationTime = (function(_super) {\n    __extends(CreationTime, _super);\n\n    function CreationTime(t) {\n      CreationTime.__super__.constructor.call(this, S.creation_time, t);\n    }\n\n    CreationTime.parse = function(slice) {\n      return Time.parse(slice, CreationTime);\n    };\n\n    return CreationTime;\n\n  })(Time);\n\n  ExpirationTime = (function(_super) {\n    __extends(ExpirationTime, _super);\n\n    function ExpirationTime(t) {\n      ExpirationTime.__super__.constructor.call(this, S.expiration_time, t);\n    }\n\n    ExpirationTime.parse = function(slice) {\n      return Time.parse(slice, ExpirationTime);\n    };\n\n    return ExpirationTime;\n\n  })(Time);\n\n  Exportable = (function(_super) {\n    __extends(Exportable, _super);\n\n    function Exportable(flag) {\n      this.flag = flag;\n      Exportable.__super__.constructor.call(this, S.exportable_certificate);\n    }\n\n    Exportable.parse = function(slice) {\n      return new Exportable(slice.read_uint8());\n    };\n\n    Exportable.prototype._v_to_buffer = function() {\n      return uint_to_buffer(8, this.flag);\n    };\n\n    return Exportable;\n\n  })(SubPacket);\n\n  Trust = (function(_super) {\n    __extends(Trust, _super);\n\n    function Trust(level, amount) {\n      this.level = level;\n      this.amount = amount;\n      Trust.__super__.constructor.call(this, S.trust_signature);\n    }\n\n    Trust.parse = function(slice) {\n      return new Trust(slice.read_uint8(), slice.read_uint8());\n    };\n\n    Trust.prototype._v_to_buffer = function() {\n      return Buffer.concat([uint_to_buffer(8, this.level), uint_to_buffer(8, this.amount)]);\n    };\n\n    return Trust;\n\n  })(SubPacket);\n\n  RegularExpression = (function(_super) {\n    __extends(RegularExpression, _super);\n\n    function RegularExpression(re) {\n      this.re = re;\n      RegularExpression.__super__.constructor.call(this, S.regular_expression);\n    }\n\n    RegularExpression.parse = function(slice) {\n      var ret;\n      ret = new RegularExpression(slice.consume_rest_to_buffer().toString('utf8'));\n      return ret;\n    };\n\n    RegularExpression.prototype._v_to_buffer = function() {\n      return new Buffer(this.re, 'utf8');\n    };\n\n    return RegularExpression;\n\n  })(SubPacket);\n\n  Revocable = (function(_super) {\n    __extends(Revocable, _super);\n\n    function Revocable(flag) {\n      this.flag = flag;\n      Revocable.__super__.constructor.call(this, S.revocable);\n    }\n\n    Revocable.parse = function(slice) {\n      return new Revocable(slice.read_uint8());\n    };\n\n    Revocable.prototype._v_to_buffer = function() {\n      return uint_to_buffer(8, this.flag);\n    };\n\n    return Revocable;\n\n  })(SubPacket);\n\n  KeyExpirationTime = (function(_super) {\n    __extends(KeyExpirationTime, _super);\n\n    function KeyExpirationTime(t) {\n      KeyExpirationTime.__super__.constructor.call(this, S.key_expiration_time, t);\n    }\n\n    KeyExpirationTime.parse = function(slice) {\n      return Time.parse(slice, KeyExpirationTime);\n    };\n\n    return KeyExpirationTime;\n\n  })(Time);\n\n  PreferredSymmetricAlgorithms = (function(_super) {\n    __extends(PreferredSymmetricAlgorithms, _super);\n\n    function PreferredSymmetricAlgorithms(v) {\n      PreferredSymmetricAlgorithms.__super__.constructor.call(this, S.preferred_symmetric_algorithms, v);\n    }\n\n    PreferredSymmetricAlgorithms.parse = function(slice) {\n      return Preference.parse(slice, PreferredSymmetricAlgorithms);\n    };\n\n    return PreferredSymmetricAlgorithms;\n\n  })(Preference);\n\n  RevocationKey = (function(_super) {\n    __extends(RevocationKey, _super);\n\n    function RevocationKey(key_class, alg, fingerprint) {\n      this.key_class = key_class;\n      this.alg = alg;\n      this.fingerprint = fingerprint;\n      RevocationKey.__super__.constructor.call(this, S.revocation_key);\n    }\n\n    RevocationKey.parse = function(slice) {\n      var fp, ka, kc;\n      kc = slice.read_uint8();\n      ka = slice.read_uint8();\n      fp = slice.read_buffer(SHA1.output_length);\n      return new RevocationKey(kc, ka, fp);\n    };\n\n    RevocationKey.prototype._v_to_buffer = function() {\n      return Buffer.concat([uint_to_buffer(8, this.key_class), uint_to_buffer(8, this.alg), new Buffer(this.fingerprint)]);\n    };\n\n    return RevocationKey;\n\n  })(SubPacket);\n\n  Issuer = (function(_super) {\n    __extends(Issuer, _super);\n\n    function Issuer(id) {\n      this.id = id;\n      Issuer.__super__.constructor.call(this, S.issuer);\n    }\n\n    Issuer.parse = function(slice) {\n      return new Issuer(slice.read_buffer(8));\n    };\n\n    Issuer.prototype._v_to_buffer = function() {\n      return new Buffer(this.id);\n    };\n\n    return Issuer;\n\n  })(SubPacket);\n\n  NotationData = (function(_super) {\n    __extends(NotationData, _super);\n\n    function NotationData(flags, name, value) {\n      this.flags = flags;\n      this.name = name;\n      this.value = value;\n      NotationData.__super__.constructor.call(this, S.notation_data);\n    }\n\n    NotationData.parse = function(slice) {\n      var flags, name, nl, value, vl;\n      flags = slice.read_uint32();\n      nl = slice.read_uint16();\n      vl = slice.read_uint16();\n      name = slice.read_buffer(nl);\n      value = slice.read_buffer(vl);\n      return new NotationData(flags, name, value);\n    };\n\n    NotationData.prototype._v_to_buffer = function() {\n      return Buffer.concat([uint_to_buffer(32, this.flags), uint_to_buffer(16, this.name.length), uint_to_buffer(16, this.value.length), new Buffer(this.name), new Buffer(this.value)]);\n    };\n\n    return NotationData;\n\n  })(SubPacket);\n\n  PreferredHashAlgorithms = (function(_super) {\n    __extends(PreferredHashAlgorithms, _super);\n\n    function PreferredHashAlgorithms(v) {\n      PreferredHashAlgorithms.__super__.constructor.call(this, S.preferred_hash_algorithms, v);\n    }\n\n    PreferredHashAlgorithms.parse = function(slice) {\n      return Preference.parse(slice, PreferredHashAlgorithms);\n    };\n\n    return PreferredHashAlgorithms;\n\n  })(Preference);\n\n  PreferredCompressionAlgorithms = (function(_super) {\n    __extends(PreferredCompressionAlgorithms, _super);\n\n    function PreferredCompressionAlgorithms(v) {\n      PreferredCompressionAlgorithms.__super__.constructor.call(this, S.preferred_compression_algorithms, v);\n    }\n\n    PreferredCompressionAlgorithms.parse = function(slice) {\n      return Preference.parse(slice, PreferredCompressionAlgorithms);\n    };\n\n    return PreferredCompressionAlgorithms;\n\n  })(Preference);\n\n  KeyServerPreferences = (function(_super) {\n    __extends(KeyServerPreferences, _super);\n\n    function KeyServerPreferences(v) {\n      KeyServerPreferences.__super__.constructor.call(this, S.key_server_preferences, v);\n    }\n\n    KeyServerPreferences.parse = function(slice) {\n      return Preference.parse(slice, KeyServerPreferences);\n    };\n\n    return KeyServerPreferences;\n\n  })(Preference);\n\n  Features = (function(_super) {\n    __extends(Features, _super);\n\n    function Features(v) {\n      Features.__super__.constructor.call(this, S.features, v);\n    }\n\n    Features.parse = function(slice) {\n      return Preference.parse(slice, Features);\n    };\n\n    return Features;\n\n  })(Preference);\n\n  PreferredKeyServer = (function(_super) {\n    __extends(PreferredKeyServer, _super);\n\n    function PreferredKeyServer(server) {\n      this.server = server;\n      PreferredKeyServer.__super__.constructor.call(this, S.preferred_key_server);\n    }\n\n    PreferredKeyServer.parse = function(slice) {\n      return new PreferredKeyServer(slice.consume_rest_to_buffer());\n    };\n\n    PreferredKeyServer.prototype._v_to_buffer = function() {\n      return this.server;\n    };\n\n    return PreferredKeyServer;\n\n  })(SubPacket);\n\n  PrimaryUserId = (function(_super) {\n    __extends(PrimaryUserId, _super);\n\n    function PrimaryUserId(flag) {\n      this.flag = flag;\n      PrimaryUserId.__super__.constructor.call(this, S.primary_user_id);\n    }\n\n    PrimaryUserId.parse = function(slice) {\n      return new PrimaryUserId(slice.read_uint8());\n    };\n\n    PrimaryUserId.prototype._v_to_buffer = function() {\n      return uint_to_buffer(8, this.flag);\n    };\n\n    return PrimaryUserId;\n\n  })(SubPacket);\n\n  PolicyURI = (function(_super) {\n    __extends(PolicyURI, _super);\n\n    function PolicyURI(flag) {\n      this.flag = flag;\n      PolicyURI.__super__.constructor.call(this, S.policy_uri);\n    }\n\n    PolicyURI.parse = function(slice) {\n      return new PolicyURI(slice.consume_rest_to_buffer());\n    };\n\n    PolicyURI.prototype._v_to_buffer = function() {\n      return this.flag;\n    };\n\n    return PolicyURI;\n\n  })(SubPacket);\n\n  KeyFlags = (function(_super) {\n    __extends(KeyFlags, _super);\n\n    function KeyFlags(v) {\n      KeyFlags.__super__.constructor.call(this, S.key_flags, v);\n    }\n\n    KeyFlags.parse = function(slice) {\n      return Preference.parse(slice, KeyFlags);\n    };\n\n    KeyFlags.prototype.all_flags = function() {\n      var e, ret, _i, _len, _ref3;\n      ret = 0;\n      _ref3 = this.v;\n      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n        e = _ref3[_i];\n        ret |= e;\n      }\n      return ret;\n    };\n\n    return KeyFlags;\n\n  })(Preference);\n\n  SignersUserID = (function(_super) {\n    __extends(SignersUserID, _super);\n\n    function SignersUserID(uid) {\n      this.uid = uid;\n      SignersUserID.__super__.constructor.call(this, S.signers_user_id);\n    }\n\n    SignersUserID.parse = function(slice) {\n      return new SignersUserID(slice.consume_rest_to_buffer());\n    };\n\n    SignersUserID.prototype._v_to_buffer = function() {\n      return this.uid;\n    };\n\n    return SignersUserID;\n\n  })(SubPacket);\n\n  ReasonForRevocation = (function(_super) {\n    __extends(ReasonForRevocation, _super);\n\n    function ReasonForRevocation(flag, reason) {\n      this.flag = flag;\n      this.reason = reason;\n      ReasonForRevocation.__super__.constructor.call(this, S.reason_for_revocation);\n    }\n\n    ReasonForRevocation.parse = function(slice) {\n      var flag, reason;\n      flag = slice.read_uint8();\n      reason = slice.consume_rest_to_buffer();\n      return new ReasonForRevocation(flag, reason);\n    };\n\n    ReasonForRevocation.prototype._v_to_buffer = function() {\n      return Buffer.concat([uint_to_buffer(8, this.flag), this.reason]);\n    };\n\n    return ReasonForRevocation;\n\n  })(SubPacket);\n\n  SignatureTarget = (function(_super) {\n    __extends(SignatureTarget, _super);\n\n    function SignatureTarget(pub_key_alg, hasher, hval) {\n      this.pub_key_alg = pub_key_alg;\n      this.hasher = hasher;\n      this.hval = hval;\n      SignatureTarget.__super__.constructor.call(this, S.signature_target);\n    }\n\n    SignatureTarget.parse = function(slice) {\n      var hasher, hval, pka;\n      pka = slice.read_uint8();\n      hasher = alloc_or_throw(slice.read_uint8());\n      hval = slice.read_buffer(hasher.output_length);\n      return new SignatureTarget(pka, hasher, hval);\n    };\n\n    SignatureTarget.prototype._v_to_buffer = function() {\n      return Buffer.concat([uint_to_buffer(8, this.pub_key_alg), uint_to_buffer(8, this.hasher.type), this.hval]);\n    };\n\n    return SignatureTarget;\n\n  })(SubPacket);\n\n  EmbeddedSignature = (function(_super) {\n    __extends(EmbeddedSignature, _super);\n\n    function EmbeddedSignature(_arg) {\n      this.sig = _arg.sig, this.rawsig = _arg.rawsig;\n      EmbeddedSignature.__super__.constructor.call(this, S.embedded_signature);\n    }\n\n    EmbeddedSignature.prototype._v_to_buffer = function() {\n      return this.rawsig;\n    };\n\n    EmbeddedSignature.prototype.to_sig = function() {\n      return this.sig;\n    };\n\n    EmbeddedSignature.parse = function(slice) {\n      var rawsig, sig;\n      rawsig = slice.peek_rest_to_buffer();\n      sig = Signature.parse(slice);\n      return new EmbeddedSignature({\n        sig: sig,\n        rawsig: rawsig\n      });\n    };\n\n    return EmbeddedSignature;\n\n  })(SubPacket);\n\n  exports.Signature = Signature;\n\n  Parser = (function() {\n    function Parser(slice) {\n      this.slice = slice;\n    }\n\n    Parser.prototype.parse_v2_or_v3 = function(v, klass) {\n      var o;\n      if (this.slice.read_uint8() !== 5) {\n        throw new error(\"Bad one-octet length\");\n      }\n      o = {};\n      o.type = this.slice.read_uint8();\n      o.time = this.slice.read_uint32();\n      o.sig_data = this.slice.peek_rest_to_buffer();\n      o.key_id = this.slice.read_buffer(8);\n      o.public_key_class = asymmetric.get_class(this.slice.read_uint8());\n      o.hasher = alloc_or_throw(this.slice.read_uint8());\n      o.signed_hash_value_hash = this.slice.read_uint16();\n      o.sig = o.public_key_class.parse_sig(this.slice);\n      o.version = v;\n      return new klass(o);\n    };\n\n    Parser.prototype.parse_v4 = function() {\n      var end, hashed_subpacket_count, o, unhashed_subpacket_count;\n      o = {};\n      o.type = this.slice.read_uint8();\n      o.public_key_class = asymmetric.get_class(this.slice.read_uint8());\n      o.hasher = alloc_or_throw(this.slice.read_uint8());\n      hashed_subpacket_count = this.slice.read_uint16();\n      end = this.slice.i + hashed_subpacket_count;\n      o.sig_data = this.slice.peek_to_buffer(hashed_subpacket_count);\n      o.hashed_subpackets = ((function() {\n        var _results;\n        _results = [];\n        while (this.slice.i < end) {\n          _results.push(this.parse_subpacket());\n        }\n        return _results;\n      }).call(this));\n      unhashed_subpacket_count = this.slice.read_uint16();\n      end = this.slice.i + unhashed_subpacket_count;\n      o.unhashed_subpackets = ((function() {\n        var _results;\n        _results = [];\n        while (this.slice.i < end) {\n          _results.push(this.parse_subpacket());\n        }\n        return _results;\n      }).call(this));\n      o.signed_hash_value_hash = this.slice.read_uint16();\n      o.sig = o.public_key_class.parse_sig(this.slice);\n      o.version = 4;\n      return new Signature(o);\n    };\n\n    Parser.prototype.parse_subpacket = function() {\n      var critical, end, five_byte_len, klass, len, raw_type, ret, type, _ref3;\n      _ref3 = this.slice.read_v4_length(), len = _ref3[0], five_byte_len = _ref3[1];\n      raw_type = this.slice.read_uint8();\n      type = raw_type & 0x7f;\n      critical = !!(raw_type & 0x80);\n      end = this.slice.clamp(len - 1);\n      klass = (function() {\n        switch (type) {\n          case S.creation_time:\n            return CreationTime;\n          case S.expiration_time:\n            return ExpirationTime;\n          case S.exportable_certificate:\n            return Exportable;\n          case S.trust_signature:\n            return Trust;\n          case S.regular_expression:\n            return RegularExpression;\n          case S.revocable:\n            return Revocable;\n          case S.key_expiration_time:\n            return KeyExpirationTime;\n          case S.preferred_symmetric_algorithms:\n            return PreferredSymmetricAlgorithms;\n          case S.revocation_key:\n            return RevocationKey;\n          case S.issuer:\n            return Issuer;\n          case S.notation_data:\n            return NotationData;\n          case S.preferred_hash_algorithms:\n            return PreferredHashAlgorithms;\n          case S.preferred_compression_algorithms:\n            return PreferredCompressionAlgorithms;\n          case S.key_server_preferences:\n            return KeyServerPreferences;\n          case S.preferred_key_server:\n            return PreferredKeyServer;\n          case S.primary_user_id:\n            return PrimaryUserId;\n          case S.policy_uri:\n            return PolicyURI;\n          case S.key_flags:\n            return KeyFlags;\n          case S.signers_user_id:\n            return SignersUserID;\n          case S.reason_for_revocation:\n            return ReasonForRevocation;\n          case S.features:\n            return Features;\n          case S.signature_target:\n            return SignatureTarget;\n          case S.embedded_signature:\n            return EmbeddedSignature;\n          default:\n            if (type >= S.experimental_low && type <= S.experimental_high) {\n              return Experimental;\n            } else {\n              throw new Error(\"Unknown signature subpacket: \" + type);\n            }\n        }\n      })();\n      ret = klass.parse(this.slice, type);\n      ret.set_opts({\n        critical: critical,\n        five_byte_len: five_byte_len\n      });\n      this.slice.unclamp(end);\n      return ret;\n    };\n\n    Parser.prototype.parse = function() {\n      var version;\n      version = this.slice.read_uint8();\n      switch (version) {\n        case C.versions.signature.V2:\n          return this.parse_v2_or_v3(version, Signature_v2);\n        case C.versions.signature.V3:\n          return this.parse_v2_or_v3(version, Signature_v3);\n        case C.versions.signature.V4:\n          return this.parse_v4();\n        default:\n          throw new Error(\"Unknown signature version: \" + version);\n      }\n    };\n\n    return Parser;\n\n  })();\n\n  exports.CreationTime = CreationTime;\n\n  exports.KeyFlags = KeyFlags;\n\n  exports.KeyExpirationTime = KeyExpirationTime;\n\n  exports.PreferredSymmetricAlgorithms = PreferredSymmetricAlgorithms;\n\n  exports.PreferredHashAlgorithms = PreferredHashAlgorithms;\n\n  exports.Features = Features;\n\n  exports.KeyServerPreferences = KeyServerPreferences;\n\n  exports.Issuer = Issuer;\n\n  exports.EmbeddedSignature = EmbeddedSignature;\n\n  exports.PrimaryUserId = PrimaryUserId;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../../asymmetric\":1,\"../../const\":5,\"../../hash\":14,\"../../util\":70,\"../buffer\":35,\"../util\":60,\"./base\":45,\"./packetsigs\":51,\"assert\":75,\"buffer\":80,\"iced-error\":115,\"iced-runtime\":118,\"util\":114}],54:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var AES, C, Packet, SHA1, SHA256, UserAttribute, bufferify, encrypt, native_rng, parse, triplesec, uint_to_buffer, _ref, _ref1,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  C = require('../../const').openpgp;\n\n  triplesec = require('triplesec');\n\n  _ref = triplesec.hash, SHA1 = _ref.SHA1, SHA256 = _ref.SHA256;\n\n  AES = triplesec.ciphers.AES;\n\n  native_rng = triplesec.prng.native_rng;\n\n  _ref1 = require('../../util'), bufferify = _ref1.bufferify, uint_to_buffer = _ref1.uint_to_buffer;\n\n  encrypt = require('../cfb').encrypt;\n\n  Packet = require('./base').Packet;\n\n  parse = require('pgp-utils').userid.parse;\n\n  UserAttribute = (function(_super) {\n    __extends(UserAttribute, _super);\n\n    function UserAttribute(data) {\n      this.data = data;\n      UserAttribute.__super__.constructor.call(this);\n    }\n\n    UserAttribute.prototype.write = function() {\n      return this.frame_packet(C.packet_tags.user_attribute, this.data);\n    };\n\n    UserAttribute.parse = function(slice) {\n      return new UserAttribute(slice.consume_rest_to_buffer());\n    };\n\n    UserAttribute.prototype.to_user_attribute = function() {\n      return this;\n    };\n\n    UserAttribute.prototype.to_signature_payload = function() {\n      return Buffer.concat([new Buffer([C.signatures.user_attribute]), uint_to_buffer(32, this.data.length), this.data]);\n    };\n\n    return UserAttribute;\n\n  })(Packet);\n\n  exports.UserAttribute = UserAttribute;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../../const\":5,\"../../util\":70,\"../cfb\":38,\"./base\":45,\"buffer\":80,\"pgp-utils\":163,\"triplesec\":181}],55:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var AES, C, Packet, SHA1, SHA256, UserID, bufferify, encrypt, native_rng, parse, triplesec, uint_to_buffer, _ref, _ref1,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  C = require('../../const').openpgp;\n\n  triplesec = require('triplesec');\n\n  _ref = triplesec.hash, SHA1 = _ref.SHA1, SHA256 = _ref.SHA256;\n\n  AES = triplesec.ciphers.AES;\n\n  native_rng = triplesec.prng.native_rng;\n\n  _ref1 = require('../../util'), bufferify = _ref1.bufferify, uint_to_buffer = _ref1.uint_to_buffer;\n\n  encrypt = require('../cfb').encrypt;\n\n  Packet = require('./base').Packet;\n\n  parse = require('pgp-utils').userid.parse;\n\n  UserID = (function(_super) {\n    __extends(UserID, _super);\n\n    function UserID(userid, components) {\n      this.components = components != null ? components : null;\n      this.userid = bufferify(userid);\n      if (this.compontents == null) {\n        this._parse();\n      }\n      UserID.__super__.constructor.call(this);\n      this._time_primary_pair = null;\n      this.primary = false;\n      this.most_recent_sig = null;\n    }\n\n    UserID.prototype.utf8 = function() {\n      return this.userid.toString('utf8');\n    };\n\n    UserID.prototype.write = function() {\n      return this.frame_packet(C.packet_tags.userid, this.userid);\n    };\n\n    UserID.parse = function(slice) {\n      return new UserID(slice.consume_rest_to_buffer());\n    };\n\n    UserID.prototype.to_userid = function() {\n      return this;\n    };\n\n    UserID.prototype.cmp = function(b) {\n      var x, y;\n      x = this.utf8();\n      y = b.utf8();\n      if (x < y) {\n        return -1;\n      } else if (x === y) {\n        return 0;\n      } else {\n        return 1;\n      }\n    };\n\n    UserID.prototype.to_signature_payload = function() {\n      return Buffer.concat([new Buffer([C.signatures.userid]), uint_to_buffer(32, this.userid.length), this.userid]);\n    };\n\n    UserID.prototype._parse = function() {\n      var c;\n      if ((c = parse(this.utf8())) != null) {\n        return this.components = c;\n      }\n    };\n\n    UserID.prototype.get_username = function() {\n      var _ref2;\n      return (_ref2 = this.components) != null ? _ref2.username : void 0;\n    };\n\n    UserID.prototype.get_comment = function() {\n      var _ref2;\n      return (_ref2 = this.components) != null ? _ref2.comment : void 0;\n    };\n\n    UserID.prototype.get_email = function() {\n      var _ref2;\n      return (_ref2 = this.components) != null ? _ref2.email : void 0;\n    };\n\n    UserID.prototype.time_primary_pair = function() {\n      var max, p, pairs, ret, s, _i, _len;\n      if (this._time_primary_pair == null) {\n        pairs = (function() {\n          var _i, _len, _ref2, _ref3, _results;\n          _ref2 = this.get_psc().get_self_sigs();\n          _results = [];\n          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n            s = _ref2[_i];\n            _results.push(s != null ? (_ref3 = s.sig) != null ? _ref3.time_primary_pair() : void 0 : void 0);\n          }\n          return _results;\n        }).call(this);\n        max = null;\n        ret = [null, null];\n        for (_i = 0, _len = pairs.length; _i < _len; _i++) {\n          p = pairs[_i];\n          if (!(p != null)) {\n            continue;\n          }\n          if (p[0] && ((ret[0] == null) || (ret[0] < p[0]))) {\n            ret[0] = p[0];\n          }\n          if (p[1] && ((ret[1] == null) || (ret[1] < p[0]))) {\n            ret[1] = p[0];\n          }\n        }\n        this._time_primary_pair = ret;\n        this.most_recent_sig = ret[0];\n      }\n      return this._time_primary_pair;\n    };\n\n    UserID.make = function(components) {\n      var c, comment, userid;\n      comment = (c = components.comment) != null ? \"(\" + c + \") \" : \"\";\n      userid = \"\" + components.username + \" \" + comment + \"<\" + components.email + \">\";\n      return new UserID(userid, components);\n    };\n\n    UserID.prototype.get_framed_signature_output = function() {\n      var _ref2, _ref3, _ref4;\n      return (_ref2 = this.get_psc()) != null ? (_ref3 = _ref2.get_self_sig()) != null ? (_ref4 = _ref3.sig) != null ? _ref4.get_framed_output() : void 0 : void 0 : void 0;\n    };\n\n    return UserID;\n\n  })(Packet);\n\n  exports.UserID = UserID;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../../const\":5,\"../../util\":70,\"../cfb\":38,\"./base\":45,\"buffer\":80,\"pgp-utils\":163,\"triplesec\":181}],56:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, Compressed, Generic, KeyMaterial, Literal, MessageParser, OnePassSignature, PKESK, PacketParser, SEIPD, Signature, SlicerBuffer, UserAttribute, UserID, inspect, parse, util, _ref;\n\n  util = require('../util');\n\n  SlicerBuffer = require('./buffer').SlicerBuffer;\n\n  C = require('../const').openpgp;\n\n  KeyMaterial = require('./packet/keymaterial').KeyMaterial;\n\n  Signature = require('./packet/signature').Signature;\n\n  _ref = require('./packet/sess'), SEIPD = _ref.SEIPD, PKESK = _ref.PKESK;\n\n  UserID = require('./packet/userid').UserID;\n\n  UserAttribute = require('./packet/user_attribute').UserAttribute;\n\n  Compressed = require('./packet/compressed').Compressed;\n\n  Generic = require('./packet/generic').Generic;\n\n  OnePassSignature = require('./packet/one_pass_sig').OnePassSignature;\n\n  Literal = require('./packet/literal').Literal;\n\n  inspect = require('util').inspect;\n\n  MessageParser = (function() {\n    function MessageParser(slice) {\n      this.slice = slice;\n    }\n\n    MessageParser.prototype.parse = function() {\n      var _results;\n      _results = [];\n      while (this.slice.rem()) {\n        _results.push(this.parse_packet());\n      }\n      return _results;\n    };\n\n    MessageParser.prototype.parse_packet = function() {\n      return (new PacketParser(this.slice)).parse();\n    };\n\n    return MessageParser;\n\n  })();\n\n  PacketParser = (function() {\n    function PacketParser(slice) {\n      this.slice = slice;\n      this.body = null;\n      this.real_packet_len = null;\n      this.tag = null;\n      this.len = null;\n      this.header_len = null;\n    }\n\n    PacketParser.prototype.parse_header = function() {\n      this.parse_tag_and_len();\n      this.header_len || (this.header_len = this.slice.offset());\n      this.body || (this.body = new SlicerBuffer(this.slice.read_buffer(this.len)));\n      this.real_packet_len || (this.real_packet_len = this.len);\n      return this.slice.unclamp();\n    };\n\n    PacketParser.prototype.parse = function() {\n      var ret;\n      this.parse_header();\n      ret = this.parse_body();\n      return ret;\n    };\n\n    PacketParser.prototype.parse_body = function() {\n      var packet, pt, raw, sb;\n      pt = C.packet_tags;\n      sb = this.body;\n      raw = sb.peek_rest_to_buffer();\n      packet = (function() {\n        switch (this.tag) {\n          case pt.PKESK:\n            return PKESK.parse(sb);\n          case pt.one_pass_sig:\n            return OnePassSignature.parse(sb);\n          case pt.secret_key:\n            return KeyMaterial.parse_private_key(sb, {\n              subkey: false\n            });\n          case pt.secret_subkey:\n            return KeyMaterial.parse_private_key(sb, {\n              subkey: true\n            });\n          case pt.public_key:\n            return KeyMaterial.parse_public_key(sb, {\n              subkey: false\n            });\n          case pt.public_subkey:\n            return KeyMaterial.parse_public_key(sb, {\n              subkey: true\n            });\n          case pt.signature:\n            return Signature.parse(sb);\n          case pt.userid:\n            return UserID.parse(sb);\n          case pt.user_attribute:\n            return UserAttribute.parse(sb);\n          case pt.SEIPD:\n            return SEIPD.parse(sb);\n          case pt.literal:\n            return Literal.parse(sb);\n          case pt.compressed:\n            return Compressed.parse(sb);\n          default:\n            return new Generic(this.tag, sb);\n        }\n      }).call(this);\n      packet.set({\n        tag: this.tag,\n        real_packet_len: this.real_packet_len,\n        header_len: this.header_len,\n        raw: raw\n      });\n      return packet;\n    };\n\n    PacketParser.prototype.parse_tag_and_len = function() {\n      var c;\n      if (this.slice.len() < 2 || ((c = this.slice.read_uint8()) & 0x80) === 0) {\n        throw new Error(\"This doesn't look like a binary PGP packet (c=\" + c + \")\");\n      }\n      if ((c & 0x40) === 0) {\n        return this.parse_tag_and_len_old(c);\n      } else {\n        return this.parse_tag_and_len_new(c);\n      }\n    };\n\n    PacketParser.prototype.parse_tag_and_len_old = function(c) {\n      this.tag = (c & 0x3f) >> 2;\n      return this.len = (function() {\n        switch (c & 0x03) {\n          case 0:\n            return this.slice.read_uint8();\n          case 1:\n            return this.slice.read_uint16();\n          case 2:\n            return this.slice.read_uint32();\n          case 3:\n            return this.slice.rem();\n        }\n      }).call(this);\n    };\n\n    PacketParser.prototype.parse_tag_and_len_new = function(c) {\n      var ret;\n      this.tag = c & 0x3f;\n      ret = this.parse_tag_len_new();\n      return ret;\n    };\n\n    PacketParser.prototype.parse_tag_len_new = function() {\n      var c, d, go, lastlen, packet_length, segments;\n      go = true;\n      segments = [];\n      this.len = 0;\n      lastlen = 0;\n      while (go) {\n        go = false;\n        c = this.slice.read_uint8();\n        lastlen = c < 192 ? c : c === 255 ? this.slice.read_uint32() : c < 224 ? (d = this.slice.read_uint8(), ((c - 192) << 8) + (d + 192)) : (this.header_len || (this.header_len = this.slice.offset()), packet_length = 1 << (c & 0x1f), segments.push(this.slice.read_buffer(packet_length)), go = true, packet_length);\n        this.len += lastlen;\n      }\n      if (segments.length) {\n        segments.push(this.slice.read_buffer(lastlen));\n        this.body = new SlicerBuffer(Buffer.concat(segments));\n        this.len = this.body.length;\n        return this.real_packet_len = this.slice.offset();\n      }\n    };\n\n    return PacketParser;\n\n  })();\n\n  exports.parse = parse = function(buf) {\n    return util.katch(function() {\n      return (new MessageParser(new SlicerBuffer(buf))).parse();\n    });\n  };\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../const\":5,\"../util\":70,\"./buffer\":35,\"./packet/compressed\":46,\"./packet/generic\":47,\"./packet/keymaterial\":48,\"./packet/literal\":49,\"./packet/one_pass_sig\":50,\"./packet/sess\":52,\"./packet/signature\":53,\"./packet/user_attribute\":54,\"./packet/userid\":55,\"buffer\":80,\"util\":114}],57:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, KeyBlock, Message, OPS, Warnings, armor, athrow, bufeq_secure, do_message, hashmod, iced, import_key_pgp, katch, konst, make_esc, parse, unix_time, util, verify_clearsign, verify_detached, __iced_k, __iced_k_noop, _ref;\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  make_esc = require('iced-error').make_esc;\n\n  OPS = require('../keyfetch').OPS;\n\n  konst = require('../const');\n\n  C = konst.openpgp;\n\n  _ref = require('../util'), katch = _ref.katch, unix_time = _ref.unix_time, athrow = _ref.athrow, Warnings = _ref.Warnings, bufeq_secure = _ref.bufeq_secure;\n\n  parse = require('./parser').parse;\n\n  import_key_pgp = require('../symmetric').import_key_pgp;\n\n  util = require('util');\n\n  armor = require('./armor');\n\n  hashmod = require('../hash');\n\n  verify_clearsign = require('./clearsign').verify;\n\n  verify_detached = require('./detachsign').verify;\n\n  KeyBlock = (function() {\n    function KeyBlock(packets, opts) {\n      this.packets = packets;\n      this.verified_signatures = [];\n      this.subkeys = [];\n      this.primary = null;\n      this.userids = [];\n      this.user_attributes = [];\n      this.warnings = new Warnings();\n      this.opts = opts || {};\n    }\n\n    KeyBlock.prototype.to_obj = function() {\n      return {\n        subkeys: this.subkeys,\n        primary: this.primary,\n        userids: this.userids\n      };\n    };\n\n    KeyBlock.prototype._extract_keys = function() {\n      var err, i, p, _i, _len, _ref1;\n      err = null;\n      if (!this.packets.length) {\n        err = new Error(\"No packets; cannot extract a key\");\n      } else if (!(this.primary = this.packets[0]).is_primary()) {\n        err = new Error(\"First packet must be the primary key\");\n      } else {\n        _ref1 = this.packets.slice(1);\n        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {\n          p = _ref1[i];\n          if (p.is_key_material() && (err == null)) {\n            if (p.key.is_toxic()) {\n              this.warnings.push(\"Ignoring toxic subkey (ElGamal Encrypt+Sign)\");\n            } else if (!p.is_primary()) {\n              this.subkeys.push(p);\n            } else if (bufeq_secure(p.get_fingerprint(), this.primary.get_fingerprint())) {\n              p.set_duplicate_primary();\n            } else {\n              err = new Error(\"cannot have 2 primary keys\");\n            }\n          }\n        }\n      }\n      return err;\n    };\n\n    KeyBlock.prototype._check_keys = function() {\n      return this._check_primary() || this._check_subkeys();\n    };\n\n    KeyBlock.prototype._check_primary = function() {\n      var err;\n      return err = !this.primary.is_self_signed() ? new Error(\"no valid primary key self-signature\") : (this.userids = this.primary.get_signed_userids()).length === 0 ? new Error(\"no valid Userid signed into key\") : (this.user_attributes = this.primary.get_signed_user_attributes(), null);\n    };\n\n    KeyBlock.prototype._check_subkeys = function() {\n      var err, i, k, msg, subkeys, _i, _len;\n      subkeys = this.subkeys;\n      err = null;\n      this.subkeys = [];\n      for (i = _i = 0, _len = subkeys.length; _i < _len; i = ++_i) {\n        k = subkeys[i];\n        if (err == null) {\n          if (k.is_signed_subkey_of(this.primary)) {\n            this.subkeys.push(k);\n          } else {\n            msg = \"Subkey \" + i + \" was invalid; discarding\";\n            this.warnings.push(msg);\n          }\n        }\n      }\n      return err;\n    };\n\n    KeyBlock.prototype.process = function(cb) {\n      var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = this._extract_keys();\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err == null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n                funcname: \"KeyBlock.process\"\n              });\n              _this._verify_sigs(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return err = arguments[0];\n                  };\n                })(),\n                lineno: 86\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          var _ref1;\n          if (!((err != null) || ((_ref1 = _this.opts) != null ? _ref1.no_check_keys : void 0))) {\n            err = _this._check_keys();\n          }\n          return cb(err);\n        };\n      })(this));\n    };\n\n    KeyBlock.prototype._verify_sigs = function(cb) {\n      var err, i, iid, msg, n_sigs, p, pid, tmp, working_set, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = null;\n      working_set = [];\n      n_sigs = 0;\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _len, _ref1, _results, _while;\n          _ref1 = _this.packets.slice(1);\n          _len = _ref1.length;\n          i = 0;\n          _results = [];\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = function() {\n              return __iced_k(_results);\n            };\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++i;\n                return _while(__iced_k);\n              });\n            };\n            _next = function(__iced_next_arg) {\n              _results.push(__iced_next_arg);\n              return _continue();\n            };\n            if (!(i < _len)) {\n              return _break();\n            } else {\n              p = _ref1[i];\n              if (err == null) {\n                (function(__iced_k) {\n                  if (!p.is_signature()) {\n                    if (n_sigs > 0) {\n                      n_sigs = 0;\n                      working_set = [];\n                    }\n                    return __iced_k(!p.is_duplicate_primary() ? working_set.push(p) : void 0);\n                  } else {\n                    (function(__iced_k) {\n                      if (!bufeq_secure((iid = p.get_issuer_key_id()), (pid = _this.primary.get_key_id()))) {\n                        n_sigs++;\n                        return __iced_k(_this.warnings.push(\"Skipping signature by another issuer: \" + (iid != null ? iid.toString('hex') : void 0) + \" != \" + (pid != null ? pid.toString('hex') : void 0)));\n                      } else {\n                        n_sigs++;\n                        p.key = _this.primary.key;\n                        p.primary = _this.primary;\n                        (function(__iced_k) {\n                          __iced_deferrals = new iced.Deferrals(__iced_k, {\n                            parent: ___iced_passed_deferral,\n                            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n                            funcname: \"KeyBlock._verify_sigs\"\n                          });\n                          p.verify(working_set, __iced_deferrals.defer({\n                            assign_fn: (function() {\n                              return function() {\n                                return tmp = arguments[0];\n                              };\n                            })(),\n                            lineno: 110\n                          }), _this.opts);\n                          __iced_deferrals._fulfill();\n                        })(function() {\n                          return __iced_k(typeof tmp !== \"undefined\" && tmp !== null ? (msg = \"Signature failure in packet \" + i + \": \" + tmp.message, _this.warnings.push(msg)) : _this.verified_signatures.push(p));\n                        });\n                      }\n                    })(__iced_k);\n                  }\n                })(_next);\n              } else {\n                return _continue();\n              }\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    return KeyBlock;\n\n  })();\n\n  Message = (function() {\n    function Message(_arg) {\n      this.keyfetch = _arg.keyfetch, this.data_fn = _arg.data_fn, this.data = _arg.data, this.strict = _arg.strict;\n      this.literals = [];\n      this.enc_data_packet = null;\n      this.warnings = new Warnings();\n    }\n\n    Message.prototype._get_session_key = function(cb) {\n      var enc, err, esk_packets, fingerprint, index, key_ids, key_material, km, p, packet, pkcs5, privk, sesskey, ___iced_passed_deferral, __iced_deferrals, __iced_k;      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      key_ids = [];\n      esk_packets = [];\n      err = null;\n      pkcs5 = false;\n      key_ids = (function() {\n        var _results;\n        _results = [];\n        while (this.packets.length && (p = this.packets[0].to_esk_packet())) {\n          esk_packets.push(p);\n          this.packets.shift();\n          _results.push(p.get_key_id());\n        }\n        return _results;\n      }).call(this);\n      (function(_this) {\n        return (function(__iced_k) {\n          if (key_ids.length) {\n            enc = true;\n            console.info(\"Key ID\", key_ids[0]);\n/*\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n                funcname: \"Message._get_session_key\"\n              });\n\n              _this.keyfetch.fetch(key_ids, konst.ops.decrypt, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    //err = arguments[0];\n                    //km = arguments[1];\n                    return index = 0;\n                  };\n                })(),\n                lineno: 171\n              }));\n\n              __iced_deferrals._fulfill();\n\n            })\n\n*/\n              packet = esk_packets[0];\n              //key_material = km.find_pgp_key_material(key_ids[index]);\n              //fingerprint = key_material.get_fingerprint();\n              //privk = key_material.key;\n              console.info(\"err\", err);\n              err = null;\n              window.auth_decrypt(packet.raw, (ok_sesskey) => {\n                  sesskey = packet.raw.slice(0, ok_sesskey.length);\n                  sesskey = Object.assign(sesskey, ok_sesskey);\n                  console.info(\"sesskey from OnlyKey:\", sesskey);\n                return cb(err, enc, sesskey, pkcs5);\n              });\n\n          } else {\n            return __iced_k(enc = false);\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          //return cb(err, enc, sesskey, pkcs5);\n        };\n      })(this));\n    };\n\n    Message.prototype._find_encrypted_data = function(cb) {\n      var err, ret;\n      err = ret = null;\n      if (this.packets.length && (ret = this.packets[0].to_enc_data_packet())) {\n        this.packets.pop();\n      } else {\n        err = new Error(\"Could not find encrypted data packet\");\n      }\n      return cb(err, ret);\n    };\n\n    Message.prototype._decrypt_with_session_key = function(sesskey, edat, pkcs5, cb) {\n      var cipher, err, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      _ref1 = katch(function() {\n        return import_key_pgp(sesskey, pkcs5);\n      }), err = _ref1[0], cipher = _ref1[1];\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err == null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n                funcname: \"Message._decrypt_with_session_key\"\n              });\n              edat.decrypt({\n                cipher: cipher\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return ret = arguments[1];\n                  };\n                })(),\n                lineno: 179\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    Message.prototype._parse = function(raw, cb) {\n      var err, packets, _ref1;\n      _ref1 = parse(raw), err = _ref1[0], packets = _ref1[1];\n      return cb(err, packets);\n    };\n\n    Message.prototype._decrypt = function(cb) {\n      var edat, err, esc, is_enc, packets, pkcs5, plaintext, sesskey, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = null;\n      esc = make_esc(cb, \"Message::decrypt\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n            funcname: \"Message._decrypt\"\n          });\n          _this._get_session_key(esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                is_enc = arguments[0];\n                sesskey = arguments[1];\n                return pkcs5 = arguments[2];\n              };\n            })(),\n            lineno: 193\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            if (is_enc) {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n                  funcname: \"Message._decrypt\"\n                });\n                _this._find_encrypted_data(esc(__iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return edat = arguments[0];\n                    };\n                  })(),\n                  lineno: 195\n                })));\n                __iced_deferrals._fulfill();\n              })(function() {\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n                    funcname: \"Message._decrypt\"\n                  });\n                  _this._decrypt_with_session_key(sesskey, edat, pkcs5, esc(__iced_deferrals.defer({\n                    assign_fn: (function() {\n                      return function() {\n                        return plaintext = arguments[0];\n                      };\n                    })(),\n                    lineno: 196\n                  })));\n                  __iced_deferrals._fulfill();\n                })(function() {\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n                      funcname: \"Message._decrypt\"\n                    });\n                    _this._parse(plaintext, esc(__iced_deferrals.defer({\n                      assign_fn: (function() {\n                        return function() {\n                          return packets = arguments[0];\n                        };\n                      })(),\n                      lineno: 197\n                    })));\n                    __iced_deferrals._fulfill();\n                  })(function() {\n                    return __iced_k(_this.packets = packets.concat(_this.packets));\n                  });\n                });\n              });\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            return cb(err);\n          });\n        };\n      })(this));\n    };\n\n    Message.prototype._inflate = function(cb) {\n      var esc, inflated, p, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      packets = [];\n      esc = make_esc(cb, \"Message::_inflate\");\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _len, _ref1, _results, _while;\n          _ref1 = _this.packets;\n          _len = _ref1.length;\n          _i = 0;\n          _results = [];\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = function() {\n              return __iced_k(_results);\n            };\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++_i;\n                return _while(__iced_k);\n              });\n            };\n            _next = function(__iced_next_arg) {\n              _results.push(__iced_next_arg);\n              return _continue();\n            };\n            if (!(_i < _len)) {\n              return _break();\n            } else {\n              p = _ref1[_i];\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n                  funcname: \"Message._inflate\"\n                });\n                p.inflate(esc(__iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return inflated = arguments[0];\n                    };\n                  })(),\n                  lineno: 207\n                })));\n                __iced_deferrals._fulfill();\n              })(function() {\n                (function(__iced_k) {\n                  if (typeof inflated !== \"undefined\" && inflated !== null) {\n                    (function(__iced_k) {\n                      __iced_deferrals = new iced.Deferrals(__iced_k, {\n                        parent: ___iced_passed_deferral,\n                        filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n                        funcname: \"Message._inflate\"\n                      });\n                      _this._parse(inflated, esc(__iced_deferrals.defer({\n                        assign_fn: (function() {\n                          return function() {\n                            return p = arguments[0];\n                          };\n                        })(),\n                        lineno: 209\n                      })));\n                      __iced_deferrals._fulfill();\n                    })(function() {\n                      return __iced_k(packets.push.apply(packets, p));\n                    });\n                  } else {\n                    return __iced_k(packets.push(p));\n                  }\n                })(_next);\n              });\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          _this.packets = packets;\n          return cb(null);\n        };\n      })(this));\n    };\n\n    Message.prototype._frame_signatures = function() {\n      var o, p, payload, ret, stack, _i, _j, _len, _len1, _ref1;\n      ret = [];\n      stack = [];\n      payload = [];\n      _ref1 = this.packets;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        p = _ref1[_i];\n        if (p.tag === C.packet_tags.one_pass_sig) {\n          stack.push({\n            open: p\n          });\n        } else if (!stack.length) {\n\n        } else if (p.tag === C.packet_tags.signature) {\n          o = stack.pop();\n          o.close = p;\n          ret.push(o);\n        } else {\n          payload.push(p);\n        }\n      }\n      for (_j = 0, _len1 = ret.length; _j < _len1; _j++) {\n        o = ret[_j];\n        o.payload = payload;\n      }\n      return ret;\n    };\n\n    Message.prototype._verify_sig = function(sig, cb) {\n      var a, b, err, i, key_material, km, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = null;\n      if (!bufeq_secure((a = sig.open.key_id), (b = sig.close.get_key_id()))) {\n        err = new Error(\"signature mismatch open v close: \" + (a != null ? a.toString('hex') : void 0) + \" != \" + (b != null ? b.toString('hex') : void 0));\n      }\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err == null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n                funcname: \"Message._verify_sig\"\n              });\n              _this.keyfetch.fetch([a], konst.ops.verify, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    km = arguments[1];\n                    return i = arguments[2];\n                  };\n                })(),\n                lineno: 247\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            if (err == null) {\n              key_material = km.find_pgp_key_material(a);\n              sig.close.key = key_material.key;\n              sig.close.key_manager = km;\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n                  funcname: \"Message._verify_sig\"\n                });\n                sig.close.verify(sig.payload, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return err = arguments[0];\n                    };\n                  })(),\n                  lineno: 259\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n            } else {\n              return __iced_k(!_this.strict ? (_this.warnings.push(\"Problem fetching key \" + (a.toString('hex')) + \": \" + (err.toString())), err = null) : void 0);\n            }\n          })(function() {\n            return cb(err);\n          });\n        };\n      })(this));\n    };\n\n    Message.prototype._verify = function(cb) {\n      var esc, sig, sigs, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Message::_verify_sigs\");\n      sigs = this._frame_signatures();\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _len, _ref1, _results, _while;\n          _ref1 = sigs;\n          _len = _ref1.length;\n          _i = 0;\n          _results = [];\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = function() {\n              return __iced_k(_results);\n            };\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++_i;\n                return _while(__iced_k);\n              });\n            };\n            _next = function(__iced_next_arg) {\n              _results.push(__iced_next_arg);\n              return _continue();\n            };\n            if (!(_i < _len)) {\n              return _break();\n            } else {\n              sig = _ref1[_i];\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n                  funcname: \"Message._verify\"\n                });\n                _this._verify_sig(sig, esc(__iced_deferrals.defer({\n                  lineno: 273\n                })));\n                __iced_deferrals._fulfill();\n              })(_next);\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(null);\n        };\n      })(this));\n    };\n\n    Message.prototype.collect_literals = function() {\n      var p, _i, _len, _ref1, _results;\n      _ref1 = this.packets;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        p = _ref1[_i];\n        if (p.tag === C.packet_tags.literal) {\n          _results.push(p);\n        }\n      }\n      return _results;\n    };\n\n    Message.prototype._process_generic = function(_arg, cb) {\n      var esc, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      packets = _arg.packets;\n      this.packets = packets;\n      esc = make_esc(cb, \"Message:process\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n            funcname: \"Message._process_generic\"\n          });\n          _this._decrypt(esc(__iced_deferrals.defer({\n            lineno: 286\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n              funcname: \"Message._process_generic\"\n            });\n            _this._inflate(esc(__iced_deferrals.defer({\n              lineno: 287\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n                funcname: \"Message._process_generic\"\n              });\n              _this._verify(esc(__iced_deferrals.defer({\n                lineno: 288\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return cb(null, _this.collect_literals());\n            });\n          });\n        };\n      })(this));\n    };\n\n    Message.prototype._verify_clearsign = function(_arg, cb) {\n      var clearsign, err, literal, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      packets = _arg.packets, clearsign = _arg.clearsign;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (clearsign == null) {\n            return __iced_k(err = new Error(\"no clearsign data found\"));\n          } else {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n                funcname: \"Message._verify_clearsign\"\n              });\n              verify_clearsign({\n                packets: packets,\n                clearsign: clearsign,\n                keyfetch: _this.keyfetch\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return literal = arguments[1];\n                  };\n                })(),\n                lineno: 297\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, [literal]);\n        };\n      })(this));\n    };\n\n    Message.prototype.parse_and_process = function(msg, cb) {\n      var esc, literals, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Message::parse_and_process\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n            funcname: \"Message.parse_and_process\"\n          });\n          _this._parse(msg.body, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return packets = arguments[0];\n              };\n            })(),\n            lineno: 304\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n              funcname: \"Message.parse_and_process\"\n            });\n            _this._process({\n              msg: msg,\n              packets: packets\n            }, esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return literals = arguments[0];\n                };\n              })(),\n              lineno: 305\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            return cb(null, literals);\n          });\n        };\n      })(this));\n    };\n\n    Message.prototype._verify_signature = function(_arg, cb) {\n      var err, literals, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      packets = _arg.packets;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (!((_this.data != null) || (_this.data_fn != null))) {\n            return __iced_k(err = new Error(\"Cannot verify detached signature without data input\"));\n          } else {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n                funcname: \"Message._verify_signature\"\n              });\n              verify_detached({\n                packets: packets,\n                data: _this.data,\n                data_fn: _this.data_fn,\n                keyfetch: _this.keyfetch\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return literals = arguments[1];\n                  };\n                })(),\n                lineno: 314\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, literals);\n        };\n      })(this));\n    };\n\n    Message.prototype._process = function(_arg, cb) {\n      var err, literals, msg, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      msg = _arg.msg, packets = _arg.packets;\n      msg.type || (msg.type = C.message_types.generic);\n      (function(_this) {\n        return (function(__iced_k) {\n          switch (msg.type) {\n            case C.message_types.generic:\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n                  funcname: \"Message._process\"\n                });\n                _this._process_generic({\n                  packets: packets\n                }, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return literals = arguments[1];\n                    };\n                  })(),\n                  lineno: 323\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n              break;\n            case C.message_types.clearsign:\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n                  funcname: \"Message._process\"\n                });\n                _this._verify_clearsign({\n                  packets: packets,\n                  clearsign: msg.clearsign\n                }, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return literals = arguments[1];\n                    };\n                  })(),\n                  lineno: 325\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n              break;\n            case C.message_types.signature:\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\",\n                  funcname: \"Message._process\"\n                });\n                _this._verify_signature({\n                  packets: packets\n                }, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return literals = arguments[1];\n                    };\n                  })(),\n                  lineno: 327\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n              break;\n            default:\n              return __iced_k(err = new Error(\"Needed a 'generic', 'clearsign', or 'signature' PGP message, got \" + msg.type));\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, literals);\n        };\n      })(this));\n    };\n\n    return Message;\n\n  })();\n\n  exports.KeyBlock = KeyBlock;\n\n  exports.Message = Message;\n\n  exports.do_message = do_message = function(_arg, cb) {\n    var armored, data, data_fn, err, esk, keyfetch, literals, msg, msg_type, proc, raw, strict, warnings, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    armored = _arg.armored, raw = _arg.raw, msg_type = _arg.msg_type, keyfetch = _arg.keyfetch, data_fn = _arg.data_fn, data = _arg.data, strict = _arg.strict;\n    literals = null;\n    err = msg = warnings = esk = null;\n    if (armored != null) {\n      _ref1 = armor.decode(armored), err = _ref1[0], msg = _ref1[1];\n    } else if (raw != null) {\n      msg_type || (msg_type = C.message_types.generic);\n      msg = {\n        body: raw,\n        type: msg_type\n      };\n    } else {\n      err = new Error(\"No input to do_message; need either 'armored' or 'raw' input\");\n    }\n    (function(_this) {\n      return (function(__iced_k) {\n        if (err == null) {\n          if (strict == null) {\n            strict = true;\n          }\n          proc = new Message({\n            keyfetch: keyfetch,\n            data_fn: data_fn,\n            data: data,\n            strict: strict\n          });\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/processor.iced\"\n            });\n            proc.parse_and_process(msg, __iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  err = arguments[0];\n                  return literals = arguments[1];\n                };\n              })(),\n              lineno: 373\n            }));\n            __iced_deferrals._fulfill();\n          })(function() {\n            warnings = proc.warnings;\n            return __iced_k(esk = proc.encryption_subkey);\n          });\n        } else {\n          return __iced_k();\n        }\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(err, literals, warnings, esk);\n      };\n    })(this));\n  };\n\n}).call(this);\n\n},{\"../const\":5,\"../hash\":14,\"../keyfetch\":24,\"../symmetric\":68,\"../util\":70,\"./armor\":33,\"./clearsign\":39,\"./detachsign\":40,\"./parser\":56,\"iced-error\":115,\"iced-runtime\":118,\"util\":114}],58:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, S2K, SHA256, SecretKeyMaterial, alloc, iterated_s2k, streamers, triplesec, _iterated_s2k_cache, _ref;\n\n  triplesec = require('triplesec');\n\n  C = require('../const').openpgp;\n\n  _ref = require('../hash'), alloc = _ref.alloc, SHA256 = _ref.SHA256, streamers = _ref.streamers;\n\n  S2K = (function() {\n    S2K.prototype._count = function(c, bias) {\n      return (16 + (c & 15)) << ((c >> 4) + bias);\n    };\n\n    function S2K() {\n      this.hash = SHA256;\n      this.streamer = streamers.SHA256();\n    }\n\n    S2K.prototype.set_hash_algorithm = function(which) {\n      if ((this.hash = alloc(which)) != null) {\n        return this.streamer = streamers[this.hash.algname]();\n      } else {\n        console.warn(\"No such hash: \" + which + \"; defaulting to SHA-256\");\n        this.hash = SHA256;\n        return this.streamer = streamers.SHA256();\n      }\n    };\n\n    S2K.prototype.read = function(slice) {\n      var c;\n      this.type = slice.read_uint8();\n      switch (this.type) {\n        case C.s2k.plain:\n          this.set_hash_algorithm(slice.read_uint8());\n          break;\n        case C.s2k.salt:\n          this.set_hash_algorithm(slice.read_uint8());\n          this.salt = slice.read_buffer(8);\n          break;\n        case C.s2k.salt_iter:\n          this.set_hash_algorithm(slice.read_uint8());\n          this.salt = slice.read_buffer(8);\n          this.EXPBIAS = 6;\n          c = slice.read_uint8();\n          this.count = this._count(c, this.EXPBIAS);\n          break;\n        case C.s2k.gnu:\n          this.read_gnu_extensions(slice);\n          break;\n        default:\n          throw new Error(\"unknown s2k type! \" + this.type);\n      }\n      return this;\n    };\n\n    S2K.prototype.read_gnu_extensions = function(slice) {\n      var buf, gnu_ext_type, id, version;\n      version = slice.read_uint8();\n      if ((id = (buf = slice.read_buffer(3)).toString('utf8')) === \"GNU\") {\n        gnu_ext_type = slice.read_uint8() + 1000;\n        switch (gnu_ext_type) {\n          case 1001:\n            return this.type = C.s2k.gnu_dummy;\n          default:\n            throw new (\"unknown s2k gnu protection mode: \" + gnu_ext_type);\n        }\n      } else {\n        throw new Error(\"Malformed GNU-extension: \" + ext);\n      }\n    };\n\n    S2K.prototype.write = function(passphrase, salt, c, keysize) {\n      var type;\n      this.type = type = 3;\n      this.salt = salt;\n      this.count = this._count(c, 6);\n      this.s2kLength = 10;\n      return this.produce_key(passphrase, keysize);\n    };\n\n    S2K.prototype.is_dummy = function() {\n      return this.type === C.s2k.gnu_dummy;\n    };\n\n    S2K.prototype.produce_key = function(passphrase, numBytes) {\n      var key, key2, prefix, ret, seed;\n      if (numBytes == null) {\n        numBytes = 16;\n      }\n      ret = (function() {\n        switch (this.type) {\n          case C.s2k.plain:\n            return this.hash(passphrase);\n          case C.s2k.salt:\n            return this.hash(Buffer.concat([this.salt, passphrase]));\n          case C.s2k.salt_iter:\n            seed = Buffer.concat([this.salt, passphrase]);\n            key = iterated_s2k({\n              alg: this.hash.algname,\n              seed: seed,\n              count: this.count\n            });\n            if ((numBytes != null) && (numBytes === 24 || numBytes === 32)) {\n              prefix = new Buffer([0]);\n              key2 = iterated_s2k({\n                alg: this.hash.algname,\n                seed: seed,\n                count: this.count,\n                prefix: prefix\n              });\n              return Buffer.concat([key, key2]);\n            } else {\n              return key;\n            }\n            break;\n          default:\n            return null;\n        }\n      }).call(this);\n      return ret.slice(0, numBytes);\n    };\n\n    return S2K;\n\n  })();\n\n  _iterated_s2k_cache = {};\n\n  iterated_s2k = function(_arg) {\n    var alg, bigbuf, count, i, k, n, prefix, rem, rembuf, ret, seed, streamer, tot, val;\n    alg = _arg.alg, seed = _arg.seed, count = _arg.count, prefix = _arg.prefix;\n    k = \"\" + alg + \"-\" + (seed.toString('base64')) + \"-\" + count;\n    if (prefix != null) {\n      k += \"-\" + (prefix.toString('base64'));\n    }\n    if ((val = _iterated_s2k_cache[k]) != null) {\n      return val;\n    }\n    streamer = streamers[alg]();\n    if (prefix != null) {\n      streamer.update(prefix);\n    }\n    bigbuf = Buffer.concat((function() {\n      var _i, _results;\n      _results = [];\n      for (i = _i = 0; _i < 4096; i = ++_i) {\n        _results.push(seed);\n      }\n      return _results;\n    })());\n    tot = 0;\n    while (tot + bigbuf.length <= count) {\n      streamer.update(bigbuf);\n      tot += bigbuf.length;\n    }\n    rem = count - tot;\n    n = Math.ceil(rem / seed.length);\n    rembuf = Buffer.concat((function() {\n      var _i, _results;\n      _results = [];\n      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {\n        _results.push(seed);\n      }\n      return _results;\n    })());\n    ret = streamer(rembuf.slice(0, rem));\n    _iterated_s2k_cache[k] = ret;\n    return ret;\n  };\n\n  SecretKeyMaterial = (function() {\n    function SecretKeyMaterial() {\n      this.s2k_convention = null;\n      this.s2k = null;\n      this.iv = null;\n      this.cipher = null;\n      this.payload = null;\n    }\n\n    SecretKeyMaterial.prototype.is_dummy = function() {\n      return (this.s2k != null) && this.s2k.is_dummy();\n    };\n\n    SecretKeyMaterial.prototype.has_private = function() {\n      return !this.is_dummy();\n    };\n\n    SecretKeyMaterial.prototype.is_locked = function() {\n      return (this.s2k_convention !== C.s2k_convention.none) && !(this.is_dummy());\n    };\n\n    return SecretKeyMaterial;\n\n  })();\n\n  exports.S2K = S2K;\n\n  exports.SecretKeyMaterial = SecretKeyMaterial;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../const\":5,\"../hash\":14,\"buffer\":80,\"triplesec\":181}],59:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, SignatureEngine, burn, decode, iced, make_esc, processor, __iced_k, __iced_k_noop;\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  make_esc = require('iced-error').make_esc;\n\n  burn = require('./burner').burn;\n\n  processor = require('./processor');\n\n  decode = require('./armor').decode;\n\n  C = require('../const');\n\n  exports.SignatureEngine = SignatureEngine = (function() {\n    function SignatureEngine(_arg) {\n      this.km = _arg.km;\n    }\n\n    SignatureEngine.prototype.get_km = function() {\n      return this.km;\n    };\n\n    SignatureEngine.prototype.box = function(msg, cb) {\n      var err, out, signing_key, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      out = {\n        type: \"pgp\"\n      };\n      (function(_this) {\n        return (function(__iced_k) {\n          if ((signing_key = _this.km.find_signing_pgp_key()) != null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced\",\n                funcname: \"SignatureEngine.box\"\n              });\n              burn({\n                msg: msg,\n                signing_key: signing_key\n              }, __iced_deferrals.defer({\n                assign_fn: (function(__slot_1, __slot_2) {\n                  return function() {\n                    err = arguments[0];\n                    __slot_1.pgp = arguments[1];\n                    return __slot_2.raw = arguments[2];\n                  };\n                })(out, out),\n                lineno: 21\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return __iced_k(typeof err === \"undefined\" || err === null ? out.armored = out.pgp : void 0);\n            });\n          } else {\n            return __iced_k(err = new Error(\"No signing key found\"));\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, out);\n        };\n      })(this));\n    };\n\n    SignatureEngine.prototype.decode = function(armored, cb) {\n      var err, msg, mt, _ref;\n      _ref = decode(armored), err = _ref[0], msg = _ref[1];\n      mt = C.openpgp.message_types;\n      if ((err == null) && (msg.type !== mt.generic)) {\n        err = new Error(\"wrong message type; expected a generic message; got \" + msg.type);\n      }\n      return cb(err, msg);\n    };\n\n    SignatureEngine.prototype.unbox = function(msg, cb) {\n      var eng, esc, literals, msg, payload, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"SignatureEngine::unbox\");\n      (function(_this) {\n        return (function(__iced_k) {\n          if (typeof msg === 'string') {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced\",\n                funcname: \"SignatureEngine.unbox\"\n              });\n              _this.decode(msg, esc(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return msg = arguments[0];\n                  };\n                })(),\n                lineno: 40\n              })));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          eng = new processor.Message({\n            keyfetch: _this.km\n          });\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced\",\n              funcname: \"SignatureEngine.unbox\"\n            });\n            eng.parse_and_process({\n              body: msg.body\n            }, esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return literals = arguments[0];\n                };\n              })(),\n              lineno: 42\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced\",\n                funcname: \"SignatureEngine.unbox\"\n              });\n              _this._check_result(literals, esc(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return payload = arguments[0];\n                  };\n                })(),\n                lineno: 43\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return cb(null, payload, msg.body);\n            });\n          });\n        };\n      })(this));\n    };\n\n    SignatureEngine.prototype._check_result = function(literals, cb) {\n      var b, err, l, n, payload, sw, _ref;\n      err = payload = null;\n      if ((n = literals.length) !== 1 || ((l = literals[0]) == null)) {\n        err = new Error(\"Expected only one pgp literal; got \" + n);\n      } else if ((sw = (_ref = l.get_data_signer()) != null ? _ref.sig : void 0) == null) {\n        err = new Error(\"Expected a signature on the payload message\");\n      } else if ((this.km.find_pgp_key((b = sw.get_key_id()))) == null) {\n        err = new Error(\"Failed sanity check; didn't have a key for '\" + (b.toString('hex')) + \"'\");\n      } else {\n        payload = l.data;\n      }\n      return cb(err, payload);\n    };\n\n    return SignatureEngine;\n\n  })();\n\n}).call(this);\n\n},{\"../const\":5,\"./armor\":33,\"./burner\":36,\"./processor\":57,\"iced-error\":115,\"iced-runtime\":118}],60:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, calc_checksum, encode_length, ops_to_keyflags;\n\n  C = require('../const');\n\n  exports.make_time_packet = function(d) {\n    var b;\n    d || (d = Math.floor(Date.now() / 1000));\n    b = new Buffer(4);\n    b.writeUInt32BE(d, 0);\n    return b;\n  };\n\n  exports.calc_checksum = calc_checksum = function(text) {\n    var i, ret, _i, _ref;\n    ret = 0;\n    for (i = _i = 0, _ref = text.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n      ret = (ret + text.readUInt8(i)) % 65536;\n    }\n    return ret;\n  };\n\n  exports.encode_length = encode_length = function(l, five_byte) {\n    var ret;\n    if (five_byte == null) {\n      five_byte = false;\n    }\n    ret = null;\n    if (l >= 8384 || five_byte) {\n      ret = new Buffer(5);\n      ret.writeUInt8(0xff, 0);\n      ret.writeUInt32BE(l, 1);\n    } else if (l < 192) {\n      ret = new Buffer(1);\n      ret.writeUInt8(l, 0);\n    } else if (l >= 192 && l < 8384) {\n      ret = new Buffer(2);\n      ret.writeUInt16BE((l - 192) + (192 << 8), 0);\n    }\n    return ret;\n  };\n\n  exports.ops_to_keyflags = ops_to_keyflags = function(ops) {\n    var out;\n    out = 0;\n    if (ops & C.ops.encrypt) {\n      out |= C.openpgp.key_flags.encrypt_comm;\n    }\n    if (ops & C.ops.decrypt) {\n      out |= C.openpgp.key_flags.encrypt_comm;\n    }\n    if (ops & C.ops.verify) {\n      out |= C.openpgp.key_flags.sign_data;\n    }\n    if (ops & C.ops.sign) {\n      out |= C.openpgp.key_flags.sign_data;\n    }\n    return out;\n  };\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"../const\":5,\"buffer\":80}],61:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var Base, C, iced, konst, __iced_k, __iced_k_noop;\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  konst = require('../const');\n\n  C = konst.openpgp;\n\n  exports.Base = Base = (function() {\n    function Base(_arg) {\n      this.packets = _arg.packets, this.keyfetch = _arg.keyfetch;\n      this._sig = null;\n    }\n\n    Base.prototype._find_signature = function(cb) {\n      var err, n;\n      err = (n = this.packets.length) !== 1 ? new Error(\"Expected one signature packet; got \" + n) : (this._sig = this.packets[0]).tag !== C.packet_tags.signature ? new Error(\"Expected a signature packet; but got type=\" + this.packets[0].tag) : null;\n      return cb(err);\n    };\n\n    Base.prototype._fetch_key = function(cb) {\n      var err, i, key_id, keymat, km, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      key_id = this._sig.get_key_id();\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/openpgp/verifier.iced\",\n            funcname: \"Base._fetch_key\"\n          });\n          _this.keyfetch.fetch([key_id], konst.ops.verify, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                km = arguments[1];\n                return i = arguments[2];\n              };\n            })(),\n            lineno: 28\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (typeof err === \"undefined\" || err === null) {\n            keymat = km.find_pgp_key_material(key_id);\n            _this._sig.key = keymat.key;\n            _this._sig.key_manager = km;\n          }\n          return cb(err);\n        };\n      })(this));\n    };\n\n    return Base;\n\n  })();\n\n}).call(this);\n\n},{\"../const\":5,\"iced-runtime\":118}],62:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var C, SHA512, SRF, bufeq_secure, buffer_to_ui8a, eme_random, emsa_pkcs1_decode, emsa_pkcs1_encode, hash_headers, iced, nbs, __iced_k, __iced_k_noop, _ref;\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  SHA512 = require('./hash').SHA512;\n\n  C = require('./const').openpgp;\n\n  nbs = require('./bn').nbs;\n\n  _ref = require('./util'), buffer_to_ui8a = _ref.buffer_to_ui8a, bufeq_secure = _ref.bufeq_secure;\n\n  SRF = require('./rand').SRF;\n\n  hash_headers = {\n    MD5: [0x30, 0x20, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10],\n    SHA1: [0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14],\n    SHA224: [0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04, 0x05, 0x00, 0x04, 0x1C],\n    SHA256: [0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20],\n    SHA384: [0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30],\n    SHA512: [0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40]\n  };\n\n  exports.emsa_pkcs1_encode = emsa_pkcs1_encode = function(hashed_data, len, opts) {\n    var buf, hasher, headers, i, n;\n    if (opts == null) {\n      opts = {};\n    }\n    hasher = opts.hasher || SHA512;\n    headers = hash_headers[hasher.algname];\n    n = len - headers.length - 3 - hasher.output_length;\n    buf = Buffer.concat([\n      new Buffer([0x00, 0x01]), new Buffer((function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {\n          _results.push(0xff);\n        }\n        return _results;\n      })()), new Buffer([0x00]), new Buffer(headers), hashed_data\n    ]);\n    return nbs(buffer_to_ui8a(buf), 256);\n  };\n\n  exports.emsa_pkcs1_decode = emsa_pkcs1_decode = function(v, hasher) {\n    var err, h, header, i, ret;\n    err = ret = null;\n    i = 0;\n    if (v.length < 2) {\n      err = new Error(\"signature was way too short: < 2 bytes\");\n    } else {\n      if (v.readUInt16BE(0) !== 0x0001) {\n        err = new Error(\"Sig verify error: Didn't get two-byte header 0x00 0x01\");\n      } else {\n        i = 2;\n        while (i < v.length && (v.readUInt8(i) === 0xff)) {\n          i++;\n        }\n        if (i >= v.length || v.readUInt8(i) !== 0) {\n          err = new Error(\"Sig verify error: Missed the 0x0 separator\");\n        } else {\n          i++;\n          header = hash_headers[hasher.algname];\n          if (!bufeq_secure(new Buffer(header), v.slice(i, header.length + i))) {\n            err = new Error(\"Sig verify error: missing ASN header for \" + hasher.algname);\n          } else {\n            i += header.length;\n            h = v.slice(i);\n            if (h.length !== hasher.output_length) {\n              err = new Error(\"Sig verify error: trailing garbage in signature\");\n            } else {\n              ret = h;\n            }\n          }\n        }\n      }\n    }\n    return [err, ret];\n  };\n\n  eme_random = function(n, cb) {\n    var b, bytes, c, diff, i, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    bytes = [];\n    (function(_this) {\n      return (function(__iced_k) {\n        var _results, _while;\n        _results = [];\n        _while = function(__iced_k) {\n          var _break, _continue, _next;\n          _break = function() {\n            return __iced_k(_results);\n          };\n          _continue = function() {\n            return iced.trampoline(function() {\n              return _while(__iced_k);\n            });\n          };\n          _next = function(__iced_next_arg) {\n            _results.push(__iced_next_arg);\n            return _continue();\n          };\n          if (!(bytes.length < n)) {\n            return _break();\n          } else {\n            diff = n - bytes.length;\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/kbpgp/src/pad.iced\"\n              });\n              SRF().random_bytes(diff, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return b = arguments[0];\n                  };\n                })(),\n                lineno: 77\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              var _i;\n              for (i = _i = 0; 0 <= diff ? _i < diff : _i > diff; i = 0 <= diff ? ++_i : --_i) {\n                c = b.readUInt8(i);\n                if (c !== 0) {\n                  bytes.push(c);\n                }\n              }\n              return _next();\n            });\n          }\n        };\n        _while(__iced_k);\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(new Buffer(bytes));\n      };\n    })(this));\n  };\n\n  exports.eme_pkcs1_encode = function(v, len, cb) {\n    var PS, buf, err, n_randos, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    ret = err = null;\n    (function(_this) {\n      return (function(__iced_k) {\n        if (v.length > len - 11) {\n          return __iced_k(err = new Error(\"cannot encrypt message -- it's too long!\"));\n        } else {\n          n_randos = len - 3 - v.length;\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/kbpgp/src/pad.iced\",\n              funcname: \"eme_pkcs1_encode\"\n            });\n            eme_random(n_randos, __iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return PS = arguments[0];\n                };\n              })(),\n              lineno: 93\n            }));\n            __iced_deferrals._fulfill();\n          })(function() {\n            buf = Buffer.concat([new Buffer([0x00, 0x02]), PS, new Buffer([0x00]), v]);\n            return __iced_k(ret = nbs(buffer_to_ui8a(buf), 256));\n          });\n        }\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(err, ret);\n      };\n    })(this));\n  };\n\n  exports.eme_pkcs1_decode = function(v) {\n    var err, i, ret;\n    err = ret = null;\n    if (v.length < 12) {\n      err = new Error(\"Ciphertext too short, needs to be >= 12 bytes\");\n    } else if (v.readUInt16BE(0) !== 0x0002) {\n      err = new Error(\"Failed to find expected header: 0x00 0x02\");\n    } else {\n      i = 2;\n      while (i < v.length && (v.readUInt8(i) !== 0x0)) {\n        i++;\n      }\n      if (i >= v.length) {\n        err = new Error(\"didn't get 0x00 seperator octet\");\n      } else {\n        i++;\n        ret = v.slice(i);\n      }\n    }\n    return [err, ret];\n  };\n\n  exports.ecc_pkcs5_pad_data = function(d) {\n    var err, pad_len, ret, v;\n    err = ret = null;\n    pad_len = 40 - d.length;\n    if (pad_len < 0) {\n      err = new Error(\"Pad underrun\");\n    } else {\n      v = (function() {\n        var _i, _results;\n        _results = [];\n        for (_i = 0; 0 <= pad_len ? _i < pad_len : _i > pad_len; 0 <= pad_len ? _i++ : _i--) {\n          _results.push(pad_len);\n        }\n        return _results;\n      })();\n      ret = Buffer.concat([d, new Buffer(v)]);\n    }\n    return [err, ret];\n  };\n\n  exports.ecc_pkcs5_unpad_data = function(buf, data_len) {\n    var c, err, i, pad_len, _i, _ref1;\n    err = null;\n    pad_len = buf.length - data_len;\n    if (pad_len < 0) {\n      err = new Error(\"Pad length was < 0; pad underrun\");\n    } else if ((buf.length % 8) !== 0) {\n      err = new Error(\"Padded data must be a multiple of 8 bytes long\");\n    } else {\n      for (i = _i = data_len, _ref1 = buf.length; data_len <= _ref1 ? _i < _ref1 : _i > _ref1; i = data_len <= _ref1 ? ++_i : --_i) {\n        if ((c = buf.readUInt8(i)) !== pad_len) {\n          err = new Error(\"Got bad PKCS#5 pad character \" + c + \" at position \" + i + \"; wanted \" + pad_len);\n          break;\n        }\n      }\n    }\n    return err;\n  };\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./bn\":4,\"./const\":5,\"./hash\":14,\"./rand\":65,\"./util\":70,\"buffer\":80,\"iced-runtime\":118}],63:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var ASP, Avg, BigInteger, MRF, PrimeFinder, SRF, Timer, fermat2_test, fta, iced, make_esc, miller_rabin, naive_is_prime, native_rng, nbi, nbs, nbv, prime_search, prng, quickmod, random_prime, small_primes, _MR_inner, _MR_small_check, __iced_k, __iced_k_noop, _ref, _ref1;\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  _ref = require('bn'), nbv = _ref.nbv, nbi = _ref.nbi, BigInteger = _ref.BigInteger;\n\n  prng = require('triplesec').prng;\n\n  native_rng = prng.native_rng;\n\n  small_primes = require('./primes').small_primes;\n\n  make_esc = require('iced-error').make_esc;\n\n  ASP = require('./util').ASP;\n\n  nbs = require('./bn').nbs;\n\n  _ref1 = require('./rand'), MRF = _ref1.MRF, SRF = _ref1.SRF;\n\n  Timer = (function() {\n    function Timer() {\n      this.start = Date.now();\n    }\n\n    Timer.prototype.stop = function() {\n      return Date.now() - this.start;\n    };\n\n    return Timer;\n\n  })();\n\n  Avg = (function() {\n    function Avg() {\n      this.tot = 0;\n      this.n = 0;\n    }\n\n    Avg.prototype.start = function() {\n      return this._t = Date.now();\n    };\n\n    Avg.prototype.stop = function() {\n      var s;\n      s = Date.now() - this._t;\n      console.log(\"ran in \" + s);\n      this.tot += s;\n      return this.n++;\n    };\n\n    Avg.prototype.avg = function() {\n      return this.tot / this.n;\n    };\n\n    return Avg;\n\n  })();\n\n  quickmod = function(p, d) {\n    return p.modInt(d);\n  };\n\n  fta = new Avg();\n\n  fermat2_test = function(n) {\n    var Bl, bl, i, ret, t, _i;\n    t = nbv(1);\n    bl = n.bitLength();\n    bl--;\n    Bl = n.byteLength();\n    for (i = _i = bl; bl <= 0 ? _i <= 0 : _i >= 0; i = bl <= 0 ? ++_i : --_i) {\n      t = t.square();\n      if (t.byteLength() > Bl) {\n        t = t.mod(n);\n      }\n      if (n.testBit(i)) {\n        t = t.shiftLeft(1);\n      }\n    }\n    if (t.compareTo(n) > 0) {\n      t = t.mod(n);\n    }\n    ret = t.compareTo(nbv(2)) === 0;\n    return ret;\n  };\n\n  _MR_inner = function(_arg) {\n    var a, j, p, p1, r, s, y, _i, _ref2;\n    s = _arg.s, r = _arg.r, p = _arg.p, p1 = _arg.p1;\n    a = MRF().random_zn(p);\n    y = a.modPow(r, p);\n    if (y.compareTo(BigInteger.ONE) !== 0) {\n      for (j = _i = _ref2 = s - 1; _ref2 <= 0 ? _i <= 0 : _i >= 0; j = _ref2 <= 0 ? ++_i : --_i) {\n        if (!(y.compareTo(p1) !== 0)) {\n          continue;\n        }\n        if (j === 0) {\n          return false;\n        }\n        y = y.square().mod(p);\n        if (y.compareTo(BigInteger.ONE) === 0) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  _MR_small_check = function(_arg) {\n    var p, _ref2;\n    p = _arg.p;\n    if (p.compareTo(BigInteger.ZERO) <= 0) {\n      return false;\n    } else if (p.compareTo(nbv(7)) <= 0) {\n      return (_ref2 = p.intValue()) === 2 || _ref2 === 3 || _ref2 === 5 || _ref2 === 7;\n    } else if (!p.testBit(0)) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n\n  miller_rabin = function(_arg, cb) {\n    var asp, esc, i, iter, p, p1, r, ret, s, ___iced_passed_deferral, __iced_deferrals, __iced_k, _begin, _end, _positive;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    p = _arg.p, iter = _arg.iter, asp = _arg.asp;\n    asp || (asp = new ASP({}));\n    iter || (iter = 10);\n    esc = make_esc(cb, \"miller_rabin\");\n    ret = _MR_small_check({\n      p: p\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        if (ret) {\n          p1 = p.subtract(BigInteger.ONE);\n          s = p1.getLowestSetBit();\n          r = p1.shiftRight(s);\n          ret = true;\n          (function(__iced_k) {\n            var _i, _results, _while;\n            i = 0;\n            _begin = 0;\n            _end = iter;\n            _positive = _end > _begin;\n            _results = [];\n            _while = function(__iced_k) {\n              var _break, _continue, _next;\n              _break = function() {\n                return __iced_k(_results);\n              };\n              _continue = function() {\n                return iced.trampoline(function() {\n                  if (_positive) {\n                    i += 1;\n                  } else {\n                    i -= 1;\n                  }\n                  return _while(__iced_k);\n                });\n              };\n              _next = function(__iced_next_arg) {\n                _results.push(__iced_next_arg);\n                return _continue();\n              };\n              if (!!((_positive === true && i >= iter) || (_positive === false && i <= iter))) {\n                return _break();\n              } else {\n\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/home/max/src/keybase/kbpgp/src/primegen.iced\"\n                  });\n                  asp.progress({\n                    what: \"mr\",\n                    i: i,\n                    total: iter,\n                    p: p\n                  }, esc(__iced_deferrals.defer({\n                    lineno: 122\n                  })));\n                  __iced_deferrals._fulfill();\n                })(function() {\n                  (function(__iced_k) {\n                    if (!_MR_inner({\n                      s: s,\n                      r: r,\n                      p: p,\n                      p1: p1\n                    })) {\n                      ret = false;\n                      (function(__iced_k) {\n_break()\n                      })(__iced_k);\n                    } else {\n                      return __iced_k();\n                    }\n                  })(_next);\n                });\n              }\n            };\n            _while(__iced_k);\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/kbpgp/src/primegen.iced\"\n              });\n              asp.progress({\n                what: \"mr\",\n                i: iter,\n                total: iter,\n                p: p\n              }, esc(__iced_deferrals.defer({\n                lineno: 127\n              })));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          });\n        } else {\n          return __iced_k();\n        }\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(null, ret);\n      };\n    })(this));\n  };\n\n  PrimeFinder = (function() {\n    function PrimeFinder(p, sieve) {\n      this.p = p;\n      this.sieve = sieve;\n      this.inc = 0;\n      this.maxinc = -1;\n      this.sievepos = quickmod(this.p, this.sieve.length);\n      this.calcmods();\n    }\n\n    PrimeFinder.prototype.getp = function() {\n      return this.p;\n    };\n\n    PrimeFinder.prototype.setmax = function(i) {\n      if (this.maxinc !== -1) {\n        throw new Error(\"can only setmax() once\");\n      }\n      return this.maxinc = i;\n    };\n\n    PrimeFinder.prototype.calcmods = function() {\n      var sp;\n      this.p = this.p.add(nbv(this.inc));\n      if (this.maxinc !== -1) {\n        this.maxinc -= this.inc;\n      }\n      this.inc = 0;\n      return this.mods = (function() {\n        var _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = small_primes.length; _i < _len; _i++) {\n          sp = small_primes[_i];\n          _results.push(quickmod(this.p, sp));\n        }\n        return _results;\n      }).call(this);\n    };\n\n    PrimeFinder.prototype.decrement_mods_find_divisor = function() {\n      var i, sp, _i, _len;\n      for (i = _i = 0, _len = small_primes.length; _i < _len; i = ++_i) {\n        sp = small_primes[i];\n        while (this.mods[i] + this.inc >= sp) {\n          this.mods[i] -= sp;\n          if ((this.mods[i] + this.inc) === 0) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n\n    PrimeFinder.prototype.next_weak = function() {\n      var step;\n      while (true) {\n        step = this.sieve[this.sievepos];\n        this.sievepos = (this.sievepos + step) % this.sieve.length;\n        this.inc += step;\n        if (this.inc > this.maxinc && this.maxinc > 0) {\n          this.tmp = nbv(0);\n          return this.tmp;\n        }\n        if (this.inc < 0) {\n          this.calcmods();\n        }\n        if (!this.decrement_mods_find_divisor()) {\n          this.tmp = this.p.add(nbv(this.inc));\n          return this.tmp;\n        }\n      }\n    };\n\n    PrimeFinder.prototype.next_fermat = function() {\n      while (true) {\n        this.next_weak();\n        if (!this.tmp || fermat2_test(this.tmp)) {\n          return this.tmp;\n        }\n      }\n    };\n\n    PrimeFinder.prototype.next_strong = function(iter) {\n      if (iter == null) {\n        iter = 32;\n      }\n      while (true) {\n        this.next_weak();\n        if (!this.tmp || (fermat2_test(this.tmp) && probab_prime(this.tmp, iter))) {\n          return this.tmp;\n        }\n      }\n    };\n\n    return PrimeFinder;\n\n  })();\n\n  prime_search = function(_arg, cb) {\n    var asp, esc, i, is_prime, iters, p, pf, pp, pvec, range, ret, sieve, start, tmp, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    start = _arg.start, range = _arg.range, sieve = _arg.sieve, asp = _arg.asp, iters = _arg.iters;\n    iters || (iters = 20);\n    pf = new PrimeFinder(start, sieve);\n    pf.setmax(range);\n    pvec = ((function() {\n      var _results;\n      _results = [];\n      while ((pp = pf.next_weak()).compareTo(BigInteger.ZERO) > 0) {\n        _results.push(pp);\n      }\n      return _results;\n    })());\n    esc = make_esc(cb, \"prime_search\");\n    ret = null;\n    (function(_this) {\n      return (function(__iced_k) {\n        var _results, _while;\n        _results = [];\n        _while = function(__iced_k) {\n          var _break, _continue, _next;\n          _break = function() {\n            return __iced_k(_results);\n          };\n          _continue = function() {\n            return iced.trampoline(function() {\n              return _while(__iced_k);\n            });\n          };\n          _next = function(__iced_next_arg) {\n            _results.push(__iced_next_arg);\n            return _continue();\n          };\n          if (!(pvec.length && (ret == null))) {\n            return _break();\n          } else {\n            i = MRF().random_word() % pvec.length;\n            p = pvec[i];\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/kbpgp/src/primegen.iced\"\n              });\n              asp.progress({\n                what: \"fermat\",\n                p: p\n              }, esc(__iced_deferrals.defer({\n                lineno: 226\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              (function(__iced_k) {\n                if (!fermat2_test(p)) {\n                  return __iced_k();\n                } else {\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/home/max/src/keybase/kbpgp/src/primegen.iced\"\n                    });\n                    miller_rabin({\n                      p: p,\n                      iters: iters,\n                      asp: asp\n                    }, esc(__iced_deferrals.defer({\n                      assign_fn: (function() {\n                        return function() {\n                          return is_prime = arguments[0];\n                        };\n                      })(),\n                      lineno: 229\n                    })));\n                    __iced_deferrals._fulfill();\n                  })(function() {\n                    (function(__iced_k) {\n                      __iced_deferrals = new iced.Deferrals(__iced_k, {\n                        parent: ___iced_passed_deferral,\n                        filename: \"/home/max/src/keybase/kbpgp/src/primegen.iced\"\n                      });\n                      asp.progress({\n                        what: \"passed_mr\",\n                        p: p\n                      }, esc(__iced_deferrals.defer({\n                        lineno: 230\n                      })));\n                      __iced_deferrals._fulfill();\n                    })(function() {\n                      return __iced_k(is_prime ? ret = p : asp.progress({\n                        what: \"failed_mr\",\n                        p: p\n                      }));\n                    });\n                  });\n                }\n              })(function() {\n                tmp = pvec.pop();\n                return _next(i < pvec.length ? pvec[i] = tmp : void 0);\n              });\n            });\n          }\n        };\n        _while(__iced_k);\n      });\n    })(this)((function(_this) {\n      return function() {\n        if (ret == null) {\n          ret = nbv(0);\n        }\n        return cb(null, ret);\n      };\n    })(this));\n  };\n\n  random_prime = function(_arg, cb) {\n    var asp, e, esc, go, iters, nbits, p, range, sieve, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    nbits = _arg.nbits, iters = _arg.iters, asp = _arg.asp, e = _arg.e;\n    sieve = [1, 2];\n    go = true;\n    esc = make_esc(cb, \"random_prime\");\n    range = nbits;\n    p = null;\n    (function(_this) {\n      return (function(__iced_k) {\n        var _results, _while;\n        _results = [];\n        _while = function(__iced_k) {\n          var _break, _continue, _next;\n          _break = function() {\n            return __iced_k(_results);\n          };\n          _continue = function() {\n            return iced.trampoline(function() {\n              return _while(__iced_k);\n            });\n          };\n          _next = function(__iced_next_arg) {\n            _results.push(__iced_next_arg);\n            return _continue();\n          };\n          if (!go) {\n            return _break();\n          } else {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/kbpgp/src/primegen.iced\"\n              });\n              SRF().random_nbit(nbits, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return p = arguments[0];\n                  };\n                })(),\n                lineno: 262\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              p = p.setBit(0).setBit(nbits - 1).setBit(nbits - 2);\n              (function(__iced_k) {\n                if ((e == null) || p.subtract(BigInteger.ONE).gcd(e).compareTo(BigInteger.ONE) === 0) {\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/home/max/src/keybase/kbpgp/src/primegen.iced\"\n                    });\n                    asp.progress({\n                      what: \"guess\",\n                      p: p\n                    }, esc(__iced_deferrals.defer({\n                      lineno: 265\n                    })));\n                    __iced_deferrals._fulfill();\n                  })(function() {\n                    (function(__iced_k) {\n                      __iced_deferrals = new iced.Deferrals(__iced_k, {\n                        parent: ___iced_passed_deferral,\n                        filename: \"/home/max/src/keybase/kbpgp/src/primegen.iced\"\n                      });\n                      prime_search({\n                        start: p,\n                        range: range,\n                        sieve: sieve,\n                        asp: asp,\n                        iters: iters\n                      }, esc(__iced_deferrals.defer({\n                        assign_fn: (function() {\n                          return function() {\n                            return p = arguments[0];\n                          };\n                        })(),\n                        lineno: 266\n                      })));\n                      __iced_deferrals._fulfill();\n                    })(function() {\n                      return __iced_k(go = (p == null) || (p.compareTo(BigInteger.ZERO) === 0));\n                    });\n                  });\n                } else {\n                  return __iced_k();\n                }\n              })(_next);\n            });\n          }\n        };\n        _while(__iced_k);\n      });\n    })(this)((function(_this) {\n      return function() {\n        (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/primegen.iced\"\n          });\n          asp.progress({\n            what: \"found\",\n            p: p\n          }, esc(__iced_deferrals.defer({\n            lineno: 269\n          })));\n          __iced_deferrals._fulfill();\n        })(function() {\n          return cb(null, p);\n        });\n      };\n    })(this));\n  };\n\n  exports.naive_is_prime = naive_is_prime = function(n) {\n    var biggest, p, _i, _len;\n    biggest = Math.floor(Math.sqrt(n));\n    for (_i = 0, _len = small_primes.length; _i < _len; _i++) {\n      p = small_primes[_i];\n      if (p > biggest) {\n        return true;\n      }\n      if ((n % p) === 0) {\n        return false;\n      }\n    }\n    return false;\n  };\n\n  exports.fermat2_test = fermat2_test;\n\n  exports.nbs = nbs;\n\n  exports.small_primes = small_primes;\n\n  exports.miller_rabin = miller_rabin;\n\n  exports.random_prime = random_prime;\n\n}).call(this);\n\n},{\"./bn\":4,\"./primes\":64,\"./rand\":65,\"./util\":70,\"bn\":71,\"iced-error\":115,\"iced-runtime\":118,\"triplesec\":181}],64:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  exports.small_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973, 10007, 10009, 10037, 10039, 10061, 10067, 10069, 10079, 10091, 10093, 10099, 10103, 10111, 10133, 10139, 10141, 10151, 10159, 10163, 10169, 10177, 10181, 10193, 10211, 10223, 10243, 10247, 10253, 10259, 10267, 10271, 10273, 10289, 10301, 10303, 10313, 10321, 10331, 10333, 10337, 10343, 10357, 10369, 10391, 10399, 10427, 10429, 10433, 10453, 10457, 10459, 10463, 10477, 10487, 10499, 10501, 10513, 10529, 10531, 10559, 10567, 10589, 10597, 10601, 10607, 10613, 10627, 10631, 10639, 10651, 10657, 10663, 10667, 10687, 10691, 10709, 10711, 10723, 10729, 10733, 10739, 10753, 10771, 10781, 10789, 10799, 10831, 10837, 10847, 10853, 10859, 10861, 10867, 10883, 10889, 10891, 10903, 10909, 10937, 10939, 10949, 10957, 10973, 10979, 10987, 10993, 11003, 11027, 11047, 11057, 11059, 11069, 11071, 11083, 11087, 11093, 11113, 11117, 11119, 11131, 11149, 11159, 11161, 11171, 11173, 11177, 11197, 11213, 11239, 11243, 11251, 11257, 11261, 11273, 11279, 11287, 11299, 11311, 11317, 11321, 11329, 11351, 11353, 11369, 11383, 11393, 11399, 11411, 11423, 11437, 11443, 11447, 11467, 11471, 11483, 11489, 11491, 11497, 11503, 11519, 11527, 11549, 11551, 11579, 11587, 11593, 11597, 11617, 11621, 11633, 11657, 11677, 11681, 11689, 11699, 11701, 11717, 11719, 11731, 11743, 11777, 11779, 11783, 11789, 11801, 11807, 11813, 11821, 11827, 11831, 11833, 11839, 11863, 11867, 11887, 11897, 11903, 11909, 11923, 11927, 11933, 11939, 11941, 11953, 11959, 11969, 11971, 11981, 11987, 12007, 12011, 12037, 12041, 12043, 12049, 12071, 12073, 12097, 12101, 12107, 12109, 12113, 12119, 12143, 12149, 12157, 12161, 12163, 12197, 12203, 12211, 12227, 12239, 12241, 12251, 12253, 12263, 12269, 12277, 12281, 12289, 12301, 12323, 12329, 12343, 12347, 12373, 12377, 12379, 12391, 12401, 12409, 12413, 12421, 12433, 12437, 12451, 12457, 12473, 12479, 12487, 12491, 12497, 12503, 12511, 12517, 12527, 12539, 12541, 12547, 12553, 12569, 12577, 12583, 12589, 12601, 12611, 12613, 12619, 12637, 12641, 12647, 12653, 12659, 12671, 12689, 12697, 12703, 12713, 12721, 12739, 12743, 12757, 12763, 12781, 12791, 12799, 12809, 12821, 12823, 12829, 12841, 12853, 12889, 12893, 12899, 12907, 12911, 12917, 12919, 12923, 12941, 12953, 12959, 12967, 12973, 12979, 12983, 13001, 13003, 13007, 13009, 13033, 13037, 13043, 13049, 13063, 13093, 13099, 13103, 13109, 13121, 13127, 13147, 13151, 13159, 13163, 13171, 13177, 13183, 13187, 13217, 13219, 13229, 13241, 13249, 13259, 13267, 13291, 13297, 13309, 13313, 13327, 13331, 13337, 13339, 13367, 13381, 13397, 13399, 13411, 13417, 13421, 13441, 13451, 13457, 13463, 13469, 13477, 13487, 13499, 13513, 13523, 13537, 13553, 13567, 13577, 13591, 13597, 13613, 13619, 13627, 13633, 13649, 13669, 13679, 13681, 13687, 13691, 13693, 13697, 13709, 13711, 13721, 13723, 13729, 13751, 13757, 13759, 13763, 13781, 13789, 13799, 13807, 13829, 13831, 13841, 13859, 13873, 13877, 13879, 13883, 13901, 13903, 13907, 13913, 13921, 13931, 13933, 13963, 13967, 13997, 13999, 14009, 14011, 14029, 14033, 14051, 14057, 14071, 14081, 14083, 14087, 14107, 14143, 14149, 14153, 14159, 14173, 14177, 14197, 14207, 14221, 14243, 14249, 14251, 14281, 14293, 14303, 14321, 14323, 14327, 14341, 14347, 14369, 14387, 14389, 14401, 14407, 14411, 14419, 14423, 14431, 14437, 14447, 14449, 14461, 14479, 14489, 14503, 14519, 14533, 14537, 14543, 14549, 14551, 14557, 14561, 14563, 14591, 14593, 14621, 14627, 14629, 14633, 14639, 14653, 14657, 14669, 14683, 14699, 14713, 14717, 14723, 14731, 14737, 14741, 14747, 14753, 14759, 14767, 14771, 14779, 14783, 14797, 14813, 14821, 14827, 14831, 14843, 14851, 14867, 14869, 14879, 14887, 14891, 14897, 14923, 14929, 14939, 14947, 14951, 14957, 14969, 14983, 15013, 15017, 15031, 15053, 15061, 15073, 15077, 15083, 15091, 15101, 15107, 15121, 15131, 15137, 15139, 15149, 15161, 15173, 15187, 15193, 15199, 15217, 15227, 15233, 15241, 15259, 15263, 15269, 15271, 15277, 15287, 15289, 15299, 15307, 15313, 15319, 15329, 15331, 15349, 15359, 15361, 15373, 15377, 15383, 15391, 15401, 15413, 15427, 15439, 15443, 15451, 15461, 15467, 15473, 15493, 15497, 15511, 15527, 15541, 15551, 15559, 15569, 15581, 15583, 15601, 15607, 15619, 15629, 15641, 15643, 15647, 15649, 15661, 15667, 15671, 15679, 15683, 15727, 15731, 15733, 15737, 15739, 15749, 15761, 15767, 15773, 15787, 15791, 15797, 15803, 15809, 15817, 15823, 15859, 15877, 15881, 15887, 15889, 15901, 15907, 15913, 15919, 15923, 15937, 15959, 15971, 15973, 15991, 16001, 16007, 16033, 16057, 16061, 16063, 16067, 16069, 16073, 16087, 16091, 16097, 16103, 16111, 16127, 16139, 16141, 16183, 16187, 16189, 16193, 16217, 16223, 16229, 16231, 16249, 16253, 16267, 16273, 16301, 16319, 16333, 16339, 16349, 16361, 16363, 16369, 16381, 16411, 16417, 16421, 16427, 16433, 16447, 16451, 16453, 16477, 16481, 16487, 16493, 16519, 16529, 16547, 16553, 16561, 16567, 16573, 16603, 16607, 16619, 16631, 16633, 16649, 16651, 16657, 16661, 16673, 16691, 16693, 16699, 16703, 16729, 16741, 16747, 16759, 16763, 16787, 16811, 16823, 16829, 16831, 16843, 16871, 16879, 16883, 16889, 16901, 16903, 16921, 16927, 16931, 16937, 16943, 16963, 16979, 16981, 16987, 16993, 17011, 17021, 17027, 17029, 17033, 17041, 17047, 17053, 17077, 17093, 17099, 17107, 17117, 17123, 17137, 17159, 17167, 17183, 17189, 17191, 17203, 17207, 17209, 17231, 17239, 17257, 17291, 17293, 17299, 17317, 17321, 17327, 17333, 17341, 17351, 17359, 17377, 17383, 17387, 17389, 17393, 17401, 17417, 17419, 17431, 17443, 17449, 17467, 17471, 17477, 17483, 17489, 17491, 17497, 17509, 17519, 17539, 17551, 17569, 17573, 17579, 17581, 17597, 17599, 17609, 17623, 17627, 17657, 17659, 17669, 17681, 17683, 17707, 17713, 17729, 17737, 17747, 17749, 17761, 17783, 17789, 17791, 17807, 17827, 17837, 17839, 17851, 17863, 17881, 17891, 17903, 17909, 17911, 17921, 17923, 17929, 17939, 17957, 17959, 17971, 17977, 17981, 17987, 17989, 18013, 18041, 18043, 18047, 18049, 18059, 18061, 18077, 18089, 18097, 18119, 18121, 18127, 18131, 18133, 18143, 18149, 18169, 18181, 18191, 18199, 18211, 18217, 18223, 18229, 18233, 18251, 18253, 18257, 18269, 18287, 18289, 18301, 18307, 18311, 18313, 18329, 18341, 18353, 18367, 18371, 18379, 18397, 18401, 18413, 18427, 18433, 18439, 18443, 18451, 18457, 18461, 18481, 18493, 18503, 18517, 18521, 18523, 18539, 18541, 18553, 18583, 18587, 18593, 18617, 18637, 18661, 18671, 18679, 18691, 18701, 18713, 18719, 18731, 18743, 18749, 18757, 18773, 18787, 18793, 18797, 18803, 18839, 18859, 18869, 18899, 18911, 18913, 18917, 18919, 18947, 18959, 18973, 18979, 19001, 19009, 19013, 19031, 19037, 19051, 19069, 19073, 19079, 19081, 19087, 19121, 19139, 19141, 19157, 19163, 19181, 19183, 19207, 19211, 19213, 19219, 19231, 19237, 19249, 19259, 19267, 19273, 19289, 19301, 19309, 19319, 19333, 19373, 19379, 19381, 19387, 19391, 19403, 19417, 19421, 19423, 19427, 19429, 19433, 19441, 19447, 19457, 19463, 19469, 19471, 19477, 19483, 19489, 19501, 19507, 19531, 19541, 19543, 19553, 19559, 19571, 19577, 19583, 19597, 19603, 19609, 19661, 19681, 19687, 19697, 19699, 19709, 19717, 19727, 19739, 19751, 19753, 19759, 19763, 19777, 19793, 19801, 19813, 19819, 19841, 19843, 19853, 19861, 19867, 19889, 19891, 19913, 19919, 19927, 19937, 19949, 19961, 19963, 19973, 19979, 19991, 19993, 19997, 20011, 20021, 20023, 20029, 20047, 20051, 20063, 20071, 20089, 20101, 20107, 20113, 20117, 20123, 20129, 20143, 20147, 20149, 20161, 20173, 20177, 20183, 20201, 20219, 20231, 20233, 20249, 20261, 20269, 20287, 20297, 20323, 20327, 20333, 20341, 20347, 20353, 20357, 20359, 20369, 20389, 20393, 20399, 20407, 20411, 20431, 20441, 20443, 20477, 20479, 20483, 20507, 20509, 20521, 20533, 20543, 20549, 20551, 20563, 20593, 20599, 20611, 20627, 20639, 20641, 20663, 20681, 20693, 20707, 20717, 20719, 20731, 20743, 20747, 20749, 20753, 20759, 20771, 20773, 20789, 20807, 20809, 20849, 20857, 20873, 20879, 20887, 20897, 20899, 20903, 20921, 20929, 20939, 20947, 20959, 20963, 20981, 20983, 21001, 21011, 21013, 21017, 21019, 21023, 21031, 21059, 21061, 21067, 21089, 21101, 21107, 21121, 21139, 21143, 21149, 21157, 21163, 21169, 21179, 21187, 21191, 21193, 21211, 21221, 21227, 21247, 21269, 21277, 21283, 21313, 21317, 21319, 21323, 21341, 21347, 21377, 21379, 21383, 21391, 21397, 21401, 21407, 21419, 21433, 21467, 21481, 21487, 21491, 21493, 21499, 21503, 21517, 21521, 21523, 21529, 21557, 21559, 21563, 21569, 21577, 21587, 21589, 21599, 21601, 21611, 21613, 21617, 21647, 21649, 21661, 21673, 21683, 21701, 21713, 21727, 21737, 21739, 21751, 21757, 21767, 21773, 21787, 21799, 21803, 21817, 21821, 21839, 21841, 21851, 21859, 21863, 21871, 21881, 21893, 21911, 21929, 21937, 21943, 21961, 21977, 21991, 21997, 22003, 22013, 22027, 22031, 22037, 22039, 22051, 22063, 22067, 22073, 22079, 22091, 22093, 22109, 22111, 22123, 22129, 22133, 22147, 22153, 22157, 22159, 22171, 22189, 22193, 22229, 22247, 22259, 22271, 22273, 22277, 22279, 22283, 22291, 22303, 22307, 22343, 22349, 22367, 22369, 22381, 22391, 22397, 22409, 22433, 22441, 22447, 22453, 22469, 22481, 22483, 22501, 22511, 22531, 22541, 22543, 22549, 22567, 22571, 22573, 22613, 22619, 22621, 22637, 22639, 22643, 22651, 22669, 22679, 22691, 22697, 22699, 22709, 22717, 22721, 22727, 22739, 22741, 22751, 22769, 22777, 22783, 22787, 22807, 22811, 22817, 22853, 22859, 22861, 22871, 22877, 22901, 22907, 22921, 22937, 22943, 22961, 22963, 22973, 22993, 23003, 23011, 23017, 23021, 23027, 23029, 23039, 23041, 23053, 23057, 23059, 23063, 23071, 23081, 23087, 23099, 23117, 23131, 23143, 23159, 23167, 23173, 23189, 23197, 23201, 23203, 23209, 23227, 23251, 23269, 23279, 23291, 23293, 23297, 23311, 23321, 23327, 23333, 23339, 23357, 23369, 23371, 23399, 23417, 23431, 23447, 23459, 23473, 23497, 23509, 23531, 23537, 23539, 23549, 23557, 23561, 23563, 23567, 23581, 23593, 23599, 23603, 23609, 23623, 23627, 23629, 23633, 23663, 23669, 23671, 23677, 23687, 23689, 23719, 23741, 23743, 23747, 23753, 23761, 23767, 23773, 23789, 23801, 23813, 23819, 23827, 23831, 23833, 23857, 23869, 23873, 23879, 23887, 23893, 23899, 23909, 23911, 23917, 23929, 23957, 23971, 23977, 23981, 23993, 24001, 24007, 24019, 24023, 24029, 24043, 24049, 24061, 24071, 24077, 24083, 24091, 24097, 24103, 24107, 24109, 24113, 24121, 24133, 24137, 24151, 24169, 24179, 24181, 24197, 24203, 24223, 24229, 24239, 24247, 24251, 24281, 24317, 24329, 24337, 24359, 24371, 24373, 24379, 24391, 24407, 24413, 24419, 24421, 24439, 24443, 24469, 24473, 24481, 24499, 24509, 24517, 24527, 24533, 24547, 24551, 24571, 24593, 24611, 24623, 24631, 24659, 24671, 24677, 24683, 24691, 24697, 24709, 24733, 24749, 24763, 24767, 24781, 24793, 24799, 24809, 24821, 24841, 24847, 24851, 24859, 24877, 24889, 24907, 24917, 24919, 24923, 24943, 24953, 24967, 24971, 24977, 24979, 24989, 25013, 25031, 25033, 25037, 25057, 25073, 25087, 25097, 25111, 25117, 25121, 25127, 25147, 25153, 25163, 25169, 25171, 25183, 25189, 25219, 25229, 25237, 25243, 25247, 25253, 25261, 25301, 25303, 25307, 25309, 25321, 25339, 25343, 25349, 25357, 25367, 25373, 25391, 25409, 25411, 25423, 25439, 25447, 25453, 25457, 25463, 25469, 25471, 25523, 25537, 25541, 25561, 25577, 25579, 25583, 25589, 25601, 25603, 25609, 25621, 25633, 25639, 25643, 25657, 25667, 25673, 25679, 25693, 25703, 25717, 25733, 25741, 25747, 25759, 25763, 25771, 25793, 25799, 25801, 25819, 25841, 25847, 25849, 25867, 25873, 25889, 25903, 25913, 25919, 25931, 25933, 25939, 25943, 25951, 25969, 25981, 25997, 25999, 26003, 26017, 26021, 26029, 26041, 26053, 26083, 26099, 26107, 26111, 26113, 26119, 26141, 26153, 26161, 26171, 26177, 26183, 26189, 26203, 26209, 26227, 26237, 26249, 26251, 26261, 26263, 26267, 26293, 26297, 26309, 26317, 26321, 26339, 26347, 26357, 26371, 26387, 26393, 26399, 26407, 26417, 26423, 26431, 26437, 26449, 26459, 26479, 26489, 26497, 26501, 26513, 26539, 26557, 26561, 26573, 26591, 26597, 26627, 26633, 26641, 26647, 26669, 26681, 26683, 26687, 26693, 26699, 26701, 26711, 26713, 26717, 26723, 26729, 26731, 26737, 26759, 26777, 26783, 26801, 26813, 26821, 26833, 26839, 26849, 26861, 26863, 26879, 26881, 26891, 26893, 26903, 26921, 26927, 26947, 26951, 26953, 26959, 26981, 26987, 26993, 27011, 27017, 27031, 27043, 27059, 27061, 27067, 27073, 27077, 27091, 27103, 27107, 27109, 27127, 27143, 27179, 27191, 27197, 27211, 27239, 27241, 27253, 27259, 27271, 27277, 27281, 27283, 27299, 27329, 27337, 27361, 27367, 27397, 27407, 27409, 27427, 27431, 27437, 27449, 27457, 27479, 27481, 27487, 27509, 27527, 27529, 27539, 27541, 27551, 27581, 27583, 27611, 27617, 27631, 27647, 27653, 27673, 27689, 27691, 27697, 27701, 27733, 27737, 27739, 27743, 27749, 27751, 27763, 27767, 27773, 27779, 27791, 27793, 27799, 27803, 27809, 27817, 27823, 27827, 27847, 27851, 27883, 27893, 27901, 27917, 27919, 27941, 27943, 27947, 27953, 27961, 27967, 27983, 27997, 28001, 28019, 28027, 28031, 28051, 28057, 28069, 28081, 28087, 28097, 28099, 28109, 28111, 28123, 28151, 28163, 28181, 28183, 28201, 28211, 28219, 28229, 28277, 28279, 28283, 28289, 28297, 28307, 28309, 28319, 28349, 28351, 28387, 28393, 28403, 28409, 28411, 28429, 28433, 28439, 28447, 28463, 28477, 28493, 28499, 28513, 28517, 28537, 28541, 28547, 28549, 28559, 28571, 28573, 28579, 28591, 28597, 28603, 28607, 28619, 28621, 28627, 28631, 28643, 28649, 28657, 28661, 28663, 28669, 28687, 28697, 28703, 28711, 28723, 28729, 28751, 28753, 28759, 28771, 28789, 28793, 28807, 28813, 28817, 28837, 28843, 28859, 28867, 28871, 28879, 28901, 28909, 28921, 28927, 28933, 28949, 28961, 28979, 29009, 29017, 29021, 29023, 29027, 29033, 29059, 29063, 29077, 29101, 29123, 29129, 29131, 29137, 29147, 29153, 29167, 29173, 29179, 29191, 29201, 29207, 29209, 29221, 29231, 29243, 29251, 29269, 29287, 29297, 29303, 29311, 29327, 29333, 29339, 29347, 29363, 29383, 29387, 29389, 29399, 29401, 29411, 29423, 29429, 29437, 29443, 29453, 29473, 29483, 29501, 29527, 29531, 29537, 29567, 29569, 29573, 29581, 29587, 29599, 29611, 29629, 29633, 29641, 29663, 29669, 29671, 29683, 29717, 29723, 29741, 29753, 29759, 29761, 29789, 29803, 29819, 29833, 29837, 29851, 29863, 29867, 29873, 29879, 29881, 29917, 29921, 29927, 29947, 29959, 29983, 29989, 30011, 30013, 30029, 30047, 30059, 30071, 30089, 30091, 30097, 30103, 30109, 30113, 30119, 30133, 30137, 30139, 30161, 30169, 30181, 30187, 30197, 30203, 30211, 30223, 30241, 30253, 30259, 30269, 30271, 30293, 30307, 30313, 30319, 30323, 30341, 30347, 30367, 30389, 30391, 30403, 30427, 30431, 30449, 30467, 30469, 30491, 30493, 30497, 30509, 30517, 30529, 30539, 30553, 30557, 30559, 30577, 30593, 30631, 30637, 30643, 30649, 30661, 30671, 30677, 30689, 30697, 30703, 30707, 30713, 30727, 30757, 30763, 30773, 30781, 30803, 30809, 30817, 30829, 30839, 30841, 30851, 30853, 30859, 30869, 30871, 30881, 30893, 30911, 30931, 30937, 30941, 30949, 30971, 30977, 30983, 31013, 31019, 31033, 31039, 31051, 31063, 31069, 31079, 31081, 31091, 31121, 31123, 31139, 31147, 31151, 31153, 31159, 31177, 31181, 31183, 31189, 31193, 31219, 31223, 31231, 31237, 31247, 31249, 31253, 31259, 31267, 31271, 31277, 31307, 31319, 31321, 31327, 31333, 31337, 31357, 31379, 31387, 31391, 31393, 31397, 31469, 31477, 31481, 31489, 31511, 31513, 31517, 31531, 31541, 31543, 31547, 31567, 31573, 31583, 31601, 31607, 31627, 31643, 31649, 31657, 31663, 31667, 31687, 31699, 31721, 31723, 31727, 31729, 31741, 31751, 31769, 31771, 31793, 31799, 31817, 31847, 31849, 31859, 31873, 31883, 31891, 31907, 31957, 31963, 31973, 31981, 31991, 32003, 32009, 32027, 32029, 32051, 32057, 32059, 32063, 32069, 32077, 32083, 32089, 32099, 32117, 32119, 32141, 32143, 32159, 32173, 32183, 32189, 32191, 32203, 32213, 32233, 32237, 32251, 32257, 32261, 32297, 32299, 32303, 32309, 32321, 32323, 32327, 32341, 32353, 32359, 32363, 32369, 32371, 32377, 32381, 32401, 32411, 32413, 32423, 32429, 32441, 32443, 32467, 32479, 32491, 32497, 32503, 32507, 32531, 32533, 32537, 32561, 32563, 32569, 32573, 32579, 32587, 32603, 32609, 32611, 32621, 32633, 32647, 32653, 32687, 32693, 32707, 32713, 32717, 32719, 32749, 32771, 32779, 32783, 32789, 32797, 32801, 32803, 32831, 32833, 32839, 32843, 32869, 32887, 32909, 32911, 32917, 32933, 32939, 32941, 32957, 32969, 32971, 32983, 32987, 32993, 32999, 33013, 33023, 33029, 33037, 33049, 33053, 33071, 33073, 33083, 33091, 33107, 33113, 33119, 33149, 33151, 33161, 33179, 33181, 33191, 33199, 33203, 33211, 33223, 33247, 33287, 33289, 33301, 33311, 33317, 33329, 33331, 33343, 33347, 33349, 33353, 33359, 33377, 33391, 33403, 33409, 33413, 33427, 33457, 33461, 33469, 33479, 33487, 33493, 33503, 33521, 33529, 33533, 33547, 33563, 33569, 33577, 33581, 33587, 33589, 33599, 33601, 33613, 33617, 33619, 33623, 33629, 33637, 33641, 33647, 33679, 33703, 33713, 33721, 33739, 33749, 33751, 33757, 33767, 33769, 33773, 33791, 33797, 33809, 33811, 33827, 33829, 33851, 33857, 33863, 33871, 33889, 33893, 33911, 33923, 33931, 33937, 33941, 33961, 33967, 33997, 34019, 34031, 34033, 34039, 34057, 34061, 34123, 34127, 34129, 34141, 34147, 34157, 34159, 34171, 34183, 34211, 34213, 34217, 34231, 34253, 34259, 34261, 34267, 34273, 34283, 34297, 34301, 34303, 34313, 34319, 34327, 34337, 34351, 34361, 34367, 34369, 34381, 34403, 34421, 34429, 34439, 34457, 34469, 34471, 34483, 34487, 34499, 34501, 34511, 34513, 34519, 34537, 34543, 34549, 34583, 34589, 34591, 34603, 34607, 34613, 34631, 34649, 34651, 34667, 34673, 34679, 34687, 34693, 34703, 34721, 34729, 34739, 34747, 34757, 34759, 34763, 34781, 34807, 34819, 34841, 34843, 34847, 34849, 34871, 34877, 34883, 34897, 34913, 34919, 34939, 34949, 34961, 34963, 34981, 35023, 35027, 35051, 35053, 35059, 35069, 35081, 35083, 35089, 35099, 35107, 35111, 35117, 35129, 35141, 35149, 35153, 35159, 35171, 35201, 35221, 35227, 35251, 35257, 35267, 35279, 35281, 35291, 35311, 35317, 35323, 35327, 35339, 35353, 35363, 35381, 35393, 35401, 35407, 35419, 35423, 35437, 35447, 35449, 35461, 35491, 35507, 35509, 35521, 35527, 35531, 35533, 35537, 35543, 35569, 35573, 35591, 35593, 35597, 35603, 35617, 35671, 35677, 35729, 35731, 35747, 35753, 35759, 35771, 35797, 35801, 35803, 35809, 35831, 35837, 35839, 35851, 35863, 35869, 35879, 35897, 35899, 35911, 35923, 35933, 35951, 35963, 35969, 35977, 35983, 35993, 35999, 36007, 36011, 36013, 36017, 36037, 36061, 36067, 36073, 36083, 36097, 36107, 36109, 36131, 36137, 36151, 36161, 36187, 36191, 36209, 36217, 36229, 36241, 36251, 36263, 36269, 36277, 36293, 36299, 36307, 36313, 36319, 36341, 36343, 36353, 36373, 36383, 36389, 36433, 36451, 36457, 36467, 36469, 36473, 36479, 36493, 36497, 36523, 36527, 36529, 36541, 36551, 36559, 36563, 36571, 36583, 36587, 36599, 36607, 36629, 36637, 36643, 36653, 36671, 36677, 36683, 36691, 36697, 36709, 36713, 36721, 36739, 36749, 36761, 36767, 36779, 36781, 36787, 36791, 36793, 36809, 36821, 36833, 36847, 36857, 36871, 36877, 36887, 36899, 36901, 36913, 36919, 36923, 36929, 36931, 36943, 36947, 36973, 36979, 36997, 37003, 37013, 37019, 37021, 37039, 37049, 37057, 37061, 37087, 37097, 37117, 37123, 37139, 37159, 37171, 37181, 37189, 37199, 37201, 37217, 37223, 37243, 37253, 37273, 37277, 37307, 37309, 37313, 37321, 37337, 37339, 37357, 37361, 37363, 37369, 37379, 37397, 37409, 37423, 37441, 37447, 37463, 37483, 37489, 37493, 37501, 37507, 37511, 37517, 37529, 37537, 37547, 37549, 37561, 37567, 37571, 37573, 37579, 37589, 37591, 37607, 37619, 37633, 37643, 37649, 37657, 37663, 37691, 37693, 37699, 37717, 37747, 37781, 37783, 37799, 37811, 37813, 37831, 37847, 37853, 37861, 37871, 37879, 37889, 37897, 37907, 37951, 37957, 37963, 37967, 37987, 37991, 37993, 37997, 38011, 38039, 38047, 38053, 38069, 38083, 38113, 38119, 38149, 38153, 38167, 38177, 38183, 38189, 38197, 38201, 38219, 38231, 38237, 38239, 38261, 38273, 38281, 38287, 38299, 38303, 38317, 38321, 38327, 38329, 38333, 38351, 38371, 38377, 38393, 38431, 38447, 38449, 38453, 38459, 38461, 38501, 38543, 38557, 38561, 38567, 38569, 38593, 38603, 38609, 38611, 38629, 38639, 38651, 38653, 38669, 38671, 38677, 38693, 38699, 38707, 38711, 38713, 38723, 38729, 38737, 38747, 38749, 38767, 38783, 38791, 38803, 38821, 38833, 38839, 38851, 38861, 38867, 38873, 38891, 38903, 38917, 38921, 38923, 38933, 38953, 38959, 38971, 38977, 38993, 39019, 39023, 39041, 39043, 39047, 39079, 39089, 39097, 39103, 39107, 39113, 39119, 39133, 39139, 39157, 39161, 39163, 39181, 39191, 39199, 39209, 39217, 39227, 39229, 39233, 39239, 39241, 39251, 39293, 39301, 39313, 39317, 39323, 39341, 39343, 39359, 39367, 39371, 39373, 39383, 39397, 39409, 39419, 39439, 39443, 39451, 39461, 39499, 39503, 39509, 39511, 39521, 39541, 39551, 39563, 39569, 39581, 39607, 39619, 39623, 39631, 39659, 39667, 39671, 39679, 39703, 39709, 39719, 39727, 39733, 39749, 39761, 39769, 39779, 39791, 39799, 39821, 39827, 39829, 39839, 39841, 39847, 39857, 39863, 39869, 39877, 39883, 39887, 39901, 39929, 39937, 39953, 39971, 39979, 39983, 39989, 40009, 40013, 40031, 40037, 40039, 40063, 40087, 40093, 40099, 40111, 40123, 40127, 40129, 40151, 40153, 40163, 40169, 40177, 40189, 40193, 40213, 40231, 40237, 40241, 40253, 40277, 40283, 40289, 40343, 40351, 40357, 40361, 40387, 40423, 40427, 40429, 40433, 40459, 40471, 40483, 40487, 40493, 40499, 40507, 40519, 40529, 40531, 40543, 40559, 40577, 40583, 40591, 40597, 40609, 40627, 40637, 40639, 40693, 40697, 40699, 40709, 40739, 40751, 40759, 40763, 40771, 40787, 40801, 40813, 40819, 40823, 40829, 40841, 40847, 40849, 40853, 40867, 40879, 40883, 40897, 40903, 40927, 40933, 40939, 40949, 40961, 40973, 40993, 41011, 41017, 41023, 41039, 41047, 41051, 41057, 41077, 41081, 41113, 41117, 41131, 41141, 41143, 41149, 41161, 41177, 41179, 41183, 41189, 41201, 41203, 41213, 41221, 41227, 41231, 41233, 41243, 41257, 41263, 41269, 41281, 41299, 41333, 41341, 41351, 41357, 41381, 41387, 41389, 41399, 41411, 41413, 41443, 41453, 41467, 41479, 41491, 41507, 41513, 41519, 41521, 41539, 41543, 41549, 41579, 41593, 41597, 41603, 41609, 41611, 41617, 41621, 41627, 41641, 41647, 41651, 41659, 41669, 41681, 41687, 41719, 41729, 41737, 41759, 41761, 41771, 41777, 41801, 41809, 41813, 41843, 41849, 41851, 41863, 41879, 41887, 41893, 41897, 41903, 41911, 41927, 41941, 41947, 41953, 41957, 41959, 41969, 41981, 41983, 41999, 42013, 42017, 42019, 42023, 42043, 42061, 42071, 42073, 42083, 42089, 42101, 42131, 42139, 42157, 42169, 42179, 42181, 42187, 42193, 42197, 42209, 42221, 42223, 42227, 42239, 42257, 42281, 42283, 42293, 42299, 42307, 42323, 42331, 42337, 42349, 42359, 42373, 42379, 42391, 42397, 42403, 42407, 42409, 42433, 42437, 42443, 42451, 42457, 42461, 42463, 42467, 42473, 42487, 42491, 42499, 42509, 42533, 42557, 42569, 42571, 42577, 42589, 42611, 42641, 42643, 42649, 42667, 42677, 42683, 42689, 42697, 42701, 42703, 42709, 42719, 42727, 42737, 42743, 42751, 42767, 42773, 42787, 42793, 42797, 42821, 42829, 42839, 42841, 42853, 42859, 42863, 42899, 42901, 42923, 42929, 42937, 42943, 42953, 42961, 42967, 42979, 42989, 43003, 43013, 43019, 43037, 43049, 43051, 43063, 43067, 43093, 43103, 43117, 43133, 43151, 43159, 43177, 43189, 43201, 43207, 43223, 43237, 43261, 43271, 43283, 43291, 43313, 43319, 43321, 43331, 43391, 43397, 43399, 43403, 43411, 43427, 43441, 43451, 43457, 43481, 43487, 43499, 43517, 43541, 43543, 43573, 43577, 43579, 43591, 43597, 43607, 43609, 43613, 43627, 43633, 43649, 43651, 43661, 43669, 43691, 43711, 43717, 43721, 43753, 43759, 43777, 43781, 43783, 43787, 43789, 43793, 43801, 43853, 43867, 43889, 43891, 43913, 43933, 43943, 43951, 43961, 43963, 43969, 43973, 43987, 43991, 43997, 44017, 44021, 44027, 44029, 44041, 44053, 44059, 44071, 44087, 44089, 44101, 44111, 44119, 44123, 44129, 44131, 44159, 44171, 44179, 44189, 44201, 44203, 44207, 44221, 44249, 44257, 44263, 44267, 44269, 44273, 44279, 44281, 44293, 44351, 44357, 44371, 44381, 44383, 44389, 44417, 44449, 44453, 44483, 44491, 44497, 44501, 44507, 44519, 44531, 44533, 44537, 44543, 44549, 44563, 44579, 44587, 44617, 44621, 44623, 44633, 44641, 44647, 44651, 44657, 44683, 44687, 44699, 44701, 44711, 44729, 44741, 44753, 44771, 44773, 44777, 44789, 44797, 44809, 44819, 44839, 44843, 44851, 44867, 44879, 44887, 44893, 44909, 44917, 44927, 44939, 44953, 44959, 44963, 44971, 44983, 44987, 45007, 45013, 45053, 45061, 45077, 45083, 45119, 45121, 45127, 45131, 45137, 45139, 45161, 45179, 45181, 45191, 45197, 45233, 45247, 45259, 45263, 45281, 45289, 45293, 45307, 45317, 45319, 45329, 45337, 45341, 45343, 45361, 45377, 45389, 45403, 45413, 45427, 45433, 45439, 45481, 45491, 45497, 45503, 45523, 45533, 45541, 45553, 45557, 45569, 45587, 45589, 45599, 45613, 45631, 45641, 45659, 45667, 45673, 45677, 45691, 45697, 45707, 45737, 45751, 45757, 45763, 45767, 45779, 45817, 45821, 45823, 45827, 45833, 45841, 45853, 45863, 45869, 45887, 45893, 45943, 45949, 45953, 45959, 45971, 45979, 45989, 46021, 46027, 46049, 46051, 46061, 46073, 46091, 46093, 46099, 46103, 46133, 46141, 46147, 46153, 46171, 46181, 46183, 46187, 46199, 46219, 46229, 46237, 46261, 46271, 46273, 46279, 46301, 46307, 46309, 46327, 46337, 46349, 46351, 46381, 46399, 46411, 46439, 46441, 46447, 46451, 46457, 46471, 46477, 46489, 46499, 46507, 46511, 46523, 46549, 46559, 46567, 46573, 46589, 46591, 46601, 46619, 46633, 46639, 46643, 46649, 46663, 46679, 46681, 46687, 46691, 46703, 46723, 46727, 46747, 46751, 46757, 46769, 46771, 46807, 46811, 46817, 46819, 46829, 46831, 46853, 46861, 46867, 46877, 46889, 46901, 46919, 46933, 46957, 46993, 46997, 47017, 47041, 47051, 47057, 47059, 47087, 47093, 47111, 47119, 47123, 47129, 47137, 47143, 47147, 47149, 47161, 47189, 47207, 47221, 47237, 47251, 47269, 47279, 47287, 47293, 47297, 47303, 47309, 47317, 47339, 47351, 47353, 47363, 47381, 47387, 47389, 47407, 47417, 47419, 47431, 47441, 47459, 47491, 47497, 47501, 47507, 47513, 47521, 47527, 47533, 47543, 47563, 47569, 47581, 47591, 47599, 47609, 47623, 47629, 47639, 47653, 47657, 47659, 47681, 47699, 47701, 47711, 47713, 47717, 47737, 47741, 47743, 47777, 47779, 47791, 47797, 47807, 47809, 47819, 47837, 47843, 47857, 47869, 47881, 47903, 47911, 47917, 47933, 47939, 47947, 47951, 47963, 47969, 47977, 47981, 48017, 48023, 48029, 48049, 48073, 48079, 48091, 48109, 48119, 48121, 48131, 48157, 48163, 48179, 48187, 48193, 48197, 48221, 48239, 48247, 48259, 48271, 48281, 48299, 48311, 48313, 48337, 48341, 48353, 48371, 48383, 48397, 48407, 48409, 48413, 48437, 48449, 48463, 48473, 48479, 48481, 48487, 48491, 48497, 48523, 48527, 48533, 48539, 48541, 48563, 48571, 48589, 48593, 48611, 48619, 48623, 48647, 48649, 48661, 48673, 48677, 48679, 48731, 48733, 48751, 48757, 48761, 48767, 48779, 48781, 48787, 48799, 48809, 48817, 48821, 48823, 48847, 48857, 48859, 48869, 48871, 48883, 48889, 48907, 48947, 48953, 48973, 48989, 48991, 49003, 49009, 49019, 49031, 49033, 49037, 49043, 49057, 49069, 49081, 49103, 49109, 49117, 49121, 49123, 49139, 49157, 49169, 49171, 49177, 49193, 49199, 49201, 49207, 49211, 49223, 49253, 49261, 49277, 49279, 49297, 49307, 49331, 49333, 49339, 49363, 49367, 49369, 49391, 49393, 49409, 49411, 49417, 49429, 49433, 49451, 49459, 49463, 49477, 49481, 49499, 49523, 49529, 49531, 49537, 49547, 49549, 49559, 49597, 49603, 49613, 49627, 49633, 49639, 49663, 49667, 49669, 49681, 49697, 49711, 49727, 49739, 49741, 49747, 49757, 49783, 49787, 49789, 49801, 49807, 49811, 49823, 49831, 49843, 49853, 49871, 49877, 49891, 49919, 49921, 49927, 49937, 49939, 49943, 49957, 49991, 49993, 49999, 50021, 50023, 50033, 50047, 50051, 50053, 50069, 50077, 50087, 50093, 50101, 50111, 50119, 50123, 50129, 50131, 50147, 50153, 50159, 50177, 50207, 50221, 50227, 50231, 50261, 50263, 50273, 50287, 50291, 50311, 50321, 50329, 50333, 50341, 50359, 50363, 50377, 50383, 50387, 50411, 50417, 50423, 50441, 50459, 50461, 50497, 50503, 50513, 50527, 50539, 50543, 50549, 50551, 50581, 50587, 50591, 50593, 50599, 50627, 50647, 50651, 50671, 50683, 50707, 50723, 50741, 50753, 50767, 50773, 50777, 50789, 50821, 50833, 50839, 50849, 50857, 50867, 50873, 50891, 50893, 50909, 50923, 50929, 50951, 50957, 50969, 50971, 50989, 50993, 51001, 51031, 51043, 51047, 51059, 51061, 51071, 51109, 51131, 51133, 51137, 51151, 51157, 51169, 51193, 51197, 51199, 51203, 51217, 51229, 51239, 51241, 51257, 51263, 51283, 51287, 51307, 51329, 51341, 51343, 51347, 51349, 51361, 51383, 51407, 51413, 51419, 51421, 51427, 51431, 51437, 51439, 51449, 51461, 51473, 51479, 51481, 51487, 51503, 51511, 51517, 51521, 51539, 51551, 51563, 51577, 51581, 51593, 51599, 51607, 51613, 51631, 51637, 51647, 51659, 51673, 51679, 51683, 51691, 51713, 51719, 51721, 51749, 51767, 51769, 51787, 51797, 51803, 51817, 51827, 51829, 51839, 51853, 51859, 51869, 51871, 51893, 51899, 51907, 51913, 51929, 51941, 51949, 51971, 51973, 51977, 51991, 52009, 52021, 52027, 52051, 52057, 52067, 52069, 52081, 52103, 52121, 52127, 52147, 52153, 52163, 52177, 52181, 52183, 52189, 52201, 52223, 52237, 52249, 52253, 52259, 52267, 52289, 52291, 52301, 52313, 52321, 52361, 52363, 52369, 52379, 52387, 52391, 52433, 52453, 52457, 52489, 52501, 52511, 52517, 52529, 52541, 52543, 52553, 52561, 52567, 52571, 52579, 52583, 52609, 52627, 52631, 52639, 52667, 52673, 52691, 52697, 52709, 52711, 52721, 52727, 52733, 52747, 52757, 52769, 52783, 52807, 52813, 52817, 52837, 52859, 52861, 52879, 52883, 52889, 52901, 52903, 52919, 52937, 52951, 52957, 52963, 52967, 52973, 52981, 52999, 53003, 53017, 53047, 53051, 53069, 53077, 53087, 53089, 53093, 53101, 53113, 53117, 53129, 53147, 53149, 53161, 53171, 53173, 53189, 53197, 53201, 53231, 53233, 53239, 53267, 53269, 53279, 53281, 53299, 53309, 53323, 53327, 53353, 53359, 53377, 53381, 53401, 53407, 53411, 53419, 53437, 53441, 53453, 53479, 53503, 53507, 53527, 53549, 53551, 53569, 53591, 53593, 53597, 53609, 53611, 53617, 53623, 53629, 53633, 53639, 53653, 53657, 53681, 53693, 53699, 53717, 53719, 53731, 53759, 53773, 53777, 53783, 53791, 53813, 53819, 53831, 53849, 53857, 53861, 53881, 53887, 53891, 53897, 53899, 53917, 53923, 53927, 53939, 53951, 53959, 53987, 53993, 54001, 54011, 54013, 54037, 54049, 54059, 54083, 54091, 54101, 54121, 54133, 54139, 54151, 54163, 54167, 54181, 54193, 54217, 54251, 54269, 54277, 54287, 54293, 54311, 54319, 54323, 54331, 54347, 54361, 54367, 54371, 54377, 54401, 54403, 54409, 54413, 54419, 54421, 54437, 54443, 54449, 54469, 54493, 54497, 54499, 54503, 54517, 54521, 54539, 54541, 54547, 54559, 54563, 54577, 54581, 54583, 54601, 54617, 54623, 54629, 54631, 54647, 54667, 54673, 54679, 54709, 54713, 54721, 54727, 54751, 54767, 54773, 54779, 54787, 54799, 54829, 54833, 54851, 54869, 54877, 54881, 54907, 54917, 54919, 54941, 54949, 54959, 54973, 54979, 54983, 55001, 55009, 55021, 55049, 55051, 55057, 55061, 55073, 55079, 55103, 55109, 55117, 55127, 55147, 55163, 55171, 55201, 55207, 55213, 55217, 55219, 55229, 55243, 55249, 55259, 55291, 55313, 55331, 55333, 55337, 55339, 55343, 55351, 55373, 55381, 55399, 55411, 55439, 55441, 55457, 55469, 55487, 55501, 55511, 55529, 55541, 55547, 55579, 55589, 55603, 55609, 55619, 55621, 55631, 55633, 55639, 55661, 55663, 55667, 55673, 55681, 55691, 55697, 55711, 55717, 55721, 55733, 55763, 55787, 55793, 55799, 55807, 55813, 55817, 55819, 55823, 55829, 55837, 55843, 55849, 55871, 55889, 55897, 55901, 55903, 55921, 55927, 55931, 55933, 55949, 55967, 55987, 55997, 56003, 56009, 56039, 56041, 56053, 56081, 56087, 56093, 56099, 56101, 56113, 56123, 56131, 56149, 56167, 56171, 56179, 56197, 56207, 56209, 56237, 56239, 56249, 56263, 56267, 56269, 56299, 56311, 56333, 56359, 56369, 56377, 56383, 56393, 56401, 56417, 56431, 56437, 56443, 56453, 56467, 56473, 56477, 56479, 56489, 56501, 56503, 56509, 56519, 56527, 56531, 56533, 56543, 56569, 56591, 56597, 56599, 56611, 56629, 56633, 56659, 56663, 56671, 56681, 56687, 56701, 56711, 56713, 56731, 56737, 56747, 56767, 56773, 56779, 56783, 56807, 56809, 56813, 56821, 56827, 56843, 56857, 56873, 56891, 56893, 56897, 56909, 56911, 56921, 56923, 56929, 56941, 56951, 56957, 56963, 56983, 56989, 56993, 56999, 57037, 57041, 57047, 57059, 57073, 57077, 57089, 57097, 57107, 57119, 57131, 57139, 57143, 57149, 57163, 57173, 57179, 57191, 57193, 57203, 57221, 57223, 57241, 57251, 57259, 57269, 57271, 57283, 57287, 57301, 57329, 57331, 57347, 57349, 57367, 57373, 57383, 57389, 57397, 57413, 57427, 57457, 57467, 57487, 57493, 57503, 57527, 57529, 57557, 57559, 57571, 57587, 57593, 57601, 57637, 57641, 57649, 57653, 57667, 57679, 57689, 57697, 57709, 57713, 57719, 57727, 57731, 57737, 57751, 57773, 57781, 57787, 57791, 57793, 57803, 57809, 57829, 57839, 57847, 57853, 57859, 57881, 57899, 57901, 57917, 57923, 57943, 57947, 57973, 57977, 57991, 58013, 58027, 58031, 58043, 58049, 58057, 58061, 58067, 58073, 58099, 58109, 58111, 58129, 58147, 58151, 58153, 58169, 58171, 58189, 58193, 58199, 58207, 58211, 58217, 58229, 58231, 58237, 58243, 58271, 58309, 58313, 58321, 58337, 58363, 58367, 58369, 58379, 58391, 58393, 58403, 58411, 58417, 58427, 58439, 58441, 58451, 58453, 58477, 58481, 58511, 58537, 58543, 58549, 58567, 58573, 58579, 58601, 58603, 58613, 58631, 58657, 58661, 58679, 58687, 58693, 58699, 58711, 58727, 58733, 58741, 58757, 58763, 58771, 58787, 58789, 58831, 58889, 58897, 58901, 58907, 58909, 58913, 58921, 58937, 58943, 58963, 58967, 58979, 58991, 58997, 59009, 59011, 59021, 59023, 59029, 59051, 59053, 59063, 59069, 59077, 59083, 59093, 59107, 59113, 59119, 59123, 59141, 59149, 59159, 59167, 59183, 59197, 59207, 59209, 59219, 59221, 59233, 59239, 59243, 59263, 59273, 59281, 59333, 59341, 59351, 59357, 59359, 59369, 59377, 59387, 59393, 59399, 59407, 59417, 59419, 59441, 59443, 59447, 59453, 59467, 59471, 59473, 59497, 59509, 59513, 59539, 59557, 59561, 59567, 59581, 59611, 59617, 59621, 59627, 59629, 59651, 59659, 59663, 59669, 59671, 59693, 59699, 59707, 59723, 59729, 59743, 59747, 59753, 59771, 59779, 59791, 59797, 59809, 59833, 59863, 59879, 59887, 59921, 59929, 59951, 59957, 59971, 59981, 59999, 60013, 60017, 60029, 60037, 60041, 60077, 60083, 60089, 60091, 60101, 60103, 60107, 60127, 60133, 60139, 60149, 60161, 60167, 60169, 60209, 60217, 60223, 60251, 60257, 60259, 60271, 60289, 60293, 60317, 60331, 60337, 60343, 60353, 60373, 60383, 60397, 60413, 60427, 60443, 60449, 60457, 60493, 60497, 60509, 60521, 60527, 60539, 60589, 60601, 60607, 60611, 60617, 60623, 60631, 60637, 60647, 60649, 60659, 60661, 60679, 60689, 60703, 60719, 60727, 60733, 60737, 60757, 60761, 60763, 60773, 60779, 60793, 60811, 60821, 60859, 60869, 60887, 60889, 60899, 60901, 60913, 60917, 60919, 60923, 60937, 60943, 60953, 60961, 61001, 61007, 61027, 61031, 61043, 61051, 61057, 61091, 61099, 61121, 61129, 61141, 61151, 61153, 61169, 61211, 61223, 61231, 61253, 61261, 61283, 61291, 61297, 61331, 61333, 61339, 61343, 61357, 61363, 61379, 61381, 61403, 61409, 61417, 61441, 61463, 61469, 61471, 61483, 61487, 61493, 61507, 61511, 61519, 61543, 61547, 61553, 61559, 61561, 61583, 61603, 61609, 61613, 61627, 61631, 61637, 61643, 61651, 61657, 61667, 61673, 61681, 61687, 61703, 61717, 61723, 61729, 61751, 61757, 61781, 61813, 61819, 61837, 61843, 61861, 61871, 61879, 61909, 61927, 61933, 61949, 61961, 61967, 61979, 61981, 61987, 61991, 62003, 62011, 62017, 62039, 62047, 62053, 62057, 62071, 62081, 62099, 62119, 62129, 62131, 62137, 62141, 62143, 62171, 62189, 62191, 62201, 62207, 62213, 62219, 62233, 62273, 62297, 62299, 62303, 62311, 62323, 62327, 62347, 62351, 62383, 62401, 62417, 62423, 62459, 62467, 62473, 62477, 62483, 62497, 62501, 62507, 62533, 62539, 62549, 62563, 62581, 62591, 62597, 62603, 62617, 62627, 62633, 62639, 62653, 62659, 62683, 62687, 62701, 62723, 62731, 62743, 62753, 62761, 62773, 62791, 62801, 62819, 62827, 62851, 62861, 62869, 62873, 62897, 62903, 62921, 62927, 62929, 62939, 62969, 62971, 62981, 62983, 62987, 62989, 63029, 63031, 63059, 63067, 63073, 63079, 63097, 63103, 63113, 63127, 63131, 63149, 63179, 63197, 63199, 63211, 63241, 63247, 63277, 63281, 63299, 63311, 63313, 63317, 63331, 63337, 63347, 63353, 63361, 63367, 63377, 63389, 63391, 63397, 63409, 63419, 63421, 63439, 63443, 63463, 63467, 63473, 63487, 63493, 63499, 63521, 63527, 63533, 63541, 63559, 63577, 63587, 63589, 63599, 63601, 63607, 63611, 63617, 63629, 63647, 63649, 63659, 63667, 63671, 63689, 63691, 63697, 63703, 63709, 63719, 63727, 63737, 63743, 63761, 63773, 63781, 63793, 63799, 63803, 63809, 63823, 63839, 63841, 63853, 63857, 63863, 63901, 63907, 63913, 63929, 63949, 63977, 63997, 64007, 64013, 64019, 64033, 64037, 64063, 64067, 64081, 64091, 64109, 64123, 64151, 64153, 64157, 64171, 64187, 64189, 64217, 64223, 64231, 64237, 64271, 64279, 64283, 64301, 64303, 64319, 64327, 64333, 64373, 64381, 64399, 64403, 64433, 64439, 64451, 64453, 64483, 64489, 64499, 64513, 64553, 64567, 64577, 64579, 64591, 64601, 64609, 64613, 64621, 64627, 64633, 64661, 64663, 64667, 64679, 64693, 64709, 64717, 64747, 64763, 64781, 64783, 64793, 64811, 64817, 64849, 64853, 64871, 64877, 64879, 64891, 64901, 64919, 64921, 64927, 64937, 64951, 64969, 64997, 65003, 65011, 65027, 65029, 65033, 65053, 65063, 65071, 65089, 65099, 65101, 65111, 65119, 65123, 65129, 65141, 65147, 65167, 65171, 65173, 65179, 65183, 65203, 65213, 65239, 65257, 65267, 65269, 65287, 65293, 65309, 65323, 65327, 65353, 65357, 65371, 65381, 65393, 65407, 65413, 65419, 65423, 65437, 65447, 65449, 65479, 65497, 65519, 65521, 65537, 65539, 65543, 65551, 65557, 65563, 65579, 65581, 65587, 65599, 65609, 65617, 65629, 65633, 65647, 65651, 65657, 65677, 65687, 65699, 65701, 65707, 65713, 65717, 65719, 65729, 65731, 65761, 65777, 65789, 65809, 65827, 65831, 65837, 65839, 65843, 65851, 65867, 65881, 65899, 65921, 65927, 65929, 65951, 65957, 65963, 65981, 65983, 65993, 66029, 66037, 66041, 66047, 66067, 66071, 66083, 66089, 66103, 66107, 66109, 66137, 66161, 66169, 66173, 66179, 66191, 66221, 66239, 66271, 66293, 66301, 66337, 66343, 66347, 66359, 66361, 66373, 66377, 66383, 66403, 66413, 66431, 66449, 66457, 66463, 66467, 66491, 66499, 66509, 66523, 66529, 66533, 66541, 66553, 66569, 66571, 66587, 66593, 66601, 66617, 66629, 66643, 66653, 66683, 66697, 66701, 66713, 66721, 66733, 66739, 66749, 66751, 66763, 66791, 66797, 66809, 66821, 66841, 66851, 66853, 66863, 66877, 66883, 66889, 66919, 66923, 66931, 66943, 66947, 66949, 66959, 66973, 66977, 67003, 67021, 67033, 67043, 67049, 67057, 67061, 67073, 67079, 67103, 67121, 67129, 67139, 67141, 67153, 67157, 67169, 67181, 67187, 67189, 67211, 67213, 67217, 67219, 67231, 67247, 67261, 67271, 67273, 67289, 67307, 67339, 67343, 67349, 67369, 67391, 67399, 67409, 67411, 67421, 67427, 67429, 67433, 67447, 67453, 67477, 67481, 67489, 67493, 67499, 67511, 67523, 67531, 67537, 67547, 67559, 67567, 67577, 67579, 67589, 67601, 67607, 67619, 67631, 67651, 67679, 67699, 67709, 67723, 67733, 67741, 67751, 67757, 67759, 67763, 67777, 67783, 67789, 67801, 67807, 67819, 67829, 67843, 67853, 67867, 67883, 67891, 67901, 67927, 67931, 67933, 67939, 67943, 67957, 67961, 67967, 67979, 67987, 67993, 68023, 68041, 68053, 68059, 68071, 68087, 68099, 68111, 68113, 68141, 68147, 68161, 68171, 68207, 68209, 68213, 68219, 68227, 68239, 68261, 68279, 68281, 68311, 68329, 68351, 68371, 68389, 68399, 68437, 68443, 68447, 68449, 68473, 68477, 68483, 68489, 68491, 68501, 68507, 68521, 68531, 68539, 68543, 68567, 68581, 68597, 68611, 68633, 68639, 68659, 68669, 68683, 68687, 68699, 68711, 68713, 68729, 68737, 68743, 68749, 68767, 68771, 68777, 68791, 68813, 68819, 68821, 68863, 68879, 68881, 68891, 68897, 68899, 68903, 68909, 68917, 68927, 68947, 68963, 68993, 69001, 69011, 69019, 69029, 69031, 69061, 69067, 69073, 69109, 69119, 69127, 69143, 69149, 69151, 69163, 69191, 69193, 69197, 69203, 69221, 69233, 69239, 69247, 69257, 69259, 69263, 69313, 69317, 69337, 69341, 69371, 69379, 69383, 69389, 69401, 69403, 69427, 69431, 69439, 69457, 69463, 69467, 69473, 69481, 69491, 69493, 69497, 69499, 69539, 69557, 69593, 69623, 69653, 69661, 69677, 69691, 69697, 69709, 69737, 69739, 69761, 69763, 69767, 69779, 69809, 69821, 69827, 69829, 69833, 69847, 69857, 69859, 69877, 69899, 69911, 69929, 69931, 69941, 69959, 69991, 69997, 70001, 70003, 70009, 70019, 70039, 70051, 70061, 70067, 70079, 70099, 70111, 70117, 70121, 70123, 70139, 70141, 70157, 70163, 70177, 70181, 70183, 70199, 70201, 70207, 70223, 70229, 70237, 70241, 70249, 70271, 70289, 70297, 70309, 70313, 70321, 70327, 70351, 70373, 70379, 70381, 70393, 70423, 70429, 70439, 70451, 70457, 70459, 70481, 70487, 70489, 70501, 70507, 70529, 70537, 70549, 70571, 70573, 70583, 70589, 70607, 70619, 70621, 70627, 70639, 70657, 70663, 70667, 70687, 70709, 70717, 70729, 70753, 70769, 70783, 70793, 70823, 70841, 70843, 70849, 70853, 70867, 70877, 70879, 70891, 70901, 70913, 70919, 70921, 70937, 70949, 70951, 70957, 70969, 70979, 70981, 70991, 70997, 70999, 71011, 71023, 71039, 71059, 71069, 71081, 71089, 71119, 71129, 71143, 71147, 71153, 71161, 71167, 71171, 71191, 71209, 71233, 71237, 71249, 71257, 71261, 71263, 71287, 71293, 71317, 71327, 71329, 71333, 71339, 71341, 71347, 71353, 71359, 71363, 71387, 71389, 71399, 71411, 71413, 71419, 71429, 71437, 71443, 71453, 71471, 71473, 71479, 71483, 71503, 71527, 71537, 71549, 71551, 71563, 71569, 71593, 71597, 71633, 71647, 71663, 71671, 71693, 71699, 71707, 71711, 71713, 71719, 71741, 71761, 71777, 71789, 71807, 71809, 71821, 71837, 71843, 71849, 71861, 71867, 71879, 71881, 71887, 71899, 71909, 71917, 71933, 71941, 71947, 71963, 71971, 71983, 71987, 71993, 71999, 72019, 72031, 72043, 72047, 72053, 72073, 72077, 72089, 72091, 72101, 72103, 72109, 72139, 72161, 72167, 72169, 72173, 72211, 72221, 72223, 72227, 72229, 72251, 72253, 72269, 72271, 72277, 72287, 72307, 72313, 72337, 72341, 72353, 72367, 72379, 72383, 72421, 72431, 72461, 72467, 72469, 72481, 72493, 72497, 72503, 72533, 72547, 72551, 72559, 72577, 72613, 72617, 72623, 72643, 72647, 72649, 72661, 72671, 72673, 72679, 72689, 72701, 72707, 72719, 72727, 72733, 72739, 72763, 72767, 72797, 72817, 72823, 72859, 72869, 72871, 72883, 72889, 72893, 72901, 72907, 72911, 72923, 72931, 72937, 72949, 72953, 72959, 72973, 72977, 72997, 73009, 73013, 73019, 73037, 73039, 73043, 73061, 73063, 73079, 73091, 73121, 73127, 73133, 73141, 73181, 73189, 73237, 73243, 73259, 73277, 73291, 73303, 73309, 73327, 73331, 73351, 73361, 73363, 73369, 73379, 73387, 73417, 73421, 73433, 73453, 73459, 73471, 73477, 73483, 73517, 73523, 73529, 73547, 73553, 73561, 73571, 73583, 73589, 73597, 73607, 73609, 73613, 73637, 73643, 73651, 73673, 73679, 73681, 73693, 73699, 73709, 73721, 73727, 73751, 73757, 73771, 73783, 73819, 73823, 73847, 73849, 73859, 73867, 73877, 73883, 73897, 73907, 73939, 73943, 73951, 73961, 73973, 73999, 74017, 74021, 74027, 74047, 74051, 74071, 74077, 74093, 74099, 74101, 74131, 74143, 74149, 74159, 74161, 74167, 74177, 74189, 74197, 74201, 74203, 74209, 74219, 74231, 74257, 74279, 74287, 74293, 74297, 74311, 74317, 74323, 74353, 74357, 74363, 74377, 74381, 74383, 74411, 74413, 74419, 74441, 74449, 74453, 74471, 74489, 74507, 74509, 74521, 74527, 74531, 74551, 74561, 74567, 74573, 74587, 74597, 74609, 74611, 74623, 74653, 74687, 74699, 74707, 74713, 74717, 74719, 74729, 74731, 74747, 74759, 74761, 74771, 74779, 74797, 74821, 74827, 74831, 74843, 74857, 74861, 74869, 74873, 74887, 74891, 74897, 74903, 74923, 74929, 74933, 74941, 74959, 75011, 75013, 75017, 75029, 75037, 75041, 75079, 75083, 75109, 75133, 75149, 75161, 75167, 75169, 75181, 75193, 75209, 75211, 75217, 75223, 75227, 75239, 75253, 75269, 75277, 75289, 75307, 75323, 75329, 75337, 75347, 75353, 75367, 75377, 75389, 75391, 75401, 75403, 75407, 75431, 75437, 75479, 75503, 75511, 75521, 75527, 75533, 75539, 75541, 75553, 75557, 75571, 75577, 75583, 75611, 75617, 75619, 75629, 75641, 75653, 75659, 75679, 75683, 75689, 75703, 75707, 75709, 75721, 75731, 75743, 75767, 75773, 75781, 75787, 75793, 75797, 75821, 75833, 75853, 75869, 75883, 75913, 75931, 75937, 75941, 75967, 75979, 75983, 75989, 75991, 75997, 76001, 76003, 76031, 76039, 76079, 76081, 76091, 76099, 76103, 76123, 76129, 76147, 76157, 76159, 76163, 76207, 76213, 76231, 76243, 76249, 76253, 76259, 76261, 76283, 76289, 76303, 76333, 76343, 76367, 76369, 76379, 76387, 76403, 76421, 76423, 76441, 76463, 76471, 76481, 76487, 76493, 76507, 76511, 76519, 76537, 76541, 76543, 76561, 76579, 76597, 76603, 76607, 76631, 76649, 76651, 76667, 76673, 76679, 76697, 76717, 76733, 76753, 76757, 76771, 76777, 76781, 76801, 76819, 76829, 76831, 76837, 76847, 76871, 76873, 76883, 76907, 76913, 76919, 76943, 76949, 76961, 76963, 76991, 77003, 77017, 77023, 77029, 77041, 77047, 77069, 77081, 77093, 77101, 77137, 77141, 77153, 77167, 77171, 77191, 77201, 77213, 77237, 77239, 77243, 77249, 77261, 77263, 77267, 77269, 77279, 77291, 77317, 77323, 77339, 77347, 77351, 77359, 77369, 77377, 77383, 77417, 77419, 77431, 77447, 77471, 77477, 77479, 77489, 77491, 77509, 77513, 77521, 77527, 77543, 77549, 77551, 77557, 77563, 77569, 77573, 77587, 77591, 77611, 77617, 77621, 77641, 77647, 77659, 77681, 77687, 77689, 77699, 77711, 77713, 77719, 77723, 77731, 77743, 77747, 77761, 77773, 77783, 77797, 77801, 77813, 77839, 77849, 77863, 77867, 77893, 77899, 77929, 77933, 77951, 77969, 77977, 77983, 77999, 78007, 78017, 78031, 78041, 78049, 78059, 78079, 78101, 78121, 78137, 78139, 78157, 78163, 78167, 78173, 78179, 78191, 78193, 78203, 78229, 78233, 78241, 78259, 78277, 78283, 78301, 78307, 78311, 78317, 78341, 78347, 78367, 78401, 78427, 78437, 78439, 78467, 78479, 78487, 78497, 78509, 78511, 78517, 78539, 78541, 78553, 78569, 78571, 78577, 78583, 78593, 78607, 78623, 78643, 78649, 78653, 78691, 78697, 78707, 78713, 78721, 78737, 78779, 78781, 78787, 78791, 78797, 78803, 78809, 78823, 78839, 78853, 78857, 78877, 78887, 78889, 78893, 78901, 78919, 78929, 78941, 78977, 78979, 78989, 79031, 79039, 79043, 79063, 79087, 79103, 79111, 79133, 79139, 79147, 79151, 79153, 79159, 79181, 79187, 79193, 79201, 79229, 79231, 79241, 79259, 79273, 79279, 79283, 79301, 79309, 79319, 79333, 79337, 79349, 79357, 79367, 79379, 79393, 79397, 79399, 79411, 79423, 79427, 79433, 79451, 79481, 79493, 79531, 79537, 79549, 79559, 79561, 79579, 79589, 79601, 79609, 79613, 79621, 79627, 79631, 79633, 79657, 79669, 79687, 79691, 79693, 79697, 79699, 79757, 79769, 79777, 79801, 79811, 79813, 79817, 79823, 79829, 79841, 79843, 79847, 79861, 79867, 79873, 79889, 79901, 79903, 79907, 79939, 79943, 79967, 79973, 79979, 79987, 79997, 79999, 80021, 80039, 80051, 80071, 80077, 80107, 80111, 80141, 80147, 80149, 80153, 80167, 80173, 80177, 80191, 80207, 80209, 80221, 80231, 80233, 80239, 80251, 80263, 80273, 80279, 80287, 80309, 80317, 80329, 80341, 80347, 80363, 80369, 80387, 80407, 80429, 80447, 80449, 80471, 80473, 80489, 80491, 80513, 80527, 80537, 80557, 80567, 80599, 80603, 80611, 80621, 80627, 80629, 80651, 80657, 80669, 80671, 80677, 80681, 80683, 80687, 80701, 80713, 80737, 80747, 80749, 80761, 80777, 80779, 80783, 80789, 80803, 80809, 80819, 80831, 80833, 80849, 80863, 80897, 80909, 80911, 80917, 80923, 80929, 80933, 80953, 80963, 80989, 81001, 81013, 81017, 81019, 81023, 81031, 81041, 81043, 81047, 81049, 81071, 81077, 81083, 81097, 81101, 81119, 81131, 81157, 81163, 81173, 81181, 81197, 81199, 81203, 81223, 81233, 81239, 81281, 81283, 81293, 81299, 81307, 81331, 81343, 81349, 81353, 81359, 81371, 81373, 81401, 81409, 81421, 81439, 81457, 81463, 81509, 81517, 81527, 81533, 81547, 81551, 81553, 81559, 81563, 81569, 81611, 81619, 81629, 81637, 81647, 81649, 81667, 81671, 81677, 81689, 81701, 81703, 81707, 81727, 81737, 81749, 81761, 81769, 81773, 81799, 81817, 81839, 81847, 81853, 81869, 81883, 81899, 81901, 81919, 81929, 81931, 81937, 81943, 81953, 81967, 81971, 81973, 82003, 82007, 82009, 82013, 82021, 82031, 82037, 82039, 82051, 82067, 82073, 82129, 82139, 82141, 82153, 82163, 82171, 82183, 82189, 82193, 82207, 82217, 82219, 82223, 82231, 82237, 82241, 82261, 82267, 82279, 82301, 82307, 82339, 82349, 82351, 82361, 82373, 82387, 82393, 82421, 82457, 82463, 82469, 82471, 82483, 82487, 82493, 82499, 82507, 82529, 82531, 82549, 82559, 82561, 82567, 82571, 82591, 82601, 82609, 82613, 82619, 82633, 82651, 82657, 82699, 82721, 82723, 82727, 82729, 82757, 82759, 82763, 82781, 82787, 82793, 82799, 82811, 82813, 82837, 82847, 82883, 82889, 82891, 82903, 82913, 82939, 82963, 82981, 82997, 83003, 83009, 83023, 83047, 83059, 83063, 83071, 83077, 83089, 83093, 83101, 83117, 83137, 83177, 83203, 83207, 83219, 83221, 83227, 83231, 83233, 83243, 83257, 83267, 83269, 83273, 83299, 83311, 83339, 83341, 83357, 83383, 83389, 83399, 83401, 83407, 83417, 83423, 83431, 83437, 83443, 83449, 83459, 83471, 83477, 83497, 83537, 83557, 83561, 83563, 83579, 83591, 83597, 83609, 83617, 83621, 83639, 83641, 83653, 83663, 83689, 83701, 83717, 83719, 83737, 83761, 83773, 83777, 83791, 83813, 83833, 83843, 83857, 83869, 83873, 83891, 83903, 83911, 83921, 83933, 83939, 83969, 83983, 83987, 84011, 84017, 84047, 84053, 84059, 84061, 84067, 84089, 84121, 84127, 84131, 84137, 84143, 84163, 84179, 84181, 84191, 84199, 84211, 84221, 84223, 84229, 84239, 84247, 84263, 84299, 84307, 84313, 84317, 84319, 84347, 84349, 84377, 84389, 84391, 84401, 84407, 84421, 84431, 84437, 84443, 84449, 84457, 84463, 84467, 84481, 84499, 84503, 84509, 84521, 84523, 84533, 84551, 84559, 84589, 84629, 84631, 84649, 84653, 84659, 84673, 84691, 84697, 84701, 84713, 84719, 84731, 84737, 84751, 84761, 84787, 84793, 84809, 84811, 84827, 84857, 84859, 84869, 84871, 84913, 84919, 84947, 84961, 84967, 84977, 84979, 84991, 85009, 85021, 85027, 85037, 85049, 85061, 85081, 85087, 85091, 85093, 85103, 85109, 85121, 85133, 85147, 85159, 85193, 85199, 85201, 85213, 85223, 85229, 85237, 85243, 85247, 85259, 85297, 85303, 85313, 85331, 85333, 85361, 85363, 85369, 85381, 85411, 85427, 85429, 85439, 85447, 85451, 85453, 85469, 85487, 85513, 85517, 85523, 85531, 85549, 85571, 85577, 85597, 85601, 85607, 85619, 85621, 85627, 85639, 85643, 85661, 85667, 85669, 85691, 85703, 85711, 85717, 85733, 85751, 85781, 85793, 85817, 85819, 85829, 85831, 85837, 85843, 85847, 85853, 85889, 85903, 85909, 85931, 85933, 85991, 85999, 86011, 86017, 86027, 86029, 86069, 86077, 86083, 86111, 86113, 86117, 86131, 86137, 86143, 86161, 86171, 86179, 86183, 86197, 86201, 86209, 86239, 86243, 86249, 86257, 86263, 86269, 86287, 86291, 86293, 86297, 86311, 86323, 86341, 86351, 86353, 86357, 86369, 86371, 86381, 86389, 86399, 86413, 86423, 86441, 86453, 86461, 86467, 86477, 86491, 86501, 86509, 86531, 86533, 86539, 86561, 86573, 86579, 86587, 86599, 86627, 86629, 86677, 86689, 86693, 86711, 86719, 86729, 86743, 86753, 86767, 86771, 86783, 86813, 86837, 86843, 86851, 86857, 86861, 86869, 86923, 86927, 86929, 86939, 86951, 86959, 86969, 86981, 86993, 87011, 87013, 87037, 87041, 87049, 87071, 87083, 87103, 87107, 87119, 87121, 87133, 87149, 87151, 87179, 87181, 87187, 87211, 87221, 87223, 87251, 87253, 87257, 87277, 87281, 87293, 87299, 87313, 87317, 87323, 87337, 87359, 87383, 87403, 87407, 87421, 87427, 87433, 87443, 87473, 87481, 87491, 87509, 87511, 87517, 87523, 87539, 87541, 87547, 87553, 87557, 87559, 87583, 87587, 87589, 87613, 87623, 87629, 87631, 87641, 87643, 87649, 87671, 87679, 87683, 87691, 87697, 87701, 87719, 87721, 87739, 87743, 87751, 87767, 87793, 87797, 87803, 87811, 87833, 87853, 87869, 87877, 87881, 87887, 87911, 87917, 87931, 87943, 87959, 87961, 87973, 87977, 87991, 88001, 88003, 88007, 88019, 88037, 88069, 88079, 88093, 88117, 88129, 88169, 88177, 88211, 88223, 88237, 88241, 88259, 88261, 88289, 88301, 88321, 88327, 88337, 88339, 88379, 88397, 88411, 88423, 88427, 88463, 88469, 88471, 88493, 88499, 88513, 88523, 88547, 88589, 88591, 88607, 88609, 88643, 88651, 88657, 88661, 88663, 88667, 88681, 88721, 88729, 88741, 88747, 88771, 88789, 88793, 88799, 88801, 88807, 88811, 88813, 88817, 88819, 88843, 88853, 88861, 88867, 88873, 88883, 88897, 88903, 88919, 88937, 88951, 88969, 88993, 88997, 89003, 89009, 89017, 89021, 89041, 89051, 89057, 89069, 89071, 89083, 89087, 89101, 89107, 89113, 89119, 89123, 89137, 89153, 89189, 89203, 89209, 89213, 89227, 89231, 89237, 89261, 89269, 89273, 89293, 89303, 89317, 89329, 89363, 89371, 89381, 89387, 89393, 89399, 89413, 89417, 89431, 89443, 89449, 89459, 89477, 89491, 89501, 89513, 89519, 89521, 89527, 89533, 89561, 89563, 89567, 89591, 89597, 89599, 89603, 89611, 89627, 89633, 89653, 89657, 89659, 89669, 89671, 89681, 89689, 89753, 89759, 89767, 89779, 89783, 89797, 89809, 89819, 89821, 89833, 89839, 89849, 89867, 89891, 89897, 89899, 89909, 89917, 89923, 89939, 89959, 89963, 89977, 89983, 89989, 90001, 90007, 90011, 90017, 90019, 90023, 90031, 90053, 90059, 90067, 90071, 90073, 90089, 90107, 90121, 90127, 90149, 90163, 90173, 90187, 90191, 90197, 90199, 90203, 90217, 90227, 90239, 90247, 90263, 90271, 90281, 90289, 90313, 90353, 90359, 90371, 90373, 90379, 90397, 90401, 90403, 90407, 90437, 90439, 90469, 90473, 90481, 90499, 90511, 90523, 90527, 90529, 90533, 90547, 90583, 90599, 90617, 90619, 90631, 90641, 90647, 90659, 90677, 90679, 90697, 90703, 90709, 90731, 90749, 90787, 90793, 90803, 90821, 90823, 90833, 90841, 90847, 90863, 90887, 90901, 90907, 90911, 90917, 90931, 90947, 90971, 90977, 90989, 90997, 91009, 91019, 91033, 91079, 91081, 91097, 91099, 91121, 91127, 91129, 91139, 91141, 91151, 91153, 91159, 91163, 91183, 91193, 91199, 91229, 91237, 91243, 91249, 91253, 91283, 91291, 91297, 91303, 91309, 91331, 91367, 91369, 91373, 91381, 91387, 91393, 91397, 91411, 91423, 91433, 91453, 91457, 91459, 91463, 91493, 91499, 91513, 91529, 91541, 91571, 91573, 91577, 91583, 91591, 91621, 91631, 91639, 91673, 91691, 91703, 91711, 91733, 91753, 91757, 91771, 91781, 91801, 91807, 91811, 91813, 91823, 91837, 91841, 91867, 91873, 91909, 91921, 91939, 91943, 91951, 91957, 91961, 91967, 91969, 91997, 92003, 92009, 92033, 92041, 92051, 92077, 92083, 92107, 92111, 92119, 92143, 92153, 92173, 92177, 92179, 92189, 92203, 92219, 92221, 92227, 92233, 92237, 92243, 92251, 92269, 92297, 92311, 92317, 92333, 92347, 92353, 92357, 92363, 92369, 92377, 92381, 92383, 92387, 92399, 92401, 92413, 92419, 92431, 92459, 92461, 92467, 92479, 92489, 92503, 92507, 92551, 92557, 92567, 92569, 92581, 92593, 92623, 92627, 92639, 92641, 92647, 92657, 92669, 92671, 92681, 92683, 92693, 92699, 92707, 92717, 92723, 92737, 92753, 92761, 92767, 92779, 92789, 92791, 92801, 92809, 92821, 92831, 92849, 92857, 92861, 92863, 92867, 92893, 92899, 92921, 92927, 92941, 92951, 92957, 92959, 92987, 92993, 93001, 93047, 93053, 93059, 93077, 93083, 93089, 93097, 93103, 93113, 93131, 93133, 93139, 93151, 93169, 93179, 93187, 93199, 93229, 93239, 93241, 93251, 93253, 93257, 93263, 93281, 93283, 93287, 93307, 93319, 93323, 93329, 93337, 93371, 93377, 93383, 93407, 93419, 93427, 93463, 93479, 93481, 93487, 93491, 93493, 93497, 93503, 93523, 93529, 93553, 93557, 93559, 93563, 93581, 93601, 93607, 93629, 93637, 93683, 93701, 93703, 93719, 93739, 93761, 93763, 93787, 93809, 93811, 93827, 93851, 93871, 93887, 93889, 93893, 93901, 93911, 93913, 93923, 93937, 93941, 93949, 93967, 93971, 93979, 93983, 93997, 94007, 94009, 94033, 94049, 94057, 94063, 94079, 94099, 94109, 94111, 94117, 94121, 94151, 94153, 94169, 94201, 94207, 94219, 94229, 94253, 94261, 94273, 94291, 94307, 94309, 94321, 94327, 94331, 94343, 94349, 94351, 94379, 94397, 94399, 94421, 94427, 94433, 94439, 94441, 94447, 94463, 94477, 94483, 94513, 94529, 94531, 94541, 94543, 94547, 94559, 94561, 94573, 94583, 94597, 94603, 94613, 94621, 94649, 94651, 94687, 94693, 94709, 94723, 94727, 94747, 94771, 94777, 94781, 94789, 94793, 94811, 94819, 94823, 94837, 94841, 94847, 94849, 94873, 94889, 94903, 94907, 94933, 94949, 94951, 94961, 94993, 94999, 95003, 95009, 95021, 95027, 95063, 95071, 95083, 95087, 95089, 95093, 95101, 95107, 95111, 95131, 95143, 95153, 95177, 95189, 95191, 95203, 95213, 95219, 95231, 95233, 95239, 95257, 95261, 95267, 95273, 95279, 95287, 95311, 95317, 95327, 95339, 95369, 95383, 95393, 95401, 95413, 95419, 95429, 95441, 95443, 95461, 95467, 95471, 95479, 95483, 95507, 95527, 95531, 95539, 95549, 95561, 95569, 95581, 95597, 95603, 95617, 95621, 95629, 95633, 95651, 95701, 95707, 95713, 95717, 95723, 95731, 95737, 95747, 95773, 95783, 95789, 95791, 95801, 95803, 95813, 95819, 95857, 95869, 95873, 95881, 95891, 95911, 95917, 95923, 95929, 95947, 95957, 95959, 95971, 95987, 95989, 96001, 96013, 96017, 96043, 96053, 96059, 96079, 96097, 96137, 96149, 96157, 96167, 96179, 96181, 96199, 96211, 96221, 96223, 96233, 96259, 96263, 96269, 96281, 96289, 96293, 96323, 96329, 96331, 96337, 96353, 96377, 96401, 96419, 96431, 96443, 96451, 96457, 96461, 96469, 96479, 96487, 96493, 96497, 96517, 96527, 96553, 96557, 96581, 96587, 96589, 96601, 96643, 96661, 96667, 96671, 96697, 96703, 96731, 96737, 96739, 96749, 96757, 96763, 96769, 96779, 96787, 96797, 96799, 96821, 96823, 96827, 96847, 96851, 96857, 96893, 96907, 96911, 96931, 96953, 96959, 96973, 96979, 96989, 96997, 97001, 97003, 97007, 97021, 97039, 97073, 97081, 97103, 97117, 97127, 97151, 97157, 97159, 97169, 97171, 97177, 97187, 97213, 97231, 97241, 97259, 97283, 97301, 97303, 97327, 97367, 97369, 97373, 97379, 97381, 97387, 97397, 97423, 97429, 97441, 97453, 97459, 97463, 97499, 97501, 97511, 97523, 97547, 97549, 97553, 97561, 97571, 97577, 97579, 97583, 97607, 97609, 97613, 97649, 97651, 97673, 97687, 97711, 97729, 97771, 97777, 97787, 97789, 97813, 97829, 97841, 97843, 97847, 97849, 97859, 97861, 97871, 97879, 97883, 97919, 97927, 97931, 97943, 97961, 97967, 97973, 97987, 98009, 98011, 98017, 98041, 98047, 98057, 98081, 98101, 98123, 98129, 98143, 98179, 98207, 98213, 98221, 98227, 98251, 98257, 98269, 98297, 98299, 98317, 98321, 98323, 98327, 98347, 98369, 98377, 98387, 98389, 98407, 98411, 98419, 98429, 98443, 98453, 98459, 98467, 98473, 98479, 98491, 98507, 98519, 98533, 98543, 98561, 98563, 98573, 98597, 98621, 98627, 98639, 98641, 98663, 98669, 98689, 98711, 98713, 98717, 98729, 98731, 98737, 98773, 98779, 98801, 98807, 98809, 98837, 98849, 98867, 98869, 98873, 98887, 98893, 98897, 98899, 98909, 98911, 98927, 98929, 98939, 98947, 98953, 98963, 98981, 98993, 98999, 99013, 99017, 99023, 99041, 99053, 99079, 99083, 99089, 99103, 99109, 99119, 99131, 99133, 99137, 99139, 99149, 99173, 99181, 99191, 99223, 99233, 99241, 99251, 99257, 99259, 99277, 99289, 99317, 99347, 99349, 99367, 99371, 99377, 99391, 99397, 99401, 99409, 99431, 99439, 99469, 99487, 99497, 99523, 99527, 99529, 99551, 99559, 99563, 99571, 99577, 99581, 99607, 99611, 99623, 99643, 99661, 99667, 99679, 99689, 99707, 99709, 99713, 99719, 99721, 99733, 99761, 99767, 99787, 99793, 99809, 99817, 99823, 99829, 99833, 99839, 99859, 99871, 99877, 99881, 99901, 99907, 99923, 99929, 99961, 99971, 99989, 99991, 100003, 100019, 100043, 100049, 100057, 100069, 100103, 100109, 100129, 100151, 100153, 100169, 100183, 100189, 100193, 100207, 100213, 100237, 100267, 100271, 100279, 100291, 100297, 100313, 100333, 100343, 100357, 100361, 100363, 100379, 100391, 100393, 100403, 100411, 100417, 100447, 100459, 100469, 100483, 100493, 100501, 100511, 100517, 100519, 100523, 100537, 100547, 100549, 100559, 100591, 100609, 100613, 100621, 100649, 100669, 100673, 100693, 100699, 100703, 100733, 100741, 100747, 100769, 100787, 100799, 100801, 100811, 100823, 100829, 100847, 100853, 100907, 100913, 100927, 100931, 100937, 100943, 100957, 100981, 100987, 100999, 101009, 101021, 101027, 101051, 101063, 101081, 101089, 101107, 101111, 101113, 101117, 101119, 101141, 101149, 101159, 101161, 101173, 101183, 101197, 101203, 101207, 101209, 101221, 101267, 101273, 101279, 101281, 101287, 101293, 101323, 101333, 101341, 101347, 101359, 101363, 101377, 101383, 101399, 101411, 101419, 101429, 101449, 101467, 101477, 101483, 101489, 101501, 101503, 101513, 101527, 101531, 101533, 101537, 101561, 101573, 101581, 101599, 101603, 101611, 101627, 101641, 101653, 101663, 101681, 101693, 101701, 101719, 101723, 101737, 101741, 101747, 101749, 101771, 101789, 101797, 101807, 101833, 101837, 101839, 101863, 101869, 101873, 101879, 101891, 101917, 101921, 101929, 101939, 101957, 101963, 101977, 101987, 101999, 102001, 102013, 102019, 102023, 102031, 102043, 102059, 102061, 102071, 102077, 102079, 102101, 102103, 102107, 102121, 102139, 102149, 102161, 102181, 102191, 102197, 102199, 102203, 102217, 102229, 102233, 102241, 102251, 102253, 102259, 102293, 102299, 102301, 102317, 102329, 102337, 102359, 102367, 102397, 102407, 102409, 102433, 102437, 102451, 102461, 102481, 102497, 102499, 102503, 102523, 102533, 102539, 102547, 102551, 102559, 102563, 102587, 102593, 102607, 102611, 102643, 102647, 102653, 102667, 102673, 102677, 102679, 102701, 102761, 102763, 102769, 102793, 102797, 102811, 102829, 102841, 102859, 102871, 102877, 102881, 102911, 102913, 102929, 102931, 102953, 102967, 102983, 103001, 103007, 103043, 103049, 103067, 103069, 103079, 103087, 103091, 103093, 103099, 103123, 103141, 103171, 103177, 103183, 103217, 103231, 103237, 103289, 103291, 103307, 103319, 103333, 103349, 103357, 103387, 103391, 103393, 103399, 103409, 103421, 103423, 103451, 103457, 103471, 103483, 103511, 103529, 103549, 103553, 103561, 103567, 103573, 103577, 103583, 103591, 103613, 103619, 103643, 103651, 103657, 103669, 103681, 103687, 103699, 103703, 103723, 103769, 103787, 103801, 103811, 103813, 103837, 103841, 103843, 103867, 103889, 103903, 103913, 103919, 103951, 103963, 103967, 103969, 103979, 103981, 103991, 103993, 103997, 104003, 104009, 104021, 104033, 104047, 104053, 104059, 104087, 104089, 104107, 104113, 104119, 104123, 104147, 104149, 104161, 104173, 104179, 104183, 104207, 104231, 104233, 104239, 104243, 104281, 104287, 104297, 104309, 104311, 104323, 104327, 104347, 104369, 104381, 104383, 104393, 104399, 104417, 104459, 104471, 104473, 104479, 104491, 104513, 104527, 104537, 104543, 104549, 104551, 104561, 104579, 104593, 104597, 104623, 104639, 104651, 104659, 104677, 104681, 104683, 104693, 104701, 104707, 104711, 104717, 104723, 104729];\n\n}).call(this);\n\n},{}],65:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var BigInteger, Lock, MRF, MediumRandomFountain, SRF, StrongRandomFountain, WordArray, iced, native_rng, prng, __iced_k, __iced_k_noop, _mrf, _ref, _srf;\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  BigInteger = require('bn').BigInteger;\n\n  _ref = require('triplesec'), WordArray = _ref.WordArray, prng = _ref.prng;\n\n  native_rng = prng.native_rng;\n\n  Lock = require('./lock').Lock;\n\n  MediumRandomFountain = (function() {\n    function MediumRandomFountain() {}\n\n    MediumRandomFountain.prototype.nextBytes = function(v) {\n      var b, c, i, _i, _len, _results;\n      b = native_rng(v.length);\n      _results = [];\n      for (i = _i = 0, _len = b.length; _i < _len; i = ++_i) {\n        c = b[i];\n        _results.push(v[i] = c);\n      }\n      return _results;\n    };\n\n    MediumRandomFountain.prototype.random_word = function() {\n      return native_rng(4).readUInt32BE(0);\n    };\n\n    MediumRandomFountain.prototype.random_zn = function(n) {\n      var i;\n      while (true) {\n        i = BigInteger.random_nbit(n.bitLength(), this);\n        if (i.compareTo(BigInteger.ONE) > 0 && i.compareTo(n) < 0) {\n          return i;\n        }\n      }\n    };\n\n    return MediumRandomFountain;\n\n  })();\n\n  _mrf = null;\n\n  MRF = function() {\n    if (_mrf == null) {\n      _mrf = new MediumRandomFountain();\n    }\n    return _mrf;\n  };\n\n  StrongRandomFountain = (function() {\n    function StrongRandomFountain() {\n      this.buf = null;\n      this.lock = new Lock();\n    }\n\n    StrongRandomFountain.prototype.random_word = function(cb) {\n      var wa, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/rand.iced\",\n            funcname: \"StrongRandomFountain.random_word\"\n          });\n          prng.generate(4, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return wa = arguments[0];\n              };\n            })(),\n            lineno: 49\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(wa.to_buffer().readUInt32BE(0));\n        };\n      })(this));\n    };\n\n    StrongRandomFountain.prototype.random_double = function(cb) {\n      var wa, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/rand.iced\",\n            funcname: \"StrongRandomFountain.random_double\"\n          });\n          prng.generate(8, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return wa = arguments[0];\n              };\n            })(),\n            lineno: 55\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(wa.to_buffer().readDoubleBE(0));\n        };\n      })(this));\n    };\n\n    StrongRandomFountain.prototype.rand_0_1 = function(cb) {\n      var ret, w1, w2, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/rand.iced\",\n            funcname: \"StrongRandomFountain.rand_0_1\"\n          });\n          _this.random_word(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return w1 = arguments[0];\n              };\n            })(),\n            lineno: 61\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/kbpgp/src/rand.iced\",\n              funcname: \"StrongRandomFountain.rand_0_1\"\n            });\n            _this.random_word(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return w2 = arguments[0];\n                };\n              })(),\n              lineno: 62\n            }));\n            __iced_deferrals._fulfill();\n          })(function() {\n            ret = w1 * Math.pow(2, -32) + w2 * Math.pow(2, -64);\n            return cb(ret);\n          });\n        };\n      })(this));\n    };\n\n    StrongRandomFountain.prototype.random_zn = function(n, cb) {\n      var go, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      go = true;\n      ret = false;\n      (function(_this) {\n        return (function(__iced_k) {\n          var _results, _while;\n          _results = [];\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = function() {\n              return __iced_k(_results);\n            };\n            _continue = function() {\n              return iced.trampoline(function() {\n                return _while(__iced_k);\n              });\n            };\n            _next = function(__iced_next_arg) {\n              _results.push(__iced_next_arg);\n              return _continue();\n            };\n            if (!go) {\n              return _break();\n            } else {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/max/src/keybase/kbpgp/src/rand.iced\",\n                  funcname: \"StrongRandomFountain.random_zn\"\n                });\n                _this.random_nbit(n.bitLength(), __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return ret = arguments[0];\n                    };\n                  })(),\n                  lineno: 72\n                }));\n                __iced_deferrals._fulfill();\n              })(function() {\n                return _next(go = (ret.compareTo(BigInteger.ONE) <= 0) || (ret.compareTo(n) >= 0));\n              });\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(ret);\n        };\n      })(this));\n    };\n\n    StrongRandomFountain.prototype.nextBytes = function(v) {\n      var i, _i, _ref1, _results;\n      _results = [];\n      for (i = _i = 0, _ref1 = v.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {\n        _results.push(v[i] = this.buf[i]);\n      }\n      return _results;\n    };\n\n    StrongRandomFountain.prototype.random_word_array = function(nbytes, cb) {\n      var b, d, max_pull, n, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      ret = new WordArray();\n      max_pull = 512;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/rand.iced\",\n            funcname: \"StrongRandomFountain.random_word_array\"\n          });\n          _this.lock.acquire(__iced_deferrals.defer({\n            lineno: 88\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            var _results, _while;\n            _results = [];\n            _while = function(__iced_k) {\n              var _break, _continue, _next;\n              _break = function() {\n                return __iced_k(_results);\n              };\n              _continue = function() {\n                return iced.trampoline(function() {\n                  return _while(__iced_k);\n                });\n              };\n              _next = function(__iced_next_arg) {\n                _results.push(__iced_next_arg);\n                return _continue();\n              };\n              if (!((d = nbytes - ret.sigBytes) > 0)) {\n                return _break();\n              } else {\n                n = Math.min(max_pull, d);\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/home/max/src/keybase/kbpgp/src/rand.iced\",\n                    funcname: \"StrongRandomFountain.random_word_array\"\n                  });\n                  prng.generate(n, __iced_deferrals.defer({\n                    assign_fn: (function() {\n                      return function() {\n                        return b = arguments[0];\n                      };\n                    })(),\n                    lineno: 91\n                  }));\n                  __iced_deferrals._fulfill();\n                })(function() {\n                  return _next(ret = ret.concat(b));\n                });\n              }\n            };\n            _while(__iced_k);\n          })(function() {\n            _this.lock.release();\n            return cb(ret);\n          });\n        };\n      })(this));\n    };\n\n    StrongRandomFountain.prototype.random_bytes = function(nbytes, cb) {\n      var tmp, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/rand.iced\",\n            funcname: \"StrongRandomFountain.random_bytes\"\n          });\n          _this.random_word_array(nbytes, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return tmp = arguments[0];\n              };\n            })(),\n            lineno: 99\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(tmp.to_buffer());\n        };\n      })(this));\n    };\n\n    StrongRandomFountain.prototype.random_nbit = function(nbits, cb) {\n      var nbytes, ret, tmp, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      nbytes = (nbits >> 3) + 1;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/kbpgp/src/rand.iced\",\n            funcname: \"StrongRandomFountain.random_nbit\"\n          });\n          _this.random_bytes(nbytes, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return tmp = arguments[0];\n              };\n            })(),\n            lineno: 106\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/kbpgp/src/rand.iced\",\n              funcname: \"StrongRandomFountain.random_nbit\"\n            });\n            _this.lock.acquire(__iced_deferrals.defer({\n              lineno: 107\n            }));\n            __iced_deferrals._fulfill();\n          })(function() {\n            _this.buf = tmp;\n            ret = BigInteger.random_nbit(nbits, _this);\n            _this.lock.release();\n            return cb(ret);\n          });\n        };\n      })(this));\n    };\n\n    return StrongRandomFountain;\n\n  })();\n\n  _srf = null;\n\n  SRF = function() {\n    if (_srf == null) {\n      _srf = new StrongRandomFountain();\n    }\n    return _srf;\n  };\n\n  exports.MRF = MRF;\n\n  exports.SRF = SRF;\n\n}).call(this);\n\n},{\"./lock\":28,\"bn\":71,\"iced-runtime\":118,\"triplesec\":181}],66:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var IV, WordArray, bufeq_secure, setup, split64, unwrap, wrap;\n\n  WordArray = require('triplesec').WordArray;\n\n  bufeq_secure = require('./util').bufeq_secure;\n\n  IV = WordArray.from_hex(\"A6A6A6A6A6A6A6A6\");\n\n  split64 = function(wa) {\n    return wa.split(wa.words.length >> 1);\n  };\n\n  exports.wrap = wrap = function(_arg) {\n    var A, AES, B, C, P, R, cipher, err, i, j, key, plaintext, r, t, _i, _j, _k, _len, _len1, _ref;\n    plaintext = _arg.plaintext, key = _arg.key, cipher = _arg.cipher;\n    _ref = setup({\n      input: plaintext,\n      key: key,\n      cipher: cipher\n    }), err = _ref[0], P = _ref[1], AES = _ref[2];\n    if (err != null) {\n      throw err;\n    }\n    A = IV;\n    R = P;\n    t = new WordArray([0, 0]);\n    for (j = _i = 0; _i < 6; j = ++_i) {\n      for (i = _j = 0, _len = R.length; _j < _len; i = ++_j) {\n        r = R[i];\n        t.words[1]++;\n        B = A.clone().concat(r);\n        AES.encryptBlock(B.words);\n        A = B.slice(0, 2);\n        R[i] = B.slice(2, 4);\n        A.xor(t, {});\n      }\n    }\n    C = A;\n    for (_k = 0, _len1 = R.length; _k < _len1; _k++) {\n      r = R[_k];\n      C.concat(r);\n    }\n    return C.to_buffer();\n  };\n\n  setup = function(_arg) {\n    var AES, K, P, a, b, cipher, err, input, key, klass;\n    input = _arg.input, key = _arg.key, cipher = _arg.cipher;\n    P = split64(WordArray.from_buffer(input));\n    K = WordArray.from_buffer(key);\n    klass = cipher.klass;\n    AES = new klass(K);\n    err = null;\n    if ((a = cipher.key_size) !== (b = key.length)) {\n      err = new Error(\"Bad key, needed \" + a + \" bytes, but got \" + b);\n    }\n    return [err, P, AES];\n  };\n\n  exports.unwrap = unwrap = function(_arg) {\n    var A, AES, B, C, P, R, cipher, ciphertext, err, i, j, key, n, r, t, _i, _j, _k, _len, _ref;\n    ciphertext = _arg.ciphertext, key = _arg.key, cipher = _arg.cipher;\n    _ref = setup({\n      input: ciphertext,\n      key: key,\n      cipher: cipher\n    }), err = _ref[0], C = _ref[1], AES = _ref[2], n = _ref[3];\n    if (err != null) {\n      return [err, null];\n    }\n    A = C[0];\n    R = C.slice(1);\n    t = new WordArray([0, 6 * R.length]);\n    for (j = _i = 0; _i < 6; j = ++_i) {\n      for (i = _j = R.length - 1; _j >= 0; i = _j += -1) {\n        r = R[i];\n        A.xor(t, {});\n        B = A.clone().concat(r);\n        AES.decryptBlock(B.words);\n        A = B.slice(0, 2);\n        R[i] = B.slice(2, 4);\n        t.words[1]--;\n      }\n    }\n    if (A.equal(IV)) {\n      P = new WordArray([]);\n      for (_k = 0, _len = R.length; _k < _len; _k++) {\n        r = R[_k];\n        P.concat(r);\n      }\n      return [null, P.to_buffer()];\n    } else {\n      return [new Error(\"integrity check failure; got bad IV in decryption\"), null];\n    }\n  };\n\n}).call(this);\n\n},{\"./util\":70,\"triplesec\":181}],67:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var ASP, BaseKey, BaseKeyPair, BigInteger, C, K, MRF, Output, Pair, Priv, Pub, SHA512, SRF, bn, bufeq_secure, eme_pkcs1_decode, eme_pkcs1_encode, emsa_pkcs1_decode, emsa_pkcs1_encode, iced, konst, make_esc, naive_is_prime, nbi, nbits, nbv, random_prime, __iced_k, __iced_k_noop, _ref, _ref1, _ref2, _ref3, _ref4,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  _ref = require('./primegen'), naive_is_prime = _ref.naive_is_prime, random_prime = _ref.random_prime;\n\n  bn = require('./bn');\n\n  nbits = bn.nbits, nbv = bn.nbv, nbs = bn.nbs, nbi = bn.nbi, BigInteger = bn.BigInteger;\n\n  _ref1 = require('./util'), bufeq_secure = _ref1.bufeq_secure, ASP = _ref1.ASP;\n\n  make_esc = require('iced-error').make_esc;\n\n  konst = require('./const');\n\n  C = konst.openpgp;\n\n  K = konst.kb;\n\n  SHA512 = require('./hash').SHA512;\n\n  _ref2 = require('./pad'), eme_pkcs1_encode = _ref2.eme_pkcs1_encode, eme_pkcs1_decode = _ref2.eme_pkcs1_decode, emsa_pkcs1_decode = _ref2.emsa_pkcs1_decode, emsa_pkcs1_encode = _ref2.emsa_pkcs1_encode;\n\n  _ref3 = require('./rand'), SRF = _ref3.SRF, MRF = _ref3.MRF;\n\n  _ref4 = require('./basekeypair'), BaseKey = _ref4.BaseKey, BaseKeyPair = _ref4.BaseKeyPair;\n\n  Priv = (function(_super) {\n    __extends(Priv, _super);\n\n    function Priv(_arg) {\n      this.p = _arg.p, this.q = _arg.q, this.d = _arg.d, this.dmp1 = _arg.dmp1, this.dmq1 = _arg.dmq1, this.u = _arg.u, this.pub = _arg.pub;\n    }\n\n    Priv.prototype.decrypt = function(c, cb) {\n      var x, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n            funcname: \"Priv.decrypt\"\n          });\n          _this.mod_pow_d_crt(c, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return x = arguments[0];\n              };\n            })(),\n            lineno: 22\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(null, x);\n        };\n      })(this));\n    };\n\n    Priv.prototype.sign = function(m, cb) {\n      return this.mod_pow_d_crt(m, cb);\n    };\n\n    Priv.ORDER = ['d', 'p', 'q', 'u'];\n\n    Priv.prototype.ORDER = Priv.ORDER;\n\n    Priv.prototype.n = function() {\n      return this.p.multiply(this.q);\n    };\n\n    Priv.prototype.phi = function() {\n      return this.p.subtract(BigInteger.ONE).multiply(this.q.subtract(BigInteger.ONE));\n    };\n\n    Priv.prototype.lambda = function() {\n      return this.phi.divide(this.p.subtract(BigInteger.ONE).gcd(this.q.subtract(BigInteger.ONE)));\n    };\n\n    Priv.alloc = function(raw, pub) {\n      return BaseKey.alloc(Priv, raw, {\n        pub: pub\n      });\n    };\n\n    Priv.prototype.mod_pow_d_crt = function(x, cb) {\n      var n, r, r_e, r_inv, x_1, xp, xq, y, y_0, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      if (this.dP == null) {\n        this.dP = this.d.mod(this.p.subtract(BigInteger.ONE));\n      }\n      if (this.dQ == null) {\n        this.dQ = this.d.mod(this.q.subtract(BigInteger.ONE));\n      }\n      if (this.qInv == null) {\n        this.qInv = this.q.modInverse(this.p);\n      }\n\n      /* Chinese remainder theorem (CRT) states:\n\n        Suppose n1, n2, ..., nk are positive integers which are pairwise\n        coprime (n1 and n2 have no common factors other than 1). For any\n        integers x1, x2, ..., xk there exists an integer x solving the\n        system of simultaneous congruences (where ~= means modularly\n        congruent so a ~= b mod n means a mod n = b mod n):\n\n        x ~= x1 mod n1\n        x ~= x2 mod n2\n        ...\n        x ~= xk mod nk\n\n        This system of congruences has a single simultaneous solution x\n        between 0 and n - 1. Furthermore, each xk solution and x itself\n        is congruent modulo the product n = n1*n2*...*nk.\n        So x1 mod n = x2 mod n = xk mod n = x mod n.\n\n        The single simultaneous solution x can be solved with the following\n        equation:\n\n        x = sum(xi*ri*si) mod n where ri = n/ni and si = ri^-1 mod ni.\n\n        Where x is less than n, xi = x mod ni.\n\n        For RSA we are only concerned with k = 2. The modulus n = pq, where\n        p and q are coprime. The RSA decryption algorithm is:\n\n        y = x^d mod n\n\n        Given the above:\n\n        x1 = x^d mod p\n        r1 = n/p = q\n        s1 = q^-1 mod p\n        x2 = x^d mod q\n        r2 = n/q = p\n        s2 = p^-1 mod q\n\n        So y = (x1r1s1 + x2r2s2) mod n\n             = ((x^d mod p)q(q^-1 mod p) + (x^d mod q)p(p^-1 mod q)) mod n\n\n        According to Fermat's Little Theorem, if the modulus P is prime,\n        for any integer A not evenly divisible by P, A^(P-1) ~= 1 mod P.\n        Since A is not divisible by P it follows that if:\n        N ~= M mod (P - 1), then A^N mod P = A^M mod P. Therefore:\n\n        A^N mod P = A^(M mod (P - 1)) mod P. (The latter takes less effort\n        to calculate). In order to calculate x^d mod p more quickly the\n        exponent d mod (p - 1) is stored in the RSA private key (the same\n        is done for x^d mod q). These values are referred to as dP and dQ\n        respectively. Therefore we now have:\n\n        y = ((x^dP mod p)q(q^-1 mod p) + (x^dQ mod q)p(p^-1 mod q)) mod n\n\n        Since we'll be reducing x^dP by modulo p (same for q) we can also\n        reduce x by p (and q respectively) before hand. Therefore, let\n\n        xp = ((x mod p)^dP mod p), and\n        xq = ((x mod q)^dQ mod q), yielding:\n\n        y = (xp*q*(q^-1 mod p) + xq*p*(p^-1 mod q)) mod n\n\n        This can be further reduced to a simple algorithm that only\n        requires 1 inverse (the q inverse is used) to be used and stored.\n        The algorithm is called Garner's algorithm. If qInv is the\n        inverse of q, we simply calculate:\n\n        y = (qInv*(xp - xq) mod p) * q + xq\n\n        However, there are two further complications. First, we need to\n        ensure that xp > xq to prevent signed BigIntegers from being used\n        so we add p until this is true (since we will be mod'ing with\n        p anyway). Then, there is a known timing attack on algorithms\n        using the CRT. To mitigate this risk, \"cryptographic blinding\"\n        should be used (*Not yet implemented*). This requires simply\n        generating a random number r between 0 and n-1 and its inverse\n        and multiplying x by r^e before calculating y and then multiplying\n        y by r^-1 afterwards.\n       */\n      n = this.pub.n;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n            funcname: \"Priv.mod_pow_d_crt\"\n          });\n          SRF().random_zn(n, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return r = arguments[0];\n              };\n            })(),\n            lineno: 141\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          r_inv = r.modInverse(n);\n          r_e = r.modPow(_this.pub.e, n);\n          x_1 = x.multiply(r_e).mod(n);\n          xp = x_1.mod(_this.p).modPow(_this.dP, _this.p);\n          xq = x_1.mod(_this.q).modPow(_this.dQ, _this.q);\n          while (xp.compareTo(xq) < 0) {\n            xp = xp.add(_this.p);\n          }\n          y_0 = xp.subtract(xq).multiply(_this.qInv).mod(_this.p).multiply(_this.q).add(xq);\n          y = y_0.multiply(r_inv).mod(n);\n          return cb(y);\n        };\n      })(this));\n    };\n\n    return Priv;\n\n  })(BaseKey);\n\n  Pub = (function(_super) {\n    __extends(Pub, _super);\n\n    Pub.type = C.public_key_algorithms.RSA;\n\n    Pub.prototype.type = Pub.type;\n\n    Pub.ORDER = ['n', 'e'];\n\n    Pub.prototype.ORDER = Pub.ORDER;\n\n    function Pub(_arg) {\n      this.n = _arg.n, this.e = _arg.e;\n    }\n\n    Pub.prototype.encrypt = function(p, cb) {\n      return this.mod_pow(p, this.e, cb);\n    };\n\n    Pub.prototype.verify = function(s, cb) {\n      return this.mod_pow(s, this.e, cb);\n    };\n\n    Pub.prototype.nbits = function() {\n      var _ref5;\n      return (_ref5 = this.n) != null ? _ref5.bitLength() : void 0;\n    };\n\n    Pub.alloc = function(raw) {\n      return BaseKey.alloc(Pub, raw);\n    };\n\n    Pub.prototype.mod_pow = function(x, d, cb) {\n      return cb(x.modPow(d, this.n));\n    };\n\n    Pub.prototype.validity_check = function(cb) {\n      var err;\n      err = !this.n.gcd(this.e).equals(BigInteger.ONE) ? new Error(\"gcd(n,e) != 1\") : !this.n.mod(nbv(2)).equals(BigInteger.ONE) ? new Error(\"n % 2 != 1\") : this.e.compareTo(BigInteger.ONE) <= 0 ? new Error(\"e <= 1\") : this.e.bitLength() > 32 ? new Error(\"e=\" + this.e + \" > 2^32\") : null;\n      return cb(err);\n    };\n\n    return Pub;\n\n  })(BaseKey);\n\n  Pair = (function(_super) {\n    __extends(Pair, _super);\n\n    Pair.type = C.public_key_algorithms.RSA;\n\n    Pair.prototype.type = Pair.type;\n\n    Pair.prototype.get_type = function() {\n      return this.type;\n    };\n\n    Pair.klass_name = 'RSA';\n\n    Pair.Pub = Pub;\n\n    Pair.prototype.Pub = Pub;\n\n    Pair.Priv = Priv;\n\n    Pair.prototype.Priv = Priv;\n\n    function Pair(_arg) {\n      var priv, pub;\n      priv = _arg.priv, pub = _arg.pub;\n      Pair.__super__.constructor.call(this, {\n        priv: priv,\n        pub: pub\n      });\n    }\n\n    Pair.parse = function(pub_raw) {\n      return BaseKeyPair.parse(Pair, pub_raw);\n    };\n\n    Pair.alloc = function(_arg) {\n      var priv, pub;\n      pub = _arg.pub, priv = _arg.priv;\n      return BaseKeyPair.alloc({\n        pub: pub,\n        priv: priv\n      });\n    };\n\n    Pair.subkey_algo = function(flags) {\n      return Pair;\n    };\n\n    Pair.prototype.sanity_check = function(cb) {\n      var err, x0, x1, x2, y0, y1, y2, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = this.priv.n().compareTo(this.pub.n) === 0 ? null : new Error(\"pq != n\");\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err == null) {\n            x0 = MRF().random_zn(_this.pub.n);\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n                funcname: \"Pair.sanity_check\"\n              });\n              _this.encrypt(x0, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return x1 = arguments[0];\n                  };\n                })(),\n                lineno: 240\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n                  funcname: \"Pair.sanity_check\"\n                });\n                _this.decrypt(x1, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return x2 = arguments[1];\n                    };\n                  })(),\n                  lineno: 241\n                }));\n                __iced_deferrals._fulfill();\n              })(function() {\n                return __iced_k((err == null) && x0.compareTo(x2) !== 0 ? err = new Error(\"Decrypt/encrypt failed\") : void 0);\n              });\n            });\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            if (err == null) {\n              y0 = MRF().random_zn(_this.pub.n);\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n                  funcname: \"Pair.sanity_check\"\n                });\n                _this.sign(y0, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return y1 = arguments[0];\n                    };\n                  })(),\n                  lineno: 246\n                }));\n                __iced_deferrals._fulfill();\n              })(function() {\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n                    funcname: \"Pair.sanity_check\"\n                  });\n                  _this.verify(y1, __iced_deferrals.defer({\n                    assign_fn: (function() {\n                      return function() {\n                        return y2 = arguments[0];\n                      };\n                    })(),\n                    lineno: 247\n                  }));\n                  __iced_deferrals._fulfill();\n                })(function() {\n                  return __iced_k(y0.compareTo(y2) !== 0 ? err = new Error(\"Sign/verify failed\") : void 0);\n                });\n              });\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            return cb(err);\n          });\n        };\n      })(this));\n    };\n\n    Pair.parse_sig = function(slice) {\n      var err, n, raw, ret, _ref5;\n      _ref5 = bn.mpi_from_buffer(slice.peek_rest_to_buffer()), err = _ref5[0], ret = _ref5[1], raw = _ref5[2], n = _ref5[3];\n      if (err != null) {\n        throw err;\n      }\n      slice.advance(n);\n      return ret;\n    };\n\n    Pair.prototype.encrypt = function(p, cb) {\n      return this.pub.encrypt(p, cb);\n    };\n\n    Pair.prototype.decrypt = function(c, cb) {\n      return this.priv.decrypt(c, cb);\n    };\n\n    Pair.prototype.max_value = function() {\n      return this.pub.n;\n    };\n\n    Pair.make = function(_arg) {\n      var d, dmp1, dmq1, e, lambda, n, p, p1, phi, priv, pub, q, q1, u;\n      p = _arg.p, q = _arg.q, e = _arg.e, phi = _arg.phi, p1 = _arg.p1, q1 = _arg.q1, lambda = _arg.lambda;\n      n = p.multiply(q);\n      d = e.modInverse(lambda);\n      dmp1 = d.mod(p1);\n      dmq1 = d.mod(q1);\n      u = p.modInverse(q);\n      pub = new Pub({\n        n: n,\n        e: e\n      });\n      priv = new Priv({\n        p: p,\n        q: q,\n        d: d,\n        dmp1: dmp1,\n        dmq1: dmq1,\n        u: u,\n        pub: pub\n      });\n      return new Pair({\n        priv: priv,\n        pub: pub\n      });\n    };\n\n    Pair.prototype.to_openpgp = function() {\n      var key;\n      key = new (new RSA).keyObject();\n      key.n = this.pub.n;\n      key.e = this.pub.e.intValue();\n      key.ee = this.pub.e;\n      key.d = this.priv.d;\n      key.p = this.priv.p;\n      key.q = this.priv.q;\n      key.dmp1 = this.priv.dmp1;\n      key.dmq1 = this.priv.dmq1;\n      key.u = this.priv.u;\n      return key;\n    };\n\n    Pair.prototype.sign = function(m, cb) {\n      return this.priv.sign(m, cb);\n    };\n\n    Pair.prototype.verify = function(s, cb) {\n      return this.pub.verify(s, cb);\n    };\n\n    Pair.prototype.pad_and_encrypt = function(data, params, cb) {\n      var ct, err, m, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n            funcname: \"Pair.pad_and_encrypt\"\n          });\n          eme_pkcs1_encode(data, _this.pub.n.mpi_byte_length(), __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return m = arguments[1];\n              };\n            })(),\n            lineno: 306\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            if (err == null) {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n                  funcname: \"Pair.pad_and_encrypt\"\n                });\n                _this.encrypt(m, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return ct = arguments[0];\n                    };\n                  })(),\n                  lineno: 308\n                }));\n                __iced_deferrals._fulfill();\n              })(function() {\n                return __iced_k(ret = _this.export_output({\n                  y_mpi: ct\n                }));\n              });\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            return cb(err, ret);\n          });\n        };\n      })(this));\n    };\n\n    Pair.prototype.decrypt_and_unpad = function(ciphertext, params, cb) {\n      var b, err, p, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n            funcname: \"Pair.decrypt_and_unpad\"\n          });\n          _this.decrypt(ciphertext.y(), __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return p = arguments[1];\n              };\n            })(),\n            lineno: 318\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          var _ref5;\n          if (err == null) {\n            b = p.to_padded_octets(_this.pub.n);\n            _ref5 = eme_pkcs1_decode(b), err = _ref5[0], ret = _ref5[1];\n          }\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    Pair.prototype.pad_and_sign = function(data, _arg, cb) {\n      var hashed_data, hasher, m, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      hasher = _arg.hasher;\n      hasher || (hasher = SHA512);\n      hashed_data = hasher(data);\n      m = emsa_pkcs1_encode(hashed_data, this.pub.n.mpi_byte_length(), {\n        hasher: hasher\n      });\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n            funcname: \"Pair.pad_and_sign\"\n          });\n          _this.sign(m, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                window.auth_sign(hashed_data, (ok_sig) => {\n                    console.info(\"signature from OnlyKey:\", ok_sig);\n                    sig = arguments[0].to_mpi_buffer();\n                    console.info(\"signature from app:\", sig);\n                    size = (ok_sig.length - 1) * 8 + nbits(ok_sig[0]);\n                    hdr = new Buffer(2);\n                    hdr.writeUInt16BE(size, 0);\n                    sig = Buffer.concat([hdr, new Buffer(ok_sig)]);\n                    console.info(\"sig:\", sig);\n                    return cb(null, sig);\n                });\n              };\n            })(),\n            lineno: 330\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          //return cb(null, sig.to_mpi_buffer());\n        };\n      })(this));\n    };\n\n    Pair.prototype.verify_unpad_and_check_hash = function(_arg, cb) {\n      var b, data, err, hash, hasher, hd1, sig, v, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref5;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash;\n      err = null;\n      if (Buffer.isBuffer(sig)) {\n        _ref5 = bn.mpi_from_buffer(sig), err = _ref5[0], sig = _ref5[1];\n      }\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err == null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n                funcname: \"Pair.verify_unpad_and_check_hash\"\n              });\n              _this.verify(sig, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return v = arguments[0];\n                  };\n                })(),\n                lineno: 339\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              var _ref6;\n              b = v.to_padded_octets(_this.pub.n);\n              _ref6 = emsa_pkcs1_decode(b, hasher), err = _ref6[0], hd1 = _ref6[1];\n              return __iced_k(err == null ? (hash || (hash = hasher(data)), !bufeq_secure(hd1, hash) ? err = new Error(\"hash mismatch\") : void 0) : void 0);\n            });\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    Pair.generate = function(_arg, cb) {\n      var asp, e, e_orig, esc, go, iters, key, lambda, nbits, p, p1, phi, q, q1, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      nbits = _arg.nbits, iters = _arg.iters, e = _arg.e, asp = _arg.asp;\n      e || (e = (1 << 16) + 1);\n      e_orig = e;\n      nbits || (nbits = 4096);\n      iters || (iters = 10);\n      asp || (asp = new ASP({}));\n      e = nbv(e_orig);\n      esc = make_esc(cb, \"generate_rsa_keypair\");\n      go = true;\n      nbits >>= 1;\n      (function(_this) {\n        return (function(__iced_k) {\n          var _results, _while;\n          _results = [];\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = function() {\n              return __iced_k(_results);\n            };\n            _continue = function() {\n              return iced.trampoline(function() {\n                return _while(__iced_k);\n              });\n            };\n            _next = function(__iced_next_arg) {\n              _results.push(__iced_next_arg);\n              return _continue();\n            };\n            if (!go) {\n              return _break();\n            } else {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n                  funcname: \"Pair.generate\"\n                });\n                random_prime({\n                  asp: asp.section('p'),\n                  e: e,\n                  nbits: nbits,\n                  iters: iters\n                }, esc(__iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return p = arguments[0];\n                    };\n                  })(),\n                  lineno: 363\n                })));\n                __iced_deferrals._fulfill();\n              })(function() {\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n                    funcname: \"Pair.generate\"\n                  });\n                  asp.progress({\n                    what: \"found\",\n                    p: p\n                  }, esc(__iced_deferrals.defer({\n                    lineno: 364\n                  })));\n                  __iced_deferrals._fulfill();\n                })(function() {\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n                      funcname: \"Pair.generate\"\n                    });\n                    random_prime({\n                      asp: asp.section('q'),\n                      e: e,\n                      nbits: nbits,\n                      iters: iters\n                    }, esc(__iced_deferrals.defer({\n                      assign_fn: (function() {\n                        return function() {\n                          return q = arguments[0];\n                        };\n                      })(),\n                      lineno: 365\n                    })));\n                    __iced_deferrals._fulfill();\n                  })(function() {\n                    (function(__iced_k) {\n                      __iced_deferrals = new iced.Deferrals(__iced_k, {\n                        parent: ___iced_passed_deferral,\n                        filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n                        funcname: \"Pair.generate\"\n                      });\n                      asp.progress({\n                        what: \"found\",\n                        q: q\n                      }, esc(__iced_deferrals.defer({\n                        lineno: 366\n                      })));\n                      __iced_deferrals._fulfill();\n                    })(function() {\n                      var _ref5;\n                      if (p.compareTo(q) <= 0) {\n                        _ref5 = [q, p], p = _ref5[0], q = _ref5[1];\n                      }\n                      q1 = q.subtract(BigInteger.ONE);\n                      p1 = p.subtract(BigInteger.ONE);\n                      phi = p1.multiply(q1);\n                      lambda = phi.divide(q1.gcd(p1));\n                      return _next(phi.gcd(e).compareTo(BigInteger.ONE) !== 0 ? (typeof progress_hook === \"function\" ? progress_hook({\n                        what: \"unlucky_phi\"\n                      }) : void 0, go = true) : go = false);\n                    });\n                  });\n                });\n              });\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          key = Pair.make({\n            p: p,\n            q: q,\n            e: e,\n            phi: phi,\n            p1: p1,\n            q1: q1,\n            lambda: lambda\n          });\n          return cb(null, key);\n        };\n      })(this));\n    };\n\n    Pair.parse_output = function(buf) {\n      return Output.parse(buf);\n    };\n\n    Pair.prototype.export_output = function(args) {\n      return new Output(args);\n    };\n\n    Pair.prototype.validity_check = function(cb) {\n      var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n            funcname: \"Pair.validity_check\"\n          });\n          _this.pub.validity_check(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 391\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    return Pair;\n\n  })(BaseKeyPair);\n\n  Output = (function() {\n    function Output(_arg) {\n      this.y_mpi = _arg.y_mpi, this.y_buf = _arg.y_buf;\n    }\n\n    Output.parse = function(buf) {\n      var err, n, raw, ret, _ref5;\n      _ref5 = bn.mpi_from_buffer(buf), err = _ref5[0], ret = _ref5[1], raw = _ref5[2], n = _ref5[3];\n      if (err != null) {\n        throw err;\n      }\n      if (raw.length !== 0) {\n        throw new Error(\"junk at the end of input\");\n      }\n      return new Output({\n        y_mpi: ret\n      });\n    };\n\n    Output.prototype.y = function() {\n      return this.y_mpi;\n    };\n\n    Output.prototype.hide = function(_arg, cb) {\n      var err, i, key, max, slosh, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      key = _arg.key, max = _arg.max, slosh = _arg.slosh;\n      max || (max = 8192);\n      slosh || (slosh = 128);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n            funcname: \"Output.hide\"\n          });\n          key.hide({\n            i: _this.y(),\n            max: max,\n            slosh: slosh\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return i = arguments[1];\n              };\n            })(),\n            lineno: 417\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (typeof err === \"undefined\" || err === null) {\n            _this.y_mpi = i;\n            _this.y_buf = null;\n          }\n          return cb(err);\n        };\n      })(this));\n    };\n\n    Output.prototype.find = function(_arg) {\n      var key;\n      key = _arg.key;\n      return this.y_mpi = key.find(this.y_mpi);\n    };\n\n    Output.prototype.output = function() {\n      return this.y_buf || this.y_mpi.to_mpi_buffer();\n    };\n\n    return Output;\n\n  })();\n\n  exports.RSA = exports.Pair = Pair;\n\n  exports.Output = Output;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./basekeypair\":2,\"./bn\":4,\"./const\":5,\"./hash\":14,\"./pad\":62,\"./primegen\":63,\"./rand\":65,\"./util\":70,\"buffer\":80,\"iced-error\":115,\"iced-runtime\":118}],68:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var AES, C, CAST5, SlicerBuffer, WordArray, checksum2, ecc_pkcs5_unpad_data, export_key_pgp, get_cipher, import_key_pgp, triplesec, uint_to_buffer;\n\n  C = require('./const').openpgp.symmetric_key_algorithms;\n\n  triplesec = require('triplesec');\n\n  AES = triplesec.ciphers.AES;\n\n  CAST5 = require('./openpgp/cast5').CAST5;\n\n  SlicerBuffer = require('./openpgp/buffer').SlicerBuffer;\n\n  WordArray = triplesec.WordArray;\n\n  uint_to_buffer = require('./util').uint_to_buffer;\n\n  ecc_pkcs5_unpad_data = require('./pad').ecc_pkcs5_unpad_data;\n\n  exports.get_cipher = get_cipher = function(n) {\n    var ret;\n    n || (n = C.AES256);\n    ret = (function() {\n      switch (n) {\n        case C.AES128:\n          return {\n            klass: AES,\n            key_size: 16\n          };\n        case C.AES192:\n          return {\n            klass: AES,\n            key_size: 24\n          };\n        case C.AES256:\n          return {\n            klass: AES,\n            key_size: 32\n          };\n        case C.CAST5:\n          return {\n            klass: CAST5,\n            key_size: CAST5.keySize\n          };\n        default:\n          throw new Error(\"unknown cipher: \" + n);\n      }\n    })();\n    ret.type = n;\n    return ret;\n  };\n\n  exports.checksum2 = checksum2 = function(buf) {\n    var i, res, _i, _ref;\n    res = 0;\n    for (i = _i = 0, _ref = buf.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n      res = (res + buf.readUInt8(i)) & 0xffff;\n    }\n    return res;\n  };\n\n  exports.import_key_pgp = import_key_pgp = function(msg, pkcs5_padding) {\n    var checksum, cipher, err, key, ret, sb;\n    if (pkcs5_padding == null) {\n      pkcs5_padding = false;\n    }\n    sb = new SlicerBuffer(msg);\n    ret = err = null;\n    cipher = get_cipher(sb.read_uint8());\n    key = sb.read_buffer(cipher.key_size);\n    checksum = sb.read_uint16();\n    err = checksum2(key) !== checksum ? new Error(\"Checksum mismatch\") : pkcs5_padding ? ecc_pkcs5_unpad_data(msg, sb.offset()) : !sb.rem() ? null : new Error(\"Junk at the end of input\");\n    if (err != null) {\n\n      console.error(`********* import_key_pgp error. 'msg' is as follows:`);\n      console.dir(msg);\n\n      throw err;\n    }\n    return new cipher.klass(WordArray.from_buffer(key));\n  };\n\n  exports.export_key_pgp = export_key_pgp = function(algo_id, key) {\n    var csum;\n    csum = checksum2(key);\n    return Buffer.concat([new Buffer([algo_id]), key, uint_to_buffer(16, csum)]);\n  };\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./const\":5,\"./openpgp/buffer\":35,\"./openpgp/cast5\":37,\"./pad\":62,\"./util\":70,\"buffer\":80,\"triplesec\":181}],69:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var iced, kb, pgp, __iced_k, __iced_k_noop;\n\n  iced = require('iced-runtime').iced;\n  __iced_k = __iced_k_noop = function() {};\n\n  pgp = require('./openpgp/keymanager');\n\n  kb = require('./keybase/hilev');\n\n  exports.import_armored_public = function(_arg, cb) {\n    var armored, asp, err, ret, warnings, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    armored = _arg.armored, asp = _arg.asp;\n    (function(_this) {\n      return (function(__iced_k) {\n        if (armored.match(/^-{5}BEGIN PGP PUBLIC KEY BLOCK-{5}/)) {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/ukm.iced\",\n              funcname: \"import_armored_public\"\n            });\n            pgp.KeyManager.import_from_armored_pgp({\n              armored: armored,\n              asp: asp\n            }, __iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  err = arguments[0];\n                  ret = arguments[1];\n                  return warnings = arguments[2];\n                };\n              })(),\n              lineno: 10\n            }));\n            __iced_deferrals._fulfill();\n          })(__iced_k);\n        } else {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/ukm.iced\",\n              funcname: \"import_armored_public\"\n            });\n            kb.KeyManager.import_public({\n              hex: armored\n            }, __iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  err = arguments[0];\n                  return ret = arguments[1];\n                };\n              })(),\n              lineno: 12\n            }));\n            __iced_deferrals._fulfill();\n          })(__iced_k);\n        }\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(err, ret);\n      };\n    })(this));\n  };\n\n}).call(this);\n\n},{\"./keybase/hilev\":17,\"./openpgp/keymanager\":42,\"iced-runtime\":118}],70:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var k, m, mods, v, _i, _len;\n\n  mods = [require(\"pgp-utils\").util, require(\"./openpgp/util\"), require(\"./keybase/util\")];\n\n  for (_i = 0, _len = mods.length; _i < _len; _i++) {\n    m = mods[_i];\n    for (k in m) {\n      v = m[k];\n      exports[k] = v;\n    }\n  }\n\n}).call(this);\n\n},{\"./keybase/util\":23,\"./openpgp/util\":60,\"pgp-utils\":163}],71:[function(require,module,exports){\n\nvar engine = require('./lib/wrap').engine;\nif (!engine) {\n  syms = require(\"./lib/pure\");\n} else {\n  syms = require(\"./lib/fast\");\n}\n\nfor (var k in syms) {\n  exports[k] = syms[k];\n}\n\n},{\"./lib/fast\":72,\"./lib/pure\":73,\"./lib/wrap\":74}],72:[function(require,module,exports){\n(function (Buffer){\n(function (){\n\n  var bigint = require(\"./wrap\").engine;\n  var zed = bigint(0);\n  var one = bigint(1);\n\n  function BigInteger (a,b) {\n        if (!(this instanceof BigInteger))\n            return new BigInteger(a,b);\n    if (typeof(a) == 'string') {\n      // Filter out any empty spaces.\n      a = a.replace(/\\s+/g,'');\n      if (!b) { b = 10; }\n      this._v = bigint(a,b);\n    } else if (typeof(a) == 'number') {\n      this._v = bigint(a);\n    } else if (typeof(a) == 'object' && Array.isArray(a)) {\n      this._v = bigint.fromBuffer(new Buffer(a));\n    } else if (a.constructor != zed.constructor) {\n      throw new Error(\"failed to get valid inner object in constructor\");\n    } else {\n      this._v = a;\n    }\n  };\n\n  function nbi() { return new BigInteger(bigint(0)); }\n  function nbv(i) { return new BigInteger(bigint(i)); }\n\n  function bigint_or_number(x) {\n    if (typeof(x) === 'number') { return nbv(x); }\n    else { return x; }\n  };\n\n  function buffer_to_array (b) {\n    var ret = new Array();\n    for (var i = 0; i < b.length; i++) {\n      ret[i] = b.readUInt8(i);\n    }\n    return ret;\n  };\n\n  BigInteger.prototype.bitLength = function () {\n    var ret;\n    if (this.signum() == 0) { ret = 0; }\n    else { ret = this._v.bitLength(); }\n    return ret;\n  };\n\n  BigInteger.prototype.byteLength = function () { return (this.bitLength() >> 3); }\n\n  BigInteger.prototype.modPowInt = function (i,n) {\n    return new BigInteger(this._v.powm(bigint(i),n._v));\n  };\n\n  BigInteger.prototype.modInt = function (i) {\n    return this._v.mod(bigint(i)).toNumber();\n  };\n\n  BigInteger.prototype.testBit = function (i) {\n    var bi = one.shiftLeft(i);\n    var tmp = this._v.and(bi);\n    var ret = tmp.eq(zed) ? 0 : 1;\n    return ret;\n  };\n\n  BigInteger.prototype.setBit = function (i) {\n    var mask = bigint(1).shiftLeft(i);\n    return new BigInteger(this._v.or(mask));\n  };\n\n  BigInteger.prototype.shiftLeft = function (i) {\n    return new BigInteger(this._v.shiftLeft(i));\n  };\n\n  BigInteger.prototype.shiftRight = function (i) {\n    return new BigInteger(this._v.shiftRight(i));\n  };\n\n  BigInteger.prototype.compareTo = function (b) {\n    return this._v.cmp(b._v);\n  };\n\n  BigInteger.prototype.modPow = function (e, n) {\n    return new BigInteger(this._v.powm(e._v, n._v));\n  };\n\n  BigInteger.prototype.square = function() {\n    return new BigInteger(this._v.mul(this._v));\n  };\n\n  BigInteger.prototype.mod = function (m) {\n    var x = this._v.mod(m._v);\n\n    // BigNum (and not BigInt) allows for mod outcome to be < 0\n    if (x.cmp(zed) < 0) {\n      x = x.add(m._v);\n    }\n    return new BigInteger(x);\n  };\n\n  BigInteger.prototype.abs = function () {\n    return new BigInteger(this._v.abs());\n  };\n\n  BigInteger.prototype.pow = function (e) {\n    return new BigInteger(this._v.pow(bigint_or_number(e)._v));\n  };\n\n  BigInteger.prototype.intValue = function () {\n    return this._v.toNumber();\n  };\n\n  BigInteger.prototype.signum = function () {\n    var cmp = this._v.cmp(zed);\n    if (cmp > 0) { ret = 1; }\n    else if (cmp === 0) { ret = 0; }\n    else { ret = -1; }\n    return ret;\n  };\n\n  BigInteger.prototype.negate = function () {\n    return new BigInteger(this._v.neg());\n  };\n\n  BigInteger.prototype.equals = function (b) {\n    return this._v.eq(b._v);\n  };\n\n  BigInteger.prototype.subtract = function (x) {\n    return new BigInteger(this._v.sub(x._v));\n  };\n\n  BigInteger.prototype.add = function(x) {\n    return new BigInteger(this._v.add(x._v));\n  };\n\n  BigInteger.prototype.multiply = function (x) {\n    return new BigInteger(this._v.mul(x._v));\n  };\n\n  BigInteger.prototype.divide = function (x) {\n    if (this._v.ge(zed) && x._v.ge(zed)) {\n      i = this._v.div(x._v);\n    } else {\n      var sign = this.signum() * x.signum();\n      i = this._v.abs().div(x._v.abs());\n      if (sign < 0) { i = i.neg(); }\n    }\n    return new BigInteger(i);\n  };\n\n  BigInteger.prototype.gcd = function (x) {\n    return new BigInteger(this._v.gcd(x._v));\n  };\n\n  BigInteger.prototype.fromBuffer = function (x) {\n    return new BigInteger(bigint.fromBuffer(x));\n  };\n\n  BigInteger.fromByteArrayUnsigned = function (b) {\n    return BigInteger.fromBuffer(new Buffer(b));\n  };\n\n  BigInteger.fromBuffer = function (x) {\n    return new BigInteger(bigint.fromBuffer(x));\n  };\n\n  BigInteger.fromDERInteger = function (buf) {\n    var ret;\n    if (buf.length == 0) { ret = BigInteger.ZERO; }\n    else if (buf[0] == 0) { ret = BigInteger.fromBuffer(buf); }\n    else {\n      ret = BigInteger.fromBuffer(buf);\n      if (buf[0] & 0x80) {\n        var z = BigInteger.ONE.shiftLeft(ret.bitLength())\n        ret = ret.subtract(z);\n      }\n    }\n    return ret;\n  };\n\n  BigInteger.prototype.compute_twos_complement = function () {\n    // Compute 2's complement: 2^n - this\n    // What should n be?  It should be rounded up to the next byte...\n    // So keep in mind that -128 is encoded 0x80.  So it matters how\n    // many bits (this+1) takes up.\n    var l = this.add(BigInteger.ONE).bitLength();\n    var bytes = Math.floor(l/8) + 1;\n    var y = BigInteger.ONE.shiftLeft(bytes*8);\n\n    // Compute the 2's-complement of this, which is 2^l - |this|.\n    return y.add(this);\n  };\n\n  BigInteger.prototype.toDERInteger = function () {\n    var ret = null;\n    var s = this.signum();\n\n    if (s == 0) { ret = new Buffer([0]); }\n    else if (s < 0) {\n      var z = this.compute_twos_complement();\n      ret = z.toBuffer();\n    } else {\n\n      var ret = this.toBuffer();\n\n      // If the high bit is on, and we're unsigned, we have to prepend a \\x00\n      // byte to show that we're positive.\n      if (this.bitLength() % 8 == 0) {\n        pad = new Buffer([0]);\n        ret = Buffer.concat([ pad, ret ]);\n      }\n    }\n    return buffer_to_array(ret);\n  };\n\n  BigInteger.prototype.divideAndRemainder = function (m) {\n    var q = new BigInteger(this._v.div(m._v));\n    var r = new BigInteger(this._v.mod(m._v));\n    return [q,r];\n  }\n\n  BigInteger.fromString = function (s, base) {\n    // Ignore the current object, that's cool....\n    var bi;\n    if (base === 256) {\n      bi = bigint.fromBuffer(s);\n    } else {\n      bi = bigint(s, base);\n    }\n    return new BigInteger(bi);\n  };\n\n  BigInteger.prototype.fromString = function (s, base) {\n    return BigInteger.fromString(s, base);\n  };\n\n  BigInteger.prototype.toByteArray = function () {\n    var b = this.toBuffer();\n    var l = b.length;\n    var ret = new Array(l);\n    for (var i = 0; i < l; i++) {\n      ret[i] = b[i];\n    }\n    return ret;\n  };\n\n  BigInteger.prototype.toByteArrayUnsigned = function () {\n    return new Uint8Array(this.toBuffer());\n  };\n\n  BigInteger.prototype.toBuffer = function (size) {\n    var ret = null;\n    if (!size) { size = 0; }\n    if (this.signum() == 0) { ret = new Buffer([]); }\n    else { ret = this._v.toBuffer(); }\n    if ((diff = size - ret.length) > 0) {\n      var pad = new Buffer(diff);\n      pad.fill(0);\n      ret = Buffer.concat([pad, ret]);\n    }\n    return ret;\n  };\n\n  BigInteger.prototype.toHex = function(size) {\n    var x = this;\n    if (this.signum() < 0) {\n      x = this.compute_twos_complement();\n    }\n    return x.toBuffer(size).toString('hex');\n  };\n\n  BigInteger.prototype.clone = function () {\n    return new BigInteger(bigint(this._v));\n  };\n\n  BigInteger.prototype.getLowestSetBit = function () {\n    var bl = this._v.bitLength();\n    var ret = -1;\n    var mask = bigint(1);\n    for (var i = 0; i < bl && ret < 0; i++) {\n      if (!mask.and(this._v).eq(zed)) {\n        ret = i;\n      } else {\n        mask = mask.shiftLeft(1);\n      }\n    }\n    return ret;\n  };\n\n  BigInteger.prototype.modInverse = function (n) {\n    return new BigInteger(this._v.invertm(n._v));\n  };\n\n  BigInteger.prototype.isEven = function () {\n    var mask = bigint(1);\n    var res = mask.and(this._v);\n    return res.eq(zed);\n  };\n\n  // returns bit length of the integer x. stolen from\n  // elsewhere is jsbn.\n  function nbits(x) {\n      var r = 1, t;\n      if((t=x>>>16) != 0) { x = t; r += 16; }\n      if((t=x>>8) != 0) { x = t; r += 8; }\n      if((t=x>>4) != 0) { x = t; r += 4; }\n      if((t=x>>2) != 0) { x = t; r += 2; }\n      if((t=x>>1) != 0) { x = t; r += 1; }\n      return r;\n  };\n\n  BigInteger.random_nbit = function (nbits, rf) {\n    var nbytes = Math.ceil(nbits / 8);\n    var buf = new Buffer(nbytes);\n    rf.nextBytes(buf);\n    var ret = bigint.fromBuffer(buf);\n    var mask = bigint(1).shiftLeft(nbits).sub(bigint(1));\n    ret = ret.and(mask);\n    return new BigInteger(ret);\n  };\n\n  BigInteger.fromHex = function (s) {\n    if (!s.match(/^[a-fA-F0-9]*$/)) { throw new Error(\"hex string invalid: \"+ s); }\n    if (s.length % 2 != 0) { throw new Error(\"got an odd-length hex-string\"); }\n    return new BigInteger(s, 16);\n  };\n\n  BigInteger.prototype.inspect = function () {\n    return \"<BigInteger/fast \" + this._v.toString() + \">\";\n  };\n\n  BigInteger.prototype.toString = function (base) {\n    if (!base) { base = 10; }\n    var raw = this._v.toString(base);\n    if (raw.length == 0) {\n      raw = \"0\";\n    } else if (base == 16 && raw.length > 1) {\n      if (raw[0] == \"0\") {\n        raw = raw.slice(1);\n      } else if (raw.slice(0,2) == \"-0\") {\n        raw = \"-\" + raw.slice(2);\n      }\n    }\n    return raw;\n  };\n\n  BigInteger.valueOf = function (x) {\n    return bigint_or_number(x);\n  };\n\n  BigInteger.ZERO = nbv(0);\n  BigInteger.ONE = nbv(1);\n\n  module.exports = {\n    BigInteger : BigInteger,\n    nbi : nbi,\n    nbv : nbv,\n    nbits : nbits\n  };\n\n})(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./wrap\":74,\"buffer\":80}],73:[function(require,module,exports){\n(function (Buffer){\n(function (){\n\n   /*\n    * Copyright (c) 2003-2005  Tom Wu (tjw@cs.Stanford.EDU)\n    * All Rights Reserved.\n    *\n    * Modified by Recurity Labs GmbH\n    *\n    * Permission is hereby granted, free of charge, to any person obtaining\n    * a copy of this software and associated documentation files (the\n    * \"Software\"), to deal in the Software without restriction, including\n    * without limitation the rights to use, copy, modify, merge, publish,\n    * distribute, sublicense, and/or sell copies of the Software, and to\n    * permit persons to whom the Software is furnished to do so, subject to\n    * the following conditions:\n    *\n    * The above copyright notice and this permission notice shall be\n    * included in all copies or substantial portions of the Software.\n    *\n    * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND,\n    * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY\n    * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n    *\n    * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,\n    * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER\n    * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF\n    * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT\n    * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n    *\n    * In addition, the following condition applies:\n    *\n    * All redistributions must retain an intact copy of this copyright notice\n    * and disclaimer.\n    */\n\n   // Basic JavaScript BN library - subset useful for RSA encryption.\n\n   // Bits per digit\n   var dbits;\n\n   // JavaScript engine analysis\n   var canary = 0xdeadbeefcafe;\n   var j_lm = ((canary&0xffffff)==0xefcafe);\n\n   // (public) Constructor\n   function BigInteger(a,b,c) {\n     // bigi has this, so add it in...\n     if (!(this instanceof BigInteger))\n       return new BigInteger(a, b, c)\n     if(a != null)\n       if(\"number\" == typeof a) this.fromNumber(a,b,c);\n       else if(b == null && \"string\" != typeof a) this.fromString(a,256);\n       else this.fromString(a,b);\n   }\n\n   // return new, unset BigInteger\n   function nbi() { return new BigInteger(null); }\n\n   // am: Compute w_j += (x*this_i), propagate carries,\n   // c is initial carry, returns final carry.\n   // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n   // We need to select the fastest one that works in this environment.\n\n   // am1: use a single mult and divide to get the high bits,\n   // max digit bits should be 26 because\n   // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n   function am1(i,x,w,j,c,n) {\n     while(--n >= 0) {\n       var v = x*this[i++]+w[j]+c;\n       c = Math.floor(v/0x4000000);\n       w[j++] = v&0x3ffffff;\n     }\n     return c;\n   }\n   // am2 avoids a big mult-and-extract completely.\n   // Max digit bits should be <= 30 because we do bitwise ops\n   // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n   function am2(i,x,w,j,c,n) {\n     var xl = x&0x7fff, xh = x>>15;\n     while(--n >= 0) {\n       var l = this[i]&0x7fff;\n       var h = this[i++]>>15;\n       var m = xh*l+h*xl;\n       l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);\n       c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\n       w[j++] = l&0x3fffffff;\n     }\n     return c;\n   }\n   // Alternately, set max digit bits to 28 since some\n   // browsers slow down when dealing with 32-bit numbers.\n   function am3(i,x,w,j,c,n) {\n     var xl = x&0x3fff, xh = x>>14;\n     while(--n >= 0) {\n       var l = this[i]&0x3fff;\n       var h = this[i++]>>14;\n       var m = xh*l+h*xl;\n       l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n       c = (l>>28)+(m>>14)+xh*h;\n       w[j++] = l&0xfffffff;\n     }\n     return c;\n   }\n\n   // Chrome seems to prefer this...\n   BigInteger.prototype.am = am3;\n   dbits = 28;\n\n   BigInteger.prototype.DB = dbits;\n   BigInteger.prototype.DM = ((1<<dbits)-1);\n   BigInteger.prototype.DV = (1<<dbits);\n\n   var BI_FP = 52;\n   BigInteger.prototype.FV = Math.pow(2,BI_FP);\n   BigInteger.prototype.F1 = BI_FP-dbits;\n   BigInteger.prototype.F2 = 2*dbits-BI_FP;\n\n   // Digit conversions\n   var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n   var BI_RC = new Array();\n   var rr,vv;\n   rr = \"0\".charCodeAt(0);\n   for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n   rr = \"a\".charCodeAt(0);\n   for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n   rr = \"A\".charCodeAt(0);\n   for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n   function int2char(n) { return BI_RM.charAt(n); }\n   function intAt(s,i) {\n     var c = BI_RC[s.charCodeAt(i)];\n     return (c==null)?-1:c;\n   }\n\n   // (protected) copy this to r\n   function bnpCopyTo(r) {\n     for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n     r.t = this.t;\n     r.s = this.s;\n   }\n\n   // (protected) set from integer value x, -DV <= x < DV\n   function bnpFromInt(x) {\n     this.t = 1;\n     this.s = (x<0)?-1:0;\n     if(x > 0) this[0] = x;\n     else if(x < -1) this[0] = x+this.DV;\n     else this.t = 0;\n   }\n\n   // return bigint initialized to value\n   function nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n   // (protected) set from string and radix\n   function bnpFromString(s,b,unsigned) {\n     var k;\n     if(b == 16) k = 4;\n     else if(b == 8) k = 3;\n     else if(b == 256) k = 8; // byte array\n     else if(b == 2) k = 1;\n     else if(b == 32) k = 5;\n     else if(b == 4) k = 2;\n     else { this.fromRadix(s,b); return this; }\n     this.t = 0;\n     this.s = 0;\n     var i = s.length, mi = false, sh = 0;\n     while(--i >= 0) {\n       var x = (k==8)?s[i]&0xff:intAt(s,i);\n       if(x < 0) {\n         if(s.charAt(i) == \"-\") mi = true;\n         continue;\n       }\n       mi = false;\n       if(sh == 0)\n         this[this.t++] = x;\n       else if(sh+k > this.DB) {\n         this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n         this[this.t++] = (x>>(this.DB-sh));\n       }\n       else\n         this[this.t-1] |= x<<sh;\n       sh += k;\n       if(sh >= this.DB) sh -= this.DB;\n     }\n     if(!unsigned && k == 8 && (s[0]&0x80) != 0) {\n       this.s = -1;\n       if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n     }\n     this.clamp();\n     if(mi) BigInteger.ZERO.subTo(this,this);\n     return this;\n   }\n\n   // (protected) clamp off excess high words\n   function bnpClamp() {\n     var c = this.s&this.DM;\n     while(this.t > 0 && this[this.t-1] == c) --this.t;\n   }\n\n   // (public) return string representation in given radix\n   function bnToString(b) {\n     if(this.s < 0) return \"-\"+this.negate().toString(b);\n     var k;\n     if(b == 16) k = 4;\n     else if(b == 8) k = 3;\n     else if(b == 2) k = 1;\n     else if(b == 32) k = 5;\n     else if(b == 4) k = 2;\n     else return this.toRadix(b);\n     var km = (1<<k)-1, d, m = false, r = \"\", i = this.t;\n     var p = this.DB-(i*this.DB)%k;\n     if(i-- > 0) {\n       if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\n       while(i >= 0) {\n         if(p < k) {\n           d = (this[i]&((1<<p)-1))<<(k-p);\n           d |= this[--i]>>(p+=this.DB-k);\n         }\n         else {\n           d = (this[i]>>(p-=k))&km;\n           if(p <= 0) { p += this.DB; --i; }\n         }\n         if(d > 0) m = true;\n         if(m) r += int2char(d);\n       }\n     }\n     return m?r:\"0\";\n   }\n\n   // (public) -this\n   function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\n   // (public) |this|\n   function bnAbs() { return (this.s<0)?this.negate():this; }\n\n   // (public) return + if this > a, - if this < a, 0 if equal\n   function bnCompareTo(a) {\n     var r = this.s-a.s;\n     if(r != 0) return r;\n     var i = this.t;\n     r = i-a.t;\n     if(r != 0) return r;\n     while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n     return 0;\n   }\n\n   // returns bit length of the integer x\n   function nbits(x) {\n     var r = 1, t;\n     if((t=x>>>16) != 0) { x = t; r += 16; }\n     if((t=x>>8) != 0) { x = t; r += 8; }\n     if((t=x>>4) != 0) { x = t; r += 4; }\n     if((t=x>>2) != 0) { x = t; r += 2; }\n     if((t=x>>1) != 0) { x = t; r += 1; }\n     return r;\n   }\n\n   // (public) return the number of bits in \"this\"\n   function bnBitLength() {\n     if(this.t <= 0) return 0;\n     return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n   }\n\n   // (protected) r = this << n*DB\n   function bnpDLShiftTo(n,r) {\n     var i;\n     for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n     for(i = n-1; i >= 0; --i) r[i] = 0;\n     r.t = this.t+n;\n     r.s = this.s;\n   }\n\n   // (protected) r = this >> n*DB\n   function bnpDRShiftTo(n,r) {\n     for(var i = n; i < this.t; ++i) r[i-n] = this[i];\n     r.t = Math.max(this.t-n,0);\n     r.s = this.s;\n   }\n\n   // (protected) r = this << n\n   function bnpLShiftTo(n,r) {\n     var bs = n%this.DB;\n     var cbs = this.DB-bs;\n     var bm = (1<<cbs)-1;\n     var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n     for(i = this.t-1; i >= 0; --i) {\n       r[i+ds+1] = (this[i]>>cbs)|c;\n       c = (this[i]&bm)<<bs;\n     }\n     for(i = ds-1; i >= 0; --i) r[i] = 0;\n     r[ds] = c;\n     r.t = this.t+ds+1;\n     r.s = this.s;\n     r.clamp();\n   }\n\n   // (protected) r = this >> n\n   function bnpRShiftTo(n,r) {\n     r.s = this.s;\n     var ds = Math.floor(n/this.DB);\n     if(ds >= this.t) { r.t = 0; return; }\n     var bs = n%this.DB;\n     var cbs = this.DB-bs;\n     var bm = (1<<bs)-1;\n     r[0] = this[ds]>>bs;\n     for(var i = ds+1; i < this.t; ++i) {\n       r[i-ds-1] |= (this[i]&bm)<<cbs;\n       r[i-ds] = this[i]>>bs;\n     }\n     if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n     r.t = this.t-ds;\n     r.clamp();\n   }\n\n   // (protected) r = this - a\n   function bnpSubTo(a,r) {\n     var i = 0, c = 0, m = Math.min(a.t,this.t);\n     while(i < m) {\n       c += this[i]-a[i];\n       r[i++] = c&this.DM;\n       c >>= this.DB;\n     }\n     if(a.t < this.t) {\n       c -= a.s;\n       while(i < this.t) {\n         c += this[i];\n         r[i++] = c&this.DM;\n         c >>= this.DB;\n       }\n       c += this.s;\n     }\n     else {\n       c += this.s;\n       while(i < a.t) {\n         c -= a[i];\n         r[i++] = c&this.DM;\n         c >>= this.DB;\n       }\n       c -= a.s;\n     }\n     r.s = (c<0)?-1:0;\n     if(c < -1) r[i++] = this.DV+c;\n     else if(c > 0) r[i++] = c;\n     r.t = i;\n     r.clamp();\n   }\n\n   // (protected) r = this * a, r != this,a (HAC 14.12)\n   // \"this\" should be the larger one if appropriate.\n   function bnpMultiplyTo(a,r) {\n     var x = this.abs(), y = a.abs();\n     var i = x.t;\n     r.t = i+y.t;\n     while(--i >= 0) r[i] = 0;\n     for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n     r.s = 0;\n     r.clamp();\n     if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n   }\n\n   // (protected) r = this^2, r != this (HAC 14.16)\n   function bnpSquareTo(r) {\n     var x = this.abs();\n     var i = r.t = 2*x.t;\n     while(--i >= 0) r[i] = 0;\n     for(i = 0; i < x.t-1; ++i) {\n       var c = x.am(i,x[i],r,2*i,0,1);\n       if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n         r[i+x.t] -= x.DV;\n         r[i+x.t+1] = 1;\n       }\n     }\n     if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n     r.s = 0;\n     r.clamp();\n   }\n\n   // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n   // r != q, this != m.  q or r may be null.\n   function bnpDivRemTo(m,q,r) {\n     var pm = m.abs();\n     if(pm.t <= 0) return;\n     var pt = this.abs();\n     if(pt.t < pm.t) {\n       if(q != null) q.fromInt(0);\n       if(r != null) this.copyTo(r);\n       return;\n     }\n     if(r == null) r = nbi();\n     var y = nbi(), ts = this.s, ms = m.s;\n     var nsh = this.DB-nbits(pm[pm.t-1]); // normalize modulus\n     if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n     else { pm.copyTo(y); pt.copyTo(r); }\n     var ys = y.t;\n     var y0 = y[ys-1];\n     if(y0 == 0) return;\n     var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n     var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n     var i = r.t, j = i-ys, t = (q==null)?nbi():q;\n     y.dlShiftTo(j,t);\n     if(r.compareTo(t) >= 0) {\n       r[r.t++] = 1;\n       r.subTo(t,r);\n     }\n     BigInteger.ONE.dlShiftTo(ys,t);\n     t.subTo(y,y);  // \"negative\" y so we can replace sub with am later\n     while(y.t < ys) y[y.t++] = 0;\n     while(--j >= 0) {\n       // Estimate quotient digit\n       var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n       if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) { // Try it out\n         y.dlShiftTo(j,t);\n         r.subTo(t,r);\n         while(r[i] < --qd) r.subTo(t,r);\n       }\n     }\n     if(q != null) {\n       r.drShiftTo(ys,q);\n       if(ts != ms) BigInteger.ZERO.subTo(q,q);\n     }\n     r.t = ys;\n     r.clamp();\n     if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder\n     if(ts < 0) BigInteger.ZERO.subTo(r,r);\n   }\n\n   // (public) this mod a\n   function bnMod(a) {\n     var r = nbi();\n     this.abs().divRemTo(a,null,r);\n     if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n     return r;\n   }\n\n   // Modular reduction using \"classic\" algorithm\n   function Classic(m) { this.m = m; }\n   function cConvert(x) {\n     if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n     else return x;\n   }\n   function cRevert(x) { return x; }\n   function cReduce(x) { x.divRemTo(this.m,null,x); }\n   function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n   function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n   Classic.prototype.convert = cConvert;\n   Classic.prototype.revert = cRevert;\n   Classic.prototype.reduce = cReduce;\n   Classic.prototype.mulTo = cMulTo;\n   Classic.prototype.sqrTo = cSqrTo;\n\n   // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n   // justification:\n   //         xy == 1 (mod m)\n   //         xy =  1+km\n   //   xy(2-xy) = (1+km)(1-km)\n   // x[y(2-xy)] = 1-k^2m^2\n   // x[y(2-xy)] == 1 (mod m^2)\n   // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n   // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n   // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n   function bnpInvDigit() {\n     if(this.t < 1) return 0;\n     var x = this[0];\n     if((x&1) == 0) return 0;\n     var y = x&3;   // y == 1/x mod 2^2\n     y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4\n     y = (y*(2-(x&0xff)*y))&0xff; // y == 1/x mod 2^8\n     y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;  // y == 1/x mod 2^16\n     // last step - calculate inverse mod DV directly;\n     // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n     y = (y*(2-x*y%this.DV))%this.DV;   // y == 1/x mod 2^dbits\n     // we really want the negative inverse, and -DV < y < DV\n     return (y>0)?this.DV-y:-y;\n   }\n\n   // Montgomery reduction\n   function Montgomery(m) {\n     this.m = m;\n     this.mp = m.invDigit();\n     this.mpl = this.mp&0x7fff;\n     this.mph = this.mp>>15;\n     this.um = (1<<(m.DB-15))-1;\n     this.mt2 = 2*m.t;\n   }\n\n   // xR mod m\n   function montConvert(x) {\n     var r = nbi();\n     x.abs().dlShiftTo(this.m.t,r);\n     r.divRemTo(this.m,null,r);\n     if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n     return r;\n   }\n\n   // x/R mod m\n   function montRevert(x) {\n     var r = nbi();\n     x.copyTo(r);\n     this.reduce(r);\n     return r;\n   }\n\n   // x = x/R mod m (HAC 14.32)\n   function montReduce(x) {\n     while(x.t <= this.mt2) // pad x so am has enough room later\n       x[x.t++] = 0;\n     for(var i = 0; i < this.m.t; ++i) {\n       // faster way of calculating u0 = x[i]*mp mod DV\n       var j = x[i]&0x7fff;\n       var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n       // use am to combine the multiply-shift-add into one call\n       j = i+this.m.t;\n       x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n       // propagate carry\n       while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n     }\n     x.clamp();\n     x.drShiftTo(this.m.t,x);\n     if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n   }\n\n   // r = \"x^2/R mod m\"; x != r\n   function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n   // r = \"xy/R mod m\"; x,y != r\n   function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\n   Montgomery.prototype.convert = montConvert;\n   Montgomery.prototype.revert = montRevert;\n   Montgomery.prototype.reduce = montReduce;\n   Montgomery.prototype.mulTo = montMulTo;\n   Montgomery.prototype.sqrTo = montSqrTo;\n\n   // (protected) true iff this is even\n   function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\n   // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n   function bnpExp(e,z) {\n     if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n     var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n     g.copyTo(r);\n     while(--i >= 0) {\n       z.sqrTo(r,r2);\n       if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n       else { var t = r; r = r2; r2 = t; }\n     }\n     return z.revert(r);\n   }\n\n   // (public) this^e % m, 0 <= e < 2^32\n   function bnModPowInt(e,m) {\n     var z;\n     if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n     return this.exp(e,z);\n   }\n\n   // protected\n   BigInteger.prototype.copyTo = bnpCopyTo;\n   BigInteger.prototype.fromInt = bnpFromInt;\n   BigInteger.prototype.fromString = bnpFromString;\n   BigInteger.prototype.clamp = bnpClamp;\n   BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n   BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n   BigInteger.prototype.lShiftTo = bnpLShiftTo;\n   BigInteger.prototype.rShiftTo = bnpRShiftTo;\n   BigInteger.prototype.subTo = bnpSubTo;\n   BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n   BigInteger.prototype.squareTo = bnpSquareTo;\n   BigInteger.prototype.divRemTo = bnpDivRemTo;\n   BigInteger.prototype.invDigit = bnpInvDigit;\n   BigInteger.prototype.isEven = bnpIsEven;\n   BigInteger.prototype.exp = bnpExp;\n\n   // public\n   BigInteger.prototype.toString = bnToString;\n   BigInteger.prototype.negate = bnNegate;\n   BigInteger.prototype.abs = bnAbs;\n   BigInteger.prototype.compareTo = bnCompareTo;\n   BigInteger.prototype.bitLength = bnBitLength;\n   BigInteger.prototype.mod = bnMod;\n   BigInteger.prototype.modPowInt = bnModPowInt;\n\n   // \"constants\"\n   BigInteger.ZERO = nbv(0);\n   BigInteger.ONE = nbv(1);\n\n   /*\n    * Copyright (c) 2003-2005  Tom Wu (tjw@cs.Stanford.EDU)\n    * All Rights Reserved.\n    *\n    * Modified by Recurity Labs GmbH\n    *\n    * Permission is hereby granted, free of charge, to any person obtaining\n    * a copy of this software and associated documentation files (the\n    * \"Software\"), to deal in the Software without restriction, including\n    * without limitation the rights to use, copy, modify, merge, publish,\n    * distribute, sublicense, and/or sell copies of the Software, and to\n    * permit persons to whom the Software is furnished to do so, subject to\n    * the following conditions:\n    *\n    * The above copyright notice and this permission notice shall be\n    * included in all copies or substantial portions of the Software.\n    *\n    * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND,\n    * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY\n    * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n    *\n    * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,\n    * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER\n    * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF\n    * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT\n    * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n    *\n    * In addition, the following condition applies:\n    *\n    * All redistributions must retain an intact copy of this copyright notice\n    * and disclaimer.\n    */\n   // Extended JavaScript BN functions, required for RSA private ops.\n\n   // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n   // Version 1.2: square() API, isProbablePrime fix\n\n   // (public)\n   function bnClone() { var r = nbi(); this.copyTo(r); return r; }\n\n   // (public) return value as integer\n   function bnIntValue() {\n     if(this.s < 0) {\n       if(this.t == 1) return this[0]-this.DV;\n       else if(this.t == 0) return -1;\n     }\n     else if(this.t == 1) return this[0];\n     else if(this.t == 0) return 0;\n     // assumes 16 < DB < 32\n     return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];\n   }\n\n   // (public) return value as byte\n   function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }\n\n   // (public) return value as short (assumes DB>=16)\n   function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }\n\n   // (protected) return x s.t. r^x < DV\n   function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\n\n   // (public) 0 if this == 0, 1 if this > 0\n   function bnSigNum() {\n     if(this.s < 0) return -1;\n     else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n     else return 1;\n   }\n\n   // (protected) convert to radix string\n   function bnpToRadix(b) {\n     if(b == null) b = 10;\n     if(this.signum() == 0 || b < 2 || b > 36) return \"0\";\n     var cs = this.chunkSize(b);\n     var a = Math.pow(b,cs);\n     var d = nbv(a), y = nbi(), z = nbi(), r = \"\";\n     this.divRemTo(d,y,z);\n     while(y.signum() > 0) {\n       r = (a+z.intValue()).toString(b).substr(1) + r;\n       y.divRemTo(d,y,z);\n     }\n     return z.intValue().toString(b) + r;\n   }\n\n   // (protected) convert from radix string\n   function bnpFromRadix(s,b) {\n     this.fromInt(0);\n     if(b == null) b = 10;\n     var cs = this.chunkSize(b);\n     var d = Math.pow(b,cs), mi = false, j = 0, w = 0;\n     for(var i = 0; i < s.length; ++i) {\n       var x = intAt(s,i);\n       if(x < 0) {\n         if(s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n         continue;\n       }\n       w = b*w+x;\n       if(++j >= cs) {\n         this.dMultiply(d);\n         this.dAddOffset(w,0);\n         j = 0;\n         w = 0;\n       }\n     }\n     if(j > 0) {\n       this.dMultiply(Math.pow(b,j));\n       this.dAddOffset(w,0);\n     }\n     if(mi) BigInteger.ZERO.subTo(this,this);\n   }\n\n   // (protected) alternate constructor\n   function bnpFromNumber(a,b,c) {\n     if(\"number\" == typeof b) {\n       // new BigInteger(int,int,RNG)\n       if(a < 2) this.fromInt(1);\n       else {\n         this.fromNumber(a,c);\n         if(!this.testBit(a-1)) // force MSB set\n           this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\n         if(this.isEven()) this.dAddOffset(1,0); // force odd\n         while(!this.isProbablePrime(b)) {\n           this.dAddOffset(2,0);\n           if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\n         }\n       }\n     }\n     else {\n       // new BigInteger(int,RNG)\n       var x = new Array(), t = a&7;\n       x.length = (a>>3)+1;\n       b.nextBytes(x);\n       if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\n       this.fromString(x,256);\n     }\n   }\n\n   // (public) convert to bigendian byte array\n   function bnToByteArray(encode_sign_bit) {\n     var i = this.t, r = new Array();\n     r[0] = this.s;\n     var p = this.DB-(i*this.DB)%8, d, k = 0;\n     if(i-- > 0) {\n       if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)\n         r[k++] = d|(this.s<<(this.DB-p));\n       while(i >= 0) {\n         if(p < 8) {\n           d = (this[i]&((1<<p)-1))<<(8-p);\n           d |= this[--i]>>(p+=this.DB-8);\n         }\n         else {\n           d = (this[i]>>(p-=8))&0xff;\n           if(p <= 0) { p += this.DB; --i; }\n         }\n         if (encode_sign_bit) {\n           if((d&0x80) != 0) d |= -256;\n           if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\n         }\n         if(k > 0 || d != this.s) r[k++] = d;\n       }\n     }\n     return r;\n   }\n\n   function bnEquals(a) { return(this.compareTo(a)==0); }\n   function bnMin(a) { return(this.compareTo(a)<0)?this:a; }\n   function bnMax(a) { return(this.compareTo(a)>0)?this:a; }\n\n   // (protected) r = this op a (bitwise)\n   function bnpBitwiseTo(a,op,r) {\n     var i, f, m = Math.min(a.t,this.t);\n     for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);\n     if(a.t < this.t) {\n       f = a.s&this.DM;\n       for(i = m; i < this.t; ++i) r[i] = op(this[i],f);\n       r.t = this.t;\n     }\n     else {\n       f = this.s&this.DM;\n       for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);\n       r.t = a.t;\n     }\n     r.s = op(this.s,a.s);\n     r.clamp();\n   }\n\n   // (public) this & a\n   function op_and(x,y) { return x&y; }\n   function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\n\n   // (public) this | a\n   function op_or(x,y) { return x|y; }\n   function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\n\n   // (public) this ^ a\n   function op_xor(x,y) { return x^y; }\n   function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\n\n   // (public) this & ~a\n   function op_andnot(x,y) { return x&~y; }\n   function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\n\n   // (public) ~this\n   function bnNot() {\n     var r = nbi();\n     for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];\n     r.t = this.t;\n     r.s = ~this.s;\n     return r;\n   }\n\n   // (public) this << n\n   function bnShiftLeft(n) {\n     var r = nbi();\n     if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\n     return r;\n   }\n\n   // (public) this >> n\n   function bnShiftRight(n) {\n     var r = nbi();\n     if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\n     return r;\n   }\n\n   // return index of lowest 1-bit in x, x < 2^31\n   function lbit(x) {\n     if(x == 0) return -1;\n     var r = 0;\n     if((x&0xffff) == 0) { x >>= 16; r += 16; }\n     if((x&0xff) == 0) { x >>= 8; r += 8; }\n     if((x&0xf) == 0) { x >>= 4; r += 4; }\n     if((x&3) == 0) { x >>= 2; r += 2; }\n     if((x&1) == 0) ++r;\n     return r;\n   }\n\n   // (public) returns index of lowest 1-bit (or -1 if none)\n   function bnGetLowestSetBit() {\n     for(var i = 0; i < this.t; ++i)\n       if(this[i] != 0) return i*this.DB+lbit(this[i]);\n     if(this.s < 0) return this.t*this.DB;\n     return -1;\n   }\n\n   // return number of 1 bits in x\n   function cbit(x) {\n     var r = 0;\n     while(x != 0) { x &= x-1; ++r; }\n     return r;\n   }\n\n   // (public) return number of set bits\n   function bnBitCount() {\n     var r = 0, x = this.s&this.DM;\n     for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);\n     return r;\n   }\n\n   // (public) true iff nth bit is set\n   function bnTestBit(n) {\n     var j = Math.floor(n/this.DB);\n     if(j >= this.t) return(this.s!=0);\n     return((this[j]&(1<<(n%this.DB)))!=0);\n   }\n\n   // (protected) this op (1<<n)\n   function bnpChangeBit(n,op) {\n     var r = BigInteger.ONE.shiftLeft(n);\n     this.bitwiseTo(r,op,r);\n     return r;\n   }\n\n   // (public) this | (1<<n)\n   function bnSetBit(n) { return this.changeBit(n,op_or); }\n\n   // (public) this & ~(1<<n)\n   function bnClearBit(n) { return this.changeBit(n,op_andnot); }\n\n   // (public) this ^ (1<<n)\n   function bnFlipBit(n) { return this.changeBit(n,op_xor); }\n\n   // (protected) r = this + a\n   function bnpAddTo(a,r) {\n     var i = 0, c = 0, m = Math.min(a.t,this.t);\n     while(i < m) {\n       c += this[i]+a[i];\n       r[i++] = c&this.DM;\n       c >>= this.DB;\n     }\n     if(a.t < this.t) {\n       c += a.s;\n       while(i < this.t) {\n         c += this[i];\n         r[i++] = c&this.DM;\n         c >>= this.DB;\n       }\n       c += this.s;\n     }\n     else {\n       c += this.s;\n       while(i < a.t) {\n         c += a[i];\n         r[i++] = c&this.DM;\n         c >>= this.DB;\n       }\n       c += a.s;\n     }\n     r.s = (c<0)?-1:0;\n     if(c > 0) r[i++] = c;\n     else if(c < -1) r[i++] = this.DV+c;\n     r.t = i;\n     r.clamp();\n   }\n\n   // (public) this + a\n   function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\n\n   // (public) this - a\n   function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\n\n   // (public) this * a\n   function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\n\n   // (public) this^2\n   function bnSquare() { var r = nbi(); this.squareTo(r); return r; }\n\n   // (public) this / a\n   function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\n\n   // (public) this % a\n   function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\n\n   // (public) [this/a,this%a]\n   function bnDivideAndRemainder(a) {\n     var q = nbi(), r = nbi();\n     this.divRemTo(a,q,r);\n     return new Array(q,r);\n   }\n\n   // (protected) this *= n, this >= 0, 1 < n < DV\n   function bnpDMultiply(n) {\n     this[this.t] = this.am(0,n-1,this,0,0,this.t);\n     ++this.t;\n     this.clamp();\n   }\n\n   // (protected) this += n << w words, this >= 0\n   function bnpDAddOffset(n,w) {\n     if(n == 0) return;\n     while(this.t <= w) this[this.t++] = 0;\n     this[w] += n;\n     while(this[w] >= this.DV) {\n       this[w] -= this.DV;\n       if(++w >= this.t) this[this.t++] = 0;\n       ++this[w];\n     }\n   }\n\n   // A \"null\" reducer\n   function NullExp() {}\n   function nNop(x) { return x; }\n   function nMulTo(x,y,r) { x.multiplyTo(y,r); }\n   function nSqrTo(x,r) { x.squareTo(r); }\n\n   NullExp.prototype.convert = nNop;\n   NullExp.prototype.revert = nNop;\n   NullExp.prototype.mulTo = nMulTo;\n   NullExp.prototype.sqrTo = nSqrTo;\n\n   // (public) this^e\n   function bnPow(e) { return this.exp(e,new NullExp()); }\n\n   // (protected) r = lower n words of \"this * a\", a.t <= n\n   // \"this\" should be the larger one if appropriate.\n   function bnpMultiplyLowerTo(a,n,r) {\n     var i = Math.min(this.t+a.t,n);\n     r.s = 0; // assumes a,this >= 0\n     r.t = i;\n     while(i > 0) r[--i] = 0;\n     var j;\n     for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);\n     for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);\n     r.clamp();\n   }\n\n   // (protected) r = \"this * a\" without lower n words, n > 0\n   // \"this\" should be the larger one if appropriate.\n   function bnpMultiplyUpperTo(a,n,r) {\n     --n;\n     var i = r.t = this.t+a.t-n;\n     r.s = 0; // assumes a,this >= 0\n     while(--i >= 0) r[i] = 0;\n     for(i = Math.max(n-this.t,0); i < a.t; ++i)\n       r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);\n     r.clamp();\n     r.drShiftTo(1,r);\n   }\n\n   // Barrett modular reduction\n   function Barrett(m) {\n     // setup Barrett\n     this.r2 = nbi();\n     this.q3 = nbi();\n     BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n     this.mu = this.r2.divide(m);\n     this.m = m;\n   }\n\n   function barrettConvert(x) {\n     if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n     else if(x.compareTo(this.m) < 0) return x;\n     else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n   }\n\n   function barrettRevert(x) { return x; }\n\n   // x = x mod m (HAC 14.42)\n   function barrettReduce(x) {\n     x.drShiftTo(this.m.t-1,this.r2);\n     if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n     this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n     this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n     while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n     x.subTo(this.r2,x);\n     while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n   }\n\n   // r = x^2 mod m; x != r\n   function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n   // r = x*y mod m; x,y != r\n   function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\n   Barrett.prototype.convert = barrettConvert;\n   Barrett.prototype.revert = barrettRevert;\n   Barrett.prototype.reduce = barrettReduce;\n   Barrett.prototype.mulTo = barrettMulTo;\n   Barrett.prototype.sqrTo = barrettSqrTo;\n\n   // (public) this^e % m (HAC 14.85)\n   function bnModPow(e,m) {\n     var i = e.bitLength(), k, r = nbv(1), z;\n     if(i <= 0) return r;\n     else if(i < 18) k = 1;\n     else if(i < 48) k = 3;\n     else if(i < 144) k = 4;\n     else if(i < 768) k = 5;\n     else k = 6;\n     if(i < 8)\n       z = new Classic(m);\n     else if(m.isEven())\n       z = new Barrett(m);\n     else\n       z = new Montgomery(m);\n\n     // precomputation\n     var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\n     g[1] = z.convert(this);\n     if(k > 1) {\n       var g2 = nbi();\n       z.sqrTo(g[1],g2);\n       while(n <= km) {\n         g[n] = nbi();\n         z.mulTo(g2,g[n-2],g[n]);\n         n += 2;\n       }\n     }\n\n     var j = e.t-1, w, is1 = true, r2 = nbi(), t;\n     i = nbits(e[j])-1;\n     while(j >= 0) {\n       if(i >= k1) w = (e[j]>>(i-k1))&km;\n       else {\n         w = (e[j]&((1<<(i+1))-1))<<(k1-i);\n         if(j > 0) w |= e[j-1]>>(this.DB+i-k1);\n       }\n\n       n = k;\n       while((w&1) == 0) { w >>= 1; --n; }\n       if((i -= n) < 0) { i += this.DB; --j; }\n       if(is1) {  // ret == 1, don't bother squaring or multiplying it\n         g[w].copyTo(r);\n         is1 = false;\n       }\n       else {\n         while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\n         if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\n         z.mulTo(r2,g[w],r);\n       }\n\n       while(j >= 0 && (e[j]&(1<<i)) == 0) {\n         z.sqrTo(r,r2); t = r; r = r2; r2 = t;\n         if(--i < 0) { i = this.DB-1; --j; }\n       }\n     }\n     return z.revert(r);\n   }\n\n   // (public) gcd(this,a) (HAC 14.54)\n   function bnGCD(a) {\n     var x = (this.s<0)?this.negate():this.clone();\n     var y = (a.s<0)?a.negate():a.clone();\n     if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\n     var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n     if(g < 0) return x;\n     if(i < g) g = i;\n     if(g > 0) {\n       x.rShiftTo(g,x);\n       y.rShiftTo(g,y);\n     }\n     while(x.signum() > 0) {\n       if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\n       if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\n       if(x.compareTo(y) >= 0) {\n         x.subTo(y,x);\n         x.rShiftTo(1,x);\n       }\n       else {\n         y.subTo(x,y);\n         y.rShiftTo(1,y);\n       }\n     }\n     if(g > 0) y.lShiftTo(g,y);\n     return y;\n   }\n\n   // (protected) this % n, n < 2^26\n   function bnpModInt(n) {\n     if(n <= 0) return 0;\n     var d = this.DV%n, r = (this.s<0)?n-1:0;\n     if(this.t > 0)\n       if(d == 0) r = this[0]%n;\n       else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;\n     return r;\n   }\n\n   // (public) 1/this % m (HAC 14.61)\n   function bnModInverse(m) {\n     var ac = m.isEven();\n     if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n     var u = m.clone(), v = this.clone();\n     var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n     while(u.signum() != 0) {\n       while(u.isEven()) {\n         u.rShiftTo(1,u);\n         if(ac) {\n           if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\n           a.rShiftTo(1,a);\n         }\n         else if(!b.isEven()) b.subTo(m,b);\n         b.rShiftTo(1,b);\n       }\n       while(v.isEven()) {\n         v.rShiftTo(1,v);\n         if(ac) {\n           if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\n           c.rShiftTo(1,c);\n         }\n         else if(!d.isEven()) d.subTo(m,d);\n         d.rShiftTo(1,d);\n       }\n       if(u.compareTo(v) >= 0) {\n         u.subTo(v,u);\n         if(ac) a.subTo(c,a);\n         b.subTo(d,b);\n       }\n       else {\n         v.subTo(u,v);\n         if(ac) c.subTo(a,c);\n         d.subTo(b,d);\n       }\n     }\n     if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n     if(d.compareTo(m) >= 0) return d.subtract(m);\n     if(d.signum() < 0) d.addTo(m,d); else return d;\n     if(d.signum() < 0) return d.add(m); else return d;\n   }\n\n   var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\n   var lplim = (1<<26)/lowprimes[lowprimes.length-1];\n\n   // (public) test primality with certainty >= 1-.5^t\n   function bnIsProbablePrime(t) {\n     var i, x = this.abs();\n     if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {\n       for(i = 0; i < lowprimes.length; ++i)\n         if(x[0] == lowprimes[i]) return true;\n       return false;\n     }\n     if(x.isEven()) return false;\n     i = 1;\n     while(i < lowprimes.length) {\n       var m = lowprimes[i], j = i+1;\n       while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n       m = x.modInt(m);\n       while(i < j) if(m%lowprimes[i++] == 0) return false;\n     }\n     return x.millerRabin(t);\n   }\n\n   /* added by Recurity Labs */\n\n   function nbits(x) {\n    var n = 1, t;\n    if ((t = x >>> 16) != 0) {\n      x = t;\n      n += 16;\n    }\n    if ((t = x >> 8) != 0) {\n      x = t;\n      n += 8;\n    }\n    if ((t = x >> 4) != 0) {\n      x = t;\n      n += 4;\n    }\n    if ((t = x >> 2) != 0) {\n      x = t;\n      n += 2;\n    }\n    if ((t = x >> 1) != 0) {\n      x = t;\n      n += 1;\n    }\n    return n;\n   }\n\n   function bnToMPI () {\n    var ba = this.toByteArray();\n    var size = (ba.length-1)*8+nbits(ba[0]);\n    var result = \"\";\n    result += String.fromCharCode((size & 0xFF00) >> 8);\n    result += String.fromCharCode(size & 0xFF);\n    result += util.bin2str(ba);\n    return result;\n   }\n   /* END of addition */\n\n   // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n   function bnpMillerRabin(t) {\n     var n1 = this.subtract(BigInteger.ONE);\n     var k = n1.getLowestSetBit();\n     if(k <= 0) return false;\n     var r = n1.shiftRight(k);\n     t = (t+1)>>1;\n     if(t > lowprimes.length) t = lowprimes.length;\n     var a = nbi();\n     for(var i = 0; i < t; ++i) {\n       //Pick bases at random, instead of starting at 2\n       a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);\n       var y = a.modPow(r,this);\n       if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n         var j = 1;\n         while(j++ < k && y.compareTo(n1) != 0) {\n           y = y.modPowInt(2,this);\n           if(y.compareTo(BigInteger.ONE) == 0) return false;\n         }\n         if(y.compareTo(n1) != 0) return false;\n       }\n     }\n     return true;\n   }\n\n   // protected\n   BigInteger.prototype.chunkSize = bnpChunkSize;\n   BigInteger.prototype.toRadix = bnpToRadix;\n   BigInteger.prototype.fromRadix = bnpFromRadix;\n   BigInteger.prototype.fromNumber = bnpFromNumber;\n   BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n   BigInteger.prototype.changeBit = bnpChangeBit;\n   BigInteger.prototype.addTo = bnpAddTo;\n   BigInteger.prototype.dMultiply = bnpDMultiply;\n   BigInteger.prototype.dAddOffset = bnpDAddOffset;\n   BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n   BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n   BigInteger.prototype.modInt = bnpModInt;\n   BigInteger.prototype.millerRabin = bnpMillerRabin;\n\n   // public\n   BigInteger.prototype.clone = bnClone;\n   BigInteger.prototype.intValue = bnIntValue;\n   BigInteger.prototype.byteValue = bnByteValue;\n   BigInteger.prototype.shortValue = bnShortValue;\n   BigInteger.prototype.signum = bnSigNum;\n   BigInteger.prototype.toByteArray = bnToByteArray;\n   BigInteger.prototype.equals = bnEquals;\n   BigInteger.prototype.min = bnMin;\n   BigInteger.prototype.max = bnMax;\n   BigInteger.prototype.and = bnAnd;\n   BigInteger.prototype.or = bnOr;\n   BigInteger.prototype.xor = bnXor;\n   BigInteger.prototype.andNot = bnAndNot;\n   BigInteger.prototype.not = bnNot;\n   BigInteger.prototype.shiftLeft = bnShiftLeft;\n   BigInteger.prototype.shiftRight = bnShiftRight;\n   BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n   BigInteger.prototype.bitCount = bnBitCount;\n   BigInteger.prototype.testBit = bnTestBit;\n   BigInteger.prototype.setBit = bnSetBit;\n   BigInteger.prototype.clearBit = bnClearBit;\n   BigInteger.prototype.flipBit = bnFlipBit;\n   BigInteger.prototype.add = bnAdd;\n   BigInteger.prototype.subtract = bnSubtract;\n   BigInteger.prototype.multiply = bnMultiply;\n   BigInteger.prototype.divide = bnDivide;\n   BigInteger.prototype.remainder = bnRemainder;\n   BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n   BigInteger.prototype.modPow = bnModPow;\n   BigInteger.prototype.modInverse = bnModInverse;\n   BigInteger.prototype.pow = bnPow;\n   BigInteger.prototype.gcd = bnGCD;\n   BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n   BigInteger.prototype.toMPI = bnToMPI;\n\n   // JSBN-specific extension\n   BigInteger.prototype.square = bnSquare;\n\n   function bigint_or_number (x) {\n    if (typeof(x) === 'number') { return nbv(x); }\n    else { return x; }\n   };\n\n   function buffer_to_ui8a (b) {\n    var l = b.length;\n    var ret = new Uint8Array(l);\n    for (var i = 0; i < l; i++) {\n      ret[i] = b.readUInt8(i);\n    }\n    return ret;\n   };\n\n   // Match this function to the bigint/bignum native JS interface\n   // in node.  Typically we're doing it the other way around.\n   BigInteger.prototype.fromBuffer = function (buf) {\n       // the last 'true' is for 'unsigned', our hack to jsbn.js to\n       // shut off DER-integer interpretation\n    this.fromString(buffer_to_ui8a(buf), 256, true);\n    return this;\n   };\n\n   BigInteger.fromBuffer = function (buf) {\n    var ret = nbi();\n    ret.fromBuffer(buf);\n    return ret;\n   };\n\n   BigInteger.random_nbit = function (nbits, rf) {\n    return new BigInteger(nbits, rf);\n   };\n\n   BigInteger.prototype.inspect = function () {\n    return \"<BigInteger/pure \" + this.toString() + \">\";\n   };\n\n   // For compatability with the 'bigi' package used by ecurve\n   BigInteger.fromHex = function (s) {\n\n    if (!s.match(/^[a-fA-F0-9]*$/)) { throw new Error(\"hex string invalid: \"+ s); }\n    if (s.length % 2 != 0) { throw new Error(\"got an odd-length hex-string\"); }\n    return new BigInteger(s, 16);\n   };\n\n   BigInteger.valueOf = function (x) {\n    return bigint_or_number(x);\n   };\n\n   BigInteger.prototype.toBuffer = function (size) {\n    var x;\n    if (!size) { size = 0; }\n    var s = this.signum();\n    if (s == 0) { x = []; }\n    else {x = this.toByteArray(s < 0); }\n    var ret = new Buffer(x);\n    if ((diff = size - x.length) > 0) {\n      var pad = new Buffer(diff);\n      pad.fill(0);\n      ret = Buffer.concat([pad,ret]);\n    }\n    return ret;\n   };\n\n   BigInteger.prototype.byteLength = function () { return this.t; }\n\n   BigInteger.prototype.toDERInteger = function () {\n    return this.toByteArray(true);\n   };\n\n   BigInteger.fromDERInteger = function (buf) {\n    var x = nbi();\n    x.fromString(buf, 256, false);\n    return x;\n   };\n\n   BigInteger.prototype.toByteArrayUnsigned = function () {\n    return new Uint8Array(this.toBuffer());\n   };\n\n   BigInteger.fromByteArrayUnsigned = function (b) {\n    return BigInteger.fromBuffer(new Buffer(b));\n   };\n\n   BigInteger.prototype.toHex = function (size) {\n    return this.toBuffer(size).toString('hex');\n   };\n\n   module.exports = {\n    BigInteger : BigInteger,\n    nbi : nbi,\n    nbv : nbv,\n    Montgomery : Montgomery,\n    Classic : Classic,\n    nbits : nbits\n   };\n})(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":80}],74:[function(require,module,exports){\n\nvar engine = null;\nvar modules = [ \"bigint\", \"bignum\" ];\nfor (var i in modules) {\n  try {\n    engine = require(modules[i]);\n    break;\n  } catch (e) {}\n}\nexports.engine = engine;\n},{}],75:[function(require,module,exports){\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// when used in node, this will actually load the util module we depend on\n// versus loading the builtin util module as happens otherwise\n// this is a bug in node module loading as far as I am concerned\nvar util = require('util/');\n\nvar pSlice = Array.prototype.slice;\nvar hasOwn = Object.prototype.hasOwnProperty;\n\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n  else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = stackStartFunction.name;\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (util.isUndefined(value)) {\n    return '' + value;\n  }\n  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {\n    return value.toString();\n  }\n  if (util.isFunction(value) || util.isRegExp(value)) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (util.isString(s)) {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nfunction getMessage(self) {\n  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(JSON.stringify(self.expected, replacer), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!util.isObject(actual) && !util.isObject(expected)) {\n    return actual == expected;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b) {\n  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (util.isString(expected)) {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n\n},{\"util/\":77}],76:[function(require,module,exports){\nmodule.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n},{}],77:[function(require,module,exports){\n(function (process,global){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./support/isBuffer\":76,\"_process\":99,\"inherits\":97}],78:[function(require,module,exports){\n(function (process,Buffer){\nvar msg = require('pako/lib/zlib/messages');\nvar zstream = require('pako/lib/zlib/zstream');\nvar zlib_deflate = require('pako/lib/zlib/deflate.js');\nvar zlib_inflate = require('pako/lib/zlib/inflate.js');\nvar constants = require('pako/lib/zlib/constants');\n\nfor (var key in constants) {\n  exports[key] = constants[key];\n}\n\n// zlib modes\nexports.NONE = 0;\nexports.DEFLATE = 1;\nexports.INFLATE = 2;\nexports.GZIP = 3;\nexports.GUNZIP = 4;\nexports.DEFLATERAW = 5;\nexports.INFLATERAW = 6;\nexports.UNZIP = 7;\n\n/**\n * Emulate Node's zlib C++ layer for use by the JS layer in index.js\n */\nfunction Zlib(mode) {\n  if (mode < exports.DEFLATE || mode > exports.UNZIP)\n    throw new TypeError(\"Bad argument\");\n\n  this.mode = mode;\n  this.init_done = false;\n  this.write_in_progress = false;\n  this.pending_close = false;\n  this.windowBits = 0;\n  this.level = 0;\n  this.memLevel = 0;\n  this.strategy = 0;\n  this.dictionary = null;\n}\n\nZlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {\n  this.windowBits = windowBits;\n  this.level = level;\n  this.memLevel = memLevel;\n  this.strategy = strategy;\n  // dictionary not supported.\n\n  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP)\n    this.windowBits += 16;\n\n  if (this.mode === exports.UNZIP)\n    this.windowBits += 32;\n\n  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW)\n    this.windowBits = -this.windowBits;\n\n  this.strm = new zstream();\n\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.GZIP:\n    case exports.DEFLATERAW:\n      var status = zlib_deflate.deflateInit2(\n        this.strm,\n        this.level,\n        exports.Z_DEFLATED,\n        this.windowBits,\n        this.memLevel,\n        this.strategy\n      );\n      break;\n    case exports.INFLATE:\n    case exports.GUNZIP:\n    case exports.INFLATERAW:\n    case exports.UNZIP:\n      var status  = zlib_inflate.inflateInit2(\n        this.strm,\n        this.windowBits\n      );\n      break;\n    default:\n      throw new Error(\"Unknown mode \" + this.mode);\n  }\n\n  if (status !== exports.Z_OK) {\n    this._error(status);\n    return;\n  }\n\n  this.write_in_progress = false;\n  this.init_done = true;\n};\n\nZlib.prototype.params = function() {\n  throw new Error(\"deflateParams Not supported\");\n};\n\nZlib.prototype._writeCheck = function() {\n  if (!this.init_done)\n    throw new Error(\"write before init\");\n\n  if (this.mode === exports.NONE)\n    throw new Error(\"already finalized\");\n\n  if (this.write_in_progress)\n    throw new Error(\"write already in progress\");\n\n  if (this.pending_close)\n    throw new Error(\"close is pending\");\n};\n\nZlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {\n  this._writeCheck();\n  this.write_in_progress = true;\n\n  var self = this;\n  process.nextTick(function() {\n    self.write_in_progress = false;\n    var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);\n    self.callback(res[0], res[1]);\n\n    if (self.pending_close)\n      self.close();\n  });\n\n  return this;\n};\n\n// set method for Node buffers, used by pako\nfunction bufferSet(data, offset) {\n  for (var i = 0; i < data.length; i++) {\n    this[offset + i] = data[i];\n  }\n}\n\nZlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {\n  this._writeCheck();\n  return this._write(flush, input, in_off, in_len, out, out_off, out_len);\n};\n\nZlib.prototype._write = function(flush, input, in_off, in_len, out, out_off, out_len) {\n  this.write_in_progress = true;\n\n  if (flush !== exports.Z_NO_FLUSH &&\n      flush !== exports.Z_PARTIAL_FLUSH &&\n      flush !== exports.Z_SYNC_FLUSH &&\n      flush !== exports.Z_FULL_FLUSH &&\n      flush !== exports.Z_FINISH &&\n      flush !== exports.Z_BLOCK) {\n    throw new Error(\"Invalid flush value\");\n  }\n\n  if (input == null) {\n    input = new Buffer(0);\n    in_len = 0;\n    in_off = 0;\n  }\n\n  if (out._set)\n    out.set = out._set;\n  else\n    out.set = bufferSet;\n\n  var strm = this.strm;\n  strm.avail_in = in_len;\n  strm.input = input;\n  strm.next_in = in_off;\n  strm.avail_out = out_len;\n  strm.output = out;\n  strm.next_out = out_off;\n\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.GZIP:\n    case exports.DEFLATERAW:\n      var status = zlib_deflate.deflate(strm, flush);\n      break;\n    case exports.UNZIP:\n    case exports.INFLATE:\n    case exports.GUNZIP:\n    case exports.INFLATERAW:\n      var status = zlib_inflate.inflate(strm, flush);\n      break;\n    default:\n      throw new Error(\"Unknown mode \" + this.mode);\n  }\n\n  if (status !== exports.Z_STREAM_END && status !== exports.Z_OK) {\n    this._error(status);\n  }\n\n  this.write_in_progress = false;\n  return [strm.avail_in, strm.avail_out];\n};\n\nZlib.prototype.close = function() {\n  if (this.write_in_progress) {\n    this.pending_close = true;\n    return;\n  }\n\n  this.pending_close = false;\n\n  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {\n    zlib_deflate.deflateEnd(this.strm);\n  } else {\n    zlib_inflate.inflateEnd(this.strm);\n  }\n\n  this.mode = exports.NONE;\n};\n\nZlib.prototype.reset = function() {\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.DEFLATERAW:\n      var status = zlib_deflate.deflateReset(this.strm);\n      break;\n    case exports.INFLATE:\n    case exports.INFLATERAW:\n      var status = zlib_inflate.inflateReset(this.strm);\n      break;\n  }\n\n  if (status !== exports.Z_OK) {\n    this._error(status);\n  }\n};\n\nZlib.prototype._error = function(status) {\n  this.onerror(msg[status] + ': ' + this.strm.msg, status);\n\n  this.write_in_progress = false;\n  if (this.pending_close)\n    this.close();\n};\n\nexports.Zlib = Zlib;\n\n}).call(this,require('_process'),require(\"buffer\").Buffer)\n},{\"_process\":99,\"buffer\":80,\"pako/lib/zlib/constants\":153,\"pako/lib/zlib/deflate.js\":155,\"pako/lib/zlib/inflate.js\":157,\"pako/lib/zlib/messages\":159,\"pako/lib/zlib/zstream\":161}],79:[function(require,module,exports){\n(function (process,Buffer){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Transform = require('_stream_transform');\n\nvar binding = require('./binding');\nvar util = require('util');\nvar assert = require('assert').ok;\n\n// zlib doesn't provide these, so kludge them in following the same\n// const naming scheme zlib uses.\nbinding.Z_MIN_WINDOWBITS = 8;\nbinding.Z_MAX_WINDOWBITS = 15;\nbinding.Z_DEFAULT_WINDOWBITS = 15;\n\n// fewer than 64 bytes per chunk is stupid.\n// technically it could work with as few as 8, but even 64 bytes\n// is absurdly low.  Usually a MB or more is best.\nbinding.Z_MIN_CHUNK = 64;\nbinding.Z_MAX_CHUNK = Infinity;\nbinding.Z_DEFAULT_CHUNK = (16 * 1024);\n\nbinding.Z_MIN_MEMLEVEL = 1;\nbinding.Z_MAX_MEMLEVEL = 9;\nbinding.Z_DEFAULT_MEMLEVEL = 8;\n\nbinding.Z_MIN_LEVEL = -1;\nbinding.Z_MAX_LEVEL = 9;\nbinding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;\n\n// expose all the zlib constants\nObject.keys(binding).forEach(function(k) {\n  if (k.match(/^Z/)) exports[k] = binding[k];\n});\n\n// translation table for return codes.\nexports.codes = {\n  Z_OK: binding.Z_OK,\n  Z_STREAM_END: binding.Z_STREAM_END,\n  Z_NEED_DICT: binding.Z_NEED_DICT,\n  Z_ERRNO: binding.Z_ERRNO,\n  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,\n  Z_DATA_ERROR: binding.Z_DATA_ERROR,\n  Z_MEM_ERROR: binding.Z_MEM_ERROR,\n  Z_BUF_ERROR: binding.Z_BUF_ERROR,\n  Z_VERSION_ERROR: binding.Z_VERSION_ERROR\n};\n\nObject.keys(exports.codes).forEach(function(k) {\n  exports.codes[exports.codes[k]] = k;\n});\n\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;\n\nexports.createDeflate = function(o) {\n  return new Deflate(o);\n};\n\nexports.createInflate = function(o) {\n  return new Inflate(o);\n};\n\nexports.createDeflateRaw = function(o) {\n  return new DeflateRaw(o);\n};\n\nexports.createInflateRaw = function(o) {\n  return new InflateRaw(o);\n};\n\nexports.createGzip = function(o) {\n  return new Gzip(o);\n};\n\nexports.createGunzip = function(o) {\n  return new Gunzip(o);\n};\n\nexports.createUnzip = function(o) {\n  return new Unzip(o);\n};\n\n\n// Convenience methods.\n// compress/decompress a string or buffer in one step.\nexports.deflate = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Deflate(opts), buffer, callback);\n};\n\nexports.deflateSync = function(buffer, opts) {\n  return zlibBufferSync(new Deflate(opts), buffer);\n};\n\nexports.gzip = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gzip(opts), buffer, callback);\n};\n\nexports.gzipSync = function(buffer, opts) {\n  return zlibBufferSync(new Gzip(opts), buffer);\n};\n\nexports.deflateRaw = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new DeflateRaw(opts), buffer, callback);\n};\n\nexports.deflateRawSync = function(buffer, opts) {\n  return zlibBufferSync(new DeflateRaw(opts), buffer);\n};\n\nexports.unzip = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Unzip(opts), buffer, callback);\n};\n\nexports.unzipSync = function(buffer, opts) {\n  return zlibBufferSync(new Unzip(opts), buffer);\n};\n\nexports.inflate = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Inflate(opts), buffer, callback);\n};\n\nexports.inflateSync = function(buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n};\n\nexports.gunzip = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gunzip(opts), buffer, callback);\n};\n\nexports.gunzipSync = function(buffer, opts) {\n  return zlibBufferSync(new Gunzip(opts), buffer);\n};\n\nexports.inflateRaw = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new InflateRaw(opts), buffer, callback);\n};\n\nexports.inflateRawSync = function(buffer, opts) {\n  return zlibBufferSync(new InflateRaw(opts), buffer);\n};\n\nfunction zlibBuffer(engine, buffer, callback) {\n  var buffers = [];\n  var nread = 0;\n\n  engine.on('error', onError);\n  engine.on('end', onEnd);\n\n  engine.end(buffer);\n  flow();\n\n  function flow() {\n    var chunk;\n    while (null !== (chunk = engine.read())) {\n      buffers.push(chunk);\n      nread += chunk.length;\n    }\n    engine.once('readable', flow);\n  }\n\n  function onError(err) {\n    engine.removeListener('end', onEnd);\n    engine.removeListener('readable', flow);\n    callback(err);\n  }\n\n  function onEnd() {\n    var buf = Buffer.concat(buffers, nread);\n    buffers = [];\n    callback(null, buf);\n    engine.close();\n  }\n}\n\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string')\n    buffer = new Buffer(buffer);\n  if (!Buffer.isBuffer(buffer))\n    throw new TypeError('Not a string or buffer');\n\n  var flushFlag = binding.Z_FINISH;\n\n  return engine._processChunk(buffer, flushFlag);\n}\n\n// generic zlib\n// minimal 2-byte header\nfunction Deflate(opts) {\n  if (!(this instanceof Deflate)) return new Deflate(opts);\n  Zlib.call(this, opts, binding.DEFLATE);\n}\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) return new Inflate(opts);\n  Zlib.call(this, opts, binding.INFLATE);\n}\n\n\n\n// gzip - bigger header, same deflate compression\nfunction Gzip(opts) {\n  if (!(this instanceof Gzip)) return new Gzip(opts);\n  Zlib.call(this, opts, binding.GZIP);\n}\n\nfunction Gunzip(opts) {\n  if (!(this instanceof Gunzip)) return new Gunzip(opts);\n  Zlib.call(this, opts, binding.GUNZIP);\n}\n\n\n\n// raw - no header\nfunction DeflateRaw(opts) {\n  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);\n  Zlib.call(this, opts, binding.DEFLATERAW);\n}\n\nfunction InflateRaw(opts) {\n  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);\n  Zlib.call(this, opts, binding.INFLATERAW);\n}\n\n\n// auto-detect header.\nfunction Unzip(opts) {\n  if (!(this instanceof Unzip)) return new Unzip(opts);\n  Zlib.call(this, opts, binding.UNZIP);\n}\n\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\nfunction Zlib(opts, mode) {\n  this._opts = opts = opts || {};\n  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;\n\n  Transform.call(this, opts);\n\n  if (opts.flush) {\n    if (opts.flush !== binding.Z_NO_FLUSH &&\n        opts.flush !== binding.Z_PARTIAL_FLUSH &&\n        opts.flush !== binding.Z_SYNC_FLUSH &&\n        opts.flush !== binding.Z_FULL_FLUSH &&\n        opts.flush !== binding.Z_FINISH &&\n        opts.flush !== binding.Z_BLOCK) {\n      throw new Error('Invalid flush flag: ' + opts.flush);\n    }\n  }\n  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;\n\n  if (opts.chunkSize) {\n    if (opts.chunkSize < exports.Z_MIN_CHUNK ||\n        opts.chunkSize > exports.Z_MAX_CHUNK) {\n      throw new Error('Invalid chunk size: ' + opts.chunkSize);\n    }\n  }\n\n  if (opts.windowBits) {\n    if (opts.windowBits < exports.Z_MIN_WINDOWBITS ||\n        opts.windowBits > exports.Z_MAX_WINDOWBITS) {\n      throw new Error('Invalid windowBits: ' + opts.windowBits);\n    }\n  }\n\n  if (opts.level) {\n    if (opts.level < exports.Z_MIN_LEVEL ||\n        opts.level > exports.Z_MAX_LEVEL) {\n      throw new Error('Invalid compression level: ' + opts.level);\n    }\n  }\n\n  if (opts.memLevel) {\n    if (opts.memLevel < exports.Z_MIN_MEMLEVEL ||\n        opts.memLevel > exports.Z_MAX_MEMLEVEL) {\n      throw new Error('Invalid memLevel: ' + opts.memLevel);\n    }\n  }\n\n  if (opts.strategy) {\n    if (opts.strategy != exports.Z_FILTERED &&\n        opts.strategy != exports.Z_HUFFMAN_ONLY &&\n        opts.strategy != exports.Z_RLE &&\n        opts.strategy != exports.Z_FIXED &&\n        opts.strategy != exports.Z_DEFAULT_STRATEGY) {\n      throw new Error('Invalid strategy: ' + opts.strategy);\n    }\n  }\n\n  if (opts.dictionary) {\n    if (!Buffer.isBuffer(opts.dictionary)) {\n      throw new Error('Invalid dictionary: it should be a Buffer instance');\n    }\n  }\n\n  this._binding = new binding.Zlib(mode);\n\n  var self = this;\n  this._hadError = false;\n  this._binding.onerror = function(message, errno) {\n    // there is no way to cleanly recover.\n    // continuing only obscures problems.\n    self._binding = null;\n    self._hadError = true;\n\n    var error = new Error(message);\n    error.errno = errno;\n    error.code = exports.codes[errno];\n    self.emit('error', error);\n  };\n\n  var level = exports.Z_DEFAULT_COMPRESSION;\n  if (typeof opts.level === 'number') level = opts.level;\n\n  var strategy = exports.Z_DEFAULT_STRATEGY;\n  if (typeof opts.strategy === 'number') strategy = opts.strategy;\n\n  this._binding.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,\n                     level,\n                     opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,\n                     strategy,\n                     opts.dictionary);\n\n  this._buffer = new Buffer(this._chunkSize);\n  this._offset = 0;\n  this._closed = false;\n  this._level = level;\n  this._strategy = strategy;\n\n  this.once('end', this.close);\n}\n\nutil.inherits(Zlib, Transform);\n\nZlib.prototype.params = function(level, strategy, callback) {\n  if (level < exports.Z_MIN_LEVEL ||\n      level > exports.Z_MAX_LEVEL) {\n    throw new RangeError('Invalid compression level: ' + level);\n  }\n  if (strategy != exports.Z_FILTERED &&\n      strategy != exports.Z_HUFFMAN_ONLY &&\n      strategy != exports.Z_RLE &&\n      strategy != exports.Z_FIXED &&\n      strategy != exports.Z_DEFAULT_STRATEGY) {\n    throw new TypeError('Invalid strategy: ' + strategy);\n  }\n\n  if (this._level !== level || this._strategy !== strategy) {\n    var self = this;\n    this.flush(binding.Z_SYNC_FLUSH, function() {\n      self._binding.params(level, strategy);\n      if (!self._hadError) {\n        self._level = level;\n        self._strategy = strategy;\n        if (callback) callback();\n      }\n    });\n  } else {\n    process.nextTick(callback);\n  }\n};\n\nZlib.prototype.reset = function() {\n  return this._binding.reset();\n};\n\n// This is the _flush function called by the transform class,\n// internally, when the last chunk has been written.\nZlib.prototype._flush = function(callback) {\n  this._transform(new Buffer(0), '', callback);\n};\n\nZlib.prototype.flush = function(kind, callback) {\n  var ws = this._writableState;\n\n  if (typeof kind === 'function' || (kind === void 0 && !callback)) {\n    callback = kind;\n    kind = binding.Z_FULL_FLUSH;\n  }\n\n  if (ws.ended) {\n    if (callback)\n      process.nextTick(callback);\n  } else if (ws.ending) {\n    if (callback)\n      this.once('end', callback);\n  } else if (ws.needDrain) {\n    var self = this;\n    this.once('drain', function() {\n      self.flush(callback);\n    });\n  } else {\n    this._flushFlag = kind;\n    this.write(new Buffer(0), '', callback);\n  }\n};\n\nZlib.prototype.close = function(callback) {\n  if (callback)\n    process.nextTick(callback);\n\n  if (this._closed)\n    return;\n\n  this._closed = true;\n\n  this._binding.close();\n\n  var self = this;\n  process.nextTick(function() {\n    self.emit('close');\n  });\n};\n\nZlib.prototype._transform = function(chunk, encoding, cb) {\n  var flushFlag;\n  var ws = this._writableState;\n  var ending = ws.ending || ws.ended;\n  var last = ending && (!chunk || ws.length === chunk.length);\n\n  if (!chunk === null && !Buffer.isBuffer(chunk))\n    return cb(new Error('invalid input'));\n\n  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag.\n  // If it's explicitly flushing at some other time, then we use\n  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression\n  // goodness.\n  if (last)\n    flushFlag = binding.Z_FINISH;\n  else {\n    flushFlag = this._flushFlag;\n    // once we've flushed the last of the queue, stop flushing and\n    // go back to the normal behavior.\n    if (chunk.length >= ws.length) {\n      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;\n    }\n  }\n\n  var self = this;\n  this._processChunk(chunk, flushFlag, cb);\n};\n\nZlib.prototype._processChunk = function(chunk, flushFlag, cb) {\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var inOff = 0;\n\n  var self = this;\n\n  var async = typeof cb === 'function';\n\n  if (!async) {\n    var buffers = [];\n    var nread = 0;\n\n    var error;\n    this.on('error', function(er) {\n      error = er;\n    });\n\n    do {\n      var res = this._binding.writeSync(flushFlag,\n                                        chunk, // in\n                                        inOff, // in_off\n                                        availInBefore, // in_len\n                                        this._buffer, // out\n                                        this._offset, //out_off\n                                        availOutBefore); // out_len\n    } while (!this._hadError && callback(res[0], res[1]));\n\n    if (this._hadError) {\n      throw error;\n    }\n\n    var buf = Buffer.concat(buffers, nread);\n    this.close();\n\n    return buf;\n  }\n\n  var req = this._binding.write(flushFlag,\n                                chunk, // in\n                                inOff, // in_off\n                                availInBefore, // in_len\n                                this._buffer, // out\n                                this._offset, //out_off\n                                availOutBefore); // out_len\n\n  req.buffer = chunk;\n  req.callback = callback;\n\n  function callback(availInAfter, availOutAfter) {\n    if (self._hadError)\n      return;\n\n    var have = availOutBefore - availOutAfter;\n    assert(have >= 0, 'have should not go down');\n\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n      self._offset += have;\n      // serve some output to the consumer.\n      if (async) {\n        self.push(out);\n      } else {\n        buffers.push(out);\n        nread += out.length;\n      }\n    }\n\n    // exhausted the output buffer, or used all the input create a new one.\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = new Buffer(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      // Not actually done.  Need to reprocess.\n      // Also, update the availInBefore to the availInAfter value,\n      // so that if we have to hit it a third (fourth, etc.) time,\n      // it'll have the correct byte counts.\n      inOff += (availInBefore - availInAfter);\n      availInBefore = availInAfter;\n\n      if (!async)\n        return true;\n\n      var newReq = self._binding.write(flushFlag,\n                                       chunk,\n                                       inOff,\n                                       availInBefore,\n                                       self._buffer,\n                                       self._offset,\n                                       self._chunkSize);\n      newReq.callback = callback; // this same function\n      newReq.buffer = chunk;\n      return;\n    }\n\n    if (!async)\n      return false;\n\n    // finished with the chunk.\n    cb();\n  }\n};\n\nutil.inherits(Deflate, Zlib);\nutil.inherits(Inflate, Zlib);\nutil.inherits(Gzip, Zlib);\nutil.inherits(Gunzip, Zlib);\nutil.inherits(DeflateRaw, Zlib);\nutil.inherits(InflateRaw, Zlib);\nutil.inherits(Unzip, Zlib);\n\n}).call(this,require('_process'),require(\"buffer\").Buffer)\n},{\"./binding\":78,\"_process\":99,\"_stream_transform\":110,\"assert\":75,\"buffer\":80,\"util\":114}],80:[function(require,module,exports){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = Buffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192\n\n/**\n * If `TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Note:\n *\n * - Implementation must support adding new properties to `Uint8Array` instances.\n *   Firefox 4-29 lacked support, fixed in Firefox 30+.\n *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *    incorrect length in some situations.\n *\n * We detect these buggy browsers and set `TYPED_ARRAY_SUPPORT` to `false` so they will\n * get the Object implementation, which is slower but will work correctly.\n */\nvar TYPED_ARRAY_SUPPORT = (function () {\n  try {\n    var buf = new ArrayBuffer(0)\n    var arr = new Uint8Array(buf)\n    arr.foo = function () { return 42 }\n    return 42 === arr.foo() && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n})()\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (subject, encoding, noZero) {\n  if (!(this instanceof Buffer))\n    return new Buffer(subject, encoding, noZero)\n\n  var type = typeof subject\n\n  // Find the length\n  var length\n  if (type === 'number')\n    length = subject > 0 ? subject >>> 0 : 0\n  else if (type === 'string') {\n    if (encoding === 'base64')\n      subject = base64clean(subject)\n    length = Buffer.byteLength(subject, encoding)\n  } else if (type === 'object' && subject !== null) { // assume object is array-like\n    if (subject.type === 'Buffer' && isArray(subject.data))\n      subject = subject.data\n    length = +subject.length > 0 ? Math.floor(+subject.length) : 0\n  } else\n    throw new Error('First argument needs to be a number, array or string.')\n\n  var buf\n  if (TYPED_ARRAY_SUPPORT) {\n    // Preferred: Return an augmented `Uint8Array` instance for best performance\n    buf = Buffer._augment(new Uint8Array(length))\n  } else {\n    // Fallback: Return THIS instance of Buffer (created by `new`)\n    buf = this\n    buf.length = length\n    buf._isBuffer = true\n  }\n\n  var i\n  if (TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {\n    // Speed optimization -- use set if we're copying from a typed array\n    buf._set(subject)\n  } else if (isArrayish(subject)) {\n    // Treat array-ish objects as a byte array\n    if (Buffer.isBuffer(subject)) {\n      for (i = 0; i < length; i++)\n        buf[i] = subject.readUInt8(i)\n    } else {\n      for (i = 0; i < length; i++)\n        buf[i] = ((subject[i] % 256) + 256) % 256\n    }\n  } else if (type === 'string') {\n    buf.write(subject, 0, encoding)\n  } else if (type === 'number' && !TYPED_ARRAY_SUPPORT && !noZero) {\n    for (i = 0; i < length; i++) {\n      buf[i] = 0\n    }\n  }\n\n  return buf\n}\n\n// STATIC METHODS\n// ==============\n\nBuffer.isEncoding = function (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.isBuffer = function (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.byteLength = function (str, encoding) {\n  var ret\n  str = str.toString()\n  switch (encoding || 'utf8') {\n    case 'hex':\n      ret = str.length / 2\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = utf8ToBytes(str).length\n      break\n    case 'ascii':\n    case 'binary':\n    case 'raw':\n      ret = str.length\n      break\n    case 'base64':\n      ret = base64ToBytes(str).length\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = str.length * 2\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.concat = function (list, totalLength) {\n  assert(isArray(list), 'Usage: Buffer.concat(list[, length])')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  } else if (list.length === 1) {\n    return list[0]\n  }\n\n  var i\n  if (totalLength === undefined) {\n    totalLength = 0\n    for (i = 0; i < list.length; i++) {\n      totalLength += list[i].length\n    }\n  }\n\n  var buf = new Buffer(totalLength)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nBuffer.compare = function (a, b) {\n  assert(Buffer.isBuffer(a) && Buffer.isBuffer(b), 'Arguments must be Buffers')\n  var x = a.length\n  var y = b.length\n  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n  if (x < y) {\n    return -1\n  }\n  if (y < x) {\n    return 1\n  }\n  return 0\n}\n\n// BUFFER INSTANCE METHODS\n// =======================\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  assert(strLen % 2 === 0, 'Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16)\n    assert(!isNaN(byte), 'Invalid hex string')\n    buf[offset + i] = byte\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction utf16leWrite (buf, string, offset, length) {\n  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nBuffer.prototype.write = function (string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length\n      length = undefined\n    }\n  } else {  // legacy\n    var swap = encoding\n    encoding = offset\n    offset = length\n    length = swap\n  }\n\n  offset = Number(offset) || 0\n  var remaining = this.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase()\n\n  var ret\n  switch (encoding) {\n    case 'hex':\n      ret = hexWrite(this, string, offset, length)\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = utf8Write(this, string, offset, length)\n      break\n    case 'ascii':\n      ret = asciiWrite(this, string, offset, length)\n      break\n    case 'binary':\n      ret = binaryWrite(this, string, offset, length)\n      break\n    case 'base64':\n      ret = base64Write(this, string, offset, length)\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = utf16leWrite(this, string, offset, length)\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.prototype.toString = function (encoding, start, end) {\n  var self = this\n\n  encoding = String(encoding || 'utf8').toLowerCase()\n  start = Number(start) || 0\n  end = (end === undefined) ? self.length : Number(end)\n\n  // Fastpath empty strings\n  if (end === start)\n    return ''\n\n  var ret\n  switch (encoding) {\n    case 'hex':\n      ret = hexSlice(self, start, end)\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = utf8Slice(self, start, end)\n      break\n    case 'ascii':\n      ret = asciiSlice(self, start, end)\n      break\n    case 'binary':\n      ret = binarySlice(self, start, end)\n      break\n    case 'base64':\n      ret = base64Slice(self, start, end)\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = utf16leSlice(self, start, end)\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.prototype.toJSON = function () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nBuffer.prototype.equals = function (b) {\n  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.compare = function (b) {\n  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')\n  return Buffer.compare(this, b)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function (target, target_start, start, end) {\n  var source = this\n\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (!target_start) target_start = 0\n\n  // Copy 0 bytes; we're done\n  if (end === start) return\n  if (target.length === 0 || source.length === 0) return\n\n  // Fatal error conditions\n  assert(end >= start, 'sourceEnd < sourceStart')\n  assert(target_start >= 0 && target_start < target.length,\n      'targetStart out of bounds')\n  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')\n  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length)\n    end = this.length\n  if (target.length - target_start < end - start)\n    end = target.length - target_start + start\n\n  var len = end - start\n\n  if (len < 100 || !TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < len; i++) {\n      target[i + target_start] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), target_start)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  var res = ''\n  var tmp = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    if (buf[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])\n      tmp = ''\n    } else {\n      tmp += '%' + buf[i].toString(16)\n    }\n  }\n\n  return res + decodeUtf8Char(tmp)\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  return asciiSlice(buf, start, end)\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len;\n    if (start < 0)\n      start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0)\n      end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start)\n    end = start\n\n  if (TYPED_ARRAY_SUPPORT) {\n    return Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    var newBuf = new Buffer(sliceLen, undefined, true)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n    return newBuf\n  }\n}\n\n// `get` will be removed in Node 0.13+\nBuffer.prototype.get = function (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` will be removed in Node 0.13+\nBuffer.prototype.set = function (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nBuffer.prototype.readUInt8 = function (offset, noAssert) {\n  if (!noAssert) {\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'Trying to read beyond buffer length')\n  }\n\n  if (offset >= this.length)\n    return\n\n  return this[offset]\n}\n\nfunction readUInt16 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val\n  if (littleEndian) {\n    val = buf[offset]\n    if (offset + 1 < len)\n      val |= buf[offset + 1] << 8\n  } else {\n    val = buf[offset] << 8\n    if (offset + 1 < len)\n      val |= buf[offset + 1]\n  }\n  return val\n}\n\nBuffer.prototype.readUInt16LE = function (offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readUInt16BE = function (offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert)\n}\n\nfunction readUInt32 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val\n  if (littleEndian) {\n    if (offset + 2 < len)\n      val = buf[offset + 2] << 16\n    if (offset + 1 < len)\n      val |= buf[offset + 1] << 8\n    val |= buf[offset]\n    if (offset + 3 < len)\n      val = val + (buf[offset + 3] << 24 >>> 0)\n  } else {\n    if (offset + 1 < len)\n      val = buf[offset + 1] << 16\n    if (offset + 2 < len)\n      val |= buf[offset + 2] << 8\n    if (offset + 3 < len)\n      val |= buf[offset + 3]\n    val = val + (buf[offset] << 24 >>> 0)\n  }\n  return val\n}\n\nBuffer.prototype.readUInt32LE = function (offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readUInt32BE = function (offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert)\n}\n\nBuffer.prototype.readInt8 = function (offset, noAssert) {\n  if (!noAssert) {\n    assert(offset !== undefined && offset !== null,\n        'missing offset')\n    assert(offset < this.length, 'Trying to read beyond buffer length')\n  }\n\n  if (offset >= this.length)\n    return\n\n  var neg = this[offset] & 0x80\n  if (neg)\n    return (0xff - this[offset] + 1) * -1\n  else\n    return this[offset]\n}\n\nfunction readInt16 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val = readUInt16(buf, offset, littleEndian, true)\n  var neg = val & 0x8000\n  if (neg)\n    return (0xffff - val + 1) * -1\n  else\n    return val\n}\n\nBuffer.prototype.readInt16LE = function (offset, noAssert) {\n  return readInt16(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readInt16BE = function (offset, noAssert) {\n  return readInt16(this, offset, false, noAssert)\n}\n\nfunction readInt32 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val = readUInt32(buf, offset, littleEndian, true)\n  var neg = val & 0x80000000\n  if (neg)\n    return (0xffffffff - val + 1) * -1\n  else\n    return val\n}\n\nBuffer.prototype.readInt32LE = function (offset, noAssert) {\n  return readInt32(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readInt32BE = function (offset, noAssert) {\n  return readInt32(this, offset, false, noAssert)\n}\n\nfunction readFloat (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  return ieee754.read(buf, offset, littleEndian, 23, 4)\n}\n\nBuffer.prototype.readFloatLE = function (offset, noAssert) {\n  return readFloat(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readFloatBE = function (offset, noAssert) {\n  return readFloat(this, offset, false, noAssert)\n}\n\nfunction readDouble (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  return ieee754.read(buf, offset, littleEndian, 52, 8)\n}\n\nBuffer.prototype.readDoubleLE = function (offset, noAssert) {\n  return readDouble(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readDoubleBE = function (offset, noAssert) {\n  return readDouble(this, offset, false, noAssert)\n}\n\nBuffer.prototype.writeUInt8 = function (value, offset, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xff)\n  }\n\n  if (offset >= this.length) return\n\n  this[offset] = value\n  return offset + 1\n}\n\nfunction writeUInt16 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xffff)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {\n    buf[offset + i] =\n        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n            (littleEndian ? i : 1 - i) * 8\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16LE = function (value, offset, noAssert) {\n  return writeUInt16(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeUInt16BE = function (value, offset, noAssert) {\n  return writeUInt16(this, value, offset, false, noAssert)\n}\n\nfunction writeUInt32 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xffffffff)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {\n    buf[offset + i] =\n        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32LE = function (value, offset, noAssert) {\n  return writeUInt32(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeUInt32BE = function (value, offset, noAssert) {\n  return writeUInt32(this, value, offset, false, noAssert)\n}\n\nBuffer.prototype.writeInt8 = function (value, offset, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7f, -0x80)\n  }\n\n  if (offset >= this.length)\n    return\n\n  if (value >= 0)\n    this.writeUInt8(value, offset, noAssert)\n  else\n    this.writeUInt8(0xff + value + 1, offset, noAssert)\n  return offset + 1\n}\n\nfunction writeInt16 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7fff, -0x8000)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  if (value >= 0)\n    writeUInt16(buf, value, offset, littleEndian, noAssert)\n  else\n    writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16LE = function (value, offset, noAssert) {\n  return writeInt16(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeInt16BE = function (value, offset, noAssert) {\n  return writeInt16(this, value, offset, false, noAssert)\n}\n\nfunction writeInt32 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7fffffff, -0x80000000)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  if (value >= 0)\n    writeUInt32(buf, value, offset, littleEndian, noAssert)\n  else\n    writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32LE = function (value, offset, noAssert) {\n  return writeInt32(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeInt32BE = function (value, offset, noAssert) {\n  return writeInt32(this, value, offset, false, noAssert)\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 7 < buf.length,\n        'Trying to write beyond buffer length')\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  assert(end >= start, 'end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  assert(start >= 0 && start < this.length, 'start out of bounds')\n  assert(end >= 0 && end <= this.length, 'end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\nBuffer.prototype.inspect = function () {\n  var out = []\n  var len = this.length\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i])\n    if (i === exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...'\n      break\n    }\n  }\n  return '<Buffer ' + out.join(' ') + '>'\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new Error('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function (arr) {\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array get/set methods before overwriting\n  arr._get = arr.get\n  arr._set = arr.set\n\n  // deprecated, will be removed in node 0.13+\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-z]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction isArray (subject) {\n  return (Array.isArray || function (subject) {\n    return Object.prototype.toString.call(subject) === '[object Array]'\n  })(subject)\n}\n\nfunction isArrayish (subject) {\n  return isArray(subject) || Buffer.isBuffer(subject) ||\n      subject && typeof subject === 'object' &&\n      typeof subject.length === 'number'\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    var b = str.charCodeAt(i)\n    if (b <= 0x7F) {\n      byteArray.push(b)\n    } else {\n      var start = i\n      if (b >= 0xD800 && b <= 0xDFFF) i++\n      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')\n      for (var j = 0; j < h.length; j++) {\n        byteArray.push(parseInt(h[j], 16))\n      }\n    }\n  }\n  return byteArray\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(str)\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length))\n      break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction decodeUtf8Char (str) {\n  try {\n    return decodeURIComponent(str)\n  } catch (err) {\n    return String.fromCharCode(0xFFFD) // UTF 8 invalid char\n  }\n}\n\n/*\n * We have to make sure that the value is a valid integer. This means that it\n * is non-negative. It has no fractional component and that it does not\n * exceed the maximum allowed value.\n */\nfunction verifuint (value, max) {\n\n  return // TESTING ONLY!!!!!!!!!!!!!!!!!!!\n\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value >= 0, 'specified a negative value for writing an unsigned value')\n  assert(value <= max, 'value is larger than maximum value for type')\n  assert(Math.floor(value) === value, 'value has a fractional component')\n}\n\nfunction verifsint (value, max, min) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value <= max, 'value larger than maximum allowed value')\n  assert(value >= min, 'value smaller than minimum allowed value')\n  assert(Math.floor(value) === value, 'value has a fractional component')\n}\n\nfunction verifIEEE754 (value, max, min) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value <= max, 'value larger than maximum allowed value')\n  assert(value >= min, 'value smaller than minimum allowed value')\n}\n\nfunction assert (test, message) {\n  if (!test) throw new Error(message || 'Failed assertion')\n}\n\n},{\"base64-js\":81,\"ieee754\":82}],81:[function(require,module,exports){\nvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n  'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n  var PLUS   = '+'.charCodeAt(0)\n  var SLASH  = '/'.charCodeAt(0)\n  var NUMBER = '0'.charCodeAt(0)\n  var LOWER  = 'a'.charCodeAt(0)\n  var UPPER  = 'A'.charCodeAt(0)\n\n  function decode (elt) {\n    var code = elt.charCodeAt(0)\n    if (code === PLUS)\n      return 62 // '+'\n    if (code === SLASH)\n      return 63 // '/'\n    if (code < NUMBER)\n      return -1 //no match\n    if (code < NUMBER + 10)\n      return code - NUMBER + 26 + 26\n    if (code < UPPER + 26)\n      return code - UPPER\n    if (code < LOWER + 26)\n      return code - LOWER + 26\n  }\n\n  function b64ToByteArray (b64) {\n    var i, j, l, tmp, placeHolders, arr\n\n    if (b64.length % 4 > 0) {\n      throw new Error('Invalid string. Length must be a multiple of 4')\n    }\n\n    // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n    var len = b64.length\n    placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n    // base64 is 4/3 + up to two characters of the original data\n    arr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n    // if there are placeholders, only get up to the last complete 4 chars\n    l = placeHolders > 0 ? b64.length - 4 : b64.length\n\n    var L = 0\n\n    function push (v) {\n      arr[L++] = v\n    }\n\n    for (i = 0, j = 0; i < l; i += 4, j += 3) {\n      tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n      push((tmp & 0xFF0000) >> 16)\n      push((tmp & 0xFF00) >> 8)\n      push(tmp & 0xFF)\n    }\n\n    if (placeHolders === 2) {\n      tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n      push(tmp & 0xFF)\n    } else if (placeHolders === 1) {\n      tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n      push((tmp >> 8) & 0xFF)\n      push(tmp & 0xFF)\n    }\n\n    return arr\n  }\n\n  function uint8ToBase64 (uint8) {\n    var i,\n      extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n      output = \"\",\n      temp, length\n\n    function encode (num) {\n      return lookup.charAt(num)\n    }\n\n    function tripletToBase64 (num) {\n      return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n    }\n\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n      temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n      output += tripletToBase64(temp)\n    }\n\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    switch (extraBytes) {\n      case 1:\n        temp = uint8[uint8.length - 1]\n        output += encode(temp >> 2)\n        output += encode((temp << 4) & 0x3F)\n        output += '=='\n        break\n      case 2:\n        temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n        output += encode(temp >> 10)\n        output += encode((temp >> 4) & 0x3F)\n        output += encode((temp << 2) & 0x3F)\n        output += '='\n        break\n    }\n\n    return output\n  }\n\n  exports.toByteArray = b64ToByteArray\n  exports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n},{}],82:[function(require,module,exports){\nexports.read = function(buffer, offset, isLE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isLE ? (nBytes - 1) : 0,\n      d = isLE ? -1 : 1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isLE ? 0 : (nBytes - 1),\n      d = isLE ? 1 : -1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n},{}],83:[function(require,module,exports){\n(function (Buffer){\nvar createHash = require('sha.js')\n\nvar md5 = toConstructor(require('./md5'))\nvar rmd160 = toConstructor(require('ripemd160'))\n\nfunction toConstructor (fn) {\n  return function () {\n    var buffers = []\n    var m= {\n      update: function (data, enc) {\n        if(!Buffer.isBuffer(data)) data = new Buffer(data, enc)\n        buffers.push(data)\n        return this\n      },\n      digest: function (enc) {\n        var buf = Buffer.concat(buffers)\n        var r = fn(buf)\n        buffers = null\n        return enc ? r.toString(enc) : r\n      }\n    }\n    return m\n  }\n}\n\nmodule.exports = function (alg) {\n  if('md5' === alg) return new md5()\n  if('rmd160' === alg) return new rmd160()\n  return createHash(alg)\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./md5\":87,\"buffer\":80,\"ripemd160\":88,\"sha.js\":90}],84:[function(require,module,exports){\n(function (Buffer){\nvar createHash = require('./create-hash')\n\nvar blocksize = 64\nvar zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)\n\nmodule.exports = Hmac\n\nfunction Hmac (alg, key) {\n  if(!(this instanceof Hmac)) return new Hmac(alg, key)\n  this._opad = opad\n  this._alg = alg\n\n  key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key\n\n  if(key.length > blocksize) {\n    key = createHash(alg).update(key).digest()\n  } else if(key.length < blocksize) {\n    key = Buffer.concat([key, zeroBuffer], blocksize)\n  }\n\n  var ipad = this._ipad = new Buffer(blocksize)\n  var opad = this._opad = new Buffer(blocksize)\n\n  for(var i = 0; i < blocksize; i++) {\n    ipad[i] = key[i] ^ 0x36\n    opad[i] = key[i] ^ 0x5C\n  }\n\n  this._hash = createHash(alg).update(ipad)\n}\n\nHmac.prototype.update = function (data, enc) {\n  this._hash.update(data, enc)\n  return this\n}\n\nHmac.prototype.digest = function (enc) {\n  var h = this._hash.digest()\n  return createHash(this._alg).update(this._opad).update(h).digest(enc)\n}\n\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./create-hash\":83,\"buffer\":80}],85:[function(require,module,exports){\n(function (Buffer){\nvar intSize = 4;\nvar zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);\nvar chrsz = 8;\n\nfunction toArray(buf, bigEndian) {\n  if ((buf.length % intSize) !== 0) {\n    var len = buf.length + (intSize - (buf.length % intSize));\n    buf = Buffer.concat([buf, zeroBuffer], len);\n  }\n\n  var arr = [];\n  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;\n  for (var i = 0; i < buf.length; i += intSize) {\n    arr.push(fn.call(buf, i));\n  }\n  return arr;\n}\n\nfunction toBuffer(arr, size, bigEndian) {\n  var buf = new Buffer(size);\n  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;\n  for (var i = 0; i < arr.length; i++) {\n    fn.call(buf, arr[i], i * 4, true);\n  }\n  return buf;\n}\n\nfunction hash(buf, fn, hashSize, bigEndian) {\n  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);\n  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);\n  return toBuffer(arr, hashSize, bigEndian);\n}\n\nmodule.exports = { hash: hash };\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":80}],86:[function(require,module,exports){\n(function (Buffer){\nvar rng = require('./rng')\n\nfunction error () {\n  var m = [].slice.call(arguments).join(' ')\n  throw new Error([\n    m,\n    'we accept pull requests',\n    'http://github.com/dominictarr/crypto-browserify'\n    ].join('\\n'))\n}\n\nexports.createHash = require('./create-hash')\n\nexports.createHmac = require('./create-hmac')\n\nexports.randomBytes = function(size, callback) {\n  if (callback && callback.call) {\n    try {\n      callback.call(this, undefined, new Buffer(rng(size)))\n    } catch (err) { callback(err) }\n  } else {\n    return new Buffer(rng(size))\n  }\n}\n\nfunction each(a, f) {\n  for(var i in a)\n    f(a[i], i)\n}\n\nexports.getHashes = function () {\n  return ['sha1', 'sha256', 'md5', 'rmd160']\n\n}\n\nvar p = require('./pbkdf2')(exports.createHmac)\nexports.pbkdf2 = p.pbkdf2\nexports.pbkdf2Sync = p.pbkdf2Sync\n\n\n// the least I can do is make error messages for the rest of the node.js/crypto api.\neach(['createCredentials'\n, 'createCipher'\n, 'createCipheriv'\n, 'createDecipher'\n, 'createDecipheriv'\n, 'createSign'\n, 'createVerify'\n, 'createDiffieHellman'\n], function (name) {\n  exports[name] = function () {\n    error('sorry,', name, 'is not implemented yet')\n  }\n})\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./create-hash\":83,\"./create-hmac\":84,\"./pbkdf2\":94,\"./rng\":95,\"buffer\":80}],87:[function(require,module,exports){\n/*\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\n\nvar helpers = require('./helpers');\n\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length\n */\nfunction core_md5(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << ((len) % 32);\n  x[(((len + 64) >>> 9) << 4) + 14] = len;\n\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n\n    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);\n    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);\n    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);\n    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);\n    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);\n    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);\n    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);\n    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);\n    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);\n    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);\n    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);\n    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);\n    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);\n    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);\n    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);\n    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);\n\n    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);\n    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);\n    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);\n    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);\n    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);\n    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);\n    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);\n    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);\n    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);\n    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);\n    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);\n    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);\n    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);\n    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);\n    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);\n    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);\n\n    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);\n    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);\n    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);\n    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);\n    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);\n    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);\n    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);\n    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);\n    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);\n    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);\n    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);\n    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);\n    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);\n    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);\n    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);\n    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);\n\n    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);\n    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);\n    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);\n    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);\n    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);\n    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);\n    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);\n    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);\n    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);\n    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);\n    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);\n    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);\n    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);\n    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);\n    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);\n    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n  }\n  return Array(a, b, c, d);\n\n}\n\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\nfunction md5_cmn(q, a, b, x, s, t)\n{\n  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);\n}\nfunction md5_ff(a, b, c, d, x, s, t)\n{\n  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\n}\nfunction md5_gg(a, b, c, d, x, s, t)\n{\n  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\n}\nfunction md5_hh(a, b, c, d, x, s, t)\n{\n  return md5_cmn(b ^ c ^ d, a, b, x, s, t);\n}\nfunction md5_ii(a, b, c, d, x, s, t)\n{\n  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction bit_rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\nmodule.exports = function md5(buf) {\n  return helpers.hash(buf, core_md5, 16);\n};\n\n},{\"./helpers\":85}],88:[function(require,module,exports){\n(function (Buffer){\n\nmodule.exports = ripemd160\n\n\n\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n/** @preserve\n(c) 2012 by Cdric Mesnil. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n// Constants table\nvar zl = [\n    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n    7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,\n    3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,\n    1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,\n    4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13];\nvar zr = [\n    5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,\n    6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,\n    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,\n    8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,\n    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11];\nvar sl = [\n     11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,\n    7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,\n    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,\n      11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,\n    9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ];\nvar sr = [\n    8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,\n    9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,\n    9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,\n    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,\n    8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ];\n\nvar hl =  [ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];\nvar hr =  [ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];\n\nvar bytesToWords = function (bytes) {\n  var words = [];\n  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {\n    words[b >>> 5] |= bytes[i] << (24 - b % 32);\n  }\n  return words;\n};\n\nvar wordsToBytes = function (words) {\n  var bytes = [];\n  for (var b = 0; b < words.length * 32; b += 8) {\n    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);\n  }\n  return bytes;\n};\n\nvar processBlock = function (H, M, offset) {\n\n  // Swap endian\n  for (var i = 0; i < 16; i++) {\n    var offset_i = offset + i;\n    var M_offset_i = M[offset_i];\n\n    // Swap\n    M[offset_i] = (\n        (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |\n        (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)\n    );\n  }\n\n  // Working variables\n  var al, bl, cl, dl, el;\n  var ar, br, cr, dr, er;\n\n  ar = al = H[0];\n  br = bl = H[1];\n  cr = cl = H[2];\n  dr = dl = H[3];\n  er = el = H[4];\n  // Computation\n  var t;\n  for (var i = 0; i < 80; i += 1) {\n    t = (al +  M[offset+zl[i]])|0;\n    if (i<16){\n        t +=  f1(bl,cl,dl) + hl[0];\n    } else if (i<32) {\n        t +=  f2(bl,cl,dl) + hl[1];\n    } else if (i<48) {\n        t +=  f3(bl,cl,dl) + hl[2];\n    } else if (i<64) {\n        t +=  f4(bl,cl,dl) + hl[3];\n    } else {// if (i<80) {\n        t +=  f5(bl,cl,dl) + hl[4];\n    }\n    t = t|0;\n    t =  rotl(t,sl[i]);\n    t = (t+el)|0;\n    al = el;\n    el = dl;\n    dl = rotl(cl, 10);\n    cl = bl;\n    bl = t;\n\n    t = (ar + M[offset+zr[i]])|0;\n    if (i<16){\n        t +=  f5(br,cr,dr) + hr[0];\n    } else if (i<32) {\n        t +=  f4(br,cr,dr) + hr[1];\n    } else if (i<48) {\n        t +=  f3(br,cr,dr) + hr[2];\n    } else if (i<64) {\n        t +=  f2(br,cr,dr) + hr[3];\n    } else {// if (i<80) {\n        t +=  f1(br,cr,dr) + hr[4];\n    }\n    t = t|0;\n    t =  rotl(t,sr[i]) ;\n    t = (t+er)|0;\n    ar = er;\n    er = dr;\n    dr = rotl(cr, 10);\n    cr = br;\n    br = t;\n  }\n  // Intermediate hash value\n  t    = (H[1] + cl + dr)|0;\n  H[1] = (H[2] + dl + er)|0;\n  H[2] = (H[3] + el + ar)|0;\n  H[3] = (H[4] + al + br)|0;\n  H[4] = (H[0] + bl + cr)|0;\n  H[0] =  t;\n};\n\nfunction f1(x, y, z) {\n  return ((x) ^ (y) ^ (z));\n}\n\nfunction f2(x, y, z) {\n  return (((x)&(y)) | ((~x)&(z)));\n}\n\nfunction f3(x, y, z) {\n  return (((x) | (~(y))) ^ (z));\n}\n\nfunction f4(x, y, z) {\n  return (((x) & (z)) | ((y)&(~(z))));\n}\n\nfunction f5(x, y, z) {\n  return ((x) ^ ((y) |(~(z))));\n}\n\nfunction rotl(x,n) {\n  return (x<<n) | (x>>>(32-n));\n}\n\nfunction ripemd160(message) {\n  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];\n\n  if (typeof message == 'string')\n    message = new Buffer(message, 'utf8');\n\n  var m = bytesToWords(message);\n\n  var nBitsLeft = message.length * 8;\n  var nBitsTotal = message.length * 8;\n\n  // Add padding\n  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n      (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |\n      (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)\n  );\n\n  for (var i=0 ; i<m.length; i += 16) {\n    processBlock(H, m, i);\n  }\n\n  // Swap endian\n  for (var i = 0; i < 5; i++) {\n      // Shortcut\n    var H_i = H[i];\n\n    // Swap\n    H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |\n          (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);\n  }\n\n  var digestbytes = wordsToBytes(H);\n  return new Buffer(digestbytes);\n}\n\n\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":80}],89:[function(require,module,exports){\nvar u = require('./util')\nvar write = u.write\nvar fill = u.zeroFill\n\nmodule.exports = function (Buffer) {\n\n  //prototype class for hash functions\n  function Hash (blockSize, finalSize) {\n    this._block = new Buffer(blockSize) //new Uint32Array(blockSize/4)\n    this._finalSize = finalSize\n    this._blockSize = blockSize\n    this._len = 0\n    this._s = 0\n  }\n\n  Hash.prototype.init = function () {\n    this._s = 0\n    this._len = 0\n  }\n\n  function lengthOf(data, enc) {\n    if(enc == null)     return data.byteLength || data.length\n    if(enc == 'ascii' || enc == 'binary')  return data.length\n    if(enc == 'hex')    return data.length/2\n    if(enc == 'base64') return data.length/3\n  }\n\n  Hash.prototype.update = function (data, enc) {\n    var bl = this._blockSize\n\n    //I'd rather do this with a streaming encoder, like the opposite of\n    //http://nodejs.org/api/string_decoder.html\n    var length\n      if(!enc && 'string' === typeof data)\n        enc = 'utf8'\n\n    if(enc) {\n      if(enc === 'utf-8')\n        enc = 'utf8'\n\n      if(enc === 'base64' || enc === 'utf8')\n        data = new Buffer(data, enc), enc = null\n\n      length = lengthOf(data, enc)\n    } else\n      length = data.byteLength || data.length\n\n    var l = this._len += length\n    var s = this._s = (this._s || 0)\n    var f = 0\n    var buffer = this._block\n    while(s < l) {\n      var t = Math.min(length, f + bl - s%bl)\n      write(buffer, data, enc, s%bl, f, t)\n      var ch = (t - f);\n      s += ch; f += ch\n\n      if(!(s%bl))\n        this._update(buffer)\n    }\n    this._s = s\n\n    return this\n\n  }\n\n  Hash.prototype.digest = function (enc) {\n    var bl = this._blockSize\n    var fl = this._finalSize\n    var len = this._len*8\n\n    var x = this._block\n\n    var bits = len % (bl*8)\n\n    //add end marker, so that appending 0's creats a different hash.\n    x[this._len % bl] = 0x80\n    fill(this._block, this._len % bl + 1)\n\n    if(bits >= fl*8) {\n      this._update(this._block)\n      u.zeroFill(this._block, 0)\n    }\n\n    //TODO: handle case where the bit length is > Math.pow(2, 29)\n    x.writeInt32BE(len, fl + 4) //big endian\n\n    var hash = this._update(this._block) || this._hash()\n    if(enc == null) return hash\n    return hash.toString(enc)\n  }\n\n  Hash.prototype._update = function () {\n    throw new Error('_update must be implemented by subclass')\n  }\n\n  return Hash\n}\n\n},{\"./util\":93}],90:[function(require,module,exports){\nvar exports = module.exports = function (alg) {\n  var Alg = exports[alg]\n  if(!Alg) throw new Error(alg + ' is not supported (we accept pull requests)')\n  return new Alg()\n}\n\nvar Buffer = require('buffer').Buffer\nvar Hash   = require('./hash')(Buffer)\n\nexports.sha =\nexports.sha1 = require('./sha1')(Buffer, Hash)\nexports.sha256 = require('./sha256')(Buffer, Hash)\n\n},{\"./hash\":89,\"./sha1\":91,\"./sha256\":92,\"buffer\":80}],91:[function(require,module,exports){\n/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\nmodule.exports = function (Buffer, Hash) {\n\n  var inherits = require('util').inherits\n\n  inherits(Sha1, Hash)\n\n  var A = 0|0\n  var B = 4|0\n  var C = 8|0\n  var D = 12|0\n  var E = 16|0\n\n  var BE = false\n  var LE = true\n\n  var W = new Int32Array(80)\n\n  var POOL = []\n\n  function Sha1 () {\n    if(POOL.length)\n      return POOL.pop().init()\n\n    if(!(this instanceof Sha1)) return new Sha1()\n    this._w = W\n    Hash.call(this, 16*4, 14*4)\n\n    this._h = null\n    this.init()\n  }\n\n  Sha1.prototype.init = function () {\n    this._a = 0x67452301\n    this._b = 0xefcdab89\n    this._c = 0x98badcfe\n    this._d = 0x10325476\n    this._e = 0xc3d2e1f0\n\n    Hash.prototype.init.call(this)\n    return this\n  }\n\n  Sha1.prototype._POOL = POOL\n\n  // assume that array is a Uint32Array with length=16,\n  // and that if it is the last block, it already has the length and the 1 bit appended.\n\n\n  var isDV = new Buffer(1) instanceof DataView\n  function readInt32BE (X, i) {\n    return isDV\n      ? X.getInt32(i, false)\n      : X.readInt32BE(i)\n  }\n\n  Sha1.prototype._update = function (array) {\n\n    var X = this._block\n    var h = this._h\n    var a, b, c, d, e, _a, _b, _c, _d, _e\n\n    a = _a = this._a\n    b = _b = this._b\n    c = _c = this._c\n    d = _d = this._d\n    e = _e = this._e\n\n    var w = this._w\n\n    for(var j = 0; j < 80; j++) {\n      var W = w[j]\n        = j < 16\n        //? X.getInt32(j*4, false)\n        //? readInt32BE(X, j*4) //*/ X.readInt32BE(j*4) //*/\n        ? X.readInt32BE(j*4)\n        : rol(w[j - 3] ^ w[j -  8] ^ w[j - 14] ^ w[j - 16], 1)\n\n      var t =\n        add(\n          add(rol(a, 5), sha1_ft(j, b, c, d)),\n          add(add(e, W), sha1_kt(j))\n        );\n\n      e = d\n      d = c\n      c = rol(b, 30)\n      b = a\n      a = t\n    }\n\n    this._a = add(a, _a)\n    this._b = add(b, _b)\n    this._c = add(c, _c)\n    this._d = add(d, _d)\n    this._e = add(e, _e)\n  }\n\n  Sha1.prototype._hash = function () {\n    if(POOL.length < 100) POOL.push(this)\n    var H = new Buffer(20)\n    //console.log(this._a|0, this._b|0, this._c|0, this._d|0, this._e|0)\n    H.writeInt32BE(this._a|0, A)\n    H.writeInt32BE(this._b|0, B)\n    H.writeInt32BE(this._c|0, C)\n    H.writeInt32BE(this._d|0, D)\n    H.writeInt32BE(this._e|0, E)\n    return H\n  }\n\n  /*\n   * Perform the appropriate triplet combination function for the current\n   * iteration\n   */\n  function sha1_ft(t, b, c, d) {\n    if(t < 20) return (b & c) | ((~b) & d);\n    if(t < 40) return b ^ c ^ d;\n    if(t < 60) return (b & c) | (b & d) | (c & d);\n    return b ^ c ^ d;\n  }\n\n  /*\n   * Determine the appropriate additive constant for the current iteration\n   */\n  function sha1_kt(t) {\n    return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\n           (t < 60) ? -1894007588 : -899497514;\n  }\n\n  /*\n   * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n   * to work around bugs in some JS interpreters.\n   * //dominictarr: this is 10 years old, so maybe this can be dropped?)\n   *\n   */\n  function add(x, y) {\n    return (x + y ) | 0\n  //lets see how this goes on testling.\n  //  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  //  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  //  return (msw << 16) | (lsw & 0xFFFF);\n  }\n\n  /*\n   * Bitwise rotate a 32-bit number to the left.\n   */\n  function rol(num, cnt) {\n    return (num << cnt) | (num >>> (32 - cnt));\n  }\n\n  return Sha1\n}\n\n},{\"util\":114}],92:[function(require,module,exports){\n\n/**\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\n * in FIPS 180-2\n * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n *\n */\n\nvar inherits = require('util').inherits\nvar BE       = false\nvar LE       = true\nvar u        = require('./util')\n\nmodule.exports = function (Buffer, Hash) {\n\n  var K = [\n      0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,\n      0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,\n      0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,\n      0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,\n      0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,\n      0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,\n      0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,\n      0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,\n      0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,\n      0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,\n      0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,\n      0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,\n      0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,\n      0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,\n      0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,\n      0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2\n    ]\n\n  inherits(Sha256, Hash)\n  var W = new Array(64)\n  var POOL = []\n  function Sha256() {\n    if(POOL.length) {\n      //return POOL.shift().init()\n    }\n    //this._data = new Buffer(32)\n\n    this.init()\n\n    this._w = W //new Array(64)\n\n    Hash.call(this, 16*4, 14*4)\n  };\n\n  Sha256.prototype.init = function () {\n\n    this._a = 0x6a09e667|0\n    this._b = 0xbb67ae85|0\n    this._c = 0x3c6ef372|0\n    this._d = 0xa54ff53a|0\n    this._e = 0x510e527f|0\n    this._f = 0x9b05688c|0\n    this._g = 0x1f83d9ab|0\n    this._h = 0x5be0cd19|0\n\n    this._len = this._s = 0\n\n    return this\n  }\n\n  var safe_add = function(x, y) {\n    var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n    return (msw << 16) | (lsw & 0xFFFF);\n  }\n\n  function S (X, n) {\n    return (X >>> n) | (X << (32 - n));\n  }\n\n  function R (X, n) {\n    return (X >>> n);\n  }\n\n  function Ch (x, y, z) {\n    return ((x & y) ^ ((~x) & z));\n  }\n\n  function Maj (x, y, z) {\n    return ((x & y) ^ (x & z) ^ (y & z));\n  }\n\n  function Sigma0256 (x) {\n    return (S(x, 2) ^ S(x, 13) ^ S(x, 22));\n  }\n\n  function Sigma1256 (x) {\n    return (S(x, 6) ^ S(x, 11) ^ S(x, 25));\n  }\n\n  function Gamma0256 (x) {\n    return (S(x, 7) ^ S(x, 18) ^ R(x, 3));\n  }\n\n  function Gamma1256 (x) {\n    return (S(x, 17) ^ S(x, 19) ^ R(x, 10));\n  }\n\n  Sha256.prototype._update = function(m) {\n    var M = this._block\n    var W = this._w\n    var a, b, c, d, e, f, g, h\n    var T1, T2\n\n    a = this._a | 0\n    b = this._b | 0\n    c = this._c | 0\n    d = this._d | 0\n    e = this._e | 0\n    f = this._f | 0\n    g = this._g | 0\n    h = this._h | 0\n\n    for (var j = 0; j < 64; j++) {\n      var w = W[j] = j < 16\n        ? M.readInt32BE(j * 4)\n        : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16]\n\n      T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w\n\n      T2 = Sigma0256(a) + Maj(a, b, c);\n      h = g; g = f; f = e; e = d + T1; d = c; c = b; b = a; a = T1 + T2;\n    }\n\n    this._a = (a + this._a) | 0\n    this._b = (b + this._b) | 0\n    this._c = (c + this._c) | 0\n    this._d = (d + this._d) | 0\n    this._e = (e + this._e) | 0\n    this._f = (f + this._f) | 0\n    this._g = (g + this._g) | 0\n    this._h = (h + this._h) | 0\n\n  };\n\n  Sha256.prototype._hash = function () {\n    if(POOL.length < 10)\n      POOL.push(this)\n\n    var H = new Buffer(32)\n\n    H.writeInt32BE(this._a,  0)\n    H.writeInt32BE(this._b,  4)\n    H.writeInt32BE(this._c,  8)\n    H.writeInt32BE(this._d, 12)\n    H.writeInt32BE(this._e, 16)\n    H.writeInt32BE(this._f, 20)\n    H.writeInt32BE(this._g, 24)\n    H.writeInt32BE(this._h, 28)\n\n    return H\n  }\n\n  return Sha256\n\n}\n\n},{\"./util\":93,\"util\":114}],93:[function(require,module,exports){\nexports.write = write\nexports.zeroFill = zeroFill\n\nexports.toString = toString\n\nfunction write (buffer, string, enc, start, from, to, LE) {\n  var l = (to - from)\n  if(enc === 'ascii' || enc === 'binary') {\n    for( var i = 0; i < l; i++) {\n      buffer[start + i] = string.charCodeAt(i + from)\n    }\n  }\n  else if(enc == null) {\n    for( var i = 0; i < l; i++) {\n      buffer[start + i] = string[i + from]\n    }\n  }\n  else if(enc === 'hex') {\n    for(var i = 0; i < l; i++) {\n      var j = from + i\n      buffer[start + i] = parseInt(string[j*2] + string[(j*2)+1], 16)\n    }\n  }\n  else if(enc === 'base64') {\n    throw new Error('base64 encoding not yet supported')\n  }\n  else\n    throw new Error(enc +' encoding not yet supported')\n}\n\n//always fill to the end!\nfunction zeroFill(buf, from) {\n  for(var i = from; i < buf.length; i++)\n    buf[i] = 0\n}\n\n\n},{}],94:[function(require,module,exports){\n(function (Buffer){\n// JavaScript PBKDF2 Implementation\n// Based on http://git.io/qsv2zw\n// Licensed under LGPL v3\n// Copyright (c) 2013 jduncanator\n\nvar blocksize = 64\nvar zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)\n\nmodule.exports = function (createHmac, exports) {\n  exports = exports || {}\n\n  exports.pbkdf2 = function(password, salt, iterations, keylen, cb) {\n    if('function' !== typeof cb)\n      throw new Error('No callback provided to pbkdf2');\n    setTimeout(function () {\n      cb(null, exports.pbkdf2Sync(password, salt, iterations, keylen))\n    })\n  }\n\n  exports.pbkdf2Sync = function(key, salt, iterations, keylen) {\n    if('number' !== typeof iterations)\n      throw new TypeError('Iterations not a number')\n    if(iterations < 0)\n      throw new TypeError('Bad iterations')\n    if('number' !== typeof keylen)\n      throw new TypeError('Key length not a number')\n    if(keylen < 0)\n      throw new TypeError('Bad key length')\n\n    //stretch key to the correct length that hmac wants it,\n    //otherwise this will happen every time hmac is called\n    //twice per iteration.\n    var key = !Buffer.isBuffer(key) ? new Buffer(key) : key\n\n    if(key.length > blocksize) {\n      key = createHash(alg).update(key).digest()\n    } else if(key.length < blocksize) {\n      key = Buffer.concat([key, zeroBuffer], blocksize)\n    }\n\n    var HMAC;\n    var cplen, p = 0, i = 1, itmp = new Buffer(4), digtmp;\n    var out = new Buffer(keylen);\n    out.fill(0);\n    while(keylen) {\n      if(keylen > 20)\n        cplen = 20;\n      else\n        cplen = keylen;\n\n      /* We are unlikely to ever use more than 256 blocks (5120 bits!)\n         * but just in case...\n         */\n        itmp[0] = (i >> 24) & 0xff;\n        itmp[1] = (i >> 16) & 0xff;\n          itmp[2] = (i >> 8) & 0xff;\n          itmp[3] = i & 0xff;\n\n          HMAC = createHmac('sha1', key);\n          HMAC.update(salt)\n          HMAC.update(itmp);\n        digtmp = HMAC.digest();\n        digtmp.copy(out, p, 0, cplen);\n\n        for(var j = 1; j < iterations; j++) {\n          HMAC = createHmac('sha1', key);\n          HMAC.update(digtmp);\n          digtmp = HMAC.digest();\n          for(var k = 0; k < cplen; k++) {\n            out[k] ^= digtmp[k];\n          }\n        }\n      keylen -= cplen;\n      i++;\n      p += cplen;\n    }\n\n    return out;\n  }\n\n  return exports\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":80}],95:[function(require,module,exports){\n(function (Buffer){\n(function() {\n  module.exports = function(size) {\n    var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array\n    /* This will not work in older browsers.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues\n     */\n    crypto.getRandomValues(bytes);\n    return bytes;\n  }\n}())\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":80}],96:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        throw TypeError('Uncaught, unspecified \"error\" event.');\n      }\n      return false;\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],97:[function(require,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n},{}],98:[function(require,module,exports){\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n},{}],99:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n},{}],100:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_duplex.js\")\n\n},{\"./lib/_stream_duplex.js\":101}],101:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nforEach(objectKeys(Writable.prototype), function(method) {\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n});\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(this.end.bind(this));\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\n}).call(this,require('_process'))\n},{\"./_stream_readable\":103,\"./_stream_writable\":105,\"_process\":99,\"core-util-is\":106,\"inherits\":97}],102:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n},{\"./_stream_transform\":104,\"core-util-is\":106,\"inherits\":97}],103:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events').EventEmitter;\n\n/*<replacement>*/\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\nvar Stream = require('stream');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  options = options || {};\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = false;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // In streams that never have any data, and do push(null) right away,\n  // the consumer can miss the 'end' event if they do some I/O before\n  // consuming the stream.  So, we don't emit('end') until some reading\n  // happens.\n  this.calledRead = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, becuase any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (typeof chunk === 'string' && !state.objectMode) {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null || chunk === undefined) {\n    state.reading = false;\n    if (!state.ended)\n      onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      // update the buffer info.\n      state.length += state.objectMode ? 1 : chunk.length;\n      if (addToFront) {\n        state.buffer.unshift(chunk);\n      } else {\n        state.reading = false;\n        state.buffer.push(chunk);\n      }\n\n      if (state.needReadable)\n        emitReadable(stream);\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n};\n\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (isNaN(n) || n === null) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = roundUpToNextPowerOf2(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else\n      return state.length;\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  var state = this._readableState;\n  state.calledRead = true;\n  var nOrig = n;\n\n  if (typeof n !== 'number' || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length - n <= state.highWaterMark)\n    doRead = true;\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading)\n    doRead = false;\n\n  if (doRead) {\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read called its callback synchronously, then `reading`\n  // will be false, and we need to re-evaluate how much data we\n  // can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we happened to read() exactly the remaining amount in the\n  // buffer, and the EOF has been seen at this point, then make sure\n  // that we emit 'end' on the very next tick.\n  if (state.ended && !state.endEmitted && state.length === 0)\n    endReadable(this);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!Buffer.isBuffer(chunk) &&\n      'string' !== typeof chunk &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode &&\n      !er) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.decoder && !state.ended) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // if we've ended and we have some data left, then emit\n  // 'readable' now to make sure it gets picked up.\n  if (state.length > 0)\n    emitReadable(stream);\n  else\n    endReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (state.emittedReadable)\n    return;\n\n  state.emittedReadable = true;\n  if (state.sync)\n    process.nextTick(function() {\n      emitReadable_(stream);\n    });\n  else\n    emitReadable_(stream);\n}\n\nfunction emitReadable_(stream) {\n  stream.emit('readable');\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(function() {\n      maybeReadMore_(stream, state);\n    });\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    if (readable !== src) return;\n    cleanup();\n  }\n\n  function onend() {\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  function cleanup() {\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (!dest._writableState || dest._writableState.needDrain)\n      ondrain();\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EE.listenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    // the handler that waits for readable events after all\n    // the data gets sucked out in flow.\n    // This would be easier to follow with a .once() handler\n    // in flow(), but that is too slow.\n    this.on('readable', pipeOnReadable);\n\n    state.flowing = true;\n    process.nextTick(function() {\n      flow(src);\n    });\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var dest = this;\n    var state = src._readableState;\n    state.awaitDrain--;\n    if (state.awaitDrain === 0)\n      flow(src);\n  };\n}\n\nfunction flow(src) {\n  var state = src._readableState;\n  var chunk;\n  state.awaitDrain = 0;\n\n  function write(dest, i, list) {\n    var written = dest.write(chunk);\n    if (false === written) {\n      state.awaitDrain++;\n    }\n  }\n\n  while (state.pipesCount && null !== (chunk = src.read())) {\n\n    if (state.pipesCount === 1)\n      write(state.pipes, 0, null);\n    else\n      forEach(state.pipes, write);\n\n    src.emit('data', chunk);\n\n    // if anyone needs a drain, then we have to wait for that.\n    if (state.awaitDrain > 0)\n      return;\n  }\n\n  // if every destination was unpiped, either before entering this\n  // function, or in the while loop, then stop flowing.\n  //\n  // NB: This is a pretty rare edge case.\n  if (state.pipesCount === 0) {\n    state.flowing = false;\n\n    // if there were data event listeners added, then switch to old mode.\n    if (EE.listenerCount(src, 'data') > 0)\n      emitDataEvents(src);\n    return;\n  }\n\n  // at this point, no one needed a drain, so we just ran out of data\n  // on the next readable event, start it over again.\n  state.ranOut = true;\n}\n\nfunction pipeOnReadable() {\n  if (this._readableState.ranOut) {\n    this._readableState.ranOut = false;\n    flow(this);\n  }\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    this.removeListener('readable', pipeOnReadable);\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    this.removeListener('readable', pipeOnReadable);\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data' && !this._readableState.flowing)\n    emitDataEvents(this);\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        this.read(0);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  emitDataEvents(this);\n  this.read(0);\n  this.emit('resume');\n};\n\nReadable.prototype.pause = function() {\n  emitDataEvents(this, true);\n  this.emit('pause');\n};\n\nfunction emitDataEvents(stream, startPaused) {\n  var state = stream._readableState;\n\n  if (state.flowing) {\n    // https://github.com/isaacs/readable-stream/issues/16\n    throw new Error('Cannot switch to old mode now.');\n  }\n\n  var paused = startPaused || false;\n  var readable = false;\n\n  // convert to an old-style stream.\n  stream.readable = true;\n  stream.pipe = Stream.prototype.pipe;\n  stream.on = stream.addListener = Stream.prototype.on;\n\n  stream.on('readable', function() {\n    readable = true;\n\n    var c;\n    while (!paused && (null !== (c = stream.read())))\n      stream.emit('data', c);\n\n    if (c === null) {\n      readable = false;\n      stream._readableState.needReadable = true;\n    }\n  });\n\n  stream.pause = function() {\n    paused = true;\n    this.emit('pause');\n  };\n\n  stream.resume = function() {\n    paused = false;\n    if (readable)\n      process.nextTick(function() {\n        stream.emit('readable');\n      });\n    else\n      this.read(0);\n    this.emit('resume');\n  };\n\n  // now make it start, just in case it hadn't already.\n  stream.emit('readable');\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n    if (!chunk || !state.objectMode && !chunk.length)\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (typeof stream[i] === 'function' &&\n        typeof this[i] === 'undefined') {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }}(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted && state.calledRead) {\n    state.ended = true;\n    process.nextTick(function() {\n      // Check that we didn't get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit('end');\n      }\n    });\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n}).call(this,require('_process'))\n},{\"_process\":99,\"buffer\":80,\"core-util-is\":106,\"events\":96,\"inherits\":97,\"isarray\":98,\"stream\":112,\"string_decoder/\":107}],104:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(options, stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined)\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  var ts = this._transformState = new TransformState(options, this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this.once('finish', function() {\n    if ('function' === typeof this._flush)\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var rs = stream._readableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n},{\"./_stream_duplex\":101,\"core-util-is\":106,\"inherits\":97}],105:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n\nvar Stream = require('stream');\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n}\n\nfunction WritableState(options, stream) {\n  options = options || {};\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, becuase any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nfunction Writable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(function() {\n    cb(er);\n  });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  if (!Buffer.isBuffer(chunk) &&\n      'string' !== typeof chunk &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    process.nextTick(function() {\n      cb(er);\n    });\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function')\n    cb = function() {};\n\n  if (state.ended)\n    writeAfterEnd(this, state, cb);\n  else if (validChunk(this, state, chunk, cb))\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n\n  return ret;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      typeof chunk === 'string') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing)\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\n  else\n    doWrite(stream, state, len, chunk, encoding, cb);\n\n  return ret;\n}\n\nfunction doWrite(stream, state, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  if (sync)\n    process.nextTick(function() {\n      cb(er);\n    });\n  else\n    cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(stream, state);\n\n    if (!finished && !state.bufferProcessing && state.buffer.length)\n      clearBuffer(stream, state);\n\n    if (sync) {\n      process.nextTick(function() {\n        afterWrite(stream, state, finished, cb);\n      });\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  cb();\n  if (finished)\n    finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n\n  for (var c = 0; c < state.buffer.length; c++) {\n    var entry = state.buffer[c];\n    var chunk = entry.chunk;\n    var encoding = entry.encoding;\n    var cb = entry.callback;\n    var len = state.objectMode ? 1 : chunk.length;\n\n    doWrite(stream, state, len, chunk, encoding, cb);\n\n    // if we didn't call the onwrite immediately, then\n    // it means that we need to wait until it does.\n    // also, that means that the chunk and cb are currently\n    // being processed, so move the buffer counter past them.\n    if (state.writing) {\n      c++;\n      break;\n    }\n  }\n\n  state.bufferProcessing = false;\n  if (c < state.buffer.length)\n    state.buffer = state.buffer.slice(c);\n  else\n    state.buffer.length = 0;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (typeof chunk !== 'undefined' && chunk !== null)\n    this.write(chunk, encoding);\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n  return (state.ending &&\n          state.length === 0 &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(stream, state);\n  if (need) {\n    state.finished = true;\n    stream.emit('finish');\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n\n}).call(this,require('_process'))\n},{\"./_stream_duplex\":101,\"_process\":99,\"buffer\":80,\"core-util-is\":106,\"inherits\":97,\"stream\":112}],106:[function(require,module,exports){\n(function (Buffer){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nfunction isBuffer(arg) {\n  return Buffer.isBuffer(arg);\n}\nexports.isBuffer = isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":80}],107:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  this.charBuffer = new Buffer(6);\n  this.charReceived = 0;\n  this.charLength = 0;\n};\n\n\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  var offset = 0;\n\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var i = (buffer.length >= this.charLength - this.charReceived) ?\n                this.charLength - this.charReceived :\n                buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, offset, i);\n    this.charReceived += (i - offset);\n    offset = i;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (i == buffer.length) return charStr;\n\n    // otherwise cut off the characters end from the beginning of this buffer\n    buffer = buffer.slice(i, buffer.length);\n    break;\n  }\n\n  var lenIncomplete = this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - lenIncomplete, end);\n    this.charReceived = lenIncomplete;\n    end -= lenIncomplete;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    this.charBuffer.write(charStr.charAt(charStr.length - 1), this.encoding);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n\n  return i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  var incomplete = this.charReceived = buffer.length % 2;\n  this.charLength = incomplete ? 2 : 0;\n  return incomplete;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  var incomplete = this.charReceived = buffer.length % 3;\n  this.charLength = incomplete ? 3 : 0;\n  return incomplete;\n}\n\n},{\"buffer\":80}],108:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_passthrough.js\")\n\n},{\"./lib/_stream_passthrough.js\":102}],109:[function(require,module,exports){\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\n},{\"./lib/_stream_duplex.js\":101,\"./lib/_stream_passthrough.js\":102,\"./lib/_stream_readable.js\":103,\"./lib/_stream_transform.js\":104,\"./lib/_stream_writable.js\":105}],110:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_transform.js\")\n\n},{\"./lib/_stream_transform.js\":104}],111:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_writable.js\")\n\n},{\"./lib/_stream_writable.js\":105}],112:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n},{\"events\":96,\"inherits\":97,\"readable-stream/duplex.js\":100,\"readable-stream/passthrough.js\":108,\"readable-stream/readable.js\":109,\"readable-stream/transform.js\":110,\"readable-stream/writable.js\":111}],113:[function(require,module,exports){\nmodule.exports=require(76)\n},{}],114:[function(require,module,exports){\nmodule.exports=require(77)\n},{\"./support/isBuffer\":113,\"_process\":99,\"inherits\":97}],115:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  var BaseError, Canceler, EscErr, EscOk, c_to_camel, ipush, make_error_klass, make_errors, make_esc, to_lower, util,\n    __slice = [].slice;\n\n  util = require('util');\n\n  exports.BaseError = BaseError = function(msg, constructor) {\n    Error.captureStackTrace(this, this.constructor);\n    return this.message = msg || 'Error';\n  };\n\n  util.inherits(BaseError, Error);\n\n  BaseError.prototype.name = \"BaseError\";\n\n  to_lower = function(s) {\n    return s[0].toUpperCase() + s.slice(1).toLowerCase();\n  };\n\n  c_to_camel = function(s) {\n    var p;\n    return ((function() {\n      var _i, _len, _ref, _results;\n      _ref = s.split(/_/);\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        p = _ref[_i];\n        _results.push(to_lower(p));\n      }\n      return _results;\n    })()).join('');\n  };\n\n  make_error_klass = function(k, code, default_msg) {\n    var ctor;\n    ctor = function(msg) {\n      BaseError.call(this, msg || default_msg, this.constructor);\n      this.istack = [];\n      this.code = code;\n      return this;\n    };\n    util.inherits(ctor, BaseError);\n    ctor.prototype.name = k;\n    ctor.prototype.inspect = function() {\n      return \"[\" + k + \": \" + this.message + \" (code \" + this.code + \")]\";\n    };\n    return ctor;\n  };\n\n  exports.make_errors = make_errors = function(d) {\n    var enam, errno, k, msg, out, val;\n    out = {\n      msg: {},\n      name: {},\n      code: {}\n    };\n    d.OK = \"Success\";\n    errno = 100;\n    for (k in d) {\n      msg = d[k];\n      if (k !== \"OK\") {\n        enam = (c_to_camel(k)) + \"Error\";\n        val = errno++;\n        out[enam] = make_error_klass(enam, val, msg);\n      } else {\n        val = 0;\n      }\n      out[k] = val;\n      out.msg[k] = out.msg[val] = msg;\n      out.name[k] = out.name[val] = k;\n      out.code[k] = val;\n    }\n    return out;\n  };\n\n  ipush = function(e, msg) {\n    if (msg != null) {\n      if (e.istack == null) {\n        e.istack = [];\n      }\n      return e.istack.push(msg);\n    }\n  };\n\n  exports.make_esc = make_esc = function(gcb, where) {\n    return function(lcb) {\n      return function() {\n        var args, err;\n        err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n        if (err == null) {\n          return lcb.apply(null, args);\n        } else if (!gcb.__esc) {\n          gcb.__esc = true;\n          ipush(err, where);\n          return gcb(err);\n        }\n      };\n    };\n  };\n\n  exports.EscOk = EscOk = (function() {\n    function EscOk(gcb, where) {\n      this.gcb = gcb;\n      this.where = where;\n    }\n\n    EscOk.prototype.bailout = function() {\n      var t;\n      if (this.gcb) {\n        t = this.gcb;\n        this.gcb = null;\n        return t(false);\n      }\n    };\n\n    EscOk.prototype.check_ok = function(cb) {\n      return (function(_this) {\n        return function() {\n          var args, ok;\n          ok = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n          if (!ok) {\n            return _this.bailout();\n          } else {\n            return cb.apply(null, args);\n          }\n        };\n      })(this);\n    };\n\n    EscOk.prototype.check_err = function(cb) {\n      return (function(_this) {\n        return function() {\n          var args, err;\n          err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n          if (err != null) {\n            ipush(err, _this.where);\n            return _this.bailout();\n          } else {\n            return cb.apply(null, args);\n          }\n        };\n      })(this);\n    };\n\n    EscOk.prototype.check_non_null = function(cb) {\n      return (function(_this) {\n        return function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          if (args[0] == null) {\n            return _this.bailout();\n          } else {\n            return cb.apply(null, args);\n          }\n        };\n      })(this);\n    };\n\n    return EscOk;\n\n  })();\n\n  exports.EscErr = EscErr = (function() {\n    function EscErr(gcb, where) {\n      this.gcb = gcb;\n      this.where = where;\n    }\n\n    EscErr.prototype.finish = function(err) {\n      var t;\n      if (this.gcb) {\n        t = this.gcb;\n        this.gcb = null;\n        return t(err);\n      }\n    };\n\n    EscErr.prototype.check_ok = function(cb, eclass, emsg) {\n      if (eclass == null) {\n        eclass = Error;\n      }\n      if (emsg == null) {\n        emsg = null;\n      }\n      return function() {\n        var args, err, ok;\n        ok = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n        if (!ok) {\n          err = new eclass(emsg);\n          ipush(err, this.where);\n          return this.finish(err);\n        } else {\n          return cb.apply(null, args);\n        }\n      };\n    };\n\n    EscErr.prototype.check_err = function(cb) {\n      return function() {\n        var args, err;\n        err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n        if (err != null) {\n          ipush(err, this.where);\n          return this.finish(err);\n        } else {\n          return cb.apply(null, args);\n        }\n      };\n    };\n\n    return EscErr;\n\n  })();\n\n  exports.Canceler = Canceler = (function() {\n    function Canceler(klass) {\n      this.klass = klass != null ? klass : Error;\n      this._canceled = false;\n    }\n\n    Canceler.prototype.is_canceled = function() {\n      return this._canceled;\n    };\n\n    Canceler.prototype.is_ok = function() {\n      return !this._canceled;\n    };\n\n    Canceler.prototype.cancel = function() {\n      return this._canceled = true;\n    };\n\n    Canceler.prototype.err = function() {\n      if (this._canceled) {\n        return new this.klass(\"Aborted\");\n      } else {\n        return null;\n      }\n    };\n\n    return Canceler;\n\n  })();\n\n  exports.chain = function(cb, f) {\n    return function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return f(function() {\n        return cb.apply(null, args);\n      });\n    };\n  };\n\n  exports.chain_err = function(cb, f) {\n    return function() {\n      var args0;\n      args0 = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return f(function() {\n        var args1;\n        args1 = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return cb.apply(null, ((args1[0] != null) && !(args0[0] != null) ? args1 : args0));\n      });\n    };\n  };\n\n}).call(this);\n\n//# sourceMappingURL=index.map\n\n},{\"util\":114}],116:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-b\n(function() {\n  module.exports = {\n    k: \"__iced_k\",\n    k_noop: \"__iced_k_noop\",\n    param: \"__iced_p_\",\n    ns: \"iced\",\n    runtime: \"runtime\",\n    Deferrals: \"Deferrals\",\n    deferrals: \"__iced_deferrals\",\n    fulfill: \"_fulfill\",\n    b_while: \"_break\",\n    t_while: \"_while\",\n    c_while: \"_continue\",\n    n_while: \"_next\",\n    n_arg: \"__iced_next_arg\",\n    defer_method: \"defer\",\n    slot: \"__slot\",\n    assign_fn: \"assign_fn\",\n    autocb: \"autocb\",\n    retslot: \"ret\",\n    trace: \"__iced_trace\",\n    passed_deferral: \"__iced_passed_deferral\",\n    findDeferral: \"findDeferral\",\n    lineno: \"lineno\",\n    parent: \"parent\",\n    filename: \"filename\",\n    funcname: \"funcname\",\n    catchExceptions: 'catchExceptions',\n    runtime_modes: [\"node\", \"inline\", \"window\", \"none\", \"browserify\", \"interp\"],\n    trampoline: \"trampoline\",\n    context: \"context\"\n  };\n\n}).call(this);\n\n},{}],117:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-b\n(function() {\n  var C, Pipeliner, iced, __iced_k, __iced_k_noop, _iand, _ior, _timeout,\n    __slice = [].slice;\n\n  __iced_k = __iced_k_noop = function() {};\n\n  C = require('./const');\n\n  exports.iced = iced = require('./runtime');\n\n  _timeout = function(cb, t, res, tmp) {\n    var arr, rv, which, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    rv = new iced.Rendezvous;\n    tmp[0] = rv.id(true).defer({\n      assign_fn: (function(_this) {\n        return function() {\n          return function() {\n            return arr = __slice.call(arguments, 0);\n          };\n        };\n      })(this)(),\n      lineno: 20,\n      context: __iced_deferrals\n    });\n    setTimeout(rv.id(false).defer({\n      lineno: 21,\n      context: __iced_deferrals\n    }), t);\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/Users/max/src/iced/iced-runtime/src/library.iced\"\n        });\n        rv.wait(__iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              return which = arguments[0];\n            };\n          })(),\n          lineno: 22\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        if (res) {\n          res[0] = which;\n        }\n        return cb.apply(null, arr);\n      };\n    })(this));\n  };\n\n  exports.timeout = function(cb, t, res) {\n    var tmp;\n    tmp = [];\n    _timeout(cb, t, res, tmp);\n    return tmp[0];\n  };\n\n  _iand = function(cb, res, tmp) {\n    var ok, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/Users/max/src/iced/iced-runtime/src/library.iced\"\n        });\n        tmp[0] = __iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              return ok = arguments[0];\n            };\n          })(),\n          lineno: 39\n        });\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        if (!ok) {\n          res[0] = false;\n        }\n        return cb();\n      };\n    })(this));\n  };\n\n  exports.iand = function(cb, res) {\n    var tmp;\n    tmp = [];\n    _iand(cb, res, tmp);\n    return tmp[0];\n  };\n\n  _ior = function(cb, res, tmp) {\n    var ok, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/Users/max/src/iced/iced-runtime/src/library.iced\"\n        });\n        tmp[0] = __iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              return ok = arguments[0];\n            };\n          })(),\n          lineno: 58\n        });\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        if (ok) {\n          res[0] = true;\n        }\n        return cb();\n      };\n    })(this));\n  };\n\n  exports.ior = function(cb, res) {\n    var tmp;\n    tmp = [];\n    _ior(cb, res, tmp);\n    return tmp[0];\n  };\n\n  exports.Pipeliner = Pipeliner = (function() {\n    function Pipeliner(window, delay) {\n      this.window = window || 1;\n      this.delay = delay || 0;\n      this.queue = [];\n      this.n_out = 0;\n      this.cb = null;\n      this[C.deferrals] = this;\n      this[\"defer\"] = this._defer;\n    }\n\n    Pipeliner.prototype.waitInQueue = function(cb) {\n      var ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          var _results, _while;\n          _results = [];\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = function() {\n              return __iced_k(_results);\n            };\n            _continue = function() {\n              return iced.trampoline(function() {\n                return _while(__iced_k);\n              });\n            };\n            _next = function(__iced_next_arg) {\n              _results.push(__iced_next_arg);\n              return _continue();\n            };\n            if (!(_this.n_out >= _this.window)) {\n              return _break();\n            } else {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/iced/iced-runtime/src/library.iced\",\n                  funcname: \"Pipeliner.waitInQueue\"\n                });\n                _this.cb = __iced_deferrals.defer({\n                  lineno: 100\n                });\n                __iced_deferrals._fulfill();\n              })(_next);\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          _this.n_out++;\n          (function(__iced_k) {\n            if (_this.delay) {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/iced/iced-runtime/src/library.iced\",\n                  funcname: \"Pipeliner.waitInQueue\"\n                });\n                setTimeout(__iced_deferrals.defer({\n                  lineno: 108\n                }), _this.delay);\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            return cb();\n          });\n        };\n      })(this));\n    };\n\n    Pipeliner.prototype.__defer = function(out, deferArgs) {\n      var tmp, voidCb, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/iced/iced-runtime/src/library.iced\",\n            funcname: \"Pipeliner.__defer\"\n          });\n          voidCb = __iced_deferrals.defer({\n            lineno: 122\n          });\n          out[0] = function() {\n            var args, _ref;\n            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n            if ((_ref = deferArgs.assign_fn) != null) {\n              _ref.apply(null, args);\n            }\n            return voidCb();\n          };\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          _this.n_out--;\n          if (_this.cb) {\n            tmp = _this.cb;\n            _this.cb = null;\n            return tmp();\n          }\n        };\n      })(this));\n    };\n\n    Pipeliner.prototype._defer = function(deferArgs) {\n      var tmp;\n      tmp = [];\n      this.__defer(tmp, deferArgs);\n      return tmp[0];\n    };\n\n    Pipeliner.prototype.flush = function(autocb) {\n      var ___iced_passed_deferral, __iced_k, _results, _while;\n      __iced_k = autocb;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      _results = [];\n      _while = (function(_this) {\n        var __iced_deferrals;\n        return function(__iced_k) {\n          var _break, _continue, _next;\n          _break = function() {\n            return __iced_k(_results);\n          };\n          _continue = function() {\n            return iced.trampoline(function() {\n              return _while(__iced_k);\n            });\n          };\n          _next = function(__iced_next_arg) {\n            _results.push(__iced_next_arg);\n            return _continue();\n          };\n          if (!_this.n_out) {\n            return _break();\n          } else {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/iced/iced-runtime/src/library.iced\",\n                funcname: \"Pipeliner.flush\"\n              });\n              _this.cb = __iced_deferrals.defer({\n                lineno: 151\n              });\n              __iced_deferrals._fulfill();\n            })(_next);\n          }\n        };\n      })(this);\n      _while(__iced_k);\n    };\n\n    return Pipeliner;\n\n  })();\n\n}).call(this);\n\n},{\"./const\":116,\"./runtime\":119}],118:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-b\n(function() {\n  var k, mod, mods, v, _i, _len;\n\n  exports[\"const\"] = require('./const');\n\n  mods = [require('./runtime'), require('./library')];\n\n  for (_i = 0, _len = mods.length; _i < _len; _i++) {\n    mod = mods[_i];\n    for (k in mod) {\n      v = mod[k];\n      exports[k] = v;\n    }\n  }\n\n}).call(this);\n\n},{\"./const\":116,\"./library\":117,\"./runtime\":119}],119:[function(require,module,exports){\n(function (process){\n// Generated by IcedCoffeeScript 1.7.1-b\n(function() {\n  var C, Deferrals, Rendezvous, exceptionHandler, findDeferral, make_defer_return, stackWalk, tick_counter, trampoline, warn, __active_trace, __c, _trace_to_string,\n    __slice = [].slice;\n\n  C = require('./const');\n\n  make_defer_return = function(obj, defer_args, id, trace_template, multi) {\n    var k, ret, trace, v;\n    trace = {};\n    for (k in trace_template) {\n      v = trace_template[k];\n      trace[k] = v;\n    }\n    trace[C.lineno] = defer_args != null ? defer_args[C.lineno] : void 0;\n    ret = function() {\n      var inner_args, o, _ref;\n      inner_args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      if (defer_args != null) {\n        if ((_ref = defer_args.assign_fn) != null) {\n          _ref.apply(null, inner_args);\n        }\n      }\n      if (obj) {\n        o = obj;\n        if (!multi) {\n          obj = null;\n        }\n        return o._fulfill(id, trace);\n      } else {\n        return warn(\"overused deferral at \" + (_trace_to_string(trace)));\n      }\n    };\n    ret[C.trace] = trace;\n    return ret;\n  };\n\n  __c = 0;\n\n  tick_counter = function(mod) {\n    __c++;\n    if ((__c % mod) === 0) {\n      __c = 0;\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  __active_trace = null;\n\n  _trace_to_string = function(tr) {\n    var fn;\n    fn = tr[C.funcname] || \"<anonymous>\";\n    return \"\" + fn + \" (\" + tr[C.filename] + \":\" + (tr[C.lineno] + 1) + \")\";\n  };\n\n  warn = function(m) {\n    return typeof console !== \"undefined\" && console !== null ? console.error(\"ICED warning: \" + m) : void 0;\n  };\n\n  exports.trampoline = trampoline = function(fn) {\n    if (!tick_counter(500)) {\n      return fn();\n    } else if (typeof process !== \"undefined\" && process !== null) {\n      return process.nextTick(fn);\n    } else {\n      return setTimeout(fn);\n    }\n  };\n\n  exports.Deferrals = Deferrals = (function() {\n    function Deferrals(k, trace) {\n      this.trace = trace;\n      this.continuation = k;\n      this.count = 1;\n      this.ret = null;\n    }\n\n    Deferrals.prototype._call = function(trace) {\n      var c;\n      if (this.continuation) {\n        __active_trace = trace;\n        c = this.continuation;\n        this.continuation = null;\n        return c(this.ret);\n      } else {\n        return warn(\"Entered dead await at \" + (_trace_to_string(trace)));\n      }\n    };\n\n    Deferrals.prototype._fulfill = function(id, trace) {\n      if (--this.count > 0) {\n\n      } else {\n        return trampoline(((function(_this) {\n          return function() {\n            return _this._call(trace);\n          };\n        })(this)));\n      }\n    };\n\n    Deferrals.prototype.defer = function(args) {\n      var self;\n      this.count++;\n      self = this;\n      return make_defer_return(self, args, null, this.trace);\n    };\n\n    return Deferrals;\n\n  })();\n\n  exports.findDeferral = findDeferral = function(args) {\n    var a, _i, _len;\n    for (_i = 0, _len = args.length; _i < _len; _i++) {\n      a = args[_i];\n      if (a != null ? a[C.trace] : void 0) {\n        return a;\n      }\n    }\n    return null;\n  };\n\n  exports.Rendezvous = Rendezvous = (function() {\n    var RvId;\n\n    function Rendezvous() {\n      this.completed = [];\n      this.waiters = [];\n      this.defer_id = 0;\n    }\n\n    RvId = (function() {\n      function RvId(rv, id, multi) {\n        this.rv = rv;\n        this.id = id;\n        this.multi = multi;\n      }\n\n      RvId.prototype.defer = function(defer_args) {\n        return this.rv._defer_with_id(this.id, defer_args, this.multi);\n      };\n\n      return RvId;\n\n    })();\n\n    Rendezvous.prototype.wait = function(cb) {\n      var x;\n      if (this.completed.length) {\n        x = this.completed.shift();\n        return cb(x);\n      } else {\n        return this.waiters.push(cb);\n      }\n    };\n\n    Rendezvous.prototype.defer = function(defer_args) {\n      var id;\n      id = this.defer_id++;\n      return this._defer_with_id(id, defer_args);\n    };\n\n    Rendezvous.prototype.id = function(i, multi) {\n      multi = !!multi;\n      return new RvId(this, i, multi);\n    };\n\n    Rendezvous.prototype._fulfill = function(id, trace) {\n      var cb;\n      if (this.waiters.length) {\n        cb = this.waiters.shift();\n        return cb(id);\n      } else {\n        return this.completed.push(id);\n      }\n    };\n\n    Rendezvous.prototype._defer_with_id = function(id, defer_args, multi) {\n      this.count++;\n      return make_defer_return(this, defer_args, id, {}, multi);\n    };\n\n    return Rendezvous;\n\n  })();\n\n  exports.stackWalk = stackWalk = function(cb) {\n    var line, ret, tr, _ref;\n    ret = [];\n    tr = cb ? cb[C.trace] : __active_trace;\n    while (tr) {\n      line = \"   at \" + (_trace_to_string(tr));\n      ret.push(line);\n      tr = tr != null ? (_ref = tr[C.parent]) != null ? _ref[C.trace] : void 0 : void 0;\n    }\n    return ret;\n  };\n\n  exports.exceptionHandler = exceptionHandler = function(err, logger) {\n    var stack;\n    if (!logger) {\n      logger = console.error;\n    }\n    logger(err.stack);\n    stack = stackWalk();\n    if (stack.length) {\n      logger(\"Iced 'stack' trace (w/ real line numbers):\");\n      return logger(stack.join(\"\\n\"));\n    }\n  };\n\n  exports.catchExceptions = function(logger) {\n    return typeof process !== \"undefined\" && process !== null ? process.on('uncaughtException', function(err) {\n      exceptionHandler(err, logger);\n      return process.exit(1);\n    }) : void 0;\n  };\n\n}).call(this);\n\n}).call(this,require('_process'))\n},{\"./const\":116,\"_process\":99}],120:[function(require,module,exports){\nif (typeof console.assert !== \"function\") { console.assert = function () {} };\nexports.BWT = require('./outlib/BWT');\nexports.BWTC = require('./outlib/BWTC');\nexports.BitStream = require('./outlib/BitStream');\nexports.Bzip2 = require('./outlib/Bzip2');\nexports.CRC32 = require('./outlib/CRC32');\nexports.Context1Model = require('./outlib/Context1Model');\nexports.DefSumModel = require('./outlib/DefSumModel');\nexports.DeflateDistanceModel = require('./outlib/DeflateDistanceModel');\nexports.Dmc = require('./outlib/Dmc');\nexports.DummyRangeCoder = require('./outlib/DummyRangeCoder');\nexports.FenwickModel = require('./outlib/FenwickModel');\nexports.Huffman = require('./outlib/Huffman');\nexports.HuffmanAllocator = require('./outlib/HuffmanAllocator');\nexports.LogDistanceModel = require('./outlib/LogDistanceModel');\nexports.Lzjb = require('./outlib/Lzjb');\nexports.LzjbR = require('./outlib/LzjbR');\nexports.Lzp3 = require('./outlib/Lzp3');\nexports.MTFModel = require('./outlib/MTFModel');\nexports.NoModel = require('./outlib/NoModel');\nexports.PPM = require('./outlib/PPM');\nexports.RangeCoder = require('./outlib/RangeCoder');\nexports.Simple = require('./outlib/Simple');\nexports.Stream = require('./outlib/Stream');\nexports.Util = require('./outlib/Util');\nexports.freeze = require('./outlib/freeze');\n\n},{\"./outlib/BWT\":121,\"./outlib/BWTC\":122,\"./outlib/BitStream\":123,\"./outlib/Bzip2\":124,\"./outlib/CRC32\":125,\"./outlib/Context1Model\":126,\"./outlib/DefSumModel\":127,\"./outlib/DeflateDistanceModel\":128,\"./outlib/Dmc\":129,\"./outlib/DummyRangeCoder\":130,\"./outlib/FenwickModel\":131,\"./outlib/Huffman\":132,\"./outlib/HuffmanAllocator\":133,\"./outlib/LogDistanceModel\":134,\"./outlib/Lzjb\":135,\"./outlib/LzjbR\":136,\"./outlib/Lzp3\":137,\"./outlib/MTFModel\":138,\"./outlib/NoModel\":139,\"./outlib/PPM\":140,\"./outlib/RangeCoder\":141,\"./outlib/Simple\":142,\"./outlib/Stream\":143,\"./outlib/Util\":144,\"./outlib/freeze\":145}],121:[function(require,module,exports){\n/** Burrows-Wheeler transform, computed with the Induced Sorting Suffix Array\n *  construction mechanism (sais).  Code is a port of:\n *    https://sites.google.com/site/yuta256/sais\n *  which is:\n *    Copyright (c) 2008-2010 Yuta Mori All Rights Reserved.\n *  and licensed under an MIT/X11 license.  I generally looked at both\n *  the C and the Java implementations to guide my work.\n *\n * This JavaScript port is:\n *    Copyright (c) 2013 C. Scott Ananian\n * and licensed under GPLv2; see the README at the top level of this package.\n */\nvar libs = [\n  require('./freeze'),\n  require('./Util')\n];\nvar body_fn = function (freeze, Util) {\n    var ASSERT = console.assert.bind(console);\n\n    // we're dispensing with the \"arbitrary alphabet\" stuff of the source\n    // and just using Uint8Arrays.\n\n    /** Find the start or end of each bucket. */\n    var getCounts = function(T, C, n, k) {\n        var i;\n        for (i = 0; i < k; i++) { C[i] = 0; }\n        for (i = 0; i < n; i++) { C[T[i]]++; }\n    };\n    var getBuckets = function(C, B, k, end) {\n        var i, sum = 0;\n        if (end) {\n            for (i = 0; i < k; i++) { sum += C[i]; B[i] = sum; }\n        } else {\n            for (i = 0; i < k; i++) { sum += C[i]; B[i] = sum - C[i]; }\n        }\n    };\n\n    /** Sort all type LMS suffixes */\n    var LMSsort = function(T, SA, C, B, n, k) {\n        var b, i, j;\n        var c0, c1;\n        /* compute SAl */\n        if (C === B) { getCounts(T, C, n, k); }\n        getBuckets(C, B, k, false); /* find starts of buckets */\n        j = n - 1;\n        b = B[c1 = T[j]];\n        j--;\n        SA[b++] = (T[j] < c1) ? ~j : j;\n        for (i = 0; i < n; i++) {\n            if ((j = SA[i]) > 0) {\n                ASSERT(T[j] >= T[j+1]);\n                if ((c0 = T[j]) !== c1) { B[c1] = b; b = B[c1 = c0]; }\n                ASSERT(i < b);\n                j--;\n                SA[b++] = (T[j] < c1) ? ~j : j;\n                SA[i] = 0;\n            } else if (j < 0) {\n                SA[i] = ~j;\n            }\n        }\n        /* compute SAs */\n        if (C === B) { getCounts(T, C, n, k); }\n        getBuckets(C, B, k, 1); /* find ends of buckets */\n        for (i = n-1, b = B[c1 = 0]; i >= 0; i--) {\n            if ((j = SA[i]) > 0) {\n                ASSERT(T[j] <= T[j+1]);\n                if ((c0 = T[j]) !== c1) { B[c1] = b; b = B[c1 = c0]; }\n                ASSERT(b <= i);\n                j--;\n                SA[--b] = (T[j] > c1) ? ~(j+1) : j;\n                SA[i] = 0;\n            }\n        }\n    };\n\n    var LMSpostproc = function(T, SA, n, m) {\n        var i, j, p, q, plen, qlen, name;\n        var c0, c1;\n        var diff;\n\n        /* compact all the sorted substrings into the first m items of SA\n         * 2*m must not be larger than n (provable) */\n        ASSERT(n > 0);\n        for (i = 0; (p = SA[i]) < 0; i++) { SA[i] = ~p; ASSERT((i+1) < n); }\n        if (i < m) {\n            for (j = i, i++; ; i++) {\n                ASSERT(i < n);\n                if ((p = SA[i]) < 0) {\n                    SA[j++] = ~p; SA[i] = 0;\n                    if (j === m) { break; }\n                }\n            }\n        }\n\n        /* store the length of all substrings */\n        c0 = T[i = j = n - 1];\n        do { c1 = c0; } while ( ((--i) >= 0 ) && ((c0=T[i]) >= c1) );\n        for (; i >= 0; ) {\n            do { c1 = c0; } while ( ((--i) >= 0 ) && ((c0=T[i]) <= c1) );\n            if (i >= 0) {\n                SA[m + ((i + 1) >>> 1)] = j - i; j = i + 1;\n                do { c1 = c0; } while ( ((--i) >= 0 ) && ((c0=T[i]) >= c1) );\n            }\n        }\n\n        /* find the lexicographic names of all substrings */\n        for (i = 0, name = 0, q = n, qlen = 0; i < m; i++) {\n            p = SA[i]; plen = SA[m + (p >>> 1)]; diff = true;\n            if ((plen === qlen) && ((q + plen) < n)) {\n                for (j = 0; (j < plen) && (T[p + j] === T[q + j]); ) { j++; }\n                if (j === plen) { diff = false; }\n            }\n            if (diff) { name++; q = p; qlen = plen; }\n            SA[m + (p >>> 1)] = name;\n        }\n\n        return name;\n    };\n\n    /* compute SA and BWT */\n    var induceSA = function(T, SA, C, B, n, k) {\n        var b, i, j;\n        var c0, c1;\n        /* compute SAl */\n        if (C === B) { getCounts(T, C, n, k); }\n        getBuckets(C, B, k, false); /* find starts of buckets */\n        j = n - 1;\n        b = B[c1 = T[j]];\n        SA[b++] = ((j > 0) && (T[j-1] < c1)) ? ~j : j;\n        for (i = 0; i < n; i++) {\n            j = SA[i]; SA[i] = ~j;\n            if (j > 0) {\n                j--;\n                ASSERT( T[j] >= T[j + 1] );\n                if ((c0 = T[j]) !== c1) { B[c1]  = b; b = B[c1=c0]; }\n                ASSERT( i < b );\n                SA[b++] = ((j > 0) && (T[j-1] < c1)) ? ~j : j;\n            }\n        }\n        /* compute SAs */\n        if (C === B) { getCounts(T, C, n, k); }\n        getBuckets(C, B, k, true); /* find ends of buckets */\n        for (i = n-1, b = B[c1 = 0]; i >= 0; i--) {\n            if ((j = SA[i]) > 0) {\n                j--;\n                ASSERT( T[j] <= T[j + 1] );\n                if ((c0 = T[j]) !== c1) { B[c1] = b; b = B[c1 = c0]; }\n                ASSERT( b <= i );\n                SA[--b] = ((j === 0) || (T[j - 1] > c1)) ? ~j : j;\n            } else {\n                SA[i] = ~j;\n            }\n        }\n    };\n\n    var computeBWT = function(T, SA, C, B, n, k) {\n        var b, i, j, pidx = -1;\n        var c0, c1;\n        /* compute SAl */\n        if (C === B) { getCounts(T, C, n, k); }\n        getBuckets(C, B, k, false); /* find starts of buckets */\n        j = n - 1;\n        b = B[c1 = T[j]];\n        SA[b++] = ((j > 0) && (T[j - 1] < c1)) ? ~j : j;\n        for (i = 0; i < n; i++) {\n            if ((j=SA[i]) > 0) {\n                j--;\n                ASSERT( T[j] >= T[j+1] );\n                SA[i] = ~(c0 = T[j]);\n                if (c0 !== c1) { B[c1] = b; b = B[c1 = c0]; }\n                ASSERT( i < b );\n                SA[b++] = ((j > 0) && (T[j - 1] < c1)) ? ~j : j;\n            } else if (j !== 0) {\n                SA[i] = ~j;\n            }\n        }\n        /* compute SAs */\n        if (C === B) { getCounts(T, C, n, k); }\n        getBuckets(C, B, k, true); /* find ends of buckets */\n        for (i = n-1, b = B[c1 = 0]; i >= 0; i--) {\n            if ((j = SA[i]) > 0) {\n                j--;\n                ASSERT( T[j] <= T[j+1] );\n                SA[i] = c0 = T[j];\n                if (c0 !== c1) { B[c1] = b; b = B[c1 = c0]; }\n                ASSERT( b <= i );\n                SA[--b] = ((j > 0) && (T[j-1] > c1)) ? (~T[j-1]) : j;\n            } else if (j !== 0) {\n                SA[i] = ~j;\n            } else {\n                pidx = i;\n            }\n        }\n        return pidx;\n    };\n\n    /* find the suffix array SA of T[0..n-1] in {0..k-1}^n\n       use a working space (excluding T and SA) of at most 2n+O(1) for a\n       constant alphabet */\n    var SA_IS = function(T, SA, fs, n, k, isbwt) {\n        var C, B, RA;\n        var i, j, b, c, m, p, q, name, pidx = 0, newfs;\n        var c0, c1;\n        var flags = 0;\n\n        // allocate temporary storage [CSA]\n        if (k <= 256) {\n            C = Util.makeS32Buffer(k);\n            if (k <= fs) { B = SA.subarray(n + fs - k); flags = 1; }\n            else { B = Util.makeS32Buffer(k); flags = 3; }\n        } else if (k <= fs) {\n            C = SA.subarray(n + fs - k);\n            if (k <= (fs - k)) { B = SA.subarray(n + fs - k * 2); flags = 0; }\n            else if (k <= 1024) { B = Util.makeS32Buffer(k); flags = 2; }\n            else { B = C; flags = 8; }\n        } else {\n            C = B = Util.makeS32Buffer(k);\n            flags = 4 | 8;\n        }\n\n        /* stage 1: reduce the problem by at least 1/2\n           sort all the LMS-substrings */\n        getCounts(T, C, n, k);\n        getBuckets(C, B, k, true); /* find ends of buckets */\n        for (i = 0; i < n; i++) { SA[i] = 0; }\n        b = -1; i = n - 1; j = n; m = 0; c0 = T[n - 1];\n        do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) >= c1));\n        for (; i >= 0 ;) {\n            do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) <= c1));\n            if ( i >= 0 ) {\n                if ( b >= 0 ) { SA[b] = j; }\n                b = --B[c1];\n                j = i;\n                ++m;\n                do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) >= c1));\n            }\n        }\n\n        if (m > 1) {\n            LMSsort(T, SA, C, B, n, k);\n            name = LMSpostproc(T, SA, n, m);\n        } else if (m === 1) {\n            SA[b] = j + 1;\n            name = 1;\n        } else {\n            name = 0;\n        }\n\n        /* stage 2: solve the reduced problem\n           recurse if names are not yet unique */\n        if(name < m) {\n            if((flags & 4) !== 0) { C = null; B = null; }\n            if((flags & 2) !== 0) { B = null; }\n            newfs = (n + fs) - (m * 2);\n            if((flags & (1 | 4 | 8)) === 0) {\n                if((k + name) <= newfs) { newfs -= k; }\n                else { flags |= 8; }\n            }\n            ASSERT( (n >>> 1) <= (newfs + m) );\n            for (i = m + (n >>> 1) - 1, j = m * 2 + newfs - 1; m <= i; i--) {\n                if(SA[i] !== 0) { SA[j--] = SA[i] - 1; }\n            }\n            RA = SA.subarray(m + newfs);\n            SA_IS(RA, SA, newfs, m, name, false);\n            RA = null;\n\n            i = n - 1; j = m * 2 - 1; c0 = T[n - 1];\n            do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) >= c1));\n            for (; i >= 0 ;) {\n                do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) <= c1));\n                if ( i >= 0 ) {\n                    SA[j--] = i + 1;\n                    do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) >= c1));\n                }\n            }\n\n            for (i = 0; i < m; i++) { SA[i] = SA[m + SA[i]]; }\n            if((flags & 4) !== 0) { C = B = Util.makeS32Buffer(k); }\n            if((flags & 2) !== 0) { B = Util.makeS32Buffer(k); }\n        }\n\n        /* stage 3: induce the result for the original problem */\n        if((flags & 8) !== 0) { getCounts(T, C, n, k); }\n        /* put all left-most S characters into their buckets */\n        if (m > 1) {\n            getBuckets(C, B, k, true); /* find ends of buckets */\n            i = m - 1; j = n; p = SA[m - 1]; c1 = T[p];\n            do {\n                q = B[c0 = c1];\n                while (q < j) { SA[--j] = 0; }\n                do {\n                    SA[--j] = p;\n                    if(--i < 0) { break; }\n                    p = SA[i];\n                } while((c1 = T[p]) === c0);\n            } while (i >= 0 );\n            while ( j > 0 ) { SA[--j] = 0; }\n        }\n        if (!isbwt) { induceSA(T, SA, C, B, n, k); }\n        else { pidx = computeBWT(T, SA, C, B, n, k); }\n        C = null; B = null;\n        return pidx;\n    };\n\n    var BWT = Object.create(null);\n    /** SA should be a Int32Array (signed!); T can be any typed array.\n     *  alphabetSize is optional if T is an Uint8Array or Uint16Array. */\n    BWT.suffixsort = function(T, SA, n, alphabetSize) {\n        ASSERT( T && SA && T.length >= n && SA.length >= n );\n        if (n <= 1) {\n            if (n === 1) { SA[0] = 0; }\n            return 0;\n        }\n        if (!alphabetSize) {\n            if (T.BYTES_PER_ELEMENT === 1) { alphabetSize = 256; }\n            else if (T.BYTES_PER_ELEMENT === 2) { alphabetSize = 65536; }\n            else throw new Error('Need to specify alphabetSize');\n        }\n        ASSERT( alphabetSize > 0 );\n        if (T.BYTES_PER_ELEMENT) {\n            ASSERT( alphabetSize <= (1 << (T.BYTES_PER_ELEMENT*8) ) );\n        }\n        return SA_IS(T, SA, 0, n, alphabetSize, false);\n    };\n    /** Burrows-Wheeler Transform.\n        A should be Int32Array (signed!); T can be any typed array.\n        U is the same type as T (it is used for output).\n        alphabetSize is optional if T is an Uint8Array or Uint16Array.\n        ASSUMES STRING IS TERMINATED WITH AN EOF CHARACTER.\n    */\n    BWT.bwtransform = function(T, U, A, n, alphabetSize) {\n        var i, pidx;\n        ASSERT( T && U && A );\n        ASSERT( T.length >= n && U.length >= n && A.length >= n );\n        if (n <= 1) {\n            if (n === 1) { U[0] = T[0]; }\n            return n;\n        }\n        if (!alphabetSize) {\n            if (T.BYTES_PER_ELEMENT === 1) { alphabetSize = 256; }\n            else if (T.BYTES_PER_ELEMENT === 2) { alphabetSize = 65536; }\n            else throw new Error('Need to specify alphabetSize');\n        }\n        ASSERT( alphabetSize > 0 );\n        if (T.BYTES_PER_ELEMENT) {\n            ASSERT( alphabetSize <= (1 << (T.BYTES_PER_ELEMENT*8) ) );\n        }\n        pidx = SA_IS(T, A, 0, n, alphabetSize, true);\n        U[0] = T[n - 1];\n        for (i = 0; i < pidx ; i++) { U[i + 1] = A[i]; }\n        for (i += 1; i < n; i++) { U[i] = A[i]; }\n        return pidx + 1;\n    };\n    /** Reverses transform above. (ASSUMED STRING IS TERMINATED WITH EOF.) */\n    BWT.unbwtransform = function(T, U, LF, n, pidx) {\n        var C = Util.makeU32Buffer(256);\n        var i, t;\n        for (i=0; i<256; i++) { C[i] = 0; }\n        for (i=0; i<n; i++) { LF[i] = C[T[i]]++; }\n        for (i=0, t=0; i<256; i++) { t += C[i]; C[i] = t - C[i]; }\n        for (i=n-1, t=0; i>=0; i--) {\n            t = LF[t] + C[U[i]=T[t]];\n            t += (t<pidx) ? 1 : 0;\n        }\n        C = null;\n    };\n\n    /** Burrows-Wheeler Transform.\n        A should be Int32Array (signed!); T can be any typed array.\n        U is the same type as T (it is used for output).\n        alphabetSize is optional if T is an Uint8Array or Uint16Array.\n        ASSUMES STRING IS CYCLIC.\n        (XXX: this is twice as inefficient as I'd like! [CSA])\n    */\n    BWT.bwtransform2 = function(T, U, n, alphabetSize) {\n        var i, j, pidx = 0;\n        ASSERT( T && U );\n        ASSERT( T.length >= n && U.length >= n );\n        if (n <= 1) {\n            if (n === 1) { U[0] = T[0]; }\n            return 0;\n        }\n        if (!alphabetSize) {\n            if (T.BYTES_PER_ELEMENT === 1) { alphabetSize = 256; }\n            else if (T.BYTES_PER_ELEMENT === 2) { alphabetSize = 65536; }\n            else throw new Error('Need to specify alphabetSize');\n        }\n        ASSERT( alphabetSize > 0 );\n        if (T.BYTES_PER_ELEMENT) {\n            ASSERT( alphabetSize <= (1 << (T.BYTES_PER_ELEMENT*8) ) );\n        }\n        // double length of T\n        var TT;\n        if (T.length >= n*2) {\n            TT = T; // do it in place if possible\n        } else if (alphabetSize <= 256) {\n            TT = Util.makeU8Buffer(n*2);\n        } else if (alphabetSize <= 65536) {\n            TT = Util.makeU16Buffer(n*2);\n        } else {\n            TT = Util.makeU32Buffer(n*2);\n        }\n        if (TT!==T) {\n            for (i=0; i<n; i++) { TT[i] = T[i]; }\n        }\n        for (i=0; i<n; i++) { TT[n+i] = TT[i]; }\n        // sort doubled string\n        var A = Util.makeS32Buffer(n*2);\n        SA_IS(TT, A, 0, n*2, alphabetSize, false);\n        for (i=0, j=0; i<2*n; i++) {\n            var s = A[i];\n            if (s < n) {\n                if (s === 0) { pidx = j; }\n                if (--s < 0) { s = n-1; }\n                U[j++] = T[s];\n            }\n        }\n        ASSERT(j===n);\n        return pidx;\n    };\n\n    return freeze(BWT);\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./Util\":144,\"./freeze\":145}],122:[function(require,module,exports){\n/* A simple bzip-like BWT compressor with a range encoder; written as a\n * self-test of the BWT package. */\nvar libs = [\n  require('./freeze'),\n  require('./BWT'),\n  require('./DefSumModel'),\n  require('./FenwickModel'),\n  require('./LogDistanceModel'),\n  require('./NoModel'),\n  require('./RangeCoder'),\n  require('./Stream'),\n  require('./Util')\n];\nvar body_fn = function (freeze, BWT, DefSumModel, FenwickModel, LogDistanceModel, NoModel, RangeCoder, Stream, Util) {\n    var EOF = Stream.EOF;\n\n    var F_PROB_MAX  = 0xFF00;\n    var F_PROB_INCR = 0x0100;\n\n    BWTC = Object.create(null);\n    BWTC.MAGIC = \"bwtc\";\n    BWTC.compressFile = Util.compressFileHelper(BWTC.MAGIC, function(input, output, size, props, finalByte) {\n        var encoder = new RangeCoder(output);\n        encoder.encodeStart(finalByte, 1);\n\n        var blockSize = 9;\n        if (typeof(props)==='number' && props >= 1 && props <= 9) {\n            blockSize = props;\n        }\n        encoder.encodeByte(blockSize);\n        var fast = (blockSize <= 5);\n        blockSize *= 100000;\n\n        var block = Util.makeU8Buffer(blockSize);\n        var readBlock = function() {\n            var pos;\n            for (pos=0; pos < blockSize; ) {\n                var ch = input.readByte();\n                if (ch < 0) { break; }\n                block[pos++] = ch;\n            }\n            return pos;\n        };\n        var U = Util.makeU8Buffer(blockSize);\n        var A = Util.makeS32Buffer(blockSize);\n        var M = Util.makeU8Buffer(256); // move to front array\n        var bitModelFactory = NoModel.factory(encoder);\n        var lenModel = new LogDistanceModel(blockSize, 0,\n                                            bitModelFactory,\n                                            bitModelFactory);\n        var length, b, c, pidx, i, j;\n        do {\n            length = readBlock();\n            if (length === 0) { break; }\n            // indicate that there's another block comin'\n            // and encode the length of the block if necessary\n            if (length === block.length) {\n                encoder.encodeFreq(1, 0, 3); // \"full size block\"\n                b = block;\n            } else {\n                encoder.encodeFreq(1, 1, 3); // \"short block\"\n                lenModel.encode(length);\n                b = block.subarray(0, length);\n            }\n            pidx = BWT.bwtransform(b, U, A, length, 256);\n            lenModel.encode(pidx); // starting index\n            // encode the alphabet subset used\n            var useTree = Util.makeU16Buffer(512);\n            for (i=0; i<length; i++) {\n                c = U[i];\n                useTree[256+c] = 1;\n            }\n            for (i=255; i>0; i--) { // sum all the way up the tree\n                useTree[i] = useTree[2*i] + useTree[2*i + 1];\n            }\n            useTree[0] = 1; // sentinel\n            for (i=1; i<512; i++) {\n                var parent = i>>>1;\n                var full = 1 << (9-Util.fls(i));\n                if (useTree[parent] === 0 || useTree[parent] === (full*2)) {\n                    /* already known full/empty */\n                } else if (i >= 256) {\n                    encoder.encodeBit(useTree[i]); // leaf node\n                } else {\n                    var v = useTree[i];\n                    v = (v===0) ? 0 : (v===full) ? 2 : 1;\n                    encoder.encodeFreq(1, v, 3);\n                }\n            }\n            // remap symbols to this subset\n            var alphabetSize = 0;\n            for (i=0; i<256; i++) {\n                if (useTree[256+i]) { // symbol in use\n                    M[alphabetSize++] = i;\n                }\n            }\n            useTree = null;\n            // MTF encoding of U\n            for (i=0; i<length; i++) {\n                c = U[i];\n                for (j=0; j<alphabetSize; j++) {\n                    if (M[j] === c) {\n                        break;\n                    }\n                }\n                console.assert(j<alphabetSize);\n                U[i] = j;\n                // move to front\n                for (; j>0; j--) {\n                    M[j] = M[j-1];\n                }\n                M[0] = c;\n            }\n            // RLE/range encoding\n            var model = new FenwickModel(encoder, alphabetSize+1,\n                                         F_PROB_MAX, F_PROB_INCR);\n            if (fast) { model = new DefSumModel(encoder, alphabetSize+1); }\n            var runLength = 0;\n            var emitLastRun = function() {\n                // binary encode runs of zeros\n                while (runLength !== 0) {\n                    if (runLength&1) {\n                        model.encode(0); // RUNA\n                        runLength-=1;\n                    } else {\n                        model.encode(1); // RUNB\n                        runLength-=2;\n                    }\n                    runLength >>>= 1;\n                }\n            };\n            for (i=0; i<length; i++) {\n                c = U[i];\n                if (c === 0) {\n                    runLength++;\n                } else {\n                    emitLastRun();\n                    model.encode(c+1);\n                    // reset for next\n                    runLength = 0;\n                }\n            }\n            emitLastRun();\n            // done with this block!\n        } while (length === block.length);\n\n        encoder.encodeFreq(1, 2, 3); // \"no more blocks\"\n        encoder.encodeFinish();\n    }, true);\n\n    BWTC.decompressFile = Util.decompressFileHelper(BWTC.MAGIC, function(input, output, size) {\n        var decoder = new RangeCoder(input);\n        decoder.decodeStart(true/* already read the extra byte */);\n        var blockSize = decoder.decodeByte();\n        console.assert(blockSize >= 1 && blockSize <= 9);\n        var fast = (blockSize <= 5);\n        blockSize *= 100000;\n\n        var block = Util.makeU8Buffer(blockSize);\n        var U = Util.makeU8Buffer(blockSize);\n        var A = Util.makeS32Buffer(blockSize);\n        var M = Util.makeU8Buffer(256); // move to front array\n        var bitModelFactory = NoModel.factory(decoder);\n        var lenModel = new LogDistanceModel(blockSize, 0,\n                                            bitModelFactory,\n                                            bitModelFactory);\n        var b, length, i, j, c;\n        while (true) {\n            var blockIndicator = decoder.decodeCulFreq(3);\n            decoder.decodeUpdate(1, blockIndicator, 3);\n            if (blockIndicator === 0) { // full-length block\n                length = blockSize;\n                b = block;\n            } else if (blockIndicator === 1) { // short block\n                length = lenModel.decode();\n                b = block.subarray(0, length);\n            } else if (blockIndicator === 2) { // all done, no more blocks\n                break;\n            }\n            // read starting index for unBWT\n            var pidx = lenModel.decode();\n            // decode the alphabet subset used\n            var useTree = Util.makeU16Buffer(512);\n            useTree[0] = 1; // sentinel\n            for (i=1; i<512; i++) {\n                var parent = i>>>1;\n                var full = 1 << (9-Util.fls(i));\n                if (useTree[parent] === 0 || useTree[parent] === (full*2)) {\n                    /* already known full/empty */\n                    useTree[i] = useTree[parent] >>> 1;\n                } else if (i >= 256) {\n                    useTree[i] = decoder.decodeBit(); // leaf node\n                } else {\n                    var v = decoder.decodeCulFreq(3);\n                    decoder.decodeUpdate(1, v, 3);\n                    useTree[i] = (v===2) ? full : v;\n                }\n            }\n            // remap symbols to this subset\n            var alphabetSize = 0;\n            for (i=0; i<256; i++) {\n                if (useTree[256+i]) { // symbol in use\n                    M[alphabetSize++] = i;\n                }\n            }\n            useTree = null;\n            // RLE/range decoding\n            var model = new FenwickModel(decoder, alphabetSize+1,\n                                         F_PROB_MAX, F_PROB_INCR);\n            if (fast) { model = new DefSumModel(decoder, alphabetSize+1, true);}\n            var val = 1; // repeat count\n            for (i=0; i<length; ) {\n                c = model.decode();\n                if (c===0) {\n                    for (j=0; j<val; j++) { b[i++] = 0; }\n                    val *= 2;\n                } else if (c===1) {\n                    for (j=0; j<val; j++) { b[i++] = 0; b[i++] = 0; }\n                    val *= 2;\n                } else {\n                    val = 1;\n                    b[i++] = c-1;\n                }\n            }\n            // MTF decode\n            for (i=0; i<length; i++) {\n                j = b[i];\n                b[i] = c = M[j];\n                // move to front\n                for (; j>0; j--) {\n                    M[j] = M[j-1];\n                }\n                M[0] = c;\n            }\n            // unBWT\n            BWT.unbwtransform(block, U, A, length, pidx);\n            // emit!\n            output.write(U, 0, length);\n        }\n        decoder.decodeFinish();\n    });\n\n    return BWTC;\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./BWT\":121,\"./DefSumModel\":127,\"./FenwickModel\":131,\"./LogDistanceModel\":134,\"./NoModel\":139,\"./RangeCoder\":141,\"./Stream\":143,\"./Util\":144,\"./freeze\":145}],123:[function(require,module,exports){\n/** Big-Endian Bit Stream, implemented on top of a (normal byte) stream. */\nvar libs = [\n  require('./Stream')\n];\nvar body_fn = function (Stream) {\n\n    var BitStream = function(stream) {\n        (function() {\n            var bufferByte = 0x100; // private var for readers\n            this.readBit = function() {\n                if ((bufferByte & 0xFF) === 0) {\n                    var ch = stream.readByte();\n                    if (ch === Stream.EOF) {\n                        this._eof = true;\n                        return ch; /* !!! */\n                    }\n                    bufferByte = (ch << 1) | 1;\n                }\n                var bit = (bufferByte & 0x100) ? 1 : 0;\n                bufferByte <<= 1;\n                return bit;\n            };\n            // seekable iff the provided stream is\n            this.seekBit = function(pos) {\n                var n_byte = pos >>> 3;\n                var n_bit = pos - (n_byte*8);\n                this.seek(n_byte);\n                this._eof = false;\n                this.readBits(n_bit);\n            };\n            this.tellBit = function() {\n                var pos = stream.tell() * 8;\n                var b = bufferByte;\n                while ((b & 0xFF) !== 0) {\n                    pos--;\n                    b <<= 1;\n                }\n                return pos;\n            };\n            // implement byte stream interface as well.\n            this.readByte = function() {\n                if ((bufferByte & 0xFF) === 0) {\n                    return stream.readByte();\n                }\n                return this.readBits(8);\n            };\n            this.seek = function(pos) {\n                stream.seek(pos);\n                bufferByte = 0x100;\n            };\n        }).call(this);\n        (function() {\n            var bufferByte = 1; // private var for writers\n            this.writeBit = function(b) {\n                bufferByte <<= 1;\n                if (b) { bufferByte |= 1; }\n                if (bufferByte & 0x100) {\n                    stream.writeByte(bufferByte & 0xFF);\n                    bufferByte = 1;\n                }\n            };\n            // implement byte stream interface as well\n            this.writeByte = function(_byte) {\n                if (bufferByte===1) {\n                    stream.writeByte(_byte);\n                } else {\n                    stream.writeBits(8, _byte);\n                }\n            };\n            this.flush = function() {\n                while (bufferByte !== 1) {\n                    this.writeBit(0);\n                }\n                if (stream.flush) { stream.flush(); }\n            };\n        }).call(this);\n    };\n    // inherit read/write methods from Stream.\n    BitStream.EOF = Stream.EOF;\n    BitStream.prototype = Object.create(Stream.prototype);\n    // bit chunk read/write\n    BitStream.prototype.readBits = function(n) {\n        var i, r = 0, b;\n        if (n > 31) {\n            r = this.readBits(n-16)*0x10000; // fp multiply, not shift\n            return r + this.readBits(16);\n        }\n        for (i = 0; i < n; i++) {\n            r <<= 1; // this could make a negative value if n>31\n            // bits read past EOF are all zeros!\n            if (this.readBit() > 0) { r++; }\n        }\n        return r;\n    };\n    BitStream.prototype.writeBits = function(n, value) {\n        if (n > 32) {\n            var low = (value & 0xFFFF);\n            var high = (value - low) / (0x10000); // fp division, not shift\n            this.writeBits(n-16, high);\n            this.writeBits(16, low);\n            return;\n        }\n        var i;\n        for (i = n-1; i >= 0; i--) {\n            this.writeBit( (value >>> i) & 1 );\n        }\n    };\n\n    return BitStream;\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./Stream\":143}],124:[function(require,module,exports){\n/*\nAn implementation of Bzip2 de/compression, including the ability to\nseek within bzip2 data.\n\nCopyright (C) 2013 C. Scott Ananian\nCopyright (C) 2012 Eli Skeggs\nCopyright (C) 2011 Kevin Kwok\n\nThis library is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Lesser General Public\nLicense as published by the Free Software Foundation; either\nversion 2.1 of the License, or (at your option) any later version.\n\nThis library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public\nLicense along with this library; if not, see\nhttp://www.gnu.org/licenses/lgpl-2.1.html\n\nAdapted from node-bzip, copyright 2012 Eli Skeggs.\nAdapted from bzip2.js, copyright 2011 Kevin Kwok (antimatter15@gmail.com).\n\nBased on micro-bunzip by Rob Landley (rob@landley.net).\n\nBased on bzip2 decompression code by Julian R Seward (jseward@acm.org),\nwhich also acknowledges contributions by Mike Burrows, David Wheeler,\nPeter Fenwick, Alistair Moffat, Radford Neal, Ian H. Witten,\nRobert Sedgewick, and Jon L. Bentley.\n\nBWT implementation based on work by Yuta Mori; see BWT.js for details.\n\nbzip2 compression code inspired by https://code.google.com/p/jbzip2\n*/\nvar libs = [\n  require('./freeze'),\n  require('./BitStream'),\n  require('./BWT'),\n  require('./CRC32'),\n  require('./HuffmanAllocator'),\n  require('./Stream'),\n  require('./Util')\n];\nvar body_fn = function (freeze, BitStream, BWT, CRC32, HuffmanAllocator, Stream, Util) {\n\nvar MAX_HUFCODE_BITS = 20;\nvar MAX_SYMBOLS = 258;\nvar SYMBOL_RUNA = 0;\nvar SYMBOL_RUNB = 1;\nvar MIN_GROUPS = 2;\nvar MAX_GROUPS = 6;\nvar GROUP_SIZE = 50;\n\nvar WHOLEPI = 0x314159265359; // 48-bit integer\nvar SQRTPI =  0x177245385090; // 48-bit integer\n\nvar EOF = Stream.EOF;\n\nvar mtf = function(array, index) {\n  var src = array[index], i;\n  for (i = index; i > 0; i--) {\n    array[i] = array[i-1];\n  }\n  array[0] = src;\n  return src;\n};\n\nvar Err = {\n  OK: 0,\n  LAST_BLOCK: -1,\n  NOT_BZIP_DATA: -2,\n  UNEXPECTED_INPUT_EOF: -3,\n  UNEXPECTED_OUTPUT_EOF: -4,\n  DATA_ERROR: -5,\n  OUT_OF_MEMORY: -6,\n  OBSOLETE_INPUT: -7,\n  END_OF_BLOCK: -8\n};\nvar ErrorMessages = {};\nErrorMessages[Err.LAST_BLOCK] =            \"Bad file checksum\";\nErrorMessages[Err.NOT_BZIP_DATA] =         \"Not bzip data\";\nErrorMessages[Err.UNEXPECTED_INPUT_EOF] =  \"Unexpected input EOF\";\nErrorMessages[Err.UNEXPECTED_OUTPUT_EOF] = \"Unexpected output EOF\";\nErrorMessages[Err.DATA_ERROR] =            \"Data error\";\nErrorMessages[Err.OUT_OF_MEMORY] =         \"Out of memory\";\nErrorMessages[Err.OBSOLETE_INPUT] = \"Obsolete (pre 0.9.5) bzip format not supported.\";\n\nvar _throw = function(status, optDetail) {\n  var msg = ErrorMessages[status] || 'unknown error';\n  if (optDetail) { msg += ': '+optDetail; }\n  var e = new TypeError(msg);\n  e.errorCode = status;\n  throw e;\n};\n\nvar Bunzip = function(inputStream, outputStream) {\n  this.writePos = this.writeCurrent = this.writeCount = 0;\n\n  this._start_bunzip(inputStream, outputStream);\n};\nBunzip.prototype._init_block = function() {\n  var moreBlocks = this._get_next_block();\n  if ( !moreBlocks ) {\n    this.writeCount = -1;\n    return false; /* no more blocks */\n  }\n  this.blockCRC = new CRC32();\n  return true;\n};\n/* XXX micro-bunzip uses (inputStream, inputBuffer, len) as arguments */\nBunzip.prototype._start_bunzip = function(inputStream, outputStream) {\n  /* Ensure that file starts with \"BZh['1'-'9'].\" */\n  var buf = Util.makeU8Buffer(4);\n  if (inputStream.read(buf, 0, 4) !== 4 ||\n      String.fromCharCode(buf[0], buf[1], buf[2]) !== 'BZh')\n    _throw(Err.NOT_BZIP_DATA, 'bad magic');\n\n  var level = buf[3] - 0x30;\n  if (level < 1 || level > 9)\n    _throw(Err.NOT_BZIP_DATA, 'level out of range');\n\n  this.reader = new BitStream(inputStream);\n\n  /* Fourth byte (ascii '1'-'9'), indicates block size in units of 100k of\n     uncompressed data.  Allocate intermediate buffer for block. */\n  this.dbufSize = 100000 * level;\n  this.nextoutput = 0;\n  this.outputStream = outputStream;\n  this.streamCRC = 0;\n};\nBunzip.prototype._get_next_block = function() {\n  var i, j, k;\n  var reader = this.reader;\n  // this is get_next_block() function from micro-bunzip:\n  /* Read in header signature and CRC, then validate signature.\n     (last block signature means CRC is for whole file, return now) */\n  var h = reader.readBits(48);\n  if (h === SQRTPI) { // last block\n    return false; /* no more blocks */\n  }\n  if (h !== WHOLEPI)\n    _throw(Err.NOT_BZIP_DATA);\n  this.targetBlockCRC = reader.readBits(32);\n  this.streamCRC = (this.targetBlockCRC ^\n                    ((this.streamCRC << 1) | (this.streamCRC>>>31))) >>> 0;\n  /* We can add support for blockRandomised if anybody complains.  There was\n     some code for this in busybox 1.0.0-pre3, but nobody ever noticed that\n     it didn't actually work. */\n  if (reader.readBits(1))\n    _throw(Err.OBSOLETE_INPUT);\n  var origPointer = reader.readBits(24);\n  if (origPointer > this.dbufSize)\n    _throw(Err.DATA_ERROR, 'initial position out of bounds');\n  /* mapping table: if some byte values are never used (encoding things\n     like ASCII text), the compression code removes the gaps to have fewer\n     symbols to deal with, and writes a sparse bitfield indicating which\n     values were present.  We make a translation table to convert the symbols\n     back to the corresponding bytes. */\n  var t = reader.readBits(16);\n  var symToByte = Util.makeU8Buffer(256), symTotal = 0;\n  for (i = 0; i < 16; i++) {\n    if (t & (1 << (0xF - i))) {\n      var o = i * 16;\n      k = reader.readBits(16);\n      for (j = 0; j < 16; j++)\n        if (k & (1 << (0xF - j)))\n          symToByte[symTotal++] = o + j;\n    }\n  }\n\n  /* How many different Huffman coding groups does this block use? */\n  var groupCount = reader.readBits(3);\n  if (groupCount < MIN_GROUPS || groupCount > MAX_GROUPS)\n    _throw(Err.DATA_ERROR);\n  /* nSelectors: Every GROUP_SIZE many symbols we select a new Huffman coding\n     group.  Read in the group selector list, which is stored as MTF encoded\n     bit runs.  (MTF=Move To Front, as each value is used it's moved to the\n     start of the list.) */\n  var nSelectors = reader.readBits(15);\n  if (nSelectors === 0)\n    _throw(Err.DATA_ERROR);\n\n  var mtfSymbol = Util.makeU8Buffer(256);\n  for (i = 0; i < groupCount; i++)\n    mtfSymbol[i] = i;\n\n  var selectors = Util.makeU8Buffer(nSelectors); // was 32768...\n\n  for (i = 0; i < nSelectors; i++) {\n    /* Get next value */\n    for (j = 0; reader.readBits(1); j++)\n      if (j >= groupCount) _throw(Err.DATA_ERROR);\n    /* Decode MTF to get the next selector */\n    selectors[i] = mtf(mtfSymbol, j);\n  }\n\n  /* Read the Huffman coding tables for each group, which code for symTotal\n     literal symbols, plus two run symbols (RUNA, RUNB) */\n  var symCount = symTotal + 2;\n  var groups = [], hufGroup;\n  for (j = 0; j < groupCount; j++) {\n    var length = Util.makeU8Buffer(symCount), temp = Util.makeU8Buffer(MAX_HUFCODE_BITS + 1);\n    /* Read Huffman code lengths for each symbol.  They're stored in\n       a way similar to MTF; record a starting value for the first symbol,\n       and an offset from the previous value for every symbol after that. */\n    t = reader.readBits(5); // lengths\n    for (i = 0; i < symCount; i++) {\n      for (;;) {\n        if (t < 1 || t > MAX_HUFCODE_BITS) _throw(Err.DATA_ERROR);\n        /* If first bit is 0, stop.  Else second bit indicates whether\n           to increment or decrement the value. */\n        if(!reader.readBits(1))\n          break;\n        if(!reader.readBits(1))\n          t++;\n        else\n          t--;\n      }\n      length[i] = t;\n    }\n\n    /* Find largest and smallest lengths in this group */\n    var minLen,  maxLen;\n    minLen = maxLen = length[0];\n    for (i = 1; i < symCount; i++) {\n      if (length[i] > maxLen)\n        maxLen = length[i];\n      else if (length[i] < minLen)\n        minLen = length[i];\n    }\n\n    /* Calculate permute[], base[], and limit[] tables from length[].\n     *\n     * permute[] is the lookup table for converting Huffman coded symbols\n     * into decoded symbols.  base[] is the amount to subtract from the\n     * value of a Huffman symbol of a given length when using permute[].\n     *\n     * limit[] indicates the largest numerical value a symbol with a given\n     * number of bits can have.  This is how the Huffman codes can vary in\n     * length: each code with a value>limit[length] needs another bit.\n     */\n    hufGroup = {};\n    groups.push(hufGroup);\n    hufGroup.permute = Util.makeU16Buffer(MAX_SYMBOLS);\n    hufGroup.limit = Util.makeU32Buffer(MAX_HUFCODE_BITS + 2);\n    hufGroup.base = Util.makeU32Buffer(MAX_HUFCODE_BITS + 1);\n    hufGroup.minLen = minLen;\n    hufGroup.maxLen = maxLen;\n    /* Calculate permute[].  Concurrently, initialize temp[] and limit[]. */\n    var pp = 0;\n    for (i = minLen; i <= maxLen; i++) {\n      temp[i] = hufGroup.limit[i] = 0;\n      for (t = 0; t < symCount; t++)\n        if (length[t] === i)\n          hufGroup.permute[pp++] = t;\n    }\n    /* Count symbols coded for at each bit length */\n    for (i = 0; i < symCount; i++)\n      temp[length[i]]++;\n    /* Calculate limit[] (the largest symbol-coding value at each bit\n     * length, which is (previous limit<<1)+symbols at this level), and\n     * base[] (number of symbols to ignore at each bit length, which is\n     * limit minus the cumulative count of symbols coded for already). */\n    pp = t = 0;\n    for (i = minLen; i < maxLen; i++) {\n      pp += temp[i];\n      /* We read the largest possible symbol size and then unget bits\n         after determining how many we need, and those extra bits could\n         be set to anything.  (They're noise from future symbols.)  At\n         each level we're really only interested in the first few bits,\n         so here we set all the trailing to-be-ignored bits to 1 so they\n         don't affect the value>limit[length] comparison. */\n      hufGroup.limit[i] = pp - 1;\n      pp <<= 1;\n      t += temp[i];\n      hufGroup.base[i + 1] = pp - t;\n    }\n    hufGroup.limit[maxLen + 1] = Number.MAX_VALUE; /* Sentinel value for reading next sym. */\n    hufGroup.limit[maxLen] = pp + temp[maxLen] - 1;\n    hufGroup.base[minLen] = 0;\n  }\n  /* We've finished reading and digesting the block header.  Now read this\n     block's Huffman coded symbols from the file and undo the Huffman coding\n     and run length encoding, saving the result into dbuf[dbufCount++]=uc */\n\n  /* Initialize symbol occurrence counters and symbol Move To Front table */\n  var byteCount = Util.makeU32Buffer(256);\n  for (i = 0; i < 256; i++)\n    mtfSymbol[i] = i;\n  /* Loop through compressed symbols. */\n  var runPos = 0, dbufCount = 0, selector = 0, uc;\n  var dbuf = this.dbuf = Util.makeU32Buffer(this.dbufSize);\n  symCount = 0;\n  for (;;) {\n    /* Determine which Huffman coding group to use. */\n    if (!(symCount--)) {\n      symCount = GROUP_SIZE - 1;\n      if (selector >= nSelectors) { _throw(Err.DATA_ERROR); }\n      hufGroup = groups[selectors[selector++]];\n    }\n    /* Read next Huffman-coded symbol. */\n    i = hufGroup.minLen;\n    j = reader.readBits(i);\n    for (;;i++) {\n      if (i > hufGroup.maxLen) { _throw(Err.DATA_ERROR); }\n      if (j <= hufGroup.limit[i])\n        break;\n      j = (j << 1) | reader.readBits(1);\n    }\n    /* Huffman decode value to get nextSym (with bounds checking) */\n    j -= hufGroup.base[i];\n    if (j < 0 || j >= MAX_SYMBOLS) { _throw(Err.DATA_ERROR); }\n    var nextSym = hufGroup.permute[j];\n    /* We have now decoded the symbol, which indicates either a new literal\n       byte, or a repeated run of the most recent literal byte.  First,\n       check if nextSym indicates a repeated run, and if so loop collecting\n       how many times to repeat the last literal. */\n    if (nextSym === SYMBOL_RUNA || nextSym === SYMBOL_RUNB) {\n      /* If this is the start of a new run, zero out counter */\n      if (!runPos){\n        runPos = 1;\n        t = 0;\n      }\n      /* Neat trick that saves 1 symbol: instead of or-ing 0 or 1 at\n         each bit position, add 1 or 2 instead.  For example,\n         1011 is 1<<0 + 1<<1 + 2<<2.  1010 is 2<<0 + 2<<1 + 1<<2.\n         You can make any bit pattern that way using 1 less symbol than\n         the basic or 0/1 method (except all bits 0, which would use no\n         symbols, but a run of length 0 doesn't mean anything in this\n         context).  Thus space is saved. */\n      if (nextSym === SYMBOL_RUNA)\n        t += runPos;\n      else\n        t += 2 * runPos;\n      runPos <<= 1;\n      continue;\n    }\n    /* When we hit the first non-run symbol after a run, we now know\n       how many times to repeat the last literal, so append that many\n       copies to our buffer of decoded symbols (dbuf) now.  (The last\n       literal used is the one at the head of the mtfSymbol array.) */\n    if (runPos){\n      runPos = 0;\n      if (dbufCount + t >= this.dbufSize) { _throw(Err.DATA_ERROR); }\n      uc = symToByte[mtfSymbol[0]];\n      byteCount[uc] += t;\n      while (t--)\n        dbuf[dbufCount++] = uc;\n    }\n    /* Is this the terminating symbol? */\n    if (nextSym > symTotal)\n      break;\n    /* At this point, nextSym indicates a new literal character.  Subtract\n       one to get the position in the MTF array at which this literal is\n       currently to be found.  (Note that the result can't be -1 or 0,\n       because 0 and 1 are RUNA and RUNB.  But another instance of the\n       first symbol in the MTF array, position 0, would have been handled\n       as part of a run above.  Therefore 1 unused MTF position minus\n       2 non-literal nextSym values equals -1.) */\n    if (dbufCount >= this.dbufSize) { _throw(Err.DATA_ERROR); }\n    i = nextSym - 1;\n    uc = mtf(mtfSymbol, i);\n    uc = symToByte[uc];\n    /* We have our literal byte.  Save it into dbuf. */\n    byteCount[uc]++;\n    dbuf[dbufCount++] = uc;\n  }\n  /* At this point, we've read all the Huffman-coded symbols (and repeated\n     runs) for this block from the input stream, and decoded them into the\n     intermediate buffer.  There are dbufCount many decoded bytes in dbuf[].\n     Now undo the Burrows-Wheeler transform on dbuf.\n     See http://dogma.net/markn/articles/bwt/bwt.htm\n  */\n  if (origPointer < 0 || origPointer >= dbufCount) { _throw(Err.DATA_ERROR); }\n  /* Turn byteCount into cumulative occurrence counts of 0 to n-1. */\n  j = 0;\n  for (i = 0; i < 256; i++) {\n    k = j + byteCount[i];\n    byteCount[i] = j;\n    j = k;\n  }\n  /* Figure out what order dbuf would be in if we sorted it. */\n  for (i = 0; i < dbufCount; i++) {\n    uc = dbuf[i] & 0xff;\n    dbuf[byteCount[uc]] |= (i << 8);\n    byteCount[uc]++;\n  }\n  /* Decode first byte by hand to initialize \"previous\" byte.  Note that it\n     doesn't get output, and if the first three characters are identical\n     it doesn't qualify as a run (hence writeRunCountdown=5). */\n  var pos = 0, current = 0, run = 0;\n  if (dbufCount) {\n    pos = dbuf[origPointer];\n    current = (pos & 0xff);\n    pos >>= 8;\n    run = -1;\n  }\n  this.writePos = pos;\n  this.writeCurrent = current;\n  this.writeCount = dbufCount;\n  this.writeRun = run;\n\n  return true; /* more blocks to come */\n};\n/* Undo burrows-wheeler transform on intermediate buffer to produce output.\n   If start_bunzip was initialized with out_fd=-1, then up to len bytes of\n   data are written to outbuf.  Return value is number of bytes written or\n   error (all errors are negative numbers).  If out_fd!=-1, outbuf and len\n   are ignored, data is written to out_fd and return is RETVAL_OK or error.\n*/\nBunzip.prototype._read_bunzip = function(outputBuffer, len) {\n    var copies, previous, outbyte;\n    /* james@jamestaylor.org: writeCount goes to -1 when the buffer is fully\n       decoded, which results in this returning RETVAL_LAST_BLOCK, also\n       equal to -1... Confusing, I'm returning 0 here to indicate no\n       bytes written into the buffer */\n  if (this.writeCount < 0) { return 0; }\n\n  var gotcount = 0;\n  var dbuf = this.dbuf, pos = this.writePos, current = this.writeCurrent;\n  var dbufCount = this.writeCount, outputsize = this.outputsize;\n  var run = this.writeRun;\n\n  while (dbufCount) {\n    dbufCount--;\n    previous = current;\n    pos = dbuf[pos];\n    current = pos & 0xff;\n    pos >>= 8;\n    if (run++ === 3){\n      copies = current;\n      outbyte = previous;\n      current = -1;\n    } else {\n      copies = 1;\n      outbyte = current;\n    }\n    this.blockCRC.updateCRCRun(outbyte, copies);\n    while (copies--) {\n      this.outputStream.writeByte(outbyte);\n      this.nextoutput++;\n    }\n    if (current != previous)\n      run = 0;\n  }\n  this.writeCount = dbufCount;\n  // check CRC\n  if (this.blockCRC.getCRC() !== this.targetBlockCRC) {\n    _throw(Err.DATA_ERROR, \"Bad block CRC \"+\n           \"(got \"+this.blockCRC.getCRC().toString(16)+\n           \" expected \"+this.targetBlockCRC.toString(16)+\")\");\n  }\n  return this.nextoutput;\n};\n\n/* Static helper functions */\nBunzip.Err = Err;\n// 'input' can be a stream or a buffer\n// 'output' can be a stream or a buffer or a number (buffer size)\nBunzip.decode = function(input, output, multistream) {\n  // make a stream from a buffer, if necessary\n  var inputStream = Util.coerceInputStream(input);\n  var o = Util.coerceOutputStream(output, output);\n  var outputStream = o.stream;\n\n  var bz = new Bunzip(inputStream, outputStream);\n  while (true) {\n    if ('eof' in inputStream && inputStream.eof()) break;\n    if (bz._init_block()) {\n      bz._read_bunzip();\n    } else {\n      var targetStreamCRC = bz.reader.readBits(32);\n      if (targetStreamCRC !== bz.streamCRC) {\n        _throw(Err.DATA_ERROR, \"Bad stream CRC \"+\n               \"(got \"+bz.streamCRC.toString(16)+\n               \" expected \"+targetStreamCRC.toString(16)+\")\");\n      }\n      if (multistream &&\n          'eof' in inputStream &&\n          !inputStream.eof()) {\n        // note that start_bunzip will also resync the bit reader to next byte\n        bz._start_bunzip(inputStream, outputStream);\n      } else break;\n    }\n  }\n  return o.retval;\n};\nBunzip.decodeBlock = function(input, pos, output) {\n  // make a stream from a buffer, if necessary\n  var inputStream = Util.coerceInputStream(input);\n  var o = Util.coerceOutputStream(output, output);\n  var outputStream = o.stream;\n  var bz = new Bunzip(inputStream, outputStream);\n  bz.reader.seekBit(pos);\n  /* Fill the decode buffer for the block */\n  var moreBlocks = bz._get_next_block();\n  if (moreBlocks) {\n    /* Init the CRC for writing */\n    bz.blockCRC = new CRC32();\n\n    /* Zero this so the current byte from before the seek is not written */\n    bz.writeCopies = 0;\n\n    /* Decompress the block and write to stdout */\n    bz._read_bunzip();\n    // XXX keep writing?\n  }\n  return o.retval;\n};\n/* Reads bzip2 file from stream or buffer `input`, and invoke\n * `callback(position, size)` once for each bzip2 block,\n * where position gives the starting position (in *bits*)\n * and size gives uncompressed size of the block (in *bytes*). */\nBunzip.table = function(input, callback, multistream) {\n  // make a stream from a buffer, if necessary\n  var inputStream = new Stream();\n  inputStream.delegate = Util.coerceInputStream(input);\n  inputStream.pos = 0;\n  inputStream.readByte = function() {\n    this.pos++;\n    return this.delegate.readByte();\n  };\n  inputStream.tell = function() { return this.pos; };\n  if (inputStream.delegate.eof) {\n    inputStream.eof = inputStream.delegate.eof.bind(inputStream.delegate);\n  }\n  var outputStream = new Stream();\n  outputStream.pos = 0;\n  outputStream.writeByte = function() { this.pos++; };\n\n  var bz = new Bunzip(inputStream, outputStream);\n  var blockSize = bz.dbufSize;\n  while (true) {\n    if ('eof' in inputStream && inputStream.eof()) break;\n\n    var position = bz.reader.tellBit();\n\n    if (bz._init_block()) {\n      var start = outputStream.pos;\n      bz._read_bunzip();\n      callback(position, outputStream.pos - start);\n    } else {\n      var crc = bz.reader.readBits(32); // (but we ignore the crc)\n      if (multistream &&\n          'eof' in inputStream &&\n          !inputStream.eof()) {\n        // note that start_bunzip will also resync the bit reader to next byte\n        bz._start_bunzip(inputStream, outputStream);\n        console.assert(bz.dbufSize === blockSize,\n                       \"shouldn't change block size within multistream file\");\n      } else break;\n    }\n  }\n};\n\n// create a Huffman tree from the table of frequencies\nvar StaticHuffman = function(freq, alphabetSize) {\n  // As in BZip2HuffmanStageEncoder.java (from jbzip2):\n  // The Huffman allocator needs its input symbol frequencies to be\n  // sorted, but we need to return code lengths in the same order as\n  // the corresponding frequencies are passed in.\n  // The symbol frequency and index are merged into a single array of\n  // integers - frequency in the high 23 bits, index in the low 9\n  // bits.\n  //     2^23 = 8,388,608 which is higher than the maximum possible\n  //            frequency for one symbol in a block\n  //     2^9 = 512 which is higher than the maximum possible\n  //            alphabet size (== 258)\n  // Sorting this array simultaneously sorts the frequencies and\n  // leaves a lookup that can be used to cheaply invert the sort\n  var i, mergedFreq = [];\n  for (i=0; i<alphabetSize; i++) {\n    mergedFreq[i] = (freq[i] << 9) | i;\n  }\n  mergedFreq.sort(function(a,b) { return a-b; });\n  var sortedFreq = mergedFreq.map(function(v) { return v>>>9; });\n  // allocate code lengths in place. (result in sortedFreq array)\n  HuffmanAllocator.allocateHuffmanCodeLengths(sortedFreq, MAX_HUFCODE_BITS);\n  // reverse the sort to put codes & code lengths in order of input symbols\n  this.codeLengths = Util.makeU8Buffer(alphabetSize);\n  for (i=0; i<alphabetSize; i++) {\n    var sym = mergedFreq[i] & 0x1FF;\n    this.codeLengths[sym] = sortedFreq[i];\n  }\n};\n// compute canonical Huffman codes, given code lengths\nStaticHuffman.prototype.computeCanonical = function() {\n  var alphabetSize = this.codeLengths.length;\n  // merge arrays; sort first by length then by symbol.\n  var i, merged = [];\n  for (i=0; i<alphabetSize; i++) {\n    merged[i] = (this.codeLengths[i] << 9) | i;\n  }\n  merged.sort(function(a,b) { return a-b; });\n  // use sorted lengths to assign codes\n  this.code = Util.makeU32Buffer(alphabetSize);\n  var code = 0, prevLen = 0;\n  for (i=0; i<alphabetSize; i++) {\n    var curLen = merged[i] >>> 9;\n    var sym = merged[i] & 0x1FF;\n    console.assert(prevLen <= curLen);\n    code <<= (curLen - prevLen);\n    this.code[sym] = code++;\n    prevLen = curLen;\n  }\n};\n// compute the cost of encoding the given range of symbols w/ this Huffman code\nStaticHuffman.prototype.cost = function(array, offset, length) {\n  var i, cost = 0;\n  for (i=0; i<length; i++) {\n    cost += this.codeLengths[array[offset+i]];\n  }\n  return cost;\n};\n// emit the bit lengths used by this Huffman code\nStaticHuffman.prototype.emit = function(outStream) {\n  // write the starting length\n  var i, currentLength = this.codeLengths[0];\n  outStream.writeBits(5, currentLength);\n  for (i=0; i<this.codeLengths.length; i++) {\n    var codeLength = this.codeLengths[i];\n    var value, delta;\n    console.assert(codeLength > 0 && codeLength <= MAX_HUFCODE_BITS);\n    if (currentLength < codeLength) {\n      value = 2; delta = codeLength - currentLength;\n    } else {\n      value = 3; delta = currentLength - codeLength;\n    }\n    while (delta-- > 0) {\n      outStream.writeBits(2, value);\n    }\n    outStream.writeBit(0);\n    currentLength = codeLength;\n  }\n};\n// encode the given symbol with this Huffman code\nStaticHuffman.prototype.encode = function(outStream, symbol) {\n  outStream.writeBits(this.codeLengths[symbol], this.code[symbol]);\n};\n\n// read a block for bzip2 compression.\nvar readBlock = function(inStream, block, length, crc) {\n  var pos = 0;\n  var lastChar = -1;\n  var runLength = 0;\n  while (pos < length) {\n    if (runLength===4) {\n      block[pos++] = 0;\n      if (pos >= length) { break; }\n    }\n    var ch = inStream.readByte();\n    if (ch === EOF) {\n      break;\n    }\n    crc.updateCRC(ch);\n    if (ch !== lastChar) {\n      lastChar = ch;\n      runLength = 1;\n    } else {\n      runLength++;\n      if (runLength > 4) {\n        if (runLength < 256) {\n          block[pos-1]++;\n          continue;\n        } else {\n          runLength = 1;\n        }\n      }\n    }\n    block[pos++] = ch;\n  }\n  return pos;\n};\n\n// divide the input into groups at most GROUP_SIZE symbols long.\n// assign each group to the Huffman table which compresses it best.\nvar assignSelectors = function(selectors, groups, input) {\n  var i, j, k;\n  for (i=0, k=0; i<input.length; i+=GROUP_SIZE) {\n    var groupSize = Math.min(GROUP_SIZE, input.length - i);\n    var best = 0, bestCost = groups[0].cost(input, i, groupSize);\n    for (j=1; j<groups.length; j++) {\n      var groupCost = groups[j].cost(input, i, groupSize);\n      if (groupCost < bestCost) {\n        best = j; bestCost = groupCost;\n      }\n    }\n    selectors[k++] = best;\n  }\n};\nvar optimizeHuffmanGroups = function(groups, targetGroups, input,\n                                     selectors, alphabetSize) {\n  // until we've got \"targetGroups\" Huffman codes, pick the Huffman code which\n  // matches the largest # of groups and split it by picking the groups\n  // which require more than the median number of bits to encode.\n  // then recompute frequencies and reassign Huffman codes.\n  var i, j, k, groupCounts = [];\n  while (groups.length < targetGroups) {\n    assignSelectors(selectors, groups, input);\n    // which code gets used the most?\n    for (i=0; i<groups.length; i++) { groupCounts[i] = 0; }\n    for (i=0; i<selectors.length; i++) {\n      groupCounts[selectors[i]]++;\n    }\n    var which = groupCounts.indexOf(Math.max.apply(Math, groupCounts));\n    // ok, let's look at the size of those blocks\n    var splits = [];\n    for (i=0, j=0; i<selectors.length; i++) {\n      if (selectors[i] !== which) { continue; }\n      var start = i*GROUP_SIZE;\n      var end = Math.min(start + GROUP_SIZE, input.length);\n      splits.push({index: i, cost:groups[which].cost(input, start, end-start)});\n    }\n    // find the median.  there are O(n) algorithms to do this, but we'll\n    // be lazy and use a full O(n ln n) sort.\n    splits.sort(function(s1, s2) { return s1.cost - s2.cost; });\n    // assign the groups in the top half to the \"new\" selector\n    for (i=(splits.length>>>1); i<splits.length; i++) {\n      selectors[splits[i].index] = groups.length;\n    }\n    groups.push(null);\n    // recompute frequencies\n    var freq = [], f;\n    for (i=0; i<groups.length; i++) {\n      f = freq[i] = [];\n      for (j=0; j<alphabetSize; j++) { f[j] = 0; }\n    }\n    for (i=0, j=0; i<input.length; ) {\n      f = freq[selectors[j++]];\n      for (k=0; k<GROUP_SIZE && i<input.length; k++) {\n        f[input[i++]]++;\n      }\n    }\n    // reconstruct Huffman codes\n    for (i=0; i<groups.length; i++) {\n      groups[i] = new StaticHuffman(freq[i], alphabetSize);\n    }\n  }\n};\n\nvar compressBlock = function(block, length, outStream) {\n  var c, i, j, k;\n  // do BWT transform\n  var U = Util.makeU8Buffer(length);\n  var pidx = BWT.bwtransform2(block, U, length, 256);\n  outStream.writeBit(0); // not randomized\n  outStream.writeBits(24, pidx);\n  // track values used; write bitmap\n  var used = [], compact = [];\n  for (i=0; i<length; i++) {\n    c = block[i];\n    used[c] = true;\n    compact[c>>>4] = true;\n  }\n  for (i=0; i<16; i++) {\n    outStream.writeBit(!!compact[i]);\n  }\n  for (i=0; i<16; i++) {\n    if (compact[i]) {\n      for (j=0; j<16; j++) {\n        outStream.writeBit(!!used[(i<<4)|j]);\n      }\n    }\n  }\n  var alphabetSize = 0;\n  for (i=0; i<256; i++) {\n    if (used[i]) {\n      alphabetSize++;\n    }\n  }\n  // now MTF and RLE/2 encoding, while tracking symbol statistics.\n  // output can be one longer than length, because we include the\n  // end-of-block character at the end. Similarly, we need a U16\n  // array because the end-of-block character can be 256.\n  var A = Util.makeU16Buffer(length+1);\n  var endOfBlock = alphabetSize + 1;\n  var freq = [];\n  for (i=0; i<=endOfBlock; i++) { freq[i] = 0; }\n  var M = Util.makeU8Buffer(alphabetSize);\n  for (i=0, j=0; i<256; i++) {\n    if (used[i]) { M[j++] = i; }\n  }\n  used = null; compact = null;\n  var pos = 0, runLength = 0;\n  var emit = function(c) {\n    A[pos++] = c;\n    freq[c]++;\n  };\n  var emitLastRun = function() {\n    while (runLength !== 0) {\n      if (runLength & 1) {\n        emit(0); // RUNA\n        runLength -= 1;\n      } else {\n        emit(1); // RUNB\n        runLength -= 2;\n      }\n      runLength >>>= 1;\n    }\n  };\n  for (i=0; i<U.length; i++) {\n    c = U[i];\n    // look for C in M\n    for (j=0; j<alphabetSize; j++) {\n      if (M[j]===c) { break; }\n    }\n    console.assert(j!==alphabetSize);\n    // shift MTF array\n    mtf(M, j);\n    // emit j\n    if (j===0) {\n      runLength++;\n    } else {\n      emitLastRun();\n      emit(j+1);\n      runLength = 0;\n    }\n  }\n  emitLastRun();\n  emit(endOfBlock); // end of block symbol\n  A = A.subarray(0, pos);\n  // now A[0...pos) has the encoded output, and freq[0-alphabetSize] has the\n  // frequencies.  Use these to construct Huffman tables.\n  // the canonical bzip2 encoder does some complicated optimization\n  // to attempt to select the best tables.  We're going to simplify things:\n  // (unless the block is very short) we're always going to create MAX_GROUPS\n  // tables; 1 based on global frequencies, and the rest based on dividing the\n  // block into MAX_GROUPS-1 pieces.\n  var groups = [];\n  var targetGroups; // how many Huffman groups should we create?\n  // look at length of MTF-encoded block to pick a good number of groups\n  if (pos >= 2400) { targetGroups = 6; }\n  else if (pos >= 1200) { targetGroups = 5; }\n  else if (pos >= 600) { targetGroups = 4; }\n  else if (pos >= 200) { targetGroups = 3; }\n  else { targetGroups = 2; }\n  // start with two Huffman groups: one with the global frequencies, and\n  // a second with a flat frequency distribution (which is also the smallest\n  // possible Huffman table to encode, which is handy to prevent excessive\n  // bloat if the input file size is very small)\n  groups.push(new StaticHuffman(freq, endOfBlock+1));\n  for (i=0; i<=endOfBlock; i++) { freq[i] = 1; }\n  groups.push(new StaticHuffman(freq, endOfBlock+1));\n  freq = null;\n  // Now optimize the Huffman groups!  this is a black art.\n  // we probably don't want to waste too much time on it, though.\n  var selectors = Util.makeU8Buffer(Math.ceil(pos / GROUP_SIZE));\n  optimizeHuffmanGroups(groups, targetGroups, A, selectors, endOfBlock+1);\n  assignSelectors(selectors, groups, A);\n\n  // okay, let's start writing out our Huffman tables\n  console.assert(groups.length >= MIN_GROUPS && groups.length <= MAX_GROUPS);\n  outStream.writeBits(3, groups.length);\n  // and write out the best selector for each group\n  outStream.writeBits(15, selectors.length);\n  for (i=0; i<groups.length; i++) { M[i] = i; } // initialize MTF table.\n  for (i=0; i<selectors.length; i++) {\n    var s = selectors[i];\n    // find selector in MTF list\n    for (j=0; j<groups.length; j++) { if (M[j]===s) { break; } }\n    console.assert(j<groups.length);\n    mtf(M, j);\n    // emit 'j' as a unary number\n    for (;j>0; j--) {\n      outStream.writeBit(1);\n    }\n    outStream.writeBit(0);\n  }\n  // okay, now emit the Huffman tables in order.\n  for (i=0; i<groups.length; i++) {\n    groups[i].emit(outStream);\n    groups[i].computeCanonical(); // get ready for next step while we're at it\n  }\n  // okay, now (finally!) emit the actual data!\n  for (i=0, k=0; i<pos; ) {\n    var huff = groups[selectors[k++]];\n    for (j=0; j<GROUP_SIZE && i<pos; j++) {\n      huff.encode(outStream, A[i++]);\n    }\n  }\n  // done.\n};\n\nvar Bzip2 = Object.create(null);\nBzip2.compressFile = function(inStream, outStream, props) {\n  inStream = Util.coerceInputStream(inStream);\n  var o = Util.coerceOutputStream(outStream, outStream);\n  outStream = new BitStream(o.stream);\n\n  var blockSizeMultiplier = 9;\n  if (typeof(props)==='number') {\n    blockSizeMultiplier = props;\n  }\n  if (blockSizeMultiplier < 1 || blockSizeMultiplier > 9) {\n    throw new Error('Invalid block size multiplier');\n  }\n\n  var blockSize = blockSizeMultiplier * 100000;\n  // the C implementation always writes at least length-19 characters,\n  // but it reads ahead enough that if the last character written was part\n  // of a run, it writes out the full run.\n  // That's really annoying to implement.\n  // So instead just subtract 19 from the blockSize; in most cases (unless\n  // there's a run at the end of the block) this will yield block divisions\n  // matching the C implementation.\n  blockSize -= 19;\n\n  // write file magic\n  outStream.writeByte('B'.charCodeAt(0));\n  outStream.writeByte('Z'.charCodeAt(0));\n  outStream.writeByte('h'.charCodeAt(0)); // Huffman-coded bzip\n  outStream.writeByte('0'.charCodeAt(0) + blockSizeMultiplier);\n\n  // allocate a buffer for the block\n  var block = Util.makeU8Buffer(blockSize);\n  var streamCRC = 0;\n  var length;\n\n  do {\n    var crc = new CRC32();\n    length = readBlock(inStream, block, blockSize, crc);\n    if (length > 0) {\n      streamCRC = (((streamCRC << 1) | (streamCRC>>>31)) ^ crc.getCRC()) >>> 0;\n      outStream.writeBits(48, WHOLEPI);\n      outStream.writeBits(32, crc.getCRC());\n      compressBlock(block, length, outStream);\n    }\n  } while (length === blockSize);\n\n  // finish up\n  outStream.writeBits(48, SQRTPI);\n  outStream.writeBits(32, streamCRC);\n  outStream.flush(); // get the last bits flushed out\n  return o.retval;\n};\n\nBzip2.decompressFile = Bunzip.decode;\nBzip2.decompressBlock = Bunzip.decodeBlock;\nBzip2.table = Bunzip.table;\n\nreturn Bzip2;\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./BWT\":121,\"./BitStream\":123,\"./CRC32\":125,\"./HuffmanAllocator\":133,\"./Stream\":143,\"./Util\":144,\"./freeze\":145}],125:[function(require,module,exports){\n/* CRC32, used in Bzip2 implementation.\n * This is a port of CRC32.java from the jbzip2 implementation at\n *   https://code.google.com/p/jbzip2\n * which is:\n *   Copyright (c) 2011 Matthew Francis\n *\n *   Permission is hereby granted, free of charge, to any person\n *   obtaining a copy of this software and associated documentation\n *   files (the \"Software\"), to deal in the Software without\n *   restriction, including without limitation the rights to use,\n *   copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the\n *   Software is furnished to do so, subject to the following\n *   conditions:\n *\n *   The above copyright notice and this permission notice shall be\n *   included in all copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n *   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n *   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n *   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n *   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n *   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n *   OTHER DEALINGS IN THE SOFTWARE.\n * This JavaScript implementation is:\n *   Copyright (c) 2013 C. Scott Ananian\n * with the same licensing terms as Matthew Francis' original implementation.\n */\nvar libs = [\n  require('./Util')\n];\nvar body_fn = function (Util) {\n\n  /**\n   * A static CRC lookup table\n   */\n    var crc32Lookup = Util.arraycopy(Util.makeU32Buffer(256), [\n    0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,\n    0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,\n    0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,\n    0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,\n    0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039, 0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,\n    0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,\n    0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,\n    0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,\n    0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,\n    0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,\n    0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,\n    0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,\n    0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,\n    0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,\n    0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,\n    0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,\n    0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,\n    0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,\n    0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,\n    0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff, 0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,\n    0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,\n    0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,\n    0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,\n    0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,\n    0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,\n    0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,\n    0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,\n    0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,\n    0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,\n    0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,\n    0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,\n    0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4\n  ]);\n\n  var CRC32 = function() {\n    /**\n     * The current CRC\n     */\n    var crc = 0xffffffff;\n\n    /**\n     * @return The current CRC\n     */\n    this.getCRC = function() {\n      return (~crc) >>> 0; // return an unsigned value\n    };\n\n    /**\n     * Update the CRC with a single byte\n     * @param value The value to update the CRC with\n     */\n    this.updateCRC = function(value) {\n      crc = (crc << 8) ^ crc32Lookup[((crc >>> 24) ^ value) & 0xff];\n    };\n\n    /**\n     * Update the CRC with a sequence of identical bytes\n     * @param value The value to update the CRC with\n     * @param count The number of bytes\n     */\n    this.updateCRCRun = function(value, count) {\n      while (count-- > 0) {\n        crc = (crc << 8) ^ crc32Lookup[((crc >>> 24) ^ value) & 0xff];\n      }\n    };\n  };\n  return CRC32;\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./Util\":144}],126:[function(require,module,exports){\n/** A simple context-1 model. */\nvar libs = [\n  require('./BitStream'),\n  require('./Huffman'),\n  require('./Util')\n];\nvar body_fn = function (BitStream,Huffman,Util) {\n\nvar Context1Model = function(modelFactory, contextSize, alphabetSize) {\n  var i;\n  this.literalModel = [];\n  // even if there's an EOF symbol, we don't need a context for it!\n  for (i=0; i<contextSize; i++) {\n    this.literalModel[i] = modelFactory(alphabetSize);\n  }\n};\nContext1Model.prototype.encode = function(ch, context) {\n  this.literalModel[context].encode(ch);\n};\nContext1Model.prototype.decode = function(context) {\n  return this.literalModel[context].decode();\n};\n\n/** Simple self-test. */\nContext1Model.MAGIC='ctx1';\nContext1Model.compressFile = Util.compressFileHelper(Context1Model.MAGIC, function(inStream, outStream, fileSize, props) {\n  var bitstream = new BitStream(outStream);\n  var alphabetSize = 256;\n  if (fileSize < 0) { alphabetSize++; }\n  var coder = Huffman.factory(bitstream, 8191);\n  var model = new Context1Model(coder, 256, alphabetSize);\n  var lastchar = 0x20;\n  var modelp = {\n    encode: function(symbol) {\n      model.encode(symbol, lastchar);\n      lastchar = symbol;\n    }\n  };\n  Util.compressWithModel(inStream, fileSize, modelp);\n  bitstream.flush();\n});\nContext1Model.decompressFile = Util.decompressFileHelper(Context1Model.MAGIC, function(inStream, outStream, fileSize) {\n  var bitstream = new BitStream(inStream);\n  var alphabetSize = 256;\n  if (fileSize < 0) { alphabetSize++; }\n  var coder = Huffman.factory(bitstream, 8191);\n  var model = new Context1Model(coder, 256, alphabetSize);\n  var lastchar = 0x20;\n  var modelp = {\n    decode: function() {\n      var symbol = model.decode(lastchar);\n      lastchar = symbol;\n      return symbol;\n    }\n  };\n  Util.decompressWithModel(outStream, fileSize, modelp);\n});\n\nreturn Context1Model;\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./BitStream\":123,\"./Huffman\":132,\"./Util\":144}],127:[function(require,module,exports){\n/** Deferred-sum model, suitable for small ( ~ 256 ) ranges. */\nvar libs = [\n  require('./RangeCoder'),\n  require('./Stream'),\n  require('./Util')\n];\nvar body_fn = function (RangeCoder,Stream,Util){\n\nvar LOG_PROB_TOTAL = 8;\nvar PROB_TOTAL = 1 << LOG_PROB_TOTAL;\nvar MAX_ESCAPE_COUNT = 40;\n\nvar DefSumModel = function(coder, size, isDecoder) {\n  var i;\n  console.assert(size < 300); // not meant for sparse\n  var ESCAPE = this.numSyms = size;\n  this.coder = coder;\n  this.prob = Util.makeU16Buffer(size+2); /* size + ESC + 1 */\n  this.escape = Util.makeU16Buffer(size+1);  /* size + 1*/\n  this.update = Util.makeU16Buffer(size+1); /* size + ESC */\n  this.prob[ESCAPE+1] = PROB_TOTAL;\n  for (i=0; i<=this.numSyms; i++) {\n    this.escape[i] = i;\n  }\n  this.updateCount = 0;\n  this.updateThresh = PROB_TOTAL - Math.floor(PROB_TOTAL / 2);\n  if (!isDecoder) { return; }\n  // extra tables for fast decoding\n  this.probToSym = Util.makeU16Buffer(PROB_TOTAL);\n  this.escProbToSym = Util.makeU16Buffer(this.numSyms);\n  for (i=0; i<PROB_TOTAL; i++) {\n    this.probToSym[i] = ESCAPE;\n  }\n  for (i=0; i<this.numSyms; i++) {\n    this.escProbToSym[i] = i;\n  }\n};\nDefSumModel.factory = function(coder, isDecoder) {\n  return function(size) { return new DefSumModel(coder, size, isDecoder); };\n};\nDefSumModel.prototype._update = function(symbol, isDecoder) {\n  if (symbol === this.numSyms) {\n    // some special cases for the escape character\n    if (this.update[symbol] >= MAX_ESCAPE_COUNT) { return; } // hard limit\n    // don't let an escape character trigger an update, because then the\n    // escaped character might find itself unescaped after the tables have\n    // been updated!\n    if (this.updateCount >= (this.updateThresh - 1)) { return; }\n  }\n  this.update[symbol]++;\n  this.updateCount++;\n  // is it time to transfer the updated probabilities?\n  if (this.updateCount < this.updateThresh) {\n    return; //defer update\n  }\n  var cumProb, cumEscProb, odd, i, j, k;\n  this.escape[0] = this.prob[0] = cumProb = cumEscProb = odd = 0;\n  for (i=0; i < this.numSyms+1; i++) {\n    var newProb = ((this.prob[i+1]-this.prob[i]) >>> 1) + this.update[i];\n    if (newProb) {\n      // live 'un\n      this.prob[i] = cumProb;\n      cumProb += newProb;\n      if (newProb & 1) { odd++; }\n      this.escape[i] = cumEscProb;\n    } else {\n      // this symbol will escape\n      this.prob[i] = cumProb;\n      this.escape[i] = cumEscProb;\n      cumEscProb++;\n    }\n  }\n  this.prob[i] = cumProb;\n  console.assert(cumProb === PROB_TOTAL);\n  /* how many updates will be required after current probs are halved? */\n  this.updateThresh = PROB_TOTAL - Math.floor((cumProb-odd) / 2);\n  /* reset the update table */\n  for (i=0; i < (this.numSyms + 1); i++) {\n    this.update[i] = 0;\n  }\n  this.update[this.numSyms] = 1; // ensure that escape never goes away\n  this.updateCount = 1;\n  /* compute decode table, if this is a decoder */\n  if (!isDecoder) { return; }\n  for (i=0, j=0, k=0; i<(this.numSyms+1); i++) {\n    var probLimit = this.prob[i+1];\n    for (; j<probLimit; j++) {\n      this.probToSym[j] = i;\n    }\n    var escProbLimit = this.escape[i+1];\n    for (; k<escProbLimit; k++) {\n      this.escProbToSym[k] = i;\n    }\n  }\n};\nDefSumModel.prototype.encode = function(symbol) {\n  var lt_f = this.prob[symbol];\n  var sy_f = this.prob[symbol+1] - lt_f;\n  console.assert(this.prob[this.numSyms+1] === PROB_TOTAL);\n  if (sy_f) {\n    this.coder.encodeShift(sy_f, lt_f, LOG_PROB_TOTAL);\n    return this._update(symbol);\n  }\n  // escape!\n  console.assert(symbol !== this.numSyms); // catch infinite recursion\n  this.encode(this.numSyms); // guaranteed non-zero probability\n  // code symbol as literal, taking advantage of reduced escape range.\n  lt_f = this.escape[symbol];\n  sy_f = this.escape[symbol+1] - lt_f;\n  var tot_f = this.escape[this.numSyms];\n  this.coder.encodeFreq(sy_f, lt_f, tot_f);\n  return this._update(symbol);\n};\nDefSumModel.prototype.decode = function() {\n  var prob = this.coder.decodeCulShift(LOG_PROB_TOTAL);\n  var symbol = this.probToSym[prob];\n  var lt_f = this.prob[symbol];\n  var sy_f = this.prob[symbol+1] - lt_f;\n  this.coder.decodeUpdate(sy_f, lt_f, PROB_TOTAL);\n  this._update(symbol, true);\n  if (symbol !== this.numSyms) {\n    return symbol;\n  }\n  // escape!\n  var tot_f = this.escape[this.numSyms];\n  prob = this.coder.decodeCulFreq(tot_f);\n  symbol = this.escProbToSym[prob];\n  lt_f = this.escape[symbol];\n  sy_f = this.escape[symbol+1] - lt_f;\n  this.coder.decodeUpdate(sy_f, lt_f, tot_f);\n  this._update(symbol, true);\n  return symbol;\n};\n\nDefSumModel.MAGIC='dfsm';\n/** Simple order-0 compressor, as self-test. */\nDefSumModel.compressFile = Util.compressFileHelper(DefSumModel.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {\n  var range = new RangeCoder(outStream);\n  range.encodeStart(finalByte, 1);\n  var model = new DefSumModel(range, (fileSize<0) ? 257 : 256);\n  Util.compressWithModel(inStream, fileSize, model);\n  range.encodeFinish();\n},true);\n/** Simple order-0 decompresser, as self-test. */\nDefSumModel.decompressFile = Util.decompressFileHelper(DefSumModel.MAGIC, function(inStream, outStream, fileSize) {\n  var range = new RangeCoder(inStream);\n  range.decodeStart(true/*already read the final byte*/);\n  var model = new DefSumModel(range, (fileSize<0) ? 257 : 256, true);\n  Util.decompressWithModel(outStream, fileSize, model);\n  range.decodeFinish();\n});\n\nreturn DefSumModel;\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./RangeCoder\":141,\"./Stream\":143,\"./Util\":144}],128:[function(require,module,exports){\n/** Distance model used by gzip/deflate.\n *  Encodes distances starting at 0 (for deflate compatibility, subtract\n *  one from distance to encode).\n *  Uses ~32-entry model to predict ln2(distance) (more-or-less) and then\n *  encodes a few more bits for the actual distance. */\nvar libs = [\n  require('./Util')\n];\nvar body_fn = function (Util){\n\n    // lengthBitsModelFactory will be called with arguments 2, 4, 8, 16, etc\n    // and must return an appropriate model or coder.\n    var DeflateDistanceModel = function(size, extraStates,\n                                        lgDistanceModelFactory,\n                                        lengthBitsModelFactory) {\n        var i;\n        var bits = Util.fls(size-1);\n        this.extraStates = +extraStates || 0;\n        this.lgDistanceModel = lgDistanceModelFactory(2*bits + extraStates);\n        // this.distanceModel[n] used for distances which are n-bits long,\n        // but only n-2 bits are encoded: the top bit is known to be one,\n        // and the next bit is encoded by the lgDistanceModel.\n        this.distanceModel = [];\n        for (i=3 ; i <= bits; i++) {\n            var numBits = i - 2;\n            this.distanceModel[i] = lengthBitsModelFactory(1<<numBits);\n        }\n    };\n    /* you can give this model arguments between 0 and (size-1), or else\n       a negative argument which is one of the 'extra states'. */\n    DeflateDistanceModel.prototype.encode = function(distance) {\n        if (distance < 4) { // small distance or an 'extra state'\n            this.lgDistanceModel.encode(distance + this.extraStates);\n            return;\n        }\n        var lgDistance = Util.fls(distance);\n        console.assert(distance & (1<<(lgDistance-1))); // top bit is set\n        console.assert(lgDistance >= 3);\n        var nextBit = (distance & (1 << (lgDistance-2))) ? 1 : 0;\n        var l = 4 + ((lgDistance-3)*2) + nextBit;\n        this.lgDistanceModel.encode(l + this.extraStates);\n        // now encode the rest of the bits.\n        var rest = distance & ((1 << (lgDistance-2)) - 1);\n        this.distanceModel[lgDistance].encode(rest);\n    };\n    DeflateDistanceModel.prototype.decode = function() {\n        var l = this.lgDistanceModel.decode() - this.extraStates;\n        if (l < 4) {\n            return l; // this is a small distance or an 'extra state'\n        }\n        var nextBit = (l&1);\n        var lgDistance = ((l-4) >>> 1) + 3;\n        var rest = this.distanceModel[lgDistance].decode();\n        return ((2+nextBit) << (lgDistance-2)) + rest;\n    };\n    return DeflateDistanceModel;\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./Util\":144}],129:[function(require,module,exports){\n/**\n * Implementation of Dynamic Markov Compression, using byte-oriented\n * nodes/transitions.\n *\n * Currently no model-shrinking is done, so be careful trying to use\n * this on large inputs!\n *\n * Notes for the future / TO DO:\n *\n * Add node merging to Dmc:\n *  - once (total states traversed / total node count) exceeds a certain value\n *    - find the median node w/rt total visits\n *    - combine all nodes w/ less visits into a single node, with transitions\n *      to node[0] - node[255] (initial context-1 states)\n *      - initially transition counts are zero?  or summed from components?\n *        needs to be summed so kirchoff principle holds\n *    - halve the edge counts of all nodes, to provide for adaptation\n *      - enforce property that all nodes point \"higher\" except for\n *        links to nodes 0-255.  So we can resum all nodes in one pass,\n *        after resetting all node.sum to zero. X YES because we know\n *        what the total sum must be, so we can arrange to scale to maintain\n *        proper sum. XXX what about node 0-255? XXX maybe just clear all\n *        edge counts XXX\n *\n * Fix buglet: ensure that kirchoff principle *exactly* holds by\n * paying attention to rounding when we distribute edge counts.  track\n * highest edge and give (desiredSum - newSum) extra counts to that\n * outgoing edge? add one to each nonzero edge until all gone?\n *\n * Split 'to' nodes when to.sum grows too high -- only if we're\n * highest incoming edge?  Fix bug again here with saturating counts;\n * we can't ignore counts w/o violating kirchoff principle, so we need\n * to clone it.  Maybe start trying to clone early (before our counter\n * saturates) so we have a better chance of cloning on the high\n * incoming edge? XXX we don't track incoming edges.  XXX so just\n * clone when we visit.\n */\nvar libs = [\n  require('./MTFModel'),\n  require('./RangeCoder'),\n  require('./Stream'),\n  require('./Util')\n];\nvar body_fn = function (MTFModel, RangeCoder, Stream, Util){\n\n// nm = no model cloning, MAX_TRANS_CNT=0xFF, MAX_MODEL_PROB=0xFFFF\n// nm2 = \"                            0xFFFF                 0xFFFF\n// nm3 = \"                             0xFFF                 0x0FFF\n// nm4 = \"                            0xFFFF                   0xFF\n// cl1 = model cloning, MAX_TRANS_CNT=0xFFFF  MAX_MODEL_PROB=0xFF\n// cl2 = model cloning, MAX_TRANS_CNT=  0xFF  MAX_MODEL_PROB=0xFF\n// cl3 = model cloning, MAX_TRANS_CNT=0xFFFF  MAX_MODEL_PROB=0xFFFF\nvar MAX_TRANS_CNT = 0xFFFF;\nvar DEFAULT_MIN_CNT1 = 8;\nvar DEFAULT_MIN_CNT2 = 128;\nvar MODEL_PROB_MAX = 0xFF00;\nvar MODEL_PROB_INCR= 0x0100;\nvar CLONE_MODELS=false;\nvar PRINT_STATS=false; // for quick benchmarking\n\n// XXX need to limit growth of model (throw away and retrain if model\n//     gets too large)\n\nvar Dmc = Object.create(null);\nDmc.MAGIC = 'dmc!';\n\nvar MarkovNode = function(coder, size, optModel) {\n  this.out = [];\n  this.model = optModel ? optModel.clone() :\n    new MTFModel(coder, size, MODEL_PROB_MAX, MODEL_PROB_INCR);\n  this.count = Util.makeU16Buffer(size);\n  this.sum = 0;\n};\nMarkovNode.prototype.clone = function(coder, size) {\n  var i;\n  var newNode = new MarkovNode(coder, size, CLONE_MODELS ? this.model : null);\n  for (i=0; i<size; i++) {\n    newNode.out[i] = this.out[i];\n  }\n  return newNode;\n};\n\nvar MarkovModel = function(coder, size, MIN_CNT1, MIN_CNT2) {\n  var i, j;\n  // initial model is 'size' states, completely linked.\n  this.coder = coder;\n  this.size = size;\n  this.MIN_CNT1 = MIN_CNT1 || DEFAULT_MIN_CNT1;\n  this.MIN_CNT2 = MIN_CNT2 || DEFAULT_MIN_CNT2;\n  this.nodes = [];\n  for (i=0; i<size; i++) {\n    this.nodes[i] = new MarkovNode(coder, size);\n  }\n  // now link nodes\n  for (i=0; i<size; i++) {\n    for (j=0; j<size; j++) {\n      this.nodes[i].out[j] = this.nodes[j];\n    }\n  }\n  // select an arbitrary node as the start state.\n  this.current = this.nodes[0];\n};\nMarkovModel.prototype.maybeSplit = function(from, symbol, to) {\n  var trans_cnt = from.count[symbol];\n  var next_cnt = to.sum;\n  var i;\n  if ( (trans_cnt <= this.MIN_CNT1) ||\n       (next_cnt - trans_cnt <= this.MIN_CNT2) ) {\n    return to; // no split\n  }\n\n  // split this guy!\n  var newNode = to.clone(this.coder, this.size);\n  this.nodes.push(newNode);\n  from.out[symbol] = newNode;\n  // distribute transition counts among new and cloned node\n  newNode.sum = to.sum = 0;\n  for (i=0; i<this.size; i++) {\n    newNode.count[i] = to.count[i] * trans_cnt / next_cnt;\n    newNode.sum += newNode.count[i];\n    to.count[i] -= newNode.count[i];\n    to.sum += to.count[i];\n  }\n\n  return newNode;\n};\nMarkovModel.prototype.encode = function(symbol) {\n  var from = this.current;\n  from.model.encode(symbol);\n  var to = from.out[symbol];\n  if (from.count[symbol] !== MAX_TRANS_CNT) {\n      from.count[symbol]++;\n      from.sum++;\n  }\n  this.current = this.maybeSplit(from, symbol, to);\n};\nMarkovModel.prototype.decode = function() {\n  var from = this.current;\n  var symbol = from.model.decode();\n  var to = from.out[symbol];\n  if (from.count[symbol] !== MAX_TRANS_CNT) {\n      from.count[symbol]++;\n      from.sum++;\n  }\n  this.current = this.maybeSplit(from, symbol, to);\n  return symbol;\n};\n\nDmc.compressFile = Util.compressFileHelper(Dmc.MAGIC, function(inStream, outStream, fileSize, props) {\n\n  props = props || {};\n  var MIN_CNT1 = (+props.m) || DEFAULT_MIN_CNT1;\n  var MIN_CNT2 = (+props.n) || DEFAULT_MIN_CNT2;\n  Util.writeUnsignedNumber(outStream, MIN_CNT1);\n  Util.writeUnsignedNumber(outStream, MIN_CNT2);\n\n  var range = new RangeCoder(outStream);\n  range.encodeStart(0xCA, 0);\n\n  var mm = new MarkovModel(range, (fileSize<0) ? 257 : 256,\n                           MIN_CNT1, MIN_CNT2);\n  var inSize = 0;\n  while (inSize !== fileSize) {\n    var ch = inStream.readByte();\n    if (ch===Stream.EOF) {\n      mm.encode(256); // end of stream\n      break;\n    }\n    mm.encode(ch);\n    inSize++;\n  }\n  var outSize = range.encodeFinish();\n  if (PRINT_STATS) {\n    console.log('M1', mm.MIN_CNT1, 'M2', mm.MIN_CNT2,\n                'states', mm.nodes.length, 'size', outSize);\n  }\n});\n\nDmc.decompressFile = Util.decompressFileHelper(Dmc.MAGIC, function(inStream, outStream, fileSize) {\n\n  var MIN_CNT1 = Util.readUnsignedNumber(inStream);\n  var MIN_CNT2 = Util.readUnsignedNumber(inStream);\n\n  var range = new RangeCoder(inStream);\n  range.decodeStart();\n\n  var mm = new MarkovModel(range, (fileSize<0) ? 257 : 256,\n                           MIN_CNT1, MIN_CNT2);\n  var outSize = 0;\n  while (outSize !== fileSize) {\n    var ch = mm.decode();\n    if (ch===256) {\n      break; // EOF\n    }\n    outStream.writeByte(ch);\n    outSize++;\n  }\n  range.decodeFinish();\n});\n\nreturn Dmc;\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./MTFModel\":138,\"./RangeCoder\":141,\"./Stream\":143,\"./Util\":144}],130:[function(require,module,exports){\n/* Dummy Range Coder, for debugging.\n * This has the same interface as RangeCoder, but just dumps the frequency\n * parameters given to the file.  This helps debug problems with the model\n * driving the range coder.\n */\nvar libs = [\n  require('./RangeCoder'),\n  require('./Util')\n];\nvar body_fn = function (RangeCoder,Util){\n    var Dummy = function(stream) {\n        RangeCoder.call(this, stream);\n    };\n    Dummy.prototype = Object.create(RangeCoder.prototype);\n    Dummy.prototype._write8 = function(b) {\n        Util.writeUnsignedNumber(this.stream, b);\n        this.stream.writeByte(b);\n    };\n    Dummy.prototype._write16 = function(s) {\n        this.stream.writeByte((s >>> 8) & 0xFF);\n        this.stream.writeByte(s & 0xFF);\n    };\n    Dummy.prototype._read8 = function() {\n        return this.stream.readByte();\n    };\n    Dummy.prototype._read16 = function() {\n        var hi = this.stream.readByte();\n        var lo = this.stream.readByte();\n        return (hi<<8) | lo;\n    };\n    Dummy.prototype.encodeStart = function(c, initlength) {\n        this.stream.writeByte(c);\n    };\n    Dummy.prototype.encodeFreq = function(sy_f, lt_f, tot_f) {\n        console.assert(sy_f > 0);\n        console.assert(tot_f > 0);\n        console.assert(tot_f <= (1<<23));\n        if ((sy_f + lt_f) > tot_f) {\n            console.error('dummy coder: lt_f + sy_f > tot_f',\n                          sy_f, lt_f, tot_f);\n        }\n        Util.writeUnsignedNumber(this.stream, sy_f);\n        Util.writeUnsignedNumber(this.stream, lt_f);\n        Util.writeUnsignedNumber(this.stream, tot_f);\n    };\n    Dummy.prototype.encodeShift = function(sy_f, lt_f, shift) {\n        this.encodeFreq(sy_f, lt_f, 1 << shift);\n    };\n    Dummy.prototype.encodeFinish = function() {\n        return 0;\n    };\n    Dummy.prototype.decodeStart = function(skipInitialRead) {\n        return skipInitialRead ? 0 : this.stream.readByte();\n    };\n    Dummy.prototype.decodeCulFreq = function(tot_f) {\n        console.assert(tot_f > 0);\n        this.sy_f = Util.readUnsignedNumber(this.stream);\n        this.lt_f = Util.readUnsignedNumber(this.stream);\n        this.tot_f= Util.readUnsignedNumber(this.stream);\n        if (tot_f !== this.tot_f) {\n            console.error('decodeCul* wrong total: got', tot_f,\n                          'expected', this.tot_f);\n        }\n        return (this.sy_f>>>1) + this.lt_f;\n    };\n    Dummy.prototype.decodeCulShift = function(shift) {\n        return this.decodeCulFreq(1<<shift);\n    };\n    Dummy.prototype.decodeUpdate = function(sy_f, lt_f, tot_f) {\n        console.assert(sy_f > 0);\n        console.assert(tot_f > 0);\n        if (sy_f !== this.sy_f ||\n            lt_f !== this.lt_f ||\n            tot_f!== this.tot_f) {\n            console.error('decodeUpdate wrong parameters; got',\n                          sy_f, lt_f, tot_f, 'expected',\n                          this.sy_f, this.lt_f, this.tot_f);\n        }\n    };\n    Dummy.prototype.decodeFinish = function() {\n    };\n\n    return Dummy;\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./RangeCoder\":141,\"./Util\":144}],131:[function(require,module,exports){\n/** Range coding model based on Fenwick trees for O(ln N) query/update. */\nvar libs = [\n  require('./RangeCoder'),\n  require('./Stream'),\n  require('./Util')\n];\nvar body_fn = function (RangeCoder,Stream,Util){\n\n/** We store two probabilities in a U32, so max prob is going to be 0xFFFF */\nvar DEFAULT_MAX_PROB = 0xFF00;\nvar DEFAULT_INCREMENT= 0x0100;\n\nvar ESC_MASK = 0x0000FFFF, ESC_SHIFT = 0;\nvar SYM_MASK = 0xFFFF0000, SYM_SHIFT = 16;\nvar SCALE_MASK=0xFFFEFFFE;\n\nvar FenwickModel = function(coder, size, max_prob, increment) {\n    this.coder = coder;\n    this.numSyms = size + 1; // save space for an escape symbol\n    this.tree = Util.makeU32Buffer(this.numSyms*2);\n    this.increment = (+increment) || DEFAULT_INCREMENT;\n    this.max_prob = (+max_prob) || DEFAULT_MAX_PROB;\n    // sanity-check to prevent overflow.\n    console.assert((this.max_prob + (this.increment-1)) <= 0xFFFF);\n    console.assert(size <= 0xFFFF);\n    // record escape probability as 1.\n    var i;\n    for (i=0; i<size; i++) {\n        this.tree[this.numSyms + i] = // escape prob=1, sym prob = 0\n            (1 << ESC_SHIFT) | (0 << SYM_SHIFT);\n    }\n    this.tree[this.numSyms + i] = // escape prob = 0, sym prob = 1\n        (0 << ESC_SHIFT) | (this.increment << SYM_SHIFT);\n    this._sumTree();\n    // probability sums are in this.tree[1].  this.tree[0] is unused.\n};\nFenwickModel.factory = function(coder, max_prob, increment) {\n    return function(size) {\n        return new FenwickModel(coder, size, max_prob, increment);\n    };\n};\nFenwickModel.prototype.clone = function() {\n    var newModel = new FenwickModel(this.coder, this.size,\n                                    this.max_prob, this.increment);\n    var i;\n    for (i=1; i<this.tree.length; i++) {\n        newModel.tree[i] = this.tree[i];\n    }\n    return newModel;\n};\nFenwickModel.prototype.encode = function(symbol) {\n    var i = this.numSyms + symbol;\n    var sy_f = this.tree[i];\n    var mask = SYM_MASK, shift = SYM_SHIFT;\n    var update = (this.increment << SYM_SHIFT);\n\n    if ((sy_f & SYM_MASK) === 0) { // escape!\n        this.encode(this.numSyms-1);\n        mask = ESC_MASK;\n        update -= (1<<ESC_SHIFT); // not going to escape no mo'\n        shift = ESC_SHIFT;\n    } else if (symbol === (this.numSyms-1) &&\n               ((this.tree[1] & ESC_MASK) >>> ESC_SHIFT) === 1) {\n        // this is the last escape, zero it out\n        update = -this.tree[i];\n    }\n    // sum up the proper lt_f\n    var lt_f = 0;\n    while (i > 1) {\n        var isRight = (i & 1);\n        var parent = (i >>> 1);\n        // if we're the right child, we need to\n        // add the prob from the left child\n        if (isRight) {\n            lt_f += this.tree[2*parent];\n        }\n        // update sums\n        this.tree[i] += update; // increase sym / decrease esc\n        i = parent;\n    }\n    var tot_f = this.tree[1];\n    this.tree[1] += update; // update prob in root\n    sy_f = (sy_f & mask) >>> shift;\n    lt_f = (lt_f & mask) >>> shift;\n    tot_f =(tot_f& mask) >>> shift;\n    this.coder.encodeFreq(sy_f, lt_f, tot_f);\n    // rescale?\n    if ((( this.tree[1] & SYM_MASK ) >>> SYM_SHIFT) >= this.max_prob) {\n        this._rescale();\n    }\n};\nFenwickModel.prototype._decode = function(isEscape) {\n    var mask = SYM_MASK, shift = SYM_SHIFT;\n    var update = (this.increment << SYM_SHIFT);\n    if (isEscape) {\n        mask = ESC_MASK;\n        update -= (1 << ESC_SHIFT);\n        shift = ESC_SHIFT;\n    }\n    var tot_f = (this.tree[1] & mask) >>> shift;\n    var prob = this.coder.decodeCulFreq(tot_f);\n    // travel down the tree looking for this\n    var i = 1, lt_f = 0;\n    while (i < this.numSyms) {\n        this.tree[i] += update;\n        // look at probability in left child.\n        var leftProb = (this.tree[2*i] & mask) >>> shift;\n        i *= 2;\n        if ((prob-lt_f) >= leftProb) {\n            lt_f += leftProb;\n            i++; // take the right child.\n        }\n    }\n    var symbol = i - this.numSyms;\n    var sy_f = (this.tree[i] & mask) >>> shift;\n    this.tree[i] += update;\n    this.coder.decodeUpdate(sy_f, lt_f, tot_f);\n    // was this the last escape?\n    if (symbol === (this.numSyms-1) &&\n        ((this.tree[1] & ESC_MASK) >>> ESC_SHIFT) === 1) {\n        update = -this.tree[i]; // zero it out\n        while (i >= 1) {\n            this.tree[i] += update;\n            i = (i >>> 1); // parent\n        }\n    }\n    // rescale?\n    if ((( this.tree[1] & SYM_MASK ) >>> SYM_SHIFT) >= this.max_prob) {\n        this._rescale();\n    }\n    return symbol;\n};\nFenwickModel.prototype.decode = function() {\n    var symbol = this._decode(false); // not escape\n    if (symbol === (this.numSyms-1)) {\n        // this was an escape!\n        symbol = this._decode(true); // an escape!\n    }\n    return symbol;\n};\nFenwickModel.prototype._rescale = function() {\n    var i, prob, noEscape = true;\n    // scale symbols (possible causing them to escape)\n    for (i=0; i < this.numSyms-1; i++) {\n        prob = this.tree[this.numSyms + i];\n        if ((prob & ESC_MASK) !== 0) {\n            // this symbol escapes\n            noEscape = false;\n            continue;\n        }\n        prob = (prob & SCALE_MASK) >>> 1;\n        if (prob === 0) {\n            // this symbol newly escapes\n            prob = (1 << ESC_SHIFT);\n            noEscape = false;\n        }\n        this.tree[this.numSyms + i] = prob;\n    }\n    // scale the escape symbol\n    prob = this.tree[this.numSyms + i];\n    prob = (prob & SCALE_MASK) >>> 1;\n    // prob should be zero if there are no escaping symbols, otherwise\n    // it must be at least 1.\n    if (noEscape) { prob = 0; }\n    else if (prob === 0) { prob = (1 << SYM_SHIFT); }\n    this.tree[this.numSyms + i] = prob;\n    // sum it all up afresh\n    this._sumTree();\n};\nFenwickModel.prototype._sumTree = function() {\n    var i;\n    // sum it all. (we know we won't overflow)\n    for (i=this.numSyms - 1; i > 0; i--) {\n        this.tree[i] = this.tree[2*i] + this.tree[2*i + 1];\n    }\n};\n\nFenwickModel.MAGIC = 'fenw';\n/** Simple order-0 compressor, as self-test. */\nFenwickModel.compressFile = Util.compressFileHelper(FenwickModel.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {\n    var range = new RangeCoder(outStream);\n    range.encodeStart(finalByte, 1);\n    var model = new FenwickModel(range, (fileSize<0) ? 257 : 256);\n    Util.compressWithModel(inStream, fileSize, model);\n    range.encodeFinish();\n}, true);\n\n/** Simple order-0 decompresser, as self-test. */\nFenwickModel.decompressFile = Util.decompressFileHelper(FenwickModel.MAGIC, function(inStream, outStream, fileSize) {\n    var range = new RangeCoder(inStream);\n    range.decodeStart(true/*already read the final byte*/);\n    var model = new FenwickModel(range, (fileSize<0) ? 257 : 256);\n    Util.decompressWithModel(outStream, fileSize, model);\n    range.decodeFinish();\n});\n\nreturn FenwickModel;\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./RangeCoder\":141,\"./Stream\":143,\"./Util\":144}],132:[function(require,module,exports){\n/* Adaptive Huffman code, using Vitter's algorithm ported from\n * vitter.c at http://code.google.com/p/compression-code/downloads/list\n * The original code was placed in the public domain, and so I\n * also place this JavaScript port in the public domain.\n *   -- C. Scott Ananian <cscott@cscott.net>, 2013\n * ps. some truly grotty C code in the originally, faithfully ported to\n *     evil comma-operator-using, assignment-in-if-condition JavaScript.\n */\nvar libs = [\n  require('./BitStream'),\n  require('./Util')\n];\nvar body_fn = function (BitStream,Util) {\n//  This code is adapted from Professor Vitter's\n//  article, Design and Analysis of Dynamic Huffman Codes,\n//  which appeared in JACM October 1987\n\n//  A design trade-off has been made to simplify the\n//  code:  a node's block is determined dynamically,\n//  and the implicit tree structure is maintained,\n//  e.g. explicit node numbers are also implicit.\n\n//  Dynamic Huffman table weight ranking\n//  is maintained per Professor Vitter's\n//  invariant (*) for algorithm FGK:\n\n//  leaves precede internal nodes of the\n//  same weight in a non-decreasing ranking\n//  of weights using implicit node numbers:\n\n//  1) leaves slide over internal nodes, internal nodes\n//  swap over groups of leaves, leaves are swapped\n//  into group leader position, but two internal\n//  nodes never change positions relative\n//  to one another.\n\n//  2) weights are incremented by 2:\n//  leaves always have even weight values;\n//  internal nodes always have odd values.\n\n//  3) even node numbers are always right children;\n//  odd numbers are left children in the tree.\n\n//  node 2 * HuffSize - 1 is always the tree root;\n//  node HuffEsc is the escape node;\n\n//  the tree is initialized by creating an\n//  escape node as the root.\n\n//  each new leaf symbol is paired with a new escape\n//  node into the previous escape node in the tree,\n//  until the last symbol which takes over the\n//  tree position of the escape node, and\n//  HuffEsc is left at zero.\n\n//  overall table size: 2 * HuffSize\n\n//  huff_init(alphabet_size, potential symbols used)\n//  huff_encode(next_symbol)\n//  next_symbol = huff_decode()\n\n//  huff_scale(by_bits) -- scale weights and re-balance tree\n\nvar HTable = function(up, down, symbol, weight) {\n    this.up = up; // next node up the tree\n    this.down = down; // pair of down nodes\n    this.symbol = symbol;       // node symbol value\n    this.weight = weight;       // node weight\n};\nHTable.prototype.clone = function() {\n  return new HTable(this.up, this.down, this.symbol, this.weight);\n};\nHTable.prototype.set = function(htable) {\n  this.up = htable.up;\n  this.down = htable.down;\n  this.symbol = htable.symbol;\n  this.weight = htable.weight;\n};\n\n//  initialize an adaptive coder\n//  for alphabet size, and count\n//  of nodes to be used\nvar Huffman = function(size, root, bitstream, max_weight) {\n  var i;\n  //  default: all alphabet symbols are used\n\n  console.assert(size && typeof(size)==='number');\n  if( !root || root > size )\n      root = size;\n\n  //  create the initial escape node\n  //  at the tree root\n\n  if ( root <<= 1 ) {\n      root--;\n  }\n\n  // create root+1 htables (coding table)\n  // XXX this could be views on a backing Uint32 array?\n  this.table = [];\n  for (i=0; i<=root; i++) {\n    this.table[i] = new HTable(0,0,0,0);\n  }\n\n  // this.map => mapping for symbols to nodes\n  this.map = [];\n  // this.size => the alphabet size\n  if( this.size = size ) {\n    for (i=0; i<size; i++) {\n      this.map[i] = 0;\n    }\n  }\n\n  // this.esc  => the current tree height\n  // this.root => the root of the tree\n  this.esc = this.root = root;\n\n  if (bitstream) {\n    this.readBit = bitstream.readBit.bind(bitstream);\n    this.writeBit = bitstream.writeBit.bind(bitstream);\n  }\n  this.max_weight = max_weight; // may be null or undefined\n}\n// factory interface\nHuffman.factory = function(bitstream, max_weight) {\n  return function(size) {\n    return new Huffman(size, size, bitstream, max_weight);\n  };\n};\n\n\n// split escape node to incorporate new symbol\n\nHuffman.prototype.split = function(symbol) {\n  var pair, node;\n\n  //  is the tree already full???\n\n  if( pair = this.esc ) {\n    this.esc--;\n  } else {\n    console.assert(false);\n    return 0;\n  }\n\n  //  if this is the last symbol, it moves into\n  //  the escape node's old position, and\n  //  this.esc is set to zero.\n\n  //  otherwise, the escape node is promoted to\n  //  parent a new escape node and the new symbol.\n\n  if( node = this.esc ) {\n    this.table[pair].down = node;\n    this.table[pair].weight = 1;\n    this.table[node].up = pair;\n    this.esc--;\n  } else {\n    pair = 0;\n    node = 1;\n  }\n\n  //  initialize the new symbol node\n\n  this.table[node].symbol = symbol;\n  this.table[node].weight = 0;\n  this.table[node].down = 0;\n  this.map[symbol] = node;\n\n  //  initialize a new escape node.\n\n  this.table[this.esc].weight = 0;\n  this.table[this.esc].down = 0;\n  this.table[this.esc].up = pair;\n  return node;\n};\n\n//  swap leaf to group leader position\n//  return symbol's new node\n\nHuffman.prototype.leader = function(node) {\n  var weight = this.table[node].weight;\n  var leader = node, prev, symbol;\n\n  while( weight === this.table[leader + 1].weight ) {\n    leader++;\n  }\n\n  if( leader === node ) {\n    return node;\n  }\n\n  // swap the leaf nodes\n\n  symbol = this.table[node].symbol;\n  prev = this.table[leader].symbol;\n\n  this.table[leader].symbol = symbol;\n  this.table[node].symbol = prev;\n  this.map[symbol] = leader;\n  this.map[prev] = node;\n  return leader;\n};\n\n//  slide internal node up over all leaves of equal weight;\n//  or exchange leaf with next smaller weight internal node\n\n//  return node's new position\n\nHuffman.prototype.slide = function(node) {\n  var next = node;\n  var swap;\n\n  swap = this.table[next++].clone();\n\n  // if we're sliding an internal node, find the\n  // highest possible leaf to exchange with\n\n  if( swap.weight & 1 ) {\n    while( swap.weight > this.table[next + 1].weight ) {\n      next++;\n    }\n  }\n\n  //  swap the two nodes\n\n  this.table[node].set(this.table[next]);\n  this.table[next].set(swap);\n\n  this.table[next].up = this.table[node].up;\n  this.table[node].up = swap.up;\n\n  //  repair the symbol map and tree structure\n\n  if( swap.weight & 1 ) {\n    this.table[swap.down].up = next;\n    this.table[swap.down - 1].up = next;\n    this.map[this.table[node].symbol] = node;\n  } else {\n    this.table[this.table[node].down - 1].up = node;\n    this.table[this.table[node].down].up = node;\n    this.map[swap.symbol] = next;\n  }\n\n  return next;\n};\n\n//  increment symbol weight and re balance the tree.\n\nHuffman.prototype.increment = function(node) {\n  var up;\n\n  //  obviate swapping a parent with its child:\n  //    increment the leaf and proceed\n  //    directly to its parent.\n\n  //  otherwise, promote leaf to group leader position in the tree\n\n  if( this.table[node].up === node + 1 ) {\n    this.table[node].weight += 2;\n    node++;\n  } else {\n    node = this.leader (node);\n  }\n\n  //  increase the weight of each node and slide\n  //  over any smaller weights ahead of it\n  //  until reaching the root\n\n  //  internal nodes work upwards from\n  //  their initial positions; while\n  //  symbol nodes slide over first,\n  //  then work up from their final\n  //  positions.\n\n  while( this.table[node].weight += 2, up = this.table[node].up ) {\n    while( this.table[node].weight > this.table[node + 1].weight ) {\n        node = this.slide (node);\n    }\n\n    if( this.table[node].weight & 1 ) {\n        node = up;\n    } else {\n        node = this.table[node].up;\n    }\n  }\n\n  /* Re-scale if necessary. */\n  if (this.max_weight) {\n    if (this.table[this.root].weight >= this.max_weight) {\n      this.scale(1);\n    }\n  }\n};\n\n//  scale all weights and re-balance the tree\n\n//  zero weight nodes are removed from the tree\n//  by sliding them out the left of the rank list\n\nHuffman.prototype.scale = function(bits) {\n  var node = this.esc, weight, prev;\n\n  //  work up the tree from the escape node\n  //  scaling weights by the value of bits\n\n  while( ++node <= this.root ) {\n    //  recompute the weight of internal nodes;\n    //  slide down and out any unused ones\n\n    if( this.table[node].weight & 1 ) {\n      if( weight = this.table[this.table[node].down].weight & ~1 ) {\n        weight += this.table[this.table[node].down - 1].weight | 1;\n      }\n\n      //  remove zero weight leaves by incrementing HuffEsc\n      //  and removing them from the symbol map.  take care\n\n    } else if( !(weight = this.table[node].weight >> bits & ~1) ) {\n      if( this.map[this.table[node].symbol] = 0, this.esc++ ) {\n        this.esc++;\n      }\n    }\n\n    // slide the scaled node back down over any\n    // previous nodes with larger weights\n\n    this.table[node].weight = weight;\n    prev = node;\n\n    while( weight < this.table[--prev].weight ) {\n      this.slide(prev);\n    }\n  }\n\n  // prepare a new escape node\n\n  this.table[this.esc].down = 0;\n};\n\n//  send the bits for an escaped symbol\n\nHuffman.prototype.sendid = function(symbol) {\n  var empty = 0, max;\n\n  //  count the number of empty symbols\n  //  before the symbol in the table\n\n  while( symbol-- ) {\n    if( !this.map[symbol] ) {\n      empty++;\n    }\n  }\n\n  //  send LSB of this count first, using\n  //  as many bits as are required for\n  //  the maximum possible count\n\n  if( max = this.size - Math.floor((this.root - this.esc) / 2) - 1 ) {\n    do {\n      this.writeBit(empty & 1);\n      empty >>= 1;\n    } while( max >>= 1 );\n  }\n};\n\n//  encode the next symbol\n\nHuffman.prototype.encode = function(symbol) {\n  var emit = 1, bit;\n  var up, idx, node;\n\n  if( symbol < this.size ) {\n    node = this.map[symbol];\n  } else {\n    console.assert(false);\n    return;\n  }\n\n  //  for a new symbol, direct the receiver to the escape node\n  //  but refuse input if table is already full.\n\n  if( !(idx = node) ) {\n    if( !(idx = this.esc) ) {\n      return;\n    }\n  }\n\n  //  accumulate the code bits by\n  //  working up the tree from\n  //  the node to the root\n\n  while( up = this.table[idx].up ) {\n    emit <<= 1; emit |= idx & 1; idx = up;\n  }\n\n  //  send the code, root selector bit first\n\n  while( bit = emit & 1, emit >>= 1 ) {\n    this.writeBit(bit);\n  }\n\n  //  send identification and incorporate\n  //  new symbols into the tree\n\n  if( !node ) {\n    this.sendid(symbol);\n    node = this.split(symbol);\n  }\n\n  //  adjust and re-balance the tree\n\n  this.increment(node);\n};\n\n//  read the identification bits\n//  for an escaped symbol\n\nHuffman.prototype.readid = function() {\n  var empty = 0, bit = 1, max, symbol;\n\n  //  receive the symbol, LSB first, reading\n  //  only the number of bits necessary to\n  //  transmit the maximum possible symbol value\n\n  if( max = this.size - Math.floor((this.root - this.esc) / 2) - 1 ) {\n    do {\n      empty |= this.readBit() ? bit : 0;\n      bit <<= 1;\n    } while( max >>= 1 );\n  }\n\n  //  the count is of unmapped symbols\n  //  in the table before the new one\n\n  for( symbol = 0; symbol < this.size; symbol++ ) {\n    if( !this.map[symbol] ) {\n      if( !empty-- ) {\n        return symbol;\n      }\n    }\n  }\n\n  //  oops!  our count is too big, either due\n  //  to a bit error, or a short node count\n  //  given to huff_init.\n\n  console.assert(false);\n  return 0;\n};\n\n//  decode the next symbol\n\nHuffman.prototype.decode = function() {\n  var node = this.root;\n  var symbol, down;\n\n  //  work down the tree from the root\n  //  until reaching either a leaf\n  //  or the escape node.  A one\n  //  bit means go left, a zero\n  //  means go right.\n\n  while( down = this.table[node].down ) {\n    if( this.readBit() ) {\n      node = down - 1;  // the left child precedes the right child\n    } else {\n      node = down;\n    }\n  }\n\n  //  sent to the escape node???\n  //  refuse to add to a full tree\n\n  if( node === this.esc ) {\n    if( this.esc ) {\n      symbol = this.readid ();\n      node = this.split (symbol);\n    } else {\n      console.assert(false);\n      return 0;\n    }\n  } else {\n    symbol = this.table[node].symbol;\n  }\n\n  //  increment weights and re-balance\n  //  the coding tree\n\n  this.increment (node);\n  return symbol;\n};\n\n// stand alone compressor, mostly for testing\nHuffman.MAGIC = 'huff';\nHuffman.compressFile = Util.compressFileHelper(Huffman.MAGIC, function(input, output, size, props) {\n  var bitstream = new BitStream(output);\n\n  var alphabetSize = 256;\n  if (size < 0) { alphabetSize++; }\n  var huff = new Huffman(257, alphabetSize, bitstream, 8191);\n  Util.compressWithModel(input, size, huff);\n  bitstream.flush();\n});\n\n// stand alone decompresser, again for testing\nHuffman.decompressFile = Util.decompressFileHelper(Huffman.MAGIC, function(input, output, size) {\n  var bitstream = new BitStream(input);\n\n  var alphabetSize = 256;\n  if (size < 0) { alphabetSize++; }\n  var huff = new Huffman(257, alphabetSize, bitstream, 8191);\n  Util.decompressWithModel(output, size, huff);\n});\n\nreturn Huffman;\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./BitStream\":123,\"./Util\":144}],133:[function(require,module,exports){\n/**\n * An in-place, length restricted Canonical Huffman code length allocator\n *\n * Based on the algorithm proposed by R. L. Milidi, A. A. Pessoa and\n * E. S. Laber in \"In-place Length-Restricted Prefix Coding\" (see:\n * http://www-di.inf.puc-rio.br/~laber/public/spire98.ps) and\n * incorporating additional ideas from the implementation of \"shcodec\"\n * by Simakov Alexander (see: http://webcenter.ru/~xander/)\n *\n * This JavaScript implementation ported from HuffmanAllocator.java from\n *   https://code.google.com/p/jbzip2\n * which is:\n *\n *   Copyright (c) 2011 Matthew Francis\n *\n *   Permission is hereby granted, free of charge, to any person\n *   obtaining a copy of this software and associated documentation\n *   files (the \"Software\"), to deal in the Software without\n *   restriction, including without limitation the rights to use,\n *   copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the\n *   Software is furnished to do so, subject to the following\n *   conditions:\n *\n *   The above copyright notice and this permission notice shall be\n *   included in all copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n *   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n *   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n *   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n *   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n *   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n *   OTHER DEALINGS IN THE SOFTWARE.\n *\n * This JavaScript implementation is:\n *   Copyright (c) 2013 C. Scott Ananian\n * with the same licensing terms as Matthew Francis' original implementation.\n */\nvar libs = [\n  require('./freeze'),\n  require('./Util')\n];\nvar body_fn = function (freeze, Util) {\n\n  /**\n   * FIRST() function\n   * @param array The code length array\n   * @param i The input position\n   * @param nodesToMove The number of internal nodes to be relocated\n   * @return The smallest {@code k} such that {@code nodesToMove <= k <= i} and\n   *         {@code i <= (array[k] % array.length)}\n   */\n  var first = function(array, i, nodesToMove) {\n    var length = array.length;\n    var limit = i;\n    var k = array.length - 2;\n\n    while ((i >= nodesToMove) && ((array[i] % length) > limit)) {\n      k = i;\n      i -= (limit - i + 1);\n    }\n    i = Math.max (nodesToMove - 1, i);\n\n    while (k > (i + 1)) {\n      var temp = (i + k) >> 1;\n      if ((array[temp] % length) > limit) {\n        k = temp;\n      } else {\n        i = temp;\n      }\n    }\n\n    return k;\n  };\n\n  /**\n   * Fills the code array with extended parent pointers\n   * @param array The code length array\n   */\n  var setExtendedParentPointers = function(array) {\n    var length = array.length;\n\n    array[0] += array[1];\n\n    var headNode, tailNode, topNode, temp;\n    for (headNode = 0, tailNode = 1, topNode = 2;\n         tailNode < (length - 1);\n         tailNode++) {\n      if ((topNode >= length) || (array[headNode] < array[topNode])) {\n        temp = array[headNode];\n        array[headNode++] = tailNode;\n      } else {\n        temp = array[topNode++];\n      }\n\n      if ((topNode >= length) ||\n          ((headNode < tailNode) && (array[headNode] < array[topNode]))) {\n        temp += array[headNode];\n        array[headNode++] = tailNode + length;\n      } else {\n        temp += array[topNode++];\n      }\n\n      array[tailNode] = temp;\n    }\n  };\n\n  /**\n   * Finds the number of nodes to relocate in order to achieve a given code\n   * length limit\n   * @param array The code length array\n   * @param maximumLength The maximum bit length for the generated codes\n   * @return The number of nodes to relocate\n   */\n  var findNodesToRelocate = function(array, maximumLength) {\n    var currentNode = array.length - 2;\n    var currentDepth;\n    for (currentDepth = 1;\n         (currentDepth < (maximumLength - 1)) && (currentNode > 1);\n         currentDepth++) {\n      currentNode =  first (array, currentNode - 1, 0);\n    }\n\n    return currentNode;\n  };\n\n\n  /**\n   * A final allocation pass with no code length limit\n   * @param array The code length array\n   */\n  var allocateNodeLengths = function(array) {\n    var firstNode = array.length - 2;\n    var nextNode = array.length - 1;\n    var currentDepth, availableNodes, lastNode, i;\n\n    for (currentDepth = 1, availableNodes = 2;\n         availableNodes > 0;\n         currentDepth++) {\n      lastNode = firstNode;\n      firstNode = first (array, lastNode - 1, 0);\n\n      for (i = availableNodes - (lastNode - firstNode); i > 0; i--) {\n        array[nextNode--] = currentDepth;\n      }\n\n      availableNodes = (lastNode - firstNode) << 1;\n    }\n  };\n\n  /**\n   * A final allocation pass that relocates nodes in order to achieve a\n   * maximum code length limit\n   * @param array The code length array\n   * @param nodesToMove The number of internal nodes to be relocated\n   * @param insertDepth The depth at which to insert relocated nodes\n   */\n  var allocateNodeLengthsWithRelocation = function(array, nodesToMove,\n                                                   insertDepth) {\n    var firstNode = array.length - 2;\n    var nextNode = array.length - 1;\n    var currentDepth = (insertDepth == 1) ? 2 : 1;\n    var nodesLeftToMove = (insertDepth == 1) ? nodesToMove - 2 : nodesToMove;\n    var availableNodes, lastNode, offset, i;\n\n    for (availableNodes = currentDepth << 1;\n         availableNodes > 0;\n         currentDepth++) {\n      lastNode = firstNode;\n      firstNode = (firstNode <= nodesToMove) ? firstNode : first (array, lastNode - 1, nodesToMove);\n\n      offset = 0;\n      if (currentDepth >= insertDepth) {\n        offset = Math.min (nodesLeftToMove, 1 << (currentDepth - insertDepth));\n      } else if (currentDepth == (insertDepth - 1)) {\n        offset = 1;\n        if ((array[firstNode]) == lastNode) {\n          firstNode++;\n        }\n      }\n\n      for (i = availableNodes - (lastNode - firstNode + offset); i > 0; i--) {\n        array[nextNode--] = currentDepth;\n      }\n\n      nodesLeftToMove -= offset;\n      availableNodes = (lastNode - firstNode + offset) << 1;\n    }\n  };\n\n  /**\n   * Allocates Canonical Huffman code lengths in place based on a sorted\n   * frequency array\n   * @param array On input, a sorted array of symbol frequencies; On output,\n   *              an array of Canonical Huffman code lengths\n   * @param maximumLength The maximum code length. Must be at least\n   *                      {@code ceil(log2(array.length))}\n   */\n  // public\n  var allocateHuffmanCodeLengths = function(array, maximumLength) {\n    switch (array.length) {\n    case 2:\n      array[1] = 1;\n    case 1:\n      array[0] = 1;\n      return;\n    }\n\n    /* Pass 1 : Set extended parent pointers */\n    setExtendedParentPointers (array);\n\n    /* Pass 2 : Find number of nodes to relocate in order to achieve\n     *          maximum code length */\n    var nodesToRelocate = findNodesToRelocate (array, maximumLength);\n\n    /* Pass 3 : Generate code lengths */\n    if ((array[0] % array.length) >= nodesToRelocate) {\n      allocateNodeLengths (array);\n    } else {\n      var insertDepth = maximumLength - (Util.fls(nodesToRelocate - 1));\n      allocateNodeLengthsWithRelocation (array, nodesToRelocate, insertDepth);\n    }\n  };\n\n  return freeze({\n    allocateHuffmanCodeLengths: allocateHuffmanCodeLengths\n  });\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./Util\":144,\"./freeze\":145}],134:[function(require,module,exports){\n/** Simple (log n)(n) distance model. */\nvar libs = [\n  require('./Util')\n];\nvar body_fn = function (Util){\n\n    // lengthBitsModelFactory will be called with arguments 2, 4, 8, 16, etc\n    // and must return an appropriate model or coder.\n    var LogDistanceModel = function(size, extraStates,\n                                    lgDistanceModelFactory,\n                                    lengthBitsModelFactory) {\n        var i;\n        var bits = Util.fls(size-1);\n        this.extraStates = +extraStates || 0;\n        this.lgDistanceModel = lgDistanceModelFactory(1 + bits + extraStates);\n        // this.distanceModel[n] used for distances which are n-bits long,\n        // but only n-1 bits are encoded: the top bit is known to be one.\n        this.distanceModel = [];\n        for (i=2 ; i <= bits; i++) {\n            var numBits = i - 1;\n            this.distanceModel[i] = lengthBitsModelFactory(1<<numBits);\n        }\n    };\n    /* you can give this model arguments between 0 and (size-1), or else\n       a negative argument which is one of the 'extra states'. */\n    LogDistanceModel.prototype.encode = function(distance) {\n        if (distance < 2) { // small distance or an 'extra state'\n            this.lgDistanceModel.encode(distance + this.extraStates);\n            return;\n        }\n        var lgDistance = Util.fls(distance);\n        console.assert(distance & (1<<(lgDistance-1))); // top bit is set\n        console.assert(lgDistance >= 2);\n        this.lgDistanceModel.encode(lgDistance + this.extraStates);\n        // now encode the rest of the bits.\n        var rest = distance & ((1 << (lgDistance-1)) - 1);\n        this.distanceModel[lgDistance].encode(rest);\n    };\n    LogDistanceModel.prototype.decode = function() {\n        var lgDistance = this.lgDistanceModel.decode() - this.extraStates;\n        if (lgDistance < 2) {\n            return lgDistance; // this is a small distance or an 'extra state'\n        }\n        var rest = this.distanceModel[lgDistance].decode();\n        return (1 << (lgDistance-1)) + rest;\n    };\n    return LogDistanceModel;\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./Util\":144}],135:[function(require,module,exports){\n/* LZJB compression: http://en.wikipedia.org/wiki/LZJB */\nvar libs = [\n  require('./Stream'),\n  require('./Util')\n];\nvar body_fn = function (Stream,Util) {\n/**\n$Id: Iuppiter.js 3026 2010-06-23 10:03:13Z Bear $\n\nCopyright (c) 2010 Nuwa Information Co., Ltd, and individual contributors.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n  1. Redistributions of source code must retain the above copyright notice,\n     this list of conditions and the following disclaimer.\n\n  2. Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in the\n     documentation and/or other materials provided with the distribution.\n\n  3. Neither the name of Nuwa Information nor the names of its contributors\n     may be used to endorse or promote products derived from this software\n     without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n$Author: Bear $\n$Date: 2010-06-23 18:03:13 +0800 (, 23  2010) $\n$Revision: 3026 $\n*/\n\nvar Lzjb = Object.create(null);\nLzjb.MAGIC = 'lzjb';\n\n// Constants was used for compress/decompress function.\nvar NBBY = 8,\n    MATCH_BITS = 6,\n    MATCH_MIN = 3,\n    MATCH_MAX = ((1 << MATCH_BITS) + (MATCH_MIN - 1)),\n    OFFSET_MASK = ((1 << (16 - MATCH_BITS)) - 1),\n    LEMPEL_SIZE_BASE = 1024;\nvar EOF = Stream.EOF;\n\n// set C_COMPAT to true if you need to decompress with the (untweaked) C lzjb\n// implementation, which breaks if offset==0; the javascript\n// implementation uses 0 to indicate an offset of OFFSET_MASK+1.\nvar C_COMPAT = true;\n\n/**\n * Compress string or byte array using fast and efficient algorithm.\n *\n * Because of weak of javascript's natural, many compression algorithm\n * become useless in javascript implementation. The main problem is\n * performance, even the simple Huffman, LZ77/78 algorithm will take many\n * many time to operate. We use LZJB algorithm to do that, it suprisingly\n * fulfills our requirement to compress string fastly and efficiently.\n *\n * Our implementation is based on\n * http://src.opensolaris.org/source/raw/onnv/onnv-gate/usr/src/uts/common/fs/zfs/lzjb.c\n * and\n * http://src.opensolaris.org/source/raw/onnv/onnv-gate/usr/src/uts/common/os/compress.c\n * It is licensed under CDDL.\n *\n * @param {Array|Uint8Array|Buffer|stream} input The stream or byte array\n *        that you want to compress.\n * @param {stream} output Optional output stream.\n * @return {Array|Uint8Array|Buffer} Compressed byte array, or 'output'\n */\nLzjb.compressFile = Util.compressFileHelper(Lzjb.MAGIC, function(inStream, outStream, fileSize, props) {\n    var sstart, dstart = [], slen,\n        src = 0, dst = 0,\n        cpy, copymap,\n        mlen, offset,\n        hash, hp,\n        lempel,\n        i, j;\n    var retval;\n\n    // in an improvement over the original C implementation, we expand\n    // the hash table to track a number of potential matches, not just the\n    // most recent.  This doesn't require any changes to the decoder.\n    // Sample impact on compression size (on wikipedia data):\n    //  EXPAND  Time     Size      Option\n    //    1   0m20.321s  50185613    -1\n    //    2   0m22.437s  46503301    -2\n    //    3   0m23.773s  45744564    -3\n    //    4   0m25.666s  45199866    -4\n    //    5   0m35.810s  44821413    -5\n    //    6   0m40.947s  44666638    -6\n    //    8   0m49.639s  44413865    -7\n    //   12   0m49.927s  44124825    -8\n    //   16   1m01.180s  43972515    -9\n    //   32   1m30.530s  43554099\n    //   64   2m14.504s  43005530\n    //  128   3m43.570s  42361718\n    //  256   6m38.681s  41684853\n    var LEMPEL_SIZE = LEMPEL_SIZE_BASE;\n    var EXPAND = 1; // default to original C impl\n    if (typeof(props)==='number') {\n        LEMPEL_SIZE *= 2;\n        props = Math.max(1, Math.min(9, props)) - 1;\n        EXPAND = 1<<Math.floor(props/2);\n        if (props&1) EXPAND = Math.round(EXPAND * 1.5);\n        if (props >=2 && props <= 4) EXPAND++;\n    }\n\n    // use Uint16Array if available (zero-filled)\n    lempel = Util.makeU16Buffer(LEMPEL_SIZE * EXPAND);\n\n    var window = Util.makeU8Buffer(OFFSET_MASK+1);\n    var windowpos = 0;\n    var winput = function(_byte) {\n        window[windowpos++] = _byte;\n        if (windowpos >= window.length) {\n            windowpos = 0;\n        }\n        return _byte;\n    };\n\n    var outwindow = Util.makeU8Buffer(17);\n    var outpos = 0;\n    var dumpout = function() {\n        var i;\n        for (i=0; i<outpos; i++) {\n            outStream.writeByte(outwindow[i]);\n        }\n        outpos = 0;\n    };\n\n    var unbuffer = [];\n    var get = function() {\n        if (unbuffer.length)\n            return unbuffer.pop();\n        return inStream.readByte();\n    };\n    var unget = function(_byte) {\n        unbuffer.push(_byte);\n    };\n\n    var copymask = 1 << (NBBY - 1);\n    var matchpossibility = [];\n    while (true) {\n        var c1 = get();\n        if (c1 === EOF) break;\n\n        if ((copymask <<= 1) == (1 << NBBY)) {\n            dumpout();\n            copymask = 1;\n            outwindow[0] = 0;\n            outpos = 1;\n        }\n\n        var c2 = get();\n        if (c2 === EOF) {\n            outwindow[outpos++] = winput(c1);\n            break;\n        }\n        var c3 = get();\n        if (c3 === EOF) {\n            outwindow[outpos++] = winput(c1);\n            unget(c2);\n            continue;\n        }\n\n        hash = (c1 << 16) + (c2 << 8) + c3;\n        hash ^= (hash >> 9);\n        hash += (hash >> 5);\n        hash ^= c1;\n        hp = (hash & (LEMPEL_SIZE - 1)) * EXPAND;\n        matchpossibility.length = 0;\n        for (j=0; j<EXPAND; j++) {\n            offset = (windowpos - lempel[hp+j]) & OFFSET_MASK;\n            cpy = window.length + windowpos - offset;\n            var w1 = window[cpy & OFFSET_MASK];\n            var w2 = window[(cpy+1) & OFFSET_MASK];\n            var w3 = window[(cpy+2) & OFFSET_MASK];\n            // if offset is small, we might not have copied the tentative\n            // bytes into the window yet.  (Note that offset=0 really means\n            // offset=(OFFSET_MASK+1).)\n            if (C_COMPAT && offset===0) {\n                w1 = c1 ^ 1; // ensure match will fail\n            } else if (offset==1) { w2 = c1; w3 = c2; }\n            else if (offset==2) { w3 = c1; }\n            if (c1 === w1 && c2 === w2 && c3 === w3) {\n                matchpossibility.push(offset);\n            }\n        }\n        // store this location in the hash, move the others over to make room\n        // oldest match drops off\n        for (j=EXPAND-1; j>0; j--)\n            lempel[hp+j] = lempel[hp+j-1];\n        lempel[hp] = windowpos;\n        // did we find any matches?\n        if (matchpossibility.length === 0) {\n            outwindow[outpos++] = winput(c1);\n            unget(c3);\n            unget(c2);\n        } else {\n            // find the longest of the possible matches\n            outwindow[0] |= copymask;\n            winput(c1); winput(c2); winput(c3);\n            var c4 = get(), last = matchpossibility[0];\n            var base = window.length + windowpos;\n            for (mlen = MATCH_MIN; mlen < MATCH_MAX; mlen++, base++) {\n                if (c4 === EOF) break;\n                for (j=0; j < matchpossibility.length; ) {\n                    var w4 = window[(base - matchpossibility[j]) & OFFSET_MASK];\n                    if (c4 !== w4) {\n                        last = matchpossibility[j];\n                        matchpossibility.splice(j, 1);\n                    } else {\n                        j++;\n                    }\n                }\n                if (matchpossibility.length===0) break; // no more matches\n                winput(c4);\n                c4 = get();\n            }\n            if (matchpossibility.length !== 0) {\n                // maximum length match, rock on!\n                last = matchpossibility[0];\n            }\n            unget(c4);\n\n            outwindow[outpos++] = ((mlen - MATCH_MIN) << (NBBY - MATCH_BITS)) |\n                (last >> NBBY);\n            outwindow[outpos++] = last & 0xFF;\n        }\n    }\n    dumpout();\n});\n\n/**\n * Decompress string or byte array using fast and efficient algorithm.\n *\n * Our implementation is based on\n * http://src.opensolaris.org/source/raw/onnv/onnv-gate/usr/src/uts/common/fs/zfs/lzjb.c\n * and\n * http://src.opensolaris.org/source/raw/onnv/onnv-gate/usr/src/uts/common/os/compress.c\n * It is licensed under CDDL.\n *\n * @param {Array|Uint8Array|Buffer|stream} input The stream or byte array\n *        that you want to decompress.\n * @param {stream} output Optional output stream.\n * @return {Array|Uint8Array|Buffer} Decompressed byte array, or 'output'\n */\nLzjb.decompressFile = Util.decompressFileHelper(Lzjb.MAGIC, function(inStream, outStream, outSize) {\n    var sstart, dstart = [], slen,\n        src = 0, dst = 0,\n        cpy, copymap,\n        mlen, offset,\n        i, c;\n    var retval;\n\n    var window = Util.makeU8Buffer(OFFSET_MASK+1);\n    var windowpos = 0;\n\n    var copymask = 1 << (NBBY - 1);\n\n    while (outSize !== 0) {\n        c = inStream.readByte();\n        if (c === EOF) break;\n\n        if ((copymask <<= 1) == (1 << NBBY)) {\n            copymask = 1;\n            copymap = c;\n            c = inStream.readByte();\n        }\n        if (copymap & copymask) {\n            mlen = (c >> (NBBY - MATCH_BITS)) + MATCH_MIN;\n            offset = ((c << NBBY) | inStream.readByte()) & OFFSET_MASK;\n            cpy = windowpos - offset;\n            if (cpy < 0) cpy += window.length;\n            if (outSize >= 0) outSize -= mlen;\n            while (--mlen >= 0) {\n                c = window[windowpos++] = window[cpy++];\n                outStream.writeByte(c);\n                if (windowpos >= window.length) { windowpos=0; }\n                if (cpy >= window.length) { cpy = 0; }\n            }\n        } else {\n            outStream.writeByte(c);\n            window[windowpos++] = c;\n            if (windowpos >= window.length) { windowpos=0; }\n            if (outSize >= 0) outSize--;\n        }\n    }\n});\n\n\nreturn Lzjb;\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./Stream\":143,\"./Util\":144}],136:[function(require,module,exports){\n/* Tweaked version of LZJB, using range coder. */\nvar libs = [\n  require('./Context1Model'),\n  require('./FenwickModel'),\n  require('./LogDistanceModel'),\n  require('./NoModel'),\n  require('./RangeCoder'),\n  require('./Stream'),\n  require('./Util')\n];\nvar body_fn = function (Context1Model,FenwickModel,LogDistanceModel,NoModel,RangeCoder,Stream,Util){\n\nvar LzjbR = Object.create(null);\nLzjbR.MAGIC = 'lzjR';\n\n// Constants was used for compress/decompress function.\nvar NBBY = 8,\n    MATCH_BITS = 6,\n    MATCH_MIN = 3,\n    MATCH_MAX = ((1 << MATCH_BITS) + (MATCH_MIN - 1)),\n    OFFSET_MASK = ((1 << (16 - MATCH_BITS)) - 1),\n    LEMPEL_SIZE_BASE = 1024;\nvar LENGTH_MODEL_CUTOFF = 32;\n\n\n/**\n * Compress using modified LZJB algorithm.  Instead of using the simple\n * 9-bit literal / 17-bit match format of the original, use a range\n * coder for the literal/match bit and for the offset and length.\n */\nLzjbR.compressFile = Util.compressFileHelper(LzjbR.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {\n    var sstart, dstart = [], slen,\n        src = 0, dst = 0,\n        cpy, copymap,\n        mlen, offset,\n        hash, hp,\n        lempel,\n        i, j;\n\n    // in an improvement over the original C implementation of LZJB, we expand\n    // the hash table to track a number of potential matches, not just the\n    // most recent.  This doesn't require any changes to the decoder.\n    var LEMPEL_SIZE = LEMPEL_SIZE_BASE;\n    var EXPAND = 1; // default to original C impl\n    if (typeof(props)==='number') {\n        LEMPEL_SIZE *= 2;\n        props = Math.max(1, Math.min(9, props)) - 1;\n        EXPAND = 1<<Math.floor(props/2);\n        if (props&1) EXPAND = Math.round(EXPAND * 1.5);\n        if (props >=2 && props <= 4) EXPAND++;\n    }\n\n    var encoder = new RangeCoder(outStream);\n    encoder.encodeStart(finalByte, 1);\n\n    // use Uint16Array if available (zero-filled)\n    lempel = Util.makeU16Buffer(LEMPEL_SIZE * EXPAND);\n\n    var window = Util.makeU8Buffer(OFFSET_MASK+1);\n    var windowpos = 0;\n    var winput = function(_byte) {\n        window[windowpos++] = _byte;\n        if (windowpos >= window.length) {\n            windowpos = 0;\n        }\n        return _byte;\n    };\n\n    var unbuffer = [];\n    var get = function() {\n        if (unbuffer.length)\n            return unbuffer.pop();\n        return inStream.readByte();\n    };\n    var unget = function(_byte) {\n        unbuffer.push(_byte);\n    };\n\n    var matchpossibility = [];\n    var MATCH = 256;\n    var EOF_SYM = 257;\n    var noModelFactory = NoModel.factory(encoder);\n    var modelFactory = FenwickModel.factory(encoder, 0xFF00, 0x100);\n    var literalModel = new Context1Model(modelFactory, 256,\n                                         ((fileSize<0) ? EOF_SYM : MATCH) + 1);\n    var sparseModelFactory = function(size) {\n        if (size <= LENGTH_MODEL_CUTOFF) { return modelFactory(size); }\n        return noModelFactory(size);\n    };\n    var lenModel = new LogDistanceModel((MATCH_MAX-MATCH_MIN)+1, 0,\n                                        modelFactory, sparseModelFactory);\n    var posModel = new LogDistanceModel(OFFSET_MASK+1, 1,\n                                        modelFactory, sparseModelFactory);\n    var lastChar = 0x20, lastOffset = 0;\n    while (true) {\n        var initialPos = windowpos;\n        var c1 = get();\n        if (c1 === Stream.EOF) break;\n\n        var c2 = get();\n        if (c2 === Stream.EOF) {\n            literalModel.encode(winput(c1), lastChar); // literal, not a match\n            break;\n        }\n        var c3 = get();\n        if (c3 === Stream.EOF) {\n            literalModel.encode(winput(c1), lastChar); // literal, not a match\n            unget(c2); lastChar = c1;\n            continue;\n        }\n\n        hash = (c1 << 16) + (c2 << 8) + c3;\n        hash ^= (hash >> 9);\n        hash += (hash >> 5);\n        hash ^= c1;\n        hp = (hash & (LEMPEL_SIZE - 1)) * EXPAND;\n        matchpossibility.length = 0;\n        for (j=0; j<EXPAND; j++) {\n            offset = (windowpos - lempel[hp+j]) & OFFSET_MASK;\n            cpy = window.length + windowpos - offset;\n            var w1 = window[cpy & OFFSET_MASK];\n            var w2 = window[(cpy+1) & OFFSET_MASK];\n            var w3 = window[(cpy+2) & OFFSET_MASK];\n            // if offset is small, we might not have copied the tentative\n            // bytes into the window yet.  (Note that offset=0 really means\n            // offset=(OFFSET_MASK+1).)\n            if (offset==1) { w2 = c1; w3 = c2; }\n            else if (offset==2) { w3 = c1; }\n            if (c1 === w1 && c2 === w2 && c3 === w3) {\n                matchpossibility.push(offset);\n            }\n        }\n        // store this location in the hash, move the others over to make room\n        // oldest match drops off\n        for (j=EXPAND-1; j>0; j--)\n            lempel[hp+j] = lempel[hp+j-1];\n        lempel[hp] = windowpos;\n        // did we find any matches?\n        if (matchpossibility.length === 0) {\n            literalModel.encode(winput(c1), lastChar); // literal, not a match\n            unget(c3);\n            unget(c2);\n            lastChar = c1;\n        } else {\n            literalModel.encode(MATCH, lastChar); // a match!\n            // find the longest of the possible matches\n            winput(c1); winput(c2); winput(c3); lastChar = c3;\n            var c4 = get(), last = matchpossibility[0];\n            var base = window.length + windowpos;\n            for (mlen = MATCH_MIN; mlen < MATCH_MAX; mlen++, base++) {\n                if (c4 === Stream.EOF) break;\n                for (j=0; j < matchpossibility.length; ) {\n                    var w4 = window[(base - matchpossibility[j]) & OFFSET_MASK];\n                    if (c4 !== w4) {\n                        last = matchpossibility[j];\n                        matchpossibility.splice(j, 1);\n                    } else {\n                        j++;\n                    }\n                }\n                if (matchpossibility.length===0) break; // no more matches\n                winput(c4); lastChar = c4;\n                c4 = get();\n            }\n            if (matchpossibility.length !== 0) {\n                // maximum length match, rock on!\n                last = matchpossibility[0];\n            }\n            unget(c4);\n\n            // encode match length\n            // XXX we could get a bit more compression if we allowed\n            // the length to predict the offset (or vice-versa)\n            lenModel.encode(mlen - MATCH_MIN);\n            offset = (initialPos - last) & OFFSET_MASK;\n            if (offset === lastOffset) {\n                posModel.encode(-1); // common case!\n            } else {\n                posModel.encode(offset);\n                lastOffset = offset;\n            }\n        }\n    }\n    if (fileSize < 0) {\n        literalModel.encode(EOF_SYM, lastChar); // end of file (streaming)\n    }\n    encoder.encodeFinish();\n}, true);\n\n/**\n * Decompress using modified LZJB algorithm.\n */\nLzjbR.decompressFile = Util.decompressFileHelper(LzjbR.MAGIC, function(inStream, outStream, outSize) {\n    var sstart, dstart = [], slen,\n        src = 0, dst = 0,\n        cpy, copymap,\n        mlen, offset,\n        i, c;\n\n    var window = Util.makeU8Buffer(OFFSET_MASK+1);\n    var windowpos = 0;\n\n    var decoder = new RangeCoder(inStream);\n    decoder.decodeStart(true/* we already read the 'free' byte*/);\n\n    var MATCH = 256;\n    var EOF_SYM = 257;\n    var noModelFactory = NoModel.factory(decoder);\n    var modelFactory = FenwickModel.factory(decoder, 0xFF00, 0x100);\n    var literalModel = new Context1Model(modelFactory, 256,\n                                         ((outSize<0) ? EOF_SYM : MATCH) + 1);\n    var sparseModelFactory = function(size) {\n        if (size <= LENGTH_MODEL_CUTOFF) { return modelFactory(size); }\n        return noModelFactory(size);\n    };\n    var lenModel = new LogDistanceModel((MATCH_MAX-MATCH_MIN)+1, 0,\n                                        modelFactory, sparseModelFactory);\n    var posModel = new LogDistanceModel(OFFSET_MASK+1, 1,\n                                        modelFactory, sparseModelFactory);\n    var lastChar = 0x20, lastOffset = 0;\n    while (outSize !== 0) {\n        c = literalModel.decode(lastChar);\n        if (c === EOF_SYM) {\n            break;\n        } else if (c === MATCH) {\n            mlen = lenModel.decode() + MATCH_MIN;\n            cpy = posModel.decode();\n            if (cpy<0) { cpy = lastOffset; }\n            else       { lastOffset = cpy; }\n            if (outSize >= 0) outSize -= mlen;\n            while (--mlen >= 0) {\n                c = lastChar = window[windowpos++] = window[cpy++];\n                outStream.writeByte(c);\n                if (windowpos >= window.length) { windowpos=0; }\n                if (cpy >= window.length) { cpy = 0; }\n            }\n        } else {\n            outStream.writeByte(c);\n            window[windowpos++] = lastChar = c;\n            if (windowpos >= window.length) { windowpos=0; }\n            if (outSize >= 0) outSize--;\n        }\n    }\n    decoder.decodeFinish();\n});\n\n\nreturn LzjbR;\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./Context1Model\":126,\"./FenwickModel\":131,\"./LogDistanceModel\":134,\"./NoModel\":139,\"./RangeCoder\":141,\"./Stream\":143,\"./Util\":144}],137:[function(require,module,exports){\n/* Implementation of LZP3(ish), with an adaptive Huffman code or a range\n * coder (instead of LZP3's original static Huffman code).\n * See: http://www.cbloom.com/papers/lzp.pdf\n */\nvar libs = [\n  require('./BitStream'),\n  require('./Context1Model'),\n  require('./DefSumModel'),\n  require('./FenwickModel'),\n  require('./Huffman'),\n  require('./LogDistanceModel'),\n  require('./NoModel'),\n  require('./RangeCoder'),\n  require('./Stream'),\n  require('./Util')\n];\nvar body_fn = function (BitStream, Context1Model, DefSumModel, FenwickModel, Huffman, LogDistanceModel, NoModel, RangeCoder, Stream, Util){\n\nvar Lzp3 = Object.create(null);\nLzp3.MAGIC = 'lzp3';\n\n// use Huffman coder (fast) or else use range coder (slow)\nvar USE_HUFFMAN_CODE = false;\n// use deferred-sum model, which is supposed to be faster (but compresses worse)\nvar USE_DEFSUM = false;\n// when to give up attempting to model the length\nvar LENGTH_MODEL_CUTOFF = 256;\nvar MODEL_MAX_PROB = 0xFF00;\nvar MODEL_INCREMENT = 0x100;\n\n// Constants was used for compress/decompress function.\nvar CTXT4_TABLE_SIZE = 1 << 16;\nvar CTXT3_TABLE_SIZE = 1 << 12;\nvar CTXT2_TABLE_SIZE = 1 << 16;\nvar CONTEXT_LEN = 4;\nvar LOG_WINDOW_SIZE = 20;\nvar WINDOW_SIZE = 1 << LOG_WINDOW_SIZE;\nvar MAX_MATCH_LEN = WINDOW_SIZE-1;\nvar MATCH_LEN_CONTEXTS = 16;\n\nvar MAX32 = 0xFFFFFFFF;\nvar MAX24 = 0x00FFFFFF;\nvar MAX16 = 0x0000FFFF;\nvar MAX8  = 0x000000FF;\n\n\nvar Window = function(maxSize) {\n  this.buffer = Util.makeU8Buffer(Math.min(maxSize+4, WINDOW_SIZE));\n  this.pos = 0;\n  // context-4 hash table.\n  this.ctxt4 = Util.makeU32Buffer(CTXT4_TABLE_SIZE);\n  // context-3 hash table\n  this.ctxt3 = Util.makeU32Buffer(CTXT3_TABLE_SIZE);\n  // context-2 table (not really a hash any more)\n  this.ctxt2 = Util.makeU32Buffer(CTXT2_TABLE_SIZE);\n  // initial context\n  this.put(0x63); this.put(0x53); this.put(0x61); this.put(0x20);\n};\nWindow.prototype.put = function(_byte) {\n  this.buffer[this.pos++] = _byte;\n  if (this.pos >= WINDOW_SIZE) { this.pos = 0; }\n  return _byte;\n};\nWindow.prototype.get = function(pos) {\n  return this.buffer[pos & (WINDOW_SIZE-1)];\n};\nWindow.prototype.context = function(pos, n) {\n  var c = 0, i;\n  pos = (pos - n) & (WINDOW_SIZE-1);\n  for (i=0; i<n; i++) {\n    c = (c << 8) | this.buffer[pos++];\n    if (pos >= WINDOW_SIZE) { pos = 0; }\n  }\n  return c;\n};\n// if matchLen !== 0, update the index; otherwise get index value.\nWindow.prototype.getIndex = function(s, matchLen) {\n  var c = this.context(s, 4);\n  // compute context hashes\n  var h4 = ((c>>>15) ^ c) & (CTXT4_TABLE_SIZE-1);\n  var h3 = ((c>>>11) ^ c) & (CTXT3_TABLE_SIZE-1);\n  var h2 = c & MAX16;\n  // check order-4 context\n  var p = 0, checkc;\n  // only do context confirmation if matchLen==0 (that is, if we're not just\n  // doing an update)\n  if (matchLen===0) {\n    p = this.ctxt4[h4];\n    if (p !== 0 && c !== this.context(p-1, 4)) {\n      p = 0; // context confirmation failed\n    }\n    if (p === 0) {\n      // check order-3 context\n      p = this.ctxt3[h3];\n      if (p !== 0 && (c & MAX24) !== this.context(p-1, 3)) {\n        p = 0; // context confirmation failed\n      }\n      if (p === 0) {\n        // check order-2 context\n        p = this.ctxt2[h2];\n        if (p !== 0 && (c && MAX16) !== this.context(p-1, 2)) {\n          p = 0; // context confirmation failed\n        }\n      }\n    }\n  }\n  // update context index\n  if (matchLen) { matchLen--; }\n  this.ctxt4[h4] = this.ctxt3[h3] = this.ctxt2[h2] =\n    (s | (matchLen << LOG_WINDOW_SIZE)) + 1;\n  // return lookup result.\n  return p;\n};\n\n/**\n * Compress using modified LZP3 algorithm.  Instead of using static\n * Huffman coding, we use an adaptive Huffman code or range encoding.\n */\nLzp3.compressFile = Util.compressFileHelper(Lzp3.MAGIC, function(inStream, outStream, fileSize, props) {\n  // sliding window & hash table\n  var window = new Window( (fileSize>=0) ? fileSize : WINDOW_SIZE );\n\n  var coderFactory, sparseCoderFactory, flush;\n\n  if (USE_HUFFMAN_CODE) {\n    // Huffman contexts\n    outStream.writeByte(0x80); // mark that this is Huffman coded.\n    var bitstream = new BitStream(outStream);\n    flush = bitstream.flush.bind(bitstream);\n    coderFactory = Huffman.factory(bitstream, MAX16);\n    sparseCoderFactory = NoModel.factory(bitstream);\n\n  } else { // range encoder\n    var range = new RangeCoder(outStream);\n    range.encodeStart(0x00, 0); // 0x00 == range encoded\n\n    coderFactory = FenwickModel.factory(range, MODEL_MAX_PROB, MODEL_INCREMENT);\n    if (USE_DEFSUM) {\n      coderFactory = DefSumModel.factory(range, false /* encoder */);\n    }\n    // switch sparseCoderFactory to a NoModel when size > cutoff\n    var noCoderFactory = NoModel.factory(range);\n    sparseCoderFactory = function(size) {\n      if (size > LENGTH_MODEL_CUTOFF) {\n        return noCoderFactory(size);\n      }\n      return coderFactory(size);\n    };\n    flush = function() { range.encodeFinish(); };\n  }\n\n  var huffLiteral= new Context1Model(coderFactory, 256,\n                                     (fileSize<0) ? 257 : 256);\n  var huffLen = [], i;\n  for (i=0; i<MATCH_LEN_CONTEXTS; i++) {\n    huffLen[i] = new LogDistanceModel(MAX_MATCH_LEN+1, 1,\n                                      coderFactory, sparseCoderFactory);\n  }\n\n  var inSize = 0, s, matchContext = 0;\n  while (inSize !== fileSize) {\n    var ch = inStream.readByte();\n    s = window.pos;\n    var p = window.getIndex(s, 0);\n    if (p !== 0) {\n      // great, a match! how long is it?\n      p--; // p=0 is used for 'not here'. p=1 really means WINDOW_SIZE\n      var prevMatchLen = (p >>> LOG_WINDOW_SIZE) + 1;\n      var matchLen = 0;\n      while (window.get(p + matchLen) === ch && matchLen < MAX_MATCH_LEN) {\n        matchLen++;\n        window.put(ch);\n        ch = inStream.readByte();\n      }\n      // code match length; match len = 0 means \"literal\"\n      // use \"extra state\" -1 to mean \"same as previous match length\"\n      if (prevMatchLen===matchLen) {\n        huffLen[matchContext&(MATCH_LEN_CONTEXTS-1)].encode(-1);\n      } else {\n        huffLen[matchContext&(MATCH_LEN_CONTEXTS-1)].encode(matchLen);\n      }\n      // update hash with this match\n      window.getIndex(s, matchLen);\n      inSize += matchLen;\n      matchContext <<= 1;\n      if (matchLen > 0) { matchContext |= 1; }\n      // XXX: LZMA uses a special \"delta match\" context here if matchLen==0\n      // XXX: it also uses the offset as context for the length (or vice-versa)\n    }\n    // always encode a literal after a match\n    var context1 = window.get(window.pos-1);\n    if (ch===Stream.EOF) {\n      if (fileSize < 0) {\n        huffLiteral.encode(256, context1);\n      }\n      break;\n    }\n    huffLiteral.encode(ch, context1);\n    window.put(ch);\n    inSize++;\n  }\n  if (flush) flush();\n});\n\n/**\n * Decompress using modified LZP3 algorithm.\n */\nLzp3.decompressFile = Util.decompressFileHelper(Lzp3.MAGIC, function(inStream, outStream, fileSize) {\n  var flags = inStream.readByte();\n  var use_huffman_code = !!(flags & 0x80);\n\n  // sliding window & hash table\n  var window = new Window( (fileSize>=0) ? fileSize : WINDOW_SIZE );\n\n  var coderFactory, sparseCoderFactory, finish;\n\n  if (use_huffman_code) {\n    // Huffman contexts\n    var bitstream = new BitStream(inStream);\n    coderFactory = Huffman.factory(bitstream, MAX16);\n    sparseCoderFactory = NoModel.factory(bitstream);\n  } else { // range encoder\n    var range = new RangeCoder(inStream);\n    range.decodeStart(true/* skip initial read */);\n    coderFactory = FenwickModel.factory(range, MODEL_MAX_PROB, MODEL_INCREMENT);\n    if (USE_DEFSUM) {\n      coderFactory = DefSumModel.factory(range, true /* decoder */);\n    }\n    // switch sparseCoderFactory to a NoModel when size > cutoff\n    var noCoderFactory = NoModel.factory(range);\n    sparseCoderFactory = function(size) {\n      if (size > LENGTH_MODEL_CUTOFF) {\n        return noCoderFactory(size);\n      }\n      return coderFactory(size);\n    };\n    finish = function() { range.decodeFinish(); };\n  }\n\n  var huffLiteral= new Context1Model(coderFactory, 256,\n                                     (fileSize<0) ? 257 : 256);\n  var huffLen = [], i;\n  for (i=0; i<MATCH_LEN_CONTEXTS; i++) {\n    huffLen[i] = new LogDistanceModel(MAX_MATCH_LEN+1, 1,\n                                      coderFactory, sparseCoderFactory);\n  }\n\n  var s, ch, outSize = 0, matchContext = 0;\n  while (outSize !== fileSize) {\n    s = window.pos;\n    var p = window.getIndex(s, 0);\n    if (p !== 0) {\n      p--; // p=0 is used for 'not here'. p=1 really means WINDOW_SIZE\n      var prevMatchLen = (p >>> LOG_WINDOW_SIZE) + 1;\n      var matchLen = huffLen[matchContext&(MATCH_LEN_CONTEXTS-1)].decode();\n      if (matchLen < 0) { matchLen = prevMatchLen; }\n      // copy characters!\n      for (i=0; i<matchLen; i++) {\n        ch = window.get(p + i);\n        outStream.writeByte(window.put(ch));\n      }\n      window.getIndex(s, matchLen);\n      outSize += matchLen;\n      matchContext <<= 1;\n      if (matchLen > 0) matchContext |= 1;\n    }\n    // literal always follows match (or failed match)\n    if (outSize === fileSize) {\n      break; // EOF\n    }\n    var context1 = window.get(window.pos-1);\n    ch = huffLiteral.decode(context1);\n    if (ch === 256) {\n      break; // EOF\n    }\n    outStream.writeByte(window.put(ch));\n    outSize++;\n  }\n  if (finish) finish();\n});\n\n\nreturn Lzp3;\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./BitStream\":123,\"./Context1Model\":126,\"./DefSumModel\":127,\"./FenwickModel\":131,\"./Huffman\":132,\"./LogDistanceModel\":134,\"./NoModel\":139,\"./RangeCoder\":141,\"./Stream\":143,\"./Util\":144}],138:[function(require,module,exports){\n/** Simple range coding model w/ escape, suitable for sparse symbol sets.\n *  Uses a move-to-front list, which is simple and relatively performant,\n *  but slows down a lot if you want to try to model escapes more precisely\n *  (which is why this feature is disabled by default).\n */\nvar libs = [\n  require('./RangeCoder'),\n  require('./Stream'),\n  require('./Util')\n];\nvar body_fn = function (RangeCoder,Stream,Util){\n\nvar DEFAULT_MAX_PROB = 0xFF00;\nvar DEFAULT_INCREMENT= 0x0100;\n\nvar NUMERIC_SORT = function(a, b) { return a - b; };\n\nvar MTFModel = function(coder, size, max_prob, increment, betterEscape) {\n    this.coder = coder;\n    this.increment = (+increment) || DEFAULT_INCREMENT;\n    this.max_prob = (+max_prob) || DEFAULT_MAX_PROB;\n    console.assert((this.max_prob + (this.increment-1)) <= 0xFFFF);\n    this.sym = Util.makeU16Buffer(size+1);\n    this.prob= Util.makeU16Buffer(size+2);\n    this.sym[0] = size; // escape code\n    this.prob[0]= 0;\n    this.seenSyms = 1;\n    // total probability always found in this.prob[this.seenSyms]\n    this.prob[this.seenSyms] = this.increment;\n    this.numSyms = size;\n    if (betterEscape) {\n        this.sortedSeen = [size];\n    }\n};\nMTFModel.factory = function(coder, max_prob, increment, betterEscape) {\n    return function(size) {\n        return new MTFModel(coder, size, max_prob, increment, betterEscape);\n    };\n};\nMTFModel.prototype.clone = function() {\n    var newModel = new MTFModel(this.coder, this.numSyms, this.max_prob,\n                                this.increment, !!this.sortedSeen);\n    var i;\n    for (i=0; i<this.seenSyms; i++) {\n        newModel.sym[i] = this.sym[i];\n        newModel.prob[i] = this.prob[i];\n    }\n    newModel.prob[i] = this.prob[i]; // total probability\n    newModel.seenSyms = this.seenSyms;\n    if (this.sortedSeen) {\n        newModel.sortedSeen = this.sortedSeen.slice(0);\n    }\n    return newModel;\n};\nMTFModel.prototype._update = function(symbol, index, sy_f) {\n    var j, tot_f;\n    // move this symbol to the end\n    for (j=index; j<this.seenSyms-1; j++) {\n        this.sym[j] = this.sym[j+1];\n        this.prob[j] = this.prob[j+1] - sy_f;\n    }\n    if (index < this.seenSyms) {\n        this.sym[j] = symbol;\n        this.prob[j] = this.prob[j+1] - sy_f;\n        // increase frequency for this symbol, and total freq at same time\n        this.prob[this.seenSyms] = tot_f =\n            this.prob[this.seenSyms] + this.increment;\n        if (symbol === this.numSyms && this.seenSyms >= this.numSyms) {\n            // this is the last time we'll see an escape! remove it.\n            tot_f = this.prob[--this.seenSyms];\n            if (this.sortedSeen) { this.sortedSeen.length--; }\n        }\n    } else { // add to the end\n        tot_f = this.prob[this.seenSyms];\n        this.sym[index] = symbol;\n        this.prob[index] = tot_f;\n        tot_f += this.increment;\n        this.prob[++this.seenSyms] = tot_f;\n        if (this.sortedSeen) {\n            this.sortedSeen.push(symbol);\n            // hopefully sort is very fast on a mostly-sorted array\n            this.sortedSeen.sort(NUMERIC_SORT);\n        }\n    }\n    if (tot_f >= this.max_prob) { this._rescale(); }\n    return;\n};\nMTFModel.prototype._rescale = function() {\n    var i, j, total=0;\n    var noEscape = true;\n    if (this.sortedSeen) { this.sortedSeen.length = 0; }\n    for(i=0, j=0; i<this.seenSyms; i++) {\n        var sym = this.sym[i];\n        var sy_f = this.prob[i+1] - this.prob[i];\n        sy_f >>>= 1;\n        if (sy_f > 0) {\n            if (sym === this.numSyms) {\n                noEscape = false;\n            }\n            this.sym[j] = sym;\n            this.prob[j++] = total;\n            total += sy_f;\n            if (this.sortedSeen) { this.sortedSeen.push(sym); }\n        }\n    }\n    this.prob[j] = total;\n    this.seenSyms = j;\n    if (this.sortedSeen) {\n        this.sortedSeen.sort(NUMERIC_SORT);\n    }\n    // don't allow escape to go to zero prob if we still need it\n    if (noEscape && this.seenSyms < this.numSyms) {\n        // NOTE this adds this.increment to escape freq; the FenwickModel\n        //      just adds one.\n        this._update(this.numSyms/*escape*/, this.seenSyms/*at end*/);\n    }\n};\nMTFModel.prototype.decode = function() {\n    var tot_f = this.prob[this.seenSyms];\n    var prob = this.coder.decodeCulFreq(tot_f);\n    // we're expecting to find the probability near the \"most recent\" side\n    // of our array\n    var i;\n    for (i=this.seenSyms-1; i>=0; i--) {\n        if (this.prob[i] <= prob /*&& prob < this.prob[i+1]*/)\n            break;\n    }\n    console.assert(i>=0);\n    var symbol = this.sym[i];\n    var lt_f = this.prob[i];\n    var sy_f = this.prob[i + 1] - lt_f;\n    this.coder.decodeUpdate(sy_f, lt_f, tot_f);\n    this._update(symbol, i, sy_f);\n    if (symbol === this.numSyms) {\n        /* this is an escape */\n        /* decode the literal */\n        sy_f = 1;\n        tot_f = this.numSyms;\n        if (this.sortedSeen) {\n            // do a slower, but more precise decoding of the literal\n            // by excluding the already-seen symbols.\n            var seen = this.sortedSeen;\n            tot_f = this.numSyms - this.seenSyms;\n            if (seen[seen.length-1] === this.numSyms) { tot_f++; }\n            symbol = lt_f = this.coder.decodeCulFreq(tot_f);\n            for (i=0; i < seen.length && seen[i] <= symbol ; i++) {\n                symbol++;\n            }\n        } else {\n            symbol = lt_f = this.coder.decodeCulFreq(tot_f);\n        }\n        this.coder.decodeUpdate(sy_f, lt_f, tot_f);\n        this._update(symbol, this.seenSyms);\n    }\n    return symbol;\n};\nMTFModel.prototype.encode = function(symbol) {\n    // look for symbol, from most-recent to oldest\n    var i, sy_f, lt_f, tot_f;\n    for (i=this.seenSyms-1; i>=0; i--) {\n        if (symbol === this.sym[i]) {\n            // ok, found it.\n            lt_f = this.prob[i];\n            sy_f = this.prob[i + 1] - lt_f;\n            tot_f = this.prob[this.seenSyms];\n            this.coder.encodeFreq(sy_f, lt_f, tot_f);\n            return this._update(symbol, i, sy_f);\n        }\n    }\n    // couldn't find this symbol.  encode as escape.\n    console.assert(symbol !== this.numSyms); // catch infinite recursion\n    this.encode(this.numSyms); // guaranteed to be found in the table.\n    // code symbol as literal\n    sy_f = 1;\n    lt_f = symbol;\n    tot_f = this.numSyms;\n    if (this.sortedSeen) {\n        // do a slower, but more precise encoding of the literal\n        // by excluding the already-seen symbols.\n        var seen = this.sortedSeen;\n        tot_f -= this.seenSyms;\n        if (seen[seen.length-1] === this.numSyms) { tot_f++; }\n        for (i=0; i < seen.length && seen[i] < symbol; i++) {\n            lt_f--;\n        }\n    }\n    this.coder.encodeFreq(sy_f, lt_f, tot_f);\n    // now add symbol to the end.\n    return this._update(symbol, this.seenSyms);\n};\n\nMTFModel.MAGIC = 'mtfm';\n/** Simple order-0 compressor, as self-test. */\nMTFModel.compressFile = Util.compressFileHelper(MTFModel.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {\n  var range = new RangeCoder(outStream);\n  range.encodeStart(finalByte, 1);\n  var model = new MTFModel(range, (fileSize<0) ? 257 : 256);\n  Util.compressWithModel(inStream, fileSize, model);\n  range.encodeFinish();\n}, true);\n\n/** Simple order-0 decompresser, as self-test. */\nMTFModel.decompressFile = Util.decompressFileHelper(MTFModel.MAGIC, function(inStream, outStream, fileSize) {\n  var range = new RangeCoder(inStream);\n  range.decodeStart(true/*we already read the 'free' byte*/);\n  var model = new MTFModel(range, (fileSize<0) ? 257 : 256);\n  Util.decompressWithModel(outStream, fileSize, model);\n  range.decodeFinish();\n});\n\nreturn MTFModel;\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./RangeCoder\":141,\"./Stream\":143,\"./Util\":144}],139:[function(require,module,exports){\n/** Simple \"lack of model\" -- just encode the bits directly.\n *  Useful especially with sparse spaces or Huffman coders where there's\n *  no obvious prediction to be made that will pay for itself.\n */\nvar libs = [\n  require('./BitStream'),\n  require('./Util')\n];\nvar body_fn = function (BitStream,Util) {\n\nvar NoModel = function(bitstream, size) {\n  this.bitstream = bitstream;\n  this.bits = Util.fls(size-1);\n};\nNoModel.factory = function(bitstream) {\n  return function(size) { return new NoModel(bitstream, size); };\n};\nNoModel.prototype.encode = function(symbol) {\n  var i;\n  for (i=this.bits-1; i>=0; i--) {\n    var b = (symbol >>> i) & 1;\n    this.bitstream.writeBit(b);\n  }\n};\nNoModel.prototype.decode = function() {\n  var i, r = 0;\n  for (i=this.bits-1; i>=0; i--) {\n    r <<= 1;\n    if (this.bitstream.readBit()) r++;\n  }\n  return r;\n};\n\n/** Brain-dead self-test. */\nNoModel.MAGIC = 'nomo';\nNoModel.compressFile = Util.compressFileHelper(NoModel.MAGIC, function(inStream, outStream, fileSize, props) {\n    var bitstream = new BitStream(outStream);\n    var model = new NoModel(bitstream, (fileSize<0) ? 257 : 256);\n    Util.compressWithModel(inStream, fileSize, model);\n    bitstream.flush();\n});\nNoModel.decompressFile = Util.decompressFileHelper(NoModel.MAGIC, function(inStream, outStream, fileSize) {\n    var bitstream = new BitStream(inStream);\n    var model = new NoModel(bitstream, (fileSize<0) ? 257 : 256);\n    Util.decompressWithModel(outStream, fileSize, model);\n});\n\nreturn NoModel;\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./BitStream\":123,\"./Util\":144}],140:[function(require,module,exports){\n/** Particularly simple-minded implementation of PPM compression. */\nvar libs = [\n  require('./RangeCoder'),\n  require('./Util')\n];\nvar body_fn = function (RangeCoder,Util) {\n\n  var MAX_CONTEXT = 5;\n  var LOG_WINDOW_SIZE = 18;\n  var WINDOW_SIZE = 1 << LOG_WINDOW_SIZE;\n\n  var Window = function() {\n    this.buffer = Util.makeU8Buffer(WINDOW_SIZE);\n    this.pos = 0;\n    this.firstPass = true;\n    for (var i=0; i<MAX_CONTEXT; i++) {\n      this.put('cSaCsA'.charCodeAt(i%6));\n    }\n  };\n  Window.prototype.put = function(_byte) {\n    this.buffer[this.pos++] = _byte;\n    if (this.pos >= WINDOW_SIZE) { this.pos = 0; this.firstPass = false; }\n    return _byte;\n  };\n  Window.prototype.get = function(pos) {\n    return this.buffer[pos & (WINDOW_SIZE-1)];\n  };\n  // the context ending just before 'pos'\n  Window.prototype.context = function(pos, n) {\n    var c = [], i;\n    pos = (pos - n) & (WINDOW_SIZE-1);\n    for (i=0; i<n; i++) {\n      c.push(this.buffer[pos++]);\n      if (pos >= WINDOW_SIZE) { pos = 0; }\n    }\n    return String.fromCharCode.apply(String, c);\n  };\n\n  var DMM_INCREMENT = 0x100, DMM_MAX_PROB = 0xFF00;\n\n  var PPM = function(coder, size) {\n    this.window = new Window();\n    this.contexts = Object.create(null);\n    // brain-dead '-1' context, using full exclusion\n    var Cm1Context = function() { };\n    Cm1Context.prototype.encode = function(symbol, exclude) {\n      var i, lt_f = 0;\n      for (i=0; i<symbol; i++) {\n        if (!exclude[i]) {\n          lt_f++;\n        }\n      }\n      var tot_f = size - exclude.total;\n      coder.encodeFreq(1, lt_f, tot_f);\n    };\n    Cm1Context.prototype.decode = function(exclude) {\n      var i, symbol, lt_f;\n      var tot_f = size - exclude.total;\n      symbol = lt_f = coder.decodeCulFreq(tot_f);\n      for (i=0; i<=symbol; i++) {\n        if (exclude[i]) {\n          symbol++;\n        }\n      }\n      coder.decodeUpdate(1, lt_f, tot_f);\n      return symbol;\n    };\n    this.cm1coder = new Cm1Context();\n\n    var DenseMTFModel = function() {\n      this.sym = [size];\n      this.prob= [0, DMM_INCREMENT];\n      this.refcount = 0;\n    };\n    DenseMTFModel.prototype._rescale = function() {\n      var seenSyms = this.sym.length;\n      var i, j, total=0;\n      var noEscape = true;\n      for(i=0, j=0; i<seenSyms; i++) {\n        var sym = this.sym[i];\n        var sy_f = this.prob[i+1] - this.prob[i];\n        sy_f >>>= 1;\n        if (sy_f > 0) {\n          if (sym === size) {\n            noEscape = false;\n          }\n          this.sym[j] = sym;\n          this.prob[j++] = total;\n          total += sy_f;\n        }\n      }\n      this.prob[j] = total;\n      seenSyms = this.sym.length = j;\n      this.prob.length = seenSyms + 1;\n      // don't allow escape to go to zero prob if we still need it\n      if (noEscape && seenSyms < size) {\n        total = this._update(size/*escape*/, seenSyms/*at end*/, 0, 1);\n      }\n      return total;\n    };\n    DenseMTFModel.prototype.update = function(symbol, incr) {\n      // find symbol\n      var i=0;\n      for (i=0; i<this.sym.length; i++) {\n        if (this.sym[i] === symbol) {\n          return this._update(symbol, i, this.prob[i+1] - this.prob[i], incr);\n        }\n      }\n      // symbol escaped\n      return this._update(symbol, i, 0, incr);\n    };\n    DenseMTFModel.prototype._update = function(symbol, index, sy_f, incr) {\n      var seenSyms = this.sym.length;\n      var i, j, tot_f;\n      // move this symbol to the end\n      for (j=index; j<seenSyms-1; j++) {\n        this.sym[j] = this.sym[j+1];\n        this.prob[j] = this.prob[j+1] - sy_f;\n      }\n      // \"method D\" -- if we add a new escaped symbol, escape & the symbol\n      // both increase by 1/2.\n      if (index < seenSyms) {\n        this.sym[j] = symbol;\n        this.prob[j] = this.prob[j+1] - sy_f;\n        // increase frequency for this symbol, and total freq at same time\n        this.prob[seenSyms] = tot_f =\n          this.prob[seenSyms] + incr;\n      } else { // add to the end\n        tot_f = this.prob[seenSyms];\n        this.sym[index] = symbol;\n        this.prob[index] = tot_f;\n        tot_f += incr;\n        this.prob[++seenSyms] = tot_f;\n        // remove probability of escape if table just filled up\n        if (this.sym.length > size) {\n          for (i=0; i<seenSyms; i++) {\n            if (size === this.sym[i]) {\n              // found it.\n              this._update(size, i, this.prob[i+1] - this.prob[i], -1);\n              this.sym.length--;\n              this.prob.length--;\n              tot_f = this.prob[this.prob.length-1];\n            }\n          }\n        }\n      }\n      if (tot_f >= DMM_MAX_PROB) { tot_f = this._rescale(); }\n      return tot_f;\n    };\n    DenseMTFModel.prototype.encode = function(symbol, exclude) {\n      // look for symbol, from most-recent to oldest\n      var i, j, sy_f, lt_f, tot_f, seenSyms = this.sym.length;\n      var ex_seen = 0, ex_lt_f = 0, ex_tot_f = 0, ex_sy_f;\n      for (i=seenSyms-1; i>=0; i--) {\n        lt_f = this.prob[i];\n        sy_f = this.prob[i + 1] - lt_f;\n        if (symbol === this.sym[i]) {\n          // ok, found it.\n          // count up the rest of the probabilities\n          for (j=i-1; j>=0 && ex_seen < exclude.total; j--) {\n            if (exclude[this.sym[j]]) {\n              ex_seen += 1;\n              ex_sy_f = this.prob[j+1] - this.prob[j];\n              ex_lt_f += ex_sy_f;\n              ex_tot_f += ex_sy_f;\n            }\n          }\n          tot_f = this.prob[seenSyms];\n          // adjust by excluded symbols\n          lt_f -= ex_lt_f;\n          tot_f -= ex_tot_f;\n          coder.encodeFreq(sy_f, lt_f, tot_f);\n          if (symbol === size) { // only update table for escapes\n            this._update(symbol, i, sy_f, DMM_INCREMENT/2);\n            return false; // escape.\n          } // otherwise we'll do update later\n          return true; // encoded character!\n        } else if (exclude[this.sym[i]]) {\n          ex_seen += 1;\n          ex_tot_f += sy_f;\n        }\n      }\n      // couldn't find this symbol.  encode as escape.\n      this.encode(size, exclude);\n      // add symbols to exclusion table\n      console.assert(this.sym[this.sym.length-1] === size);//escape\n      for (i=0; i<this.sym.length-1; i++) {\n        if (!exclude[this.sym[i]]) {\n          exclude[this.sym[i]] = true;\n          exclude.total++;\n        }\n      }\n    };\n    DenseMTFModel.prototype.decode = function(exclude) {\n      var seenSyms = this.sym.length;\n      var tot_f = this.prob[seenSyms];\n      var ex_seen = 0, ex_lt_f = 0, ex_tot_f = 0, ex_sy_f;\n      var i;\n      for (i=seenSyms-1; i>=0 && ex_seen < exclude.total; i--) {\n        if (exclude[this.sym[i]]) {\n          ex_seen += 1;\n          ex_tot_f += this.prob[i+1] - this.prob[i];\n        }\n      }\n      var prob = coder.decodeCulFreq(tot_f - ex_tot_f) + ex_tot_f;\n      // we're expecting to find the probability near the \"most recent\" side\n      // of our array\n      ex_lt_f = ex_tot_f;\n      for (i=seenSyms-1; i>=0; i--) {\n        if (exclude[this.sym[i]]) {\n          ex_sy_f = this.prob[i+1] - this.prob[i];\n          ex_lt_f -= ex_sy_f;\n          prob -= ex_sy_f;\n        } else if (this.prob[i] <= prob /*&& prob < this.prob[i+1]*/)\n          break;\n      }\n      console.assert(i>=0);\n      var symbol = this.sym[i];\n      var lt_f = this.prob[i];\n      var sy_f = this.prob[i + 1] - lt_f;\n      coder.decodeUpdate(sy_f, lt_f - ex_lt_f, tot_f - ex_tot_f);\n      // defer update\n      if (symbol < size) { return symbol; }\n      // an escape\n      this._update(symbol, i, sy_f, DMM_INCREMENT/2);\n      // add symbols to exclusion table\n      console.assert(this.sym[this.sym.length-1] === size);//escape\n      for (i=0; i<this.sym.length-1; i++) {\n        if (!exclude[this.sym[i]]) {\n          exclude[this.sym[i]] = true;\n          exclude.total++;\n        }\n      }\n      return -1;\n    };\n    this.newContext = function(initialSymbol) {\n      return new DenseMTFModel();\n    };\n    this.newExclude = function() {\n      var result = Object.create(null);\n      result.total = 0; // no excluded symbols (yet)\n      return result;\n    };\n    // set up some initial contexts\n    (function() {\n      var i, j;\n      for (i=0; i<MAX_CONTEXT; i++) {\n        for (j=0; j<=i; j++) {\n          var cc = this.window.context(j+((MAX_CONTEXT-1)-i), j);\n          if (!this.contexts[cc]) { this.contexts[cc] = this.newContext(); }\n          this.contexts[cc].refcount++;\n        }\n      }\n    }).call(this);\n  };\n  PPM.prototype.update = function(symbol, contextString, matchLevel) {\n    // slide up the contexts, updating them\n    var model, c, cc;\n    for (c=0; c <= MAX_CONTEXT; c++) {\n      cc = contextString.slice(MAX_CONTEXT - c);\n      model = this.contexts[cc];\n      if (!model) {\n        model = this.contexts[cc] = this.newContext();\n      }\n      if (c >= matchLevel) {\n        // only update useful contexts\n        model.update(symbol, DMM_INCREMENT / 2);\n      }\n      // refcount all contexts, whether used/updated or not\n      model.refcount++;\n    }\n    // now garbage-collect old contexts\n    contextString = this.window.context(this.window.pos + MAX_CONTEXT,\n                                        MAX_CONTEXT);\n    var firstPass = this.window.firstPass;\n    for (c=MAX_CONTEXT; c>=0 && !firstPass; c--) {\n      cc = contextString.slice(0, c);\n      model = this.contexts[cc];\n      console.assert(model);\n      if ((--model.refcount) <= 0) {\n        console.assert(cc !== ''); // don't allow context-0 to be gc'ed!\n        delete this.contexts[cc];\n      }\n    }\n    // ok, advance window.\n    this.window.put(symbol);\n  };\n  PPM.prototype.decode = function() {\n    var contextString = this.window.context(this.window.pos, MAX_CONTEXT);\n    var exclude = this.newExclude();\n    var model, c, cc, symbol;\n    for (c=MAX_CONTEXT; c>=0; c--) {\n      cc = contextString.slice(MAX_CONTEXT - c);\n      model = this.contexts[cc];\n      if (model) {\n        symbol = model.decode(exclude);\n        if (symbol >= 0) {\n          this.update(symbol, contextString, c);\n          return symbol;\n        }\n      }\n    }\n    // still no match, fall back to context -1\n    symbol = this.cm1coder.decode(exclude);\n    this.update(symbol, contextString, c);\n    return symbol;\n  };\n  PPM.prototype.encode = function(symbol) {\n    var contextString = this.window.context(this.window.pos, MAX_CONTEXT);\n    var exclude = this.newExclude();\n    var c;\n    for (c=MAX_CONTEXT; c>=0; c--) {\n      var cc = contextString.slice(MAX_CONTEXT - c);\n      var model = this.contexts[cc];\n      if (model) {\n        var success = model.encode(symbol, exclude);\n        if (success) {\n          this.update(symbol, contextString, c);\n          return;\n        }\n      }\n    }\n    // fall back to context -1 (but still use exclusion table)\n    this.cm1coder.encode(symbol, exclude);\n    this.update(symbol, contextString, c);\n    return;\n  };\n\n  PPM.MAGIC = 'ppm2';\n  PPM.compressFile = Util.compressFileHelper(PPM.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {\n    var range = new RangeCoder(outStream);\n    range.encodeStart(finalByte, 1);\n    var model = new PPM(range, (fileSize<0) ? 257 : 256);\n    Util.compressWithModel(inStream, fileSize, model);\n    range.encodeFinish();\n  }, true);\n  PPM.decompressFile = Util.decompressFileHelper(PPM.MAGIC, function(inStream, outStream, fileSize) {\n    var range = new RangeCoder(inStream);\n    range.decodeStart(true/*we already read the 'free' byte*/);\n    var model = new PPM(range, (fileSize<0) ? 257 : 256);\n    Util.decompressWithModel(outStream, fileSize, model);\n    range.decodeFinish();\n  });\n\n  return PPM;\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./RangeCoder\":141,\"./Util\":144}],141:[function(require,module,exports){\n/* Range Coder.  Inspired by rangecod.c from rngcod13.zip from\n *    http://www.compressconsult.com/rangecoder/\n * This JavaScript version is:\n *    Copyright (c) 2013 C. Scott Ananian.\n */\nvar libs = [\n];\nvar body_fn = function (){\n\n    // Uses 32-bit integer math.  Hopefully the JavaScript runtime figures\n    // that out. ;)\n    // see https://github.com/kripken/emscripten/wiki/LLVM-Types-in-JavaScript\n    // for some hints on doing 32-bit unsigned match in JavaScript.\n    // One key is the use of \">>>0\" to change a signed result to unsigned.\n    var CODE_BITS = 32;\n    var Top_value = Math.pow(2, CODE_BITS-1);\n    var SHIFT_BITS = (CODE_BITS - 9);\n    var EXTRA_BITS = ((CODE_BITS-2) % 8 + 1);\n    var Bottom_value = (Top_value >>> 8);\n\n    var MAX_INT = Math.pow(2, CODE_BITS) - 1;\n\n    /* it is highly recommended that the total frequency count is less  */\n    /* than 1 << 19 to minimize rounding effects.                       */\n    /* the total frequency count MUST be less than 1<<23                */\n\n\n    var RangeCoder = function(stream) {\n        this.low = 0; /* low end of interval */\n        this.range = Top_value; /* length of interval */\n        this.buffer = 0; /* buffer for input/output */\n        this.help = 0; /* bytes_to_follow / intermediate value */\n        this.bytecount = 0; /* counter for output bytes */\n        this.stream = stream;\n    };\n\n    /* Do the normalization before we need a defined state, instead of\n     * after messing it up.  This simplifies starting and ending. */\n    var enc_normalize = function(rc, outputStream) {\n        while (rc.range <= Bottom_value) { /* do we need renormalization? */\n            if (rc.low < (0xFF << SHIFT_BITS)) {//no carry possible, so output\n                outputStream.writeByte(rc.buffer);\n                for (; rc.help; rc.help--)\n                    outputStream.writeByte(0xFF);\n                rc.buffer = (rc.low >>> SHIFT_BITS) & 0xFF;\n            } else if (rc.low & Top_value) { /* carry now, no future carry */\n                outputStream.writeByte(rc.buffer+1);\n                for (; rc.help; rc.help--)\n                    outputStream.writeByte(0x00);\n                rc.buffer = (rc.low >>> SHIFT_BITS) & 0xFF;\n            } else {\n                rc.help++;\n                if (rc.help > MAX_INT)\n                    throw new Error(\"Too many bytes outstanding, \"+\n                                    \"file too large!\");\n            }\n            rc.range = (rc.range << 8) >>> 0;/*ensure result remains positive*/\n            rc.low = ((rc.low << 8) & (Top_value - 1)) >>> 0; /* unsigned */\n            rc.bytecount++;\n        }\n    };\n\n    /* Start the encoder                                         */\n    /* c is written as the first byte in the datastream.\n     * one could do w/o, but then you have an additional if per output byte */\n    RangeCoder.prototype.encodeStart = function(c, initlength) {\n        this.low = 0;\n        this.range = Top_value;\n        this.buffer = c;\n        this.help = 0;\n        this.bytecount = initlength;\n    };\n\n   /* Encode a symbol using frequencies                         */\n    /* rc is the range coder to be used                          */\n    /* sy_f is the interval length (frequency of the symbol)     */\n    /* lt_f is the lower end (frequency sum of < symbols)        */\n    /* tot_f is the total interval length (total frequency sum)  */\n    /* or (faster): tot_f = (code_value)1<<shift                             */\n    RangeCoder.prototype.encodeFreq = function(sy_f, lt_f, tot_f) {\n        enc_normalize(this, this.stream);\n        var r = (this.range / tot_f) >>> 0; // note coercion to integer\n        var tmp = r * lt_f;\n        this.low += tmp;\n        if ((lt_f + sy_f) < tot_f) {\n            this.range = r * sy_f;\n        } else {\n            this.range -= tmp;\n        }\n    };\n    RangeCoder.prototype.encodeShift = function(sy_f, lt_f, shift) {\n        enc_normalize(this, this.stream);\n        var r = this.range >>> shift;\n        var tmp = r * lt_f;\n        this.low += tmp;\n        if ((lt_f + sy_f) >>> shift) {\n            this.range -= tmp;\n        } else {\n            this.range = r * sy_f;\n        }\n    };\n    /* Encode a bit w/o modelling. */\n    RangeCoder.prototype.encodeBit = function(b) {\n        this.encodeShift(1, b?1:0, 1);\n    };\n    /* Encode a byte w/o modelling. */\n    RangeCoder.prototype.encodeByte = function(b) {\n        this.encodeShift(1, b, 8);\n    };\n    /* Encode a short w/o modelling. */\n    RangeCoder.prototype.encodeShort = function(s) {\n        this.encodeShift(1, s, 16);\n    };\n\n    /* Finish encoding                                           */\n    /* returns number of bytes written                           */\n    RangeCoder.prototype.encodeFinish = function() {\n        var outputStream = this.stream;\n        enc_normalize(this, outputStream);\n        this.bytecount += 5;\n        var tmp = this.low >>> SHIFT_BITS;\n        if ((this.low & (Bottom_value-1)) >= ((this.bytecount&0xFFFFFF)>>>1)) {\n            tmp++;\n        }\n        if (tmp > 0xFF) { /* we have a carry */\n            outputStream.writeByte(this.buffer + 1);\n            for (; this.help; this.help--)\n                outputStream.writeByte(0x00);\n        } else { /* no carry */\n            outputStream.writeByte(this.buffer);\n            for (; this.help; this.help--)\n                outputStream.writeByte(0xFF);\n        }\n        outputStream.writeByte(tmp & 0xFF);\n        // XXX: i'm pretty sure these could be three arbitrary bytes\n        //      they are consumed by the decoder at the end\n        outputStream.writeByte((this.bytecount >>> 16) & 0xFF);\n        outputStream.writeByte((this.bytecount >>>  8) & 0xFF);\n        outputStream.writeByte((this.bytecount       ) & 0xFF);\n        return this.bytecount;\n    };\n\n    /* Start the decoder; you need to provide the *second* byte from the\n     * datastream. (The first byte was provided to startEncoding and is\n     * ignored by the decoder.)\n     */\n    RangeCoder.prototype.decodeStart = function(skipInitialRead) {\n        var c = skipInitialRead ? 0 : this.stream.readByte();\n        if (typeof(c) !== 'number' || c < 0) {\n            return c; // EOF\n        }\n        this.buffer = this.stream.readByte();\n        this.low = this.buffer >>> (8 - EXTRA_BITS);\n        this.range = 1 << EXTRA_BITS;\n        return c;\n    };\n\n    var dec_normalize = function(rc, inputStream) {\n        while (rc.range <= Bottom_value) {\n            rc.low = (rc.low << 8) | ((rc.buffer << EXTRA_BITS) & 0xFF);\n            /* rc.low could be negative here; don't fix it quite yet */\n            rc.buffer = inputStream.readByte();\n            rc.low |= rc.buffer >>> (8-EXTRA_BITS);\n            rc.low = rc.low >>> 0; /* fix it now */\n            rc.range = (rc.range << 8) >>> 0; /* ensure stays positive */\n        }\n    };\n\n    /* Calculate cumulative frequency for next symbol. Does NO update!*/\n    /* rc is the range coder to be used                          */\n    /* tot_f is the total frequency                              */\n    /* or: totf is (code_value)1<<shift                                      */\n    /* returns the <= cumulative frequency                         */\n    RangeCoder.prototype.decodeCulFreq = function(tot_f) {\n        dec_normalize(this, this.stream);\n        this.help = (this.range / tot_f) >>> 0; // note coercion to integer\n        var tmp = (this.low / this.help) >>> 0; // again\n        return (tmp >= tot_f ? tot_f-1 : tmp);\n    };\n    RangeCoder.prototype.decodeCulShift = function(shift) {\n        dec_normalize(this, this.stream);\n        this.help = this.range >>> shift;\n        var tmp = (this.low / this.help) >>> 0; // coercion to unsigned\n        // shift is less than 31, so shift below will remain positive\n        return ((tmp>>>shift) ? (1<<shift)-1 : tmp);\n    };\n\n    /* Update decoding state                                     */\n    /* rc is the range coder to be used                          */\n    /* sy_f is the interval length (frequency of the symbol)     */\n    /* lt_f is the lower end (frequency sum of < symbols)        */\n    /* tot_f is the total interval length (total frequency sum)  */\n    RangeCoder.prototype.decodeUpdate = function(sy_f, lt_f, tot_f) {\n        var tmp = this.help * lt_f; // should not overflow!\n        this.low -= tmp;\n        if (lt_f + sy_f < tot_f) {\n            this.range = (this.help * sy_f);\n        } else {\n            this.range -= tmp;\n        }\n    };\n\n    /* Decode a bit w/o modelling. */\n    RangeCoder.prototype.decodeBit = function() {\n        var tmp = this.decodeCulShift(1);\n        this.decodeUpdate(1, tmp, 1<<1);\n        return tmp;\n    };\n    /* decode a byte w/o modelling */\n    RangeCoder.prototype.decodeByte = function() {\n        var tmp = this.decodeCulShift(8);\n        this.decodeUpdate(1, tmp, 1<<8);\n        return tmp;\n    };\n    /* decode a short w/o modelling */\n    RangeCoder.prototype.decodeShort = function() {\n        var tmp = this.decodeCulShift(16);\n        this.decodeUpdate(1, tmp, 1<<16);\n        return tmp;\n    };\n\n    /* Finish decoding */\n    RangeCoder.prototype.decodeFinish = function() {\n        /* normalize to use up all bytes */\n        dec_normalize(this, this.stream);\n    };\n\n    /** Utility functions */\n\n    // bitstream interface\n    RangeCoder.prototype.writeBit = RangeCoder.prototype.encodeBit;\n    RangeCoder.prototype.readBit = RangeCoder.prototype.decodeBit;\n\n    // stream interface\n    RangeCoder.prototype.writeByte = RangeCoder.prototype.encodeByte;\n    RangeCoder.prototype.readByte = RangeCoder.prototype.decodeByte;\n\n    return RangeCoder;\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{}],142:[function(require,module,exports){\n/* *Very* simple de/compression utility, based on simple_c and simple_d from\n * rngcod13.zip at http://www.compressconsult.com/rangecoder/\n * Really just a demonstration/test of the rangecoder.\n */\nvar libs = [\n  require('./RangeCoder'),\n  require('./Stream'),\n  require('./Util')\n];\nvar body_fn = function (RangeCoder,Stream,Util){\n    var MAX_BLOCK_SIZE = 1<<17;\n\n    var Simple = Object.create(null);\n    Simple.MAGIC = 'smpl';\n    Simple.compressFile = Util.compressFileHelper(Simple.MAGIC, function(input, output, size, props, finalByte) {\n        var encoder = new RangeCoder(output);\n        encoder.encodeStart(finalByte, 1);\n\n        // read a block\n        var block = Util.makeU8Buffer(MAX_BLOCK_SIZE);\n        var counts = [];\n        var blockLength = 0, sawEOF = false;\n\n        var readBlock = function() {\n            var pos = 0;\n            // initialize counts\n            for (pos=0; pos < 256; pos++) {\n                counts[pos] = 0;\n            }\n            if (sawEOF) {\n                blockLength = 0;\n                return;\n            }\n            for (pos=0; pos < MAX_BLOCK_SIZE; ) {\n                var c = input.readByte();\n                if (c===Stream.EOF) {\n                    sawEOF = true;\n                    break;\n                }\n                block[pos++] = c;\n                counts[c]++;\n                // bail if some count reaches maximum\n                if (counts[c]===0xFFFF) {\n                    break;\n                }\n            }\n            blockLength = pos;\n        };\n\n        while (true) {\n            var i;\n            readBlock();\n            if (sawEOF && blockLength===0) {\n                break;\n            }\n            // indicate that there's another block comin'\n            encoder.encodeBit(true);\n            // write all the statistics\n            for (i=0; i<256; i++) {\n                encoder.encodeShort(counts[i]);\n            }\n            // convert counts to cumulative counts\n            counts[256] = blockLength;\n            for (i=256; i; i--) {\n                counts[i-1] = counts[i] - counts[i-1];\n            }\n            // encode the symbols using the probability table.\n            for (i=0; i<blockLength; i++) {\n                var ch = block[i];\n                encoder.encodeFreq(counts[ch+1]-counts[ch], counts[ch],\n                                   counts[256]);\n            }\n        }\n        // write a stop bit\n        encoder.encodeBit(false);\n        // done!\n        encoder.encodeFinish();\n    }, true);\n    Simple.decompressFile = Util.decompressFileHelper(Simple.MAGIC, function(input, output, size) {\n        var decoder = new RangeCoder(input);\n        decoder.decodeStart(true/*we already read the 'free' byte*/);\n        while (decoder.decodeBit()) {\n            var i, counts = [];\n            // read all the statistics\n            for (i=0; i<256; i++) {\n                counts[i] = decoder.decodeShort();\n            }\n            // compute cumulative stats & total block size\n            var blocksize = 0;\n            for (i=0; i<256; i++) {\n                var tmp = counts[i];\n                counts[i] = blocksize;\n                blocksize += tmp;\n            }\n            counts[256] = blocksize;\n\n            for (i=0; i<blocksize; i++) {\n                var cf = decoder.decodeCulFreq(blocksize);\n                // inefficient way to look up the symbol.\n                var symbol;\n                for (symbol=0; symbol<256; symbol++)\n                    // careful, there are length-0 ranges\n                    // (where counts[symbol]===counts[symbol+1])\n                    if (counts[symbol]<=cf && cf < counts[symbol+1])\n                        break;\n                var ch = symbol;\n                decoder.decodeUpdate(counts[symbol+1] - counts[symbol],\n                                     counts[symbol], blocksize);\n                output.writeByte(symbol);\n            }\n        }\n        decoder.decodeFinish();\n    });\n    return Simple;\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./RangeCoder\":141,\"./Stream\":143,\"./Util\":144}],143:[function(require,module,exports){\n/** Abstract Stream interface, for byte-oriented i/o. */\nvar libs = [\n  require('./freeze')\n];\nvar body_fn = function (freeze) {\n    var EOF = -1;\n\n    var Stream = function() {\n        /* ABSTRACT */\n    };\n    // you must define one of read / readByte for a readable stream\n    Stream.prototype.readByte = function() {\n        var buf = [ 0 ];\n        var len = this.read(buf, 0, 1);\n        if (len===0) { this._eof = true; return EOF; }\n        return buf[0];\n    };\n    Stream.prototype.read = function(buf, bufOffset, length) {\n        var ch, bytesRead = 0;\n        while (bytesRead < length) {\n            ch = this.readByte();\n            if (ch === EOF) { this._eof = true; break; }\n            buf[bufOffset+(bytesRead++)] = ch;\n        }\n        return bytesRead;\n    };\n    // reasonable default implementation of 'eof'\n    Stream.prototype.eof = function() { return !!this._eof; };\n    // not all readable streams are seekable\n    Stream.prototype.seek = function(pos) {\n        throw new Error('Stream is not seekable.');\n    };\n    Stream.prototype.tell = function() {\n        throw new Error('Stream is not seekable.');\n    };\n    // you must define one of write / writeByte for a writable stream\n    Stream.prototype.writeByte = function(_byte) {\n        var buf = [ _byte ];\n        this.write(buf, 0, 1);\n    };\n    Stream.prototype.write = function(buf, bufOffset, length) {\n        var i;\n        for (i=0; i<length; i++) {\n            this.writeByte(buf[bufOffset + i]);\n        }\n        return length;\n    };\n    // flush will happily do nothing if you don't override it.\n    Stream.prototype.flush = function() { };\n\n    // export EOF as a constant.\n    Stream.EOF = EOF;\n\n    return freeze(Stream);\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{\"./freeze\":145}],144:[function(require,module,exports){\n(function (process,Buffer){\n/* Some basic utilities, used in a number of places. */\nvar libs = [\n  require('./freeze'),\n  require('./Stream')\n];\nvar body_fn = function (freeze, Stream) {\n    var Util = Object.create(null);\n\n    var EOF = Stream.EOF;\n\n    /* Take a buffer, array, or stream, and return an input stream. */\n    Util.coerceInputStream = function(input, forceRead) {\n        if (!('readByte' in input)) {\n            var buffer = input;\n            input = new Stream();\n            input.size = buffer.length;\n            input.pos = 0;\n            input.readByte = function() {\n                if (this.pos >= this.size) { return EOF; }\n                return buffer[this.pos++];\n            };\n            input.read = function(buf, bufOffset, length) {\n                var bytesRead = 0;\n                while (bytesRead < length && this.pos < buffer.length) {\n                    buf[bufOffset++] = buffer[this.pos++];\n                    bytesRead++;\n                }\n                return bytesRead;\n            };\n            input.seek = function(pos) { this.pos = pos; };\n            input.tell = function() { return this.pos; };\n            input.eof = function() { return this.pos >= buffer.length; };\n        } else if (forceRead && !('read' in input)) {\n            // wrap input if it doesn't implement read\n            var s = input;\n            input = new Stream();\n            input.readByte = function() {\n                var ch = s.readByte();\n                if (ch === EOF) { this._eof = true; }\n                return ch;\n            };\n            if ('size' in s) { input.size = s.size; }\n            if ('seek' in s) {\n                input.seek = function(pos) {\n                    s.seek(pos); // may throw if s doesn't implement seek\n                    this._eof = false;\n                };\n            }\n            if ('tell' in s) {\n                input.tell = s.tell.bind(s);\n            }\n        }\n        return input;\n    };\n\n    var BufferStream = function(buffer, resizeOk) {\n        this.buffer = buffer;\n        this.resizeOk = resizeOk;\n        this.pos = 0;\n    };\n    BufferStream.prototype = Object.create(Stream.prototype);\n    BufferStream.prototype.writeByte = function(_byte) {\n        if (this.resizeOk && this.pos >= this.buffer.length) {\n            var newBuffer = Util.makeU8Buffer(this.buffer.length * 2);\n            newBuffer.set(this.buffer);\n            this.buffer = newBuffer;\n        }\n        this.buffer[this.pos++] = _byte;\n    };\n    BufferStream.prototype.getBuffer = function() {\n        // trim buffer if needed\n        if (this.pos !== this.buffer.length) {\n            if (!this.resizeOk)\n                throw new TypeError('outputsize does not match decoded input');\n            var newBuffer = Util.makeU8Buffer(this.pos);\n            newBuffer.set(this.buffer.subarray(0, this.pos));\n            this.buffer = newBuffer;\n        }\n        return this.buffer;\n    };\n\n    /* Take a stream (or not) and an (optional) size, and return an\n     * output stream.  Return an object with a 'retval' field equal to\n     * the output stream (if that was given) or else a pointer at the\n     * internal Uint8Array/buffer/array; and a 'stream' field equal to\n     * an output stream to use.\n     */\n    Util.coerceOutputStream = function(output, size) {\n        var r = { stream: output, retval: output };\n        if (output) {\n            if (typeof(output)==='object' && 'writeByte' in output) {\n                return r; /* leave output alone */\n            } else if (typeof(size) === 'number') {\n                console.assert(size >= 0);\n                r.stream = new BufferStream(Util.makeU8Buffer(size), false);\n            } else { // output is a buffer\n                r.stream = new BufferStream(output, false);\n            }\n        } else {\n            r.stream = new BufferStream(Util.makeU8Buffer(16384), true);\n        }\n        Object.defineProperty(r, 'retval', {\n            get: r.stream.getBuffer.bind(r.stream)\n        });\n        return r;\n    };\n\n    Util.compressFileHelper = function(magic, guts, suppressFinalByte) {\n        return function(inStream, outStream, props) {\n            inStream = Util.coerceInputStream(inStream);\n            var o = Util.coerceOutputStream(outStream, outStream);\n            outStream = o.stream;\n\n            // write the magic number to identify this file type\n            // (it better be ASCII, we're not doing utf-8 conversion)\n            var i;\n            for (i=0; i<magic.length; i++) {\n                outStream.writeByte(magic.charCodeAt(i));\n            }\n\n            // if we know the size, write it\n            var fileSize;\n            if ('size' in inStream && inStream.size >= 0) {\n                fileSize = inStream.size;\n            } else {\n                fileSize = -1; // size unknown\n            }\n            if (suppressFinalByte) {\n                var tmpOutput = Util.coerceOutputStream([]);\n                Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);\n                tmpOutput = tmpOutput.retval;\n                for (i=0; i<tmpOutput.length-1; i++) {\n                    outStream.writeByte(tmpOutput[i]);\n                }\n                suppressFinalByte = tmpOutput[tmpOutput.length-1];\n            } else {\n                Util.writeUnsignedNumber(outStream, fileSize + 1);\n            }\n\n            // call the guts to do the real compression\n            guts(inStream, outStream, fileSize, props, suppressFinalByte);\n\n            return o.retval;\n        };\n    };\n    Util.decompressFileHelper = function(magic, guts) {\n        return function(inStream, outStream) {\n            inStream = Util.coerceInputStream(inStream);\n\n            // read the magic number to confirm this file type\n            // (it better be ASCII, we're not doing utf-8 conversion)\n            var i;\n            for (i=0; i<magic.length; i++) {\n                if (magic.charCodeAt(i) !== inStream.readByte()) {\n                    throw new Error(\"Bad magic\");\n                }\n            }\n\n            // read the file size & create an appropriate output stream/buffer\n            var fileSize = Util.readUnsignedNumber(inStream) - 1;\n            var o = Util.coerceOutputStream(outStream, fileSize);\n            outStream = o.stream;\n\n            // call the guts to do the real decompression\n            guts(inStream, outStream, fileSize);\n\n            return o.retval;\n        };\n    };\n    // a helper for simple self-test of model encode\n    Util.compressWithModel = function(inStream, fileSize, model) {\n        var inSize = 0;\n        while (inSize !== fileSize) {\n            var ch = inStream.readByte();\n            if (ch === EOF) {\n                model.encode(256); // end of stream;\n                break;\n            }\n            model.encode(ch);\n            inSize++;\n        }\n    };\n    // a helper for simple self-test of model decode\n    Util.decompressWithModel = function(outStream, fileSize, model) {\n        var outSize = 0;\n        while (outSize !== fileSize) {\n            var ch = model.decode();\n            if (ch === 256) {\n                break; // end of stream;\n            }\n            outStream.writeByte(ch);\n            outSize++;\n        }\n    };\n\n    /** Write a number using a self-delimiting big-endian encoding. */\n    Util.writeUnsignedNumber = function(output, n) {\n        console.assert(n >= 0);\n        var bytes = [], i;\n        do {\n            bytes.push(n & 0x7F);\n            // use division instead of shift to allow encoding numbers up to\n            // 2^53\n            n = Math.floor( n / 128 );\n        } while (n !== 0);\n        bytes[0] |= 0x80; // mark end of encoding.\n        for (i=bytes.length-1; i>=0; i--) {\n            output.writeByte(bytes[i]); // write in big-endian order\n        }\n        return output;\n    };\n\n    /** Read a number using a self-delimiting big-endian encoding. */\n    Util.readUnsignedNumber = function(input) {\n        var n = 0, c;\n        while (true) {\n            c = input.readByte();\n            if (c&0x80) { n += (c&0x7F); break; }\n            // using + and * instead of << allows decoding numbers up to 2^53\n            n = (n + c) * 128;\n        }\n        return n;\n    };\n\n    // Compatibility thunks for Buffer/TypedArray constructors.\n\n    var zerofill = function(a) {\n        for (var i = 0, len = a.length; i < len; i++) {\n            a[i] = 0;\n        }\n        return a;\n    };\n\n    var fallbackarray = function(size) {\n        return zerofill(new Array(size));\n    };\n\n    // Node 0.11.6 - 0.11.10ish don't properly zero fill typed arrays.\n    // See https://github.com/joyent/node/issues/6664\n    // Try to detect and workaround the bug.\n    var ensureZeroed = function id(a) { return a; };\n    if ((typeof(process) !== 'undefined') &&\n        Array.prototype.some.call(new Uint32Array(128), function(x) {\n            return x !== 0;\n        })) {\n        //console.warn('Working around broken TypedArray');\n        ensureZeroed = zerofill;\n    }\n\n    /** Portable 8-bit unsigned buffer. */\n    Util.makeU8Buffer = (typeof(Uint8Array) !== 'undefined') ? function(size) {\n        // Uint8Array ought to be  automatically zero-filled\n        return ensureZeroed(new Uint8Array(size));\n    } : (typeof(Buffer) !== 'undefined') ? function(size) {\n        var b = new Buffer(size);\n        b.fill(0);\n        return b;\n    } : fallbackarray;\n\n    /** Portable 16-bit unsigned buffer. */\n    Util.makeU16Buffer = (typeof(Uint16Array) !== 'undefined') ? function(size) {\n        // Uint16Array ought to be  automatically zero-filled\n        return ensureZeroed(new Uint16Array(size));\n    } : fallbackarray;\n\n    /** Portable 32-bit unsigned buffer. */\n    Util.makeU32Buffer = (typeof(Uint32Array) !== 'undefined') ? function(size) {\n        // Uint32Array ought to be  automatically zero-filled\n        return ensureZeroed(new Uint32Array(size));\n    } : fallbackarray;\n\n    /** Portable 32-bit signed buffer. */\n    Util.makeS32Buffer = (typeof(Int32Array) !== 'undefined') ? function(size) {\n        // Int32Array ought to be  automatically zero-filled\n        return ensureZeroed(new Int32Array(size));\n    } : fallbackarray;\n\n    Util.arraycopy = function(dst, src) {\n        console.assert(dst.length >= src.length);\n        for (var i = 0, len = src.length; i < len ; i++) {\n            dst[i] = src[i];\n        }\n        return dst;\n    };\n\n    /** Highest bit set in a byte. */\n    var bytemsb = [\n        0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,\n        5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7,\n        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n        7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 /* 256 */\n    ];\n    console.assert(bytemsb.length===0x100);\n    /** Find last set (most significant bit).\n     *  @return the last bit set in the argument.\n     *          <code>fls(0)==0</code> and <code>fls(1)==1</code>. */\n    var fls = Util.fls = function(v) {\n        console.assert(v>=0);\n        if (v > 0xFFFFFFFF) { // use floating-point mojo\n            return 32 + fls(Math.floor(v / 0x100000000));\n        }\n        if ( (v & 0xFFFF0000) !== 0) {\n            if ( (v & 0xFF000000) !== 0) {\n                return 24 + bytemsb[(v>>>24) & 0xFF];\n            } else {\n                return 16 + bytemsb[v>>>16];\n            }\n        } else if ( (v & 0x0000FF00) !== 0) {\n            return 8 + bytemsb[v>>>8];\n        } else {\n            return bytemsb[v];\n        }\n    };\n    /** Returns ceil(log2(n)) */\n    Util.log2c = function(v) {\n        return (v===0)?-1:fls(v-1);\n    };\n\n    return freeze(Util); // ensure constants are recognized as such.\n};\nmodule.exports = body_fn.apply(null, libs);\n\n}).call(this,require('_process'),require(\"buffer\").Buffer)\n},{\"./Stream\":143,\"./freeze\":145,\"_process\":99,\"buffer\":80}],145:[function(require,module,exports){\n\nvar libs = [\n];\nvar body_fn = function (){\n  'use strict';\n\n  // Object.freeze(), or a thunk if that method is not present in this\n  // JavaScript environment.\n\n  if (Object.freeze) {\n    return Object.freeze;\n  } else {\n    return function(o) { return o; };\n  }\n\n};\nmodule.exports = body_fn.apply(null, libs);\n\n},{}],146:[function(require,module,exports){\nvar assert = require('assert')\nvar BigInteger = require('bn').BigInteger\n\nvar Point = require('./point')\n\nfunction Curve(p, a, b, Gx, Gy, n, h) {\n  this.p = p\n  this.a = a\n  this.b = b\n  this.G = Point.fromAffine(this, Gx, Gy)\n  this.n = n\n  this.h = h\n\n  this.infinity = new Point(this, null, null, BigInteger.ZERO)\n\n  // result caching\n  this.pOverFour = p.add(BigInteger.ONE).shiftRight(2)\n}\n\nCurve.prototype.pointFromX = function(isOdd, x) {\n  var alpha = x.pow(3).add(this.a.multiply(x)).add(this.b).mod(this.p)\n  var beta = alpha.modPow(this.pOverFour, this.p)\n\n  var y = beta\n  if (beta.isEven() ^ !isOdd) {\n    y = this.p.subtract(y) // -y % p\n  }\n\n  return Point.fromAffine(this, x, y)\n}\n\nCurve.prototype.isInfinity = function(Q) {\n  if (Q === this.infinity) return true\n\n  return Q.z.signum() === 0 && Q.y.signum() !== 0\n}\n\nCurve.prototype.isOnCurve = function(Q) {\n  if (this.isInfinity(Q)) return true\n\n  var x = Q.affineX\n  var y = Q.affineY\n  var a = this.a\n  var b = this.b\n  var p = this.p\n\n  // Check that xQ and yQ are integers in the interval [0, p - 1]\n  if (x.signum() < 0 || x.compareTo(p) >= 0) return false\n  if (y.signum() < 0 || y.compareTo(p) >= 0) return false\n\n  // and check that y^2 = x^3 + ax + b (mod p)\n  var lhs = y.square().mod(p)\n  var rhs = x.pow(3).add(a.multiply(x)).add(b).mod(p)\n  return lhs.equals(rhs)\n}\n\n/**\n * Validate an elliptic curve point.\n *\n * See SEC 1, section 3.2.2.1: Elliptic Curve Public Key Validation Primitive\n */\nCurve.prototype.validate = function(Q) {\n  // Check Q != O\n  assert(!this.isInfinity(Q), 'Point is at infinity')\n  assert(this.isOnCurve(Q), 'Point is not on the curve')\n\n  // Check nQ = O (where Q is a scalar multiple of G)\n  var nQ = Q.multiply(this.n)\n  assert(this.isInfinity(nQ), 'Point is not a scalar multiple of G')\n\n  return true\n}\n\nmodule.exports = Curve\n\n},{\"./point\":150,\"assert\":75,\"bn\":71}],147:[function(require,module,exports){\nmodule.exports={\n  \"secp128r1\": {\n    \"p\": \"fffffffdffffffffffffffffffffffff\",\n    \"a\": \"fffffffdfffffffffffffffffffffffc\",\n    \"b\": \"e87579c11079f43dd824993c2cee5ed3\",\n    \"n\": \"fffffffe0000000075a30d1b9038a115\",\n    \"h\": \"01\",\n    \"Gx\": \"161ff7528b899b2d0c28607ca52c5b86\",\n    \"Gy\": \"cf5ac8395bafeb13c02da292dded7a83\"\n  },\n  \"secp160k1\": {\n    \"p\": \"fffffffffffffffffffffffffffffffeffffac73\",\n    \"a\": \"00\",\n    \"b\": \"07\",\n    \"n\": \"0100000000000000000001b8fa16dfab9aca16b6b3\",\n    \"h\": \"01\",\n    \"Gx\": \"3b4c382ce37aa192a4019e763036f4f5dd4d7ebb\",\n    \"Gy\": \"938cf935318fdced6bc28286531733c3f03c4fee\"\n  },\n  \"secp160r1\": {\n    \"p\": \"ffffffffffffffffffffffffffffffff7fffffff\",\n    \"a\": \"ffffffffffffffffffffffffffffffff7ffffffc\",\n    \"b\": \"1c97befc54bd7a8b65acf89f81d4d4adc565fa45\",\n    \"n\": \"0100000000000000000001f4c8f927aed3ca752257\",\n    \"h\": \"01\",\n    \"Gx\": \"4a96b5688ef573284664698968c38bb913cbfc82\",\n    \"Gy\": \"23a628553168947d59dcc912042351377ac5fb32\"\n  },\n  \"secp192k1\": {\n    \"p\": \"fffffffffffffffffffffffffffffffffffffffeffffee37\",\n    \"a\": \"00\",\n    \"b\": \"03\",\n    \"n\": \"fffffffffffffffffffffffe26f2fc170f69466a74defd8d\",\n    \"h\": \"01\",\n    \"Gx\": \"db4ff10ec057e9ae26b07d0280b7f4341da5d1b1eae06c7d\",\n    \"Gy\": \"9b2f2f6d9c5628a7844163d015be86344082aa88d95e2f9d\"\n  },\n  \"secp192r1\": {\n    \"p\": \"fffffffffffffffffffffffffffffffeffffffffffffffff\",\n    \"a\": \"fffffffffffffffffffffffffffffffefffffffffffffffc\",\n    \"b\": \"64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1\",\n    \"n\": \"ffffffffffffffffffffffff99def836146bc9b1b4d22831\",\n    \"h\": \"01\",\n    \"Gx\": \"188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\",\n    \"Gy\": \"07192b95ffc8da78631011ed6b24cdd573f977a11e794811\"\n  },\n  \"secp256k1\": {\n    \"p\": \"fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\",\n    \"a\": \"00\",\n    \"b\": \"07\",\n    \"n\": \"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\",\n    \"h\": \"01\",\n    \"Gx\": \"79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\",\n    \"Gy\": \"483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\"\n  },\n  \"secp256r1\": {\n    \"p\": \"ffffffff00000001000000000000000000000000ffffffffffffffffffffffff\",\n    \"a\": \"ffffffff00000001000000000000000000000000fffffffffffffffffffffffc\",\n    \"b\": \"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\",\n    \"n\": \"ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551\",\n    \"h\": \"01\",\n    \"Gx\": \"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\",\n    \"Gy\": \"4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\"\n  }\n}\n\n},{}],148:[function(require,module,exports){\nvar Point = require('./point')\nvar Curve = require('./curve')\n\nvar getCurveByName = require('./names')\n\nmodule.exports = {\n  Curve: Curve,\n  Point: Point,\n  getCurveByName: getCurveByName\n}\n\n},{\"./curve\":146,\"./names\":149,\"./point\":150}],149:[function(require,module,exports){\nvar BigInteger = require('bn').BigInteger\n\nvar curves = require('./curves')\nvar Curve = require('./curve')\n\nfunction getCurveByName(name) {\n  var curve = curves[name]\n  if (!curve) return null\n\n  var p = new BigInteger(curve.p, 16)\n  var a = new BigInteger(curve.a, 16)\n  var b = new BigInteger(curve.b, 16)\n  var n = new BigInteger(curve.n, 16)\n  var h = new BigInteger(curve.h, 16)\n  var Gx = new BigInteger(curve.Gx, 16)\n  var Gy = new BigInteger(curve.Gy, 16)\n\n  return new Curve(p, a, b, Gx, Gy, n, h)\n}\n\nmodule.exports = getCurveByName\n\n},{\"./curve\":146,\"./curves\":147,\"bn\":71}],150:[function(require,module,exports){\n(function (Buffer){\nvar assert = require('assert')\nvar BigInteger = require('bn').BigInteger\n\nvar THREE = BigInteger.valueOf(3)\n\nfunction Point(curve, x, y, z) {\n  assert.notStrictEqual(z, undefined, 'Missing Z coordinate')\n\n  this.curve = curve\n  this.x = x\n  this.y = y\n  this.z = z\n  this._zInv = null\n\n  this.compressed = true\n}\n\nObject.defineProperty(Point.prototype, 'zInv', {\n  get: function() {\n    if (this._zInv === null) {\n      this._zInv = this.z.modInverse(this.curve.p)\n    }\n\n    return this._zInv\n  }\n})\n\nObject.defineProperty(Point.prototype, 'affineX', {\n  get: function() {\n    return this.x.multiply(this.zInv).mod(this.curve.p)\n  }\n})\n\nObject.defineProperty(Point.prototype, 'affineY', {\n  get: function() {\n    return this.y.multiply(this.zInv).mod(this.curve.p)\n  }\n})\n\nPoint.fromAffine = function(curve, x, y) {\n  return new Point(curve, x, y, BigInteger.ONE)\n}\n\nPoint.prototype.equals = function(other) {\n  if (other === this) return true\n  if (this.curve.isInfinity(this)) return this.curve.isInfinity(other)\n  if (this.curve.isInfinity(other)) return this.curve.isInfinity(this)\n\n  // u = Y2 * Z1 - Y1 * Z2\n  var u = other.y.multiply(this.z).subtract(this.y.multiply(other.z)).mod(this.curve.p)\n\n  if (u.signum() !== 0) return false\n\n  // v = X2 * Z1 - X1 * Z2\n  var v = other.x.multiply(this.z).subtract(this.x.multiply(other.z)).mod(this.curve.p)\n\n  return v.signum() === 0\n}\n\nPoint.prototype.negate = function() {\n  var y = this.curve.p.subtract(this.y)\n\n  return new Point(this.curve, this.x, y, this.z)\n}\n\nPoint.prototype.add = function(b) {\n  if (this.curve.isInfinity(this)) return b\n  if (this.curve.isInfinity(b)) return this\n\n  var x1 = this.x\n  var y1 = this.y\n  var x2 = b.x\n  var y2 = b.y\n\n  // u = Y2 * Z1 - Y1 * Z2\n  var u = y2.multiply(this.z).subtract(y1.multiply(b.z)).mod(this.curve.p)\n  // v = X2 * Z1 - X1 * Z2\n  var v = x2.multiply(this.z).subtract(x1.multiply(b.z)).mod(this.curve.p)\n\n  if (v.signum() === 0) {\n    if (u.signum() === 0) {\n      return this.twice() // this == b, so double\n    }\n\n    return this.curve.infinity // this = -b, so infinity\n  }\n\n  var v2 = v.square()\n  var v3 = v2.multiply(v)\n  var x1v2 = x1.multiply(v2)\n  var zu2 = u.square().multiply(this.z)\n\n  // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)\n  var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.p)\n  // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3\n  var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.p)\n  // z3 = v^3 * z1 * z2\n  var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.p)\n\n  return new Point(this.curve, x3, y3, z3)\n}\n\nPoint.prototype.twice = function() {\n  if (this.curve.isInfinity(this)) return this\n  if (this.y.signum() === 0) return this.curve.infinity\n\n  var x1 = this.x\n  var y1 = this.y\n\n  var y1z1 = y1.multiply(this.z)\n  var y1sqz1 = y1z1.multiply(y1).mod(this.curve.p)\n  var a = this.curve.a\n\n  // w = 3 * x1^2 + a * z1^2\n  var w = x1.square().multiply(THREE)\n\n  if (a.signum() !== 0) {\n    w = w.add(this.z.square().multiply(a))\n  }\n\n  w = w.mod(this.curve.p)\n  // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)\n  var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.p)\n  // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3\n  var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.pow(3)).mod(this.curve.p)\n  // z3 = 8 * (y1 * z1)^3\n  var z3 = y1z1.pow(3).shiftLeft(3).mod(this.curve.p)\n\n  return new Point(this.curve, x3, y3, z3)\n}\n\n// Simple NAF (Non-Adjacent Form) multiplication algorithm\n// TODO: modularize the multiplication algorithm\nPoint.prototype.multiply = function(k) {\n  if (this.curve.isInfinity(this)) return this\n  if (k.signum() === 0) return this.curve.infinity\n\n  var e = k\n  var h = e.multiply(THREE)\n\n  var neg = this.negate()\n  var R = this\n\n  for (var i = h.bitLength() - 2; i > 0; --i) {\n    R = R.twice()\n\n    var hBit = h.testBit(i)\n    var eBit = e.testBit(i)\n\n    if (hBit != eBit) {\n      R = R.add(hBit ? this : neg)\n    }\n  }\n\n  return R\n}\n\n// Compute this*j + x*k (simultaneous multiplication)\nPoint.prototype.multiplyTwo = function(j, x, k) {\n  var i\n\n  if (j.bitLength() > k.bitLength())\n    i = j.bitLength() - 1\n  else\n    i = k.bitLength() - 1\n\n  var R = this.curve.infinity\n  var both = this.add(x)\n\n  while (i >= 0) {\n    R = R.twice()\n\n    var jBit = j.testBit(i)\n    var kBit = k.testBit(i)\n\n    if (jBit) {\n      if (kBit) {\n        R = R.add(both)\n\n      } else {\n        R = R.add(this)\n      }\n\n    } else {\n      if (kBit) {\n        R = R.add(x)\n      }\n    }\n    --i\n  }\n\n  return R\n}\n\nPoint.prototype.getEncoded = function(compressed) {\n  if (compressed == undefined) compressed = this.compressed\n  if (this.curve.isInfinity(this)) return new Buffer('00', 'hex') // Infinity point encoded is simply '00'\n\n  var x = this.affineX\n  var y = this.affineY\n\n  var buffer\n\n  // Determine size of q in bytes\n  var byteLength = Math.floor((this.curve.p.bitLength() + 7) / 8)\n\n  // 0x02/0x03 | X\n  if (compressed) {\n    buffer = new Buffer(1 + byteLength)\n    buffer.writeUInt8(y.isEven() ? 0x02 : 0x03, 0)\n\n  // 0x04 | X | Y\n  } else {\n    buffer = new Buffer(1 + byteLength + byteLength)\n    buffer.writeUInt8(0x04, 0)\n\n    y.toBuffer(byteLength).copy(buffer, 1 + byteLength)\n  }\n\n  x.toBuffer(byteLength).copy(buffer, 1)\n\n  return buffer\n}\n\nPoint.decodeFrom = function(curve, buffer) {\n  var type = buffer.readUInt8(0)\n  var compressed = (type !== 4)\n\n  var x = BigInteger.fromBuffer(buffer.slice(1, 33))\n  var byteLength = Math.floor((curve.p.bitLength() + 7) / 8)\n\n  var Q\n  if (compressed) {\n    assert.equal(buffer.length, byteLength + 1, 'Invalid sequence length')\n    assert(type === 0x02 || type === 0x03, 'Invalid sequence tag')\n\n    var isOdd = (type === 0x03)\n    Q = curve.pointFromX(isOdd, x)\n\n  } else {\n    assert.equal(buffer.length, 1 + byteLength + byteLength, 'Invalid sequence length')\n\n    var y = BigInteger.fromBuffer(buffer.slice(1 + byteLength))\n    Q = Point.fromAffine(curve, x, y)\n  }\n\n  Q.compressed = compressed\n  return Q\n}\n\nPoint.prototype.toString = function () {\n  if (this.curve.isInfinity(this)) return '(INFINITY)'\n\n  return '(' + this.affineX.toString() + ',' + this.affineY.toString() + ')'\n}\n\nmodule.exports = Point\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"assert\":75,\"bn\":71,\"buffer\":80}],151:[function(require,module,exports){\n'use strict';\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof(source) !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (source.hasOwnProperty(p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs+len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for(var i=0; i<len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function(chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i=0, l=chunks.length; i<l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i=0, l=chunks.length; i<l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for(var i=0; i<len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function(chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n},{}],152:[function(require,module,exports){\n'use strict';\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It doesn't worth to make additional optimizationa as in original.\n// Small size is preferable.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0\n    , s2 = ((adler >>> 16) & 0xffff) |0\n    , n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n},{}],153:[function(require,module,exports){\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n},{}],154:[function(require,module,exports){\n'use strict';\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for(var n =0; n < 256; n++){\n    c = n;\n    for(var k =0; k < 8; k++){\n      c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable\n    , end = pos + len;\n\n  crc = crc ^ (-1);\n\n  for (var i = pos; i < end; i++ ) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n},{}],155:[function(require,module,exports){\n'use strict';\n\nvar utils   = require('../utils/common');\nvar trees   = require('./trees');\nvar adler32 = require('./adler32');\nvar crc32   = require('./crc32');\nvar msg   = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2*L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only (s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH-1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH-1)) ? s.strstart : MIN_MATCH-1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH-1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size-MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH-1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1- s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length-1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH-1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart-1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart-1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH-1 ? s.strstart : MIN_MATCH-1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nvar Config = function (good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n};\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2*D_CODES+1) * 2);\n  this.bl_tree    = new utils.Buf16((2*BL_CODES+1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS+1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2*L_CODES+1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2*L_CODES+1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  s.d_buf = s.lit_bufsize >> 1;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n                );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg){\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n/* =========================================================================\n * Copy the source state to the destination state\n */\n//function deflateCopy(dest, source) {\n//\n//}\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n},{\"../utils/common\":151,\"./adler32\":152,\"./crc32\":154,\"./messages\":159,\"./trees\":160}],156:[function(require,module,exports){\n'use strict';\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  var window;                 /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n\n},{}],157:[function(require,module,exports){\n'use strict';\n\n\nvar utils = require('../utils/common');\nvar adler32 = require('./adler32');\nvar crc32   = require('./crc32');\nvar inflate_fast = require('./inffast');\nvar inflate_table = require('./inftrees');\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction ZSWAP32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, {bits: 9});\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, {bits: 5});\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window,src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window,src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window,src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n    case HEAD:\n      if (state.wrap === 0) {\n        state.mode = TYPEDO;\n        break;\n      }\n      //=== NEEDBITS(16);\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n        state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = FLAGS;\n        break;\n      }\n      state.flags = 0;           /* expect zlib header */\n      if (state.head) {\n        state.head.done = false;\n      }\n      if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n        strm.msg = 'incorrect header check';\n        state.mode = BAD;\n        break;\n      }\n      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n        strm.msg = 'unknown compression method';\n        state.mode = BAD;\n        break;\n      }\n      //--- DROPBITS(4) ---//\n      hold >>>= 4;\n      bits -= 4;\n      //---//\n      len = (hold & 0x0f)/*BITS(4)*/ + 8;\n      if (state.wbits === 0) {\n        state.wbits = len;\n      }\n      else if (len > state.wbits) {\n        strm.msg = 'invalid window size';\n        state.mode = BAD;\n        break;\n      }\n      state.dmax = 1 << len;\n      //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n      state.mode = hold & 0x200 ? DICTID : TYPE;\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      break;\n    case FLAGS:\n      //=== NEEDBITS(16); */\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.flags = hold;\n      if ((state.flags & 0xff) !== Z_DEFLATED) {\n        strm.msg = 'unknown compression method';\n        state.mode = BAD;\n        break;\n      }\n      if (state.flags & 0xe000) {\n        strm.msg = 'unknown header flags set';\n        state.mode = BAD;\n        break;\n      }\n      if (state.head) {\n        state.head.text = ((hold >> 8) & 1);\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = TIME;\n      /* falls through */\n    case TIME:\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if (state.head) {\n        state.head.time = hold;\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC4(state.check, hold)\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        hbuf[2] = (hold >>> 16) & 0xff;\n        hbuf[3] = (hold >>> 24) & 0xff;\n        state.check = crc32(state.check, hbuf, 4, 0);\n        //===\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = OS;\n      /* falls through */\n    case OS:\n      //=== NEEDBITS(16); */\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if (state.head) {\n        state.head.xflags = (hold & 0xff);\n        state.head.os = (hold >> 8);\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = EXLEN;\n      /* falls through */\n    case EXLEN:\n      if (state.flags & 0x0400) {\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.length = hold;\n        if (state.head) {\n          state.head.extra_len = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n      }\n      else if (state.head) {\n        state.head.extra = null/*Z_NULL*/;\n      }\n      state.mode = EXTRA;\n      /* falls through */\n    case EXTRA:\n      if (state.flags & 0x0400) {\n        copy = state.length;\n        if (copy > have) { copy = have; }\n        if (copy) {\n          if (state.head) {\n            len = state.head.extra_len - state.length;\n            if (!state.head.extra) {\n              // Use untyped array for more conveniend processing later\n              state.head.extra = new Array(state.head.extra_len);\n            }\n            utils.arraySet(\n              state.head.extra,\n              input,\n              next,\n              // extra field is limited to 65536 bytes\n              // - no need for additional size check\n              copy,\n              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n              len\n            );\n            //zmemcpy(state.head.extra + len, next,\n            //        len + copy > state.head.extra_max ?\n            //        state.head.extra_max - len : copy);\n          }\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          state.length -= copy;\n        }\n        if (state.length) { break inf_leave; }\n      }\n      state.length = 0;\n      state.mode = NAME;\n      /* falls through */\n    case NAME:\n      if (state.flags & 0x0800) {\n        if (have === 0) { break inf_leave; }\n        copy = 0;\n        do {\n          // TODO: 2 or 1 bytes?\n          len = input[next + copy++];\n          /* use constant limit because in js we should not preallocate memory */\n          if (state.head && len &&\n              (state.length < 65536 /*state.head.name_max*/)) {\n            state.head.name += String.fromCharCode(len);\n          }\n        } while (len && copy < have);\n\n        if (state.flags & 0x0200) {\n          state.check = crc32(state.check, input, copy, next);\n        }\n        have -= copy;\n        next += copy;\n        if (len) { break inf_leave; }\n      }\n      else if (state.head) {\n        state.head.name = null;\n      }\n      state.length = 0;\n      state.mode = COMMENT;\n      /* falls through */\n    case COMMENT:\n      if (state.flags & 0x1000) {\n        if (have === 0) { break inf_leave; }\n        copy = 0;\n        do {\n          len = input[next + copy++];\n          /* use constant limit because in js we should not preallocate memory */\n          if (state.head && len &&\n              (state.length < 65536 /*state.head.comm_max*/)) {\n            state.head.comment += String.fromCharCode(len);\n          }\n        } while (len && copy < have);\n        if (state.flags & 0x0200) {\n          state.check = crc32(state.check, input, copy, next);\n        }\n        have -= copy;\n        next += copy;\n        if (len) { break inf_leave; }\n      }\n      else if (state.head) {\n        state.head.comment = null;\n      }\n      state.mode = HCRC;\n      /* falls through */\n    case HCRC:\n      if (state.flags & 0x0200) {\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (hold !== (state.check & 0xffff)) {\n          strm.msg = 'header crc mismatch';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n      }\n      if (state.head) {\n        state.head.hcrc = ((state.flags >> 9) & 1);\n        state.head.done = true;\n      }\n      strm.adler = state.check = 0 /*crc32(0L, Z_NULL, 0)*/;\n      state.mode = TYPE;\n      break;\n    case DICTID:\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      strm.adler = state.check = ZSWAP32(hold);\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = DICT;\n      /* falls through */\n    case DICT:\n      if (state.havedict === 0) {\n        //--- RESTORE() ---\n        strm.next_out = put;\n        strm.avail_out = left;\n        strm.next_in = next;\n        strm.avail_in = have;\n        state.hold = hold;\n        state.bits = bits;\n        //---\n        return Z_NEED_DICT;\n      }\n      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n      state.mode = TYPE;\n      /* falls through */\n    case TYPE:\n      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case TYPEDO:\n      if (state.last) {\n        //--- BYTEBITS() ---//\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        state.mode = CHECK;\n        break;\n      }\n      //=== NEEDBITS(3); */\n      while (bits < 3) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.last = (hold & 0x01)/*BITS(1)*/;\n      //--- DROPBITS(1) ---//\n      hold >>>= 1;\n      bits -= 1;\n      //---//\n\n      switch ((hold & 0x03)/*BITS(2)*/) {\n      case 0:                             /* stored block */\n        //Tracev((stderr, \"inflate:     stored block%s\\n\",\n        //        state.last ? \" (last)\" : \"\"));\n        state.mode = STORED;\n        break;\n      case 1:                             /* fixed block */\n        fixedtables(state);\n        //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n        //        state.last ? \" (last)\" : \"\"));\n        state.mode = LEN_;             /* decode codes */\n        if (flush === Z_TREES) {\n          //--- DROPBITS(2) ---//\n          hold >>>= 2;\n          bits -= 2;\n          //---//\n          break inf_leave;\n        }\n        break;\n      case 2:                             /* dynamic block */\n        //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n        //        state.last ? \" (last)\" : \"\"));\n        state.mode = TABLE;\n        break;\n      case 3:\n        strm.msg = 'invalid block type';\n        state.mode = BAD;\n      }\n      //--- DROPBITS(2) ---//\n      hold >>>= 2;\n      bits -= 2;\n      //---//\n      break;\n    case STORED:\n      //--- BYTEBITS() ---// /* go to byte boundary */\n      hold >>>= bits & 7;\n      bits -= bits & 7;\n      //---//\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n        strm.msg = 'invalid stored block lengths';\n        state.mode = BAD;\n        break;\n      }\n      state.length = hold & 0xffff;\n      //Tracev((stderr, \"inflate:       stored length %u\\n\",\n      //        state.length));\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = COPY_;\n      if (flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case COPY_:\n      state.mode = COPY;\n      /* falls through */\n    case COPY:\n      copy = state.length;\n      if (copy) {\n        if (copy > have) { copy = have; }\n        if (copy > left) { copy = left; }\n        if (copy === 0) { break inf_leave; }\n        //--- zmemcpy(put, next, copy); ---\n        utils.arraySet(output, input, next, copy, put);\n        //---//\n        have -= copy;\n        next += copy;\n        left -= copy;\n        put += copy;\n        state.length -= copy;\n        break;\n      }\n      //Tracev((stderr, \"inflate:       stored end\\n\"));\n      state.mode = TYPE;\n      break;\n    case TABLE:\n      //=== NEEDBITS(14); */\n      while (bits < 14) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n      //--- DROPBITS(5) ---//\n      hold >>>= 5;\n      bits -= 5;\n      //---//\n      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n      //--- DROPBITS(5) ---//\n      hold >>>= 5;\n      bits -= 5;\n      //---//\n      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n      //--- DROPBITS(4) ---//\n      hold >>>= 4;\n      bits -= 4;\n      //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n      if (state.nlen > 286 || state.ndist > 30) {\n        strm.msg = 'too many length or distance symbols';\n        state.mode = BAD;\n        break;\n      }\n//#endif\n      //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n      state.have = 0;\n      state.mode = LENLENS;\n      /* falls through */\n    case LENLENS:\n      while (state.have < state.ncode) {\n        //=== NEEDBITS(3);\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n        //--- DROPBITS(3) ---//\n        hold >>>= 3;\n        bits -= 3;\n        //---//\n      }\n      while (state.have < 19) {\n        state.lens[order[state.have++]] = 0;\n      }\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      //state.next = state.codes;\n      //state.lencode = state.next;\n      // Switch to use dynamic table\n      state.lencode = state.lendyn;\n      state.lenbits = 7;\n\n      opts = {bits: state.lenbits};\n      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n      state.lenbits = opts.bits;\n\n      if (ret) {\n        strm.msg = 'invalid code lengths set';\n        state.mode = BAD;\n        break;\n      }\n      //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n      state.have = 0;\n      state.mode = CODELENS;\n      /* falls through */\n    case CODELENS:\n      while (state.have < state.nlen + state.ndist) {\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_val < 16) {\n          //--- DROPBITS(here.bits) ---//\n          hold >>>= here_bits;\n          bits -= here_bits;\n          //---//\n          state.lens[state.have++] = here_val;\n        }\n        else {\n          if (here_val === 16) {\n            //=== NEEDBITS(here.bits + 2);\n            n = here_bits + 2;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            if (state.have === 0) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            len = state.lens[state.have - 1];\n            copy = 3 + (hold & 0x03);//BITS(2);\n            //--- DROPBITS(2) ---//\n            hold >>>= 2;\n            bits -= 2;\n            //---//\n          }\n          else if (here_val === 17) {\n            //=== NEEDBITS(here.bits + 3);\n            n = here_bits + 3;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            len = 0;\n            copy = 3 + (hold & 0x07);//BITS(3);\n            //--- DROPBITS(3) ---//\n            hold >>>= 3;\n            bits -= 3;\n            //---//\n          }\n          else {\n            //=== NEEDBITS(here.bits + 7);\n            n = here_bits + 7;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            len = 0;\n            copy = 11 + (hold & 0x7f);//BITS(7);\n            //--- DROPBITS(7) ---//\n            hold >>>= 7;\n            bits -= 7;\n            //---//\n          }\n          if (state.have + copy > state.nlen + state.ndist) {\n            strm.msg = 'invalid bit length repeat';\n            state.mode = BAD;\n            break;\n          }\n          while (copy--) {\n            state.lens[state.have++] = len;\n          }\n        }\n      }\n\n      /* handle error breaks in while */\n      if (state.mode === BAD) { break; }\n\n      /* check for end-of-block code (better have one) */\n      if (state.lens[256] === 0) {\n        strm.msg = 'invalid code -- missing end-of-block';\n        state.mode = BAD;\n        break;\n      }\n\n      /* build code tables -- note: do not change the lenbits or distbits\n         values here (9 and 6) without reading the comments in inftrees.h\n         concerning the ENOUGH constants, which depend on those values */\n      state.lenbits = 9;\n\n      opts = {bits: state.lenbits};\n      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      // state.next_index = opts.table_index;\n      state.lenbits = opts.bits;\n      // state.lencode = state.next;\n\n      if (ret) {\n        strm.msg = 'invalid literal/lengths set';\n        state.mode = BAD;\n        break;\n      }\n\n      state.distbits = 6;\n      //state.distcode.copy(state.codes);\n      // Switch to use dynamic table\n      state.distcode = state.distdyn;\n      opts = {bits: state.distbits};\n      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      // state.next_index = opts.table_index;\n      state.distbits = opts.bits;\n      // state.distcode = state.next;\n\n      if (ret) {\n        strm.msg = 'invalid distances set';\n        state.mode = BAD;\n        break;\n      }\n      //Tracev((stderr, 'inflate:       codes ok\\n'));\n      state.mode = LEN_;\n      if (flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case LEN_:\n      state.mode = LEN;\n      /* falls through */\n    case LEN:\n      if (have >= 6 && left >= 258) {\n        //--- RESTORE() ---\n        strm.next_out = put;\n        strm.avail_out = left;\n        strm.next_in = next;\n        strm.avail_in = have;\n        state.hold = hold;\n        state.bits = bits;\n        //---\n        inflate_fast(strm, _out);\n        //--- LOAD() ---\n        put = strm.next_out;\n        output = strm.output;\n        left = strm.avail_out;\n        next = strm.next_in;\n        input = strm.input;\n        have = strm.avail_in;\n        hold = state.hold;\n        bits = state.bits;\n        //---\n\n        if (state.mode === TYPE) {\n          state.back = -1;\n        }\n        break;\n      }\n      state.back = 0;\n      for (;;) {\n        here = state.lencode[hold & ((1 << state.lenbits) -1)];  /*BITS(state.lenbits)*/\n        here_bits = here >>> 24;\n        here_op = (here >>> 16) & 0xff;\n        here_val = here & 0xffff;\n\n        if (here_bits <= bits) { break; }\n        //--- PULLBYTE() ---//\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n        //---//\n      }\n      if (here_op && (here_op & 0xf0) === 0) {\n        last_bits = here_bits;\n        last_op = here_op;\n        last_val = here_val;\n        for (;;) {\n          here = state.lencode[last_val +\n                  ((hold & ((1 << (last_bits + last_op)) -1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((last_bits + here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        //--- DROPBITS(last.bits) ---//\n        hold >>>= last_bits;\n        bits -= last_bits;\n        //---//\n        state.back += last_bits;\n      }\n      //--- DROPBITS(here.bits) ---//\n      hold >>>= here_bits;\n      bits -= here_bits;\n      //---//\n      state.back += here_bits;\n      state.length = here_val;\n      if (here_op === 0) {\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        state.mode = LIT;\n        break;\n      }\n      if (here_op & 32) {\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.back = -1;\n        state.mode = TYPE;\n        break;\n      }\n      if (here_op & 64) {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break;\n      }\n      state.extra = here_op & 15;\n      state.mode = LENEXT;\n      /* falls through */\n    case LENEXT:\n      if (state.extra) {\n        //=== NEEDBITS(state.extra);\n        n = state.extra;\n        while (bits < n) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.length += hold & ((1 << state.extra) -1)/*BITS(state.extra)*/;\n        //--- DROPBITS(state.extra) ---//\n        hold >>>= state.extra;\n        bits -= state.extra;\n        //---//\n        state.back += state.extra;\n      }\n      //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n      state.was = state.length;\n      state.mode = DIST;\n      /* falls through */\n    case DIST:\n      for (;;) {\n        here = state.distcode[hold & ((1 << state.distbits) -1)];/*BITS(state.distbits)*/\n        here_bits = here >>> 24;\n        here_op = (here >>> 16) & 0xff;\n        here_val = here & 0xffff;\n\n        if ((here_bits) <= bits) { break; }\n        //--- PULLBYTE() ---//\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n        //---//\n      }\n      if ((here_op & 0xf0) === 0) {\n        last_bits = here_bits;\n        last_op = here_op;\n        last_val = here_val;\n        for (;;) {\n          here = state.distcode[last_val +\n                  ((hold & ((1 << (last_bits + last_op)) -1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((last_bits + here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        //--- DROPBITS(last.bits) ---//\n        hold >>>= last_bits;\n        bits -= last_bits;\n        //---//\n        state.back += last_bits;\n      }\n      //--- DROPBITS(here.bits) ---//\n      hold >>>= here_bits;\n      bits -= here_bits;\n      //---//\n      state.back += here_bits;\n      if (here_op & 64) {\n        strm.msg = 'invalid distance code';\n        state.mode = BAD;\n        break;\n      }\n      state.offset = here_val;\n      state.extra = (here_op) & 15;\n      state.mode = DISTEXT;\n      /* falls through */\n    case DISTEXT:\n      if (state.extra) {\n        //=== NEEDBITS(state.extra);\n        n = state.extra;\n        while (bits < n) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.offset += hold & ((1 << state.extra) -1)/*BITS(state.extra)*/;\n        //--- DROPBITS(state.extra) ---//\n        hold >>>= state.extra;\n        bits -= state.extra;\n        //---//\n        state.back += state.extra;\n      }\n//#ifdef INFLATE_STRICT\n      if (state.offset > state.dmax) {\n        strm.msg = 'invalid distance too far back';\n        state.mode = BAD;\n        break;\n      }\n//#endif\n      //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n      state.mode = MATCH;\n      /* falls through */\n    case MATCH:\n      if (left === 0) { break inf_leave; }\n      copy = _out - left;\n      if (state.offset > copy) {         /* copy from window */\n        copy = state.offset - copy;\n        if (copy > state.whave) {\n          if (state.sane) {\n            strm.msg = 'invalid distance too far back';\n            state.mode = BAD;\n            break;\n          }\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n        }\n        if (copy > state.wnext) {\n          copy -= state.wnext;\n          from = state.wsize - copy;\n        }\n        else {\n          from = state.wnext - copy;\n        }\n        if (copy > state.length) { copy = state.length; }\n        from_source = state.window;\n      }\n      else {                              /* copy from output */\n        from_source = output;\n        from = put - state.offset;\n        copy = state.length;\n      }\n      if (copy > left) { copy = left; }\n      left -= copy;\n      state.length -= copy;\n      do {\n        output[put++] = from_source[from++];\n      } while (--copy);\n      if (state.length === 0) { state.mode = LEN; }\n      break;\n    case LIT:\n      if (left === 0) { break inf_leave; }\n      output[put++] = state.length;\n      left--;\n      state.mode = LEN;\n      break;\n    case CHECK:\n      if (state.wrap) {\n        //=== NEEDBITS(32);\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          // Use '|' insdead of '+' to make sure that result is signed\n          hold |= input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        _out -= left;\n        strm.total_out += _out;\n        state.total += _out;\n        if (_out) {\n          strm.adler = state.check =\n              /*UPDATE(state.check, put - _out, _out);*/\n              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n        }\n        _out = left;\n        // NB: crc32 stored as signed 32-bit int, ZSWAP32 returns signed too\n        if ((state.flags ? hold : ZSWAP32(hold)) !== state.check) {\n          strm.msg = 'incorrect data check';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n      }\n      state.mode = LENGTH;\n      /* falls through */\n    case LENGTH:\n      if (state.wrap && state.flags) {\n        //=== NEEDBITS(32);\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (hold !== (state.total & 0xffffffff)) {\n          strm.msg = 'incorrect length check';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n      }\n      state.mode = DONE;\n      /* falls through */\n    case DONE:\n      ret = Z_STREAM_END;\n      break inf_leave;\n    case BAD:\n      ret = Z_DATA_ERROR;\n      break inf_leave;\n    case MEM:\n      return Z_MEM_ERROR;\n    case SYNC:\n      /* falls through */\n    default:\n      return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n},{\"../utils/common\":151,\"./adler32\":152,\"./crc32\":154,\"./inffast\":156,\"./inftrees\":158}],158:[function(require,module,exports){\n'use strict';\n\n\nvar utils = require('../utils/common');\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code's length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS+1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS+1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n      base = extra = work;    /* dummy value--not used */\n      end = 19;\n  } else if (type === LENS) {\n      base = lbase;\n      base_index -= 257;\n      extra = lext;\n      extra_index -= 257;\n      end = 256;\n  } else {                    /* DISTS */\n      base = dbase;\n      extra = dext;\n      end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  var i=0;\n  /* process all codes and make table entries */\n  for (;;) {\n    i++;\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n},{\"../utils/common\":151}],159:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  '2':    'need dictionary',     /* Z_NEED_DICT       2  */\n  '1':    'stream end',          /* Z_STREAM_END      1  */\n  '0':    '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n},{}],160:[function(require,module,exports){\n'use strict';\n\n\nvar utils = require('../utils/common');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2*L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES+2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH-MIN_MATCH+1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nvar StaticTreeDesc = function (static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n};\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nvar TreeDesc = function(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n};\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short (s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c*2]/*.Code*/, tree[c*2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max]*2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max+1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n*2 +1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n*2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n-base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n*2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length-1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits+1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m*2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m*2 + 1]/*.Len*/)*tree[m*2]/*.Freq*/;\n        tree[m*2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS+1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits-1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n*2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n*2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS+1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES-1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1<<extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length-1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0 ; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1<<extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for ( ; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n*2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n*2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n*2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n*2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES+1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n*2 + 1]/*.Len*/ = 5;\n    static_dtree[n*2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc =new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n*2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n*2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n*2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK*2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n*2;\n  var _m2 = m*2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j+1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx*2] << 8) | (s.pending_buf[s.d_buf + lx*2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code+LITERALS+1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n*2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node*2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n*2 + 1]/*.Dad*/ = tree[m*2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0*2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code+1)*2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n+1)*2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6*2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10*2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138*2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0*2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n+1)*2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count-3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count-3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count-11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex]*2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3*(max_blindex+1) + 5+5+4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes-1,   5);\n  send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank]*2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes-1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes-1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n*2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK<<1)+(last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES<<1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len+3+7) >>> 3;\n    static_lenb = (s.static_len+3+7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len+4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES<<1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES<<1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code+1, s.d_desc.max_code+1, max_blindex+1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc*2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc]+LITERALS+1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize-1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n},{\"../utils/common\":151}],161:[function(require,module,exports){\n'use strict';\n\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n},{}],162:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-e\n(function() {\n  var Encoder, Message, Parser, bufeq_fast, clearsign, compute_crc24, crc24_to_base64, crc_table, decode, encode, formatCheckSum, getCheckSum, katch, make_line, strip, trim, uint_to_buffer, verifyCheckSum, _ref;\n\n  _ref = require('./util'), trim = _ref.trim, strip = _ref.strip, katch = _ref.katch, bufeq_fast = _ref.bufeq_fast, uint_to_buffer = _ref.uint_to_buffer;\n\n  make_line = function(x) {\n    if (x == null) {\n      x = \"\";\n    }\n    return \"\" + x + \"\\n\";\n  };\n\n  exports.Encoder = Encoder = (function() {\n    function Encoder(C) {\n      this.C = C;\n    }\n\n    Encoder.prototype.frame = function(t) {\n      var dash, i;\n      dash = ((function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; _i < 5; i = ++_i) {\n          _results.push(\"-\");\n        }\n        return _results;\n      })()).join('');\n      return {\n        begin: make_line(dash + (\"BEGIN PGP \" + t) + dash),\n        end: make_line(dash + (\"END PGP \" + t) + dash)\n      };\n    };\n\n    Encoder.prototype.b64e = function(d) {\n      var end, i, parts, raw, w;\n      raw = d.toString('base64');\n      w = 64;\n      parts = (function() {\n        var _i, _ref1, _results;\n        _results = [];\n        for (i = _i = 0, _ref1 = raw.length; w > 0 ? _i < _ref1 : _i > _ref1; i = _i += w) {\n          end = Math.min(i + w, raw.length);\n          _results.push(raw.slice(i, end));\n        }\n        return _results;\n      })();\n      return make_line(parts.join(\"\\n\"));\n    };\n\n    Encoder.prototype.header = function() {\n      var x;\n      return ((function() {\n        var _i, _len, _ref1, _results;\n        _ref1 = [\"Version: \" + this.C.header.version, \"Comment: \" + this.C.header.comment];\n        _results = [];\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          x = _ref1[_i];\n          _results.push(make_line(x));\n        }\n        return _results;\n      }).call(this)).join('');\n    };\n\n    Encoder.prototype.encode = function(type, data) {\n      var f;\n      f = this.frame(type);\n      return f.begin.concat(this.header(), make_line(), this.b64e(data), formatCheckSum(data), f.end);\n    };\n\n    return Encoder;\n\n  })();\n\n  exports.clearsign_header = clearsign = function(C, data, hasher_name) {\n    var enc, f;\n    enc = new Encoder(C);\n    f = enc.frame(\"SIGNED MESSAGE\").begin;\n    return f.concat(make_line(\"Hash: \" + hasher_name), make_line(), data);\n  };\n\n  exports.encode = encode = function(C, type, data) {\n    return (new Encoder(C)).encode(type, data);\n  };\n\n  crc_table = [0x00000000, 0x00864cfb, 0x018ad50d, 0x010c99f6, 0x0393e6e1, 0x0315aa1a, 0x021933ec, 0x029f7f17, 0x07a18139, 0x0727cdc2, 0x062b5434, 0x06ad18cf, 0x043267d8, 0x04b42b23, 0x05b8b2d5, 0x053efe2e, 0x0fc54e89, 0x0f430272, 0x0e4f9b84, 0x0ec9d77f, 0x0c56a868, 0x0cd0e493, 0x0ddc7d65, 0x0d5a319e, 0x0864cfb0, 0x08e2834b, 0x09ee1abd, 0x09685646, 0x0bf72951, 0x0b7165aa, 0x0a7dfc5c, 0x0afbb0a7, 0x1f0cd1e9, 0x1f8a9d12, 0x1e8604e4, 0x1e00481f, 0x1c9f3708, 0x1c197bf3, 0x1d15e205, 0x1d93aefe, 0x18ad50d0, 0x182b1c2b, 0x192785dd, 0x19a1c926, 0x1b3eb631, 0x1bb8faca, 0x1ab4633c, 0x1a322fc7, 0x10c99f60, 0x104fd39b, 0x11434a6d, 0x11c50696, 0x135a7981, 0x13dc357a, 0x12d0ac8c, 0x1256e077, 0x17681e59, 0x17ee52a2, 0x16e2cb54, 0x166487af, 0x14fbf8b8, 0x147db443, 0x15712db5, 0x15f7614e, 0x3e19a3d2, 0x3e9fef29, 0x3f9376df, 0x3f153a24, 0x3d8a4533, 0x3d0c09c8, 0x3c00903e, 0x3c86dcc5, 0x39b822eb, 0x393e6e10, 0x3832f7e6, 0x38b4bb1d, 0x3a2bc40a, 0x3aad88f1, 0x3ba11107, 0x3b275dfc, 0x31dced5b, 0x315aa1a0, 0x30563856, 0x30d074ad, 0x324f0bba, 0x32c94741, 0x33c5deb7, 0x3343924c, 0x367d6c62, 0x36fb2099, 0x37f7b96f, 0x3771f594, 0x35ee8a83, 0x3568c678, 0x34645f8e, 0x34e21375, 0x2115723b, 0x21933ec0, 0x209fa736, 0x2019ebcd, 0x228694da, 0x2200d821, 0x230c41d7, 0x238a0d2c, 0x26b4f302, 0x2632bff9, 0x273e260f, 0x27b86af4, 0x252715e3, 0x25a15918, 0x24adc0ee, 0x242b8c15, 0x2ed03cb2, 0x2e567049, 0x2f5ae9bf, 0x2fdca544, 0x2d43da53, 0x2dc596a8, 0x2cc90f5e, 0x2c4f43a5, 0x2971bd8b, 0x29f7f170, 0x28fb6886, 0x287d247d, 0x2ae25b6a, 0x2a641791, 0x2b688e67, 0x2beec29c, 0x7c3347a4, 0x7cb50b5f, 0x7db992a9, 0x7d3fde52, 0x7fa0a145, 0x7f26edbe, 0x7e2a7448, 0x7eac38b3, 0x7b92c69d, 0x7b148a66, 0x7a181390, 0x7a9e5f6b, 0x7801207c, 0x78876c87, 0x798bf571, 0x790db98a, 0x73f6092d, 0x737045d6, 0x727cdc20, 0x72fa90db, 0x7065efcc, 0x70e3a337, 0x71ef3ac1, 0x7169763a, 0x74578814, 0x74d1c4ef, 0x75dd5d19, 0x755b11e2, 0x77c46ef5, 0x7742220e, 0x764ebbf8, 0x76c8f703, 0x633f964d, 0x63b9dab6, 0x62b54340, 0x62330fbb, 0x60ac70ac, 0x602a3c57, 0x6126a5a1, 0x61a0e95a, 0x649e1774, 0x64185b8f, 0x6514c279, 0x65928e82, 0x670df195, 0x678bbd6e, 0x66872498, 0x66016863, 0x6cfad8c4, 0x6c7c943f, 0x6d700dc9, 0x6df64132, 0x6f693e25, 0x6fef72de, 0x6ee3eb28, 0x6e65a7d3, 0x6b5b59fd, 0x6bdd1506, 0x6ad18cf0, 0x6a57c00b, 0x68c8bf1c, 0x684ef3e7, 0x69426a11, 0x69c426ea, 0x422ae476, 0x42aca88d, 0x43a0317b, 0x43267d80, 0x41b90297, 0x413f4e6c, 0x4033d79a, 0x40b59b61, 0x458b654f, 0x450d29b4, 0x4401b042, 0x4487fcb9, 0x461883ae, 0x469ecf55, 0x479256a3, 0x47141a58, 0x4defaaff, 0x4d69e604, 0x4c657ff2, 0x4ce33309, 0x4e7c4c1e, 0x4efa00e5, 0x4ff69913, 0x4f70d5e8, 0x4a4e2bc6, 0x4ac8673d, 0x4bc4fecb, 0x4b42b230, 0x49ddcd27, 0x495b81dc, 0x4857182a, 0x48d154d1, 0x5d26359f, 0x5da07964, 0x5cace092, 0x5c2aac69, 0x5eb5d37e, 0x5e339f85, 0x5f3f0673, 0x5fb94a88, 0x5a87b4a6, 0x5a01f85d, 0x5b0d61ab, 0x5b8b2d50, 0x59145247, 0x59921ebc, 0x589e874a, 0x5818cbb1, 0x52e37b16, 0x526537ed, 0x5369ae1b, 0x53efe2e0, 0x51709df7, 0x51f6d10c, 0x50fa48fa, 0x507c0401, 0x5542fa2f, 0x55c4b6d4, 0x54c82f22, 0x544e63d9, 0x56d11cce, 0x56575035, 0x575bc9c3, 0x57dd8538];\n\n  compute_crc24 = function(input, initval) {\n    var crc, index, j, _i, _ref1;\n    if (initval == null) {\n      initval = 0xB704CE;\n    }\n    crc = initval;\n    index = 0;\n    while ((input.length - index) > 16) {\n      crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.readUInt8(index + 0)) & 0xff];\n      crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.readUInt8(index + 1)) & 0xff];\n      crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.readUInt8(index + 2)) & 0xff];\n      crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.readUInt8(index + 3)) & 0xff];\n      crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.readUInt8(index + 4)) & 0xff];\n      crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.readUInt8(index + 5)) & 0xff];\n      crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.readUInt8(index + 6)) & 0xff];\n      crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.readUInt8(index + 7)) & 0xff];\n      crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.readUInt8(index + 8)) & 0xff];\n      crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.readUInt8(index + 9)) & 0xff];\n      crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.readUInt8(index + 10)) & 0xff];\n      crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.readUInt8(index + 11)) & 0xff];\n      crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.readUInt8(index + 12)) & 0xff];\n      crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.readUInt8(index + 13)) & 0xff];\n      crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.readUInt8(index + 14)) & 0xff];\n      crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.readUInt8(index + 15)) & 0xff];\n      index += 16;\n    }\n    for (j = _i = index, _ref1 = input.length; index <= _ref1 ? _i < _ref1 : _i > _ref1; j = index <= _ref1 ? ++_i : --_i) {\n      crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.readUInt8(index++)) & 0xff];\n    }\n    return crc & 0xffffff;\n  };\n\n  getCheckSum = function(data, pad) {\n    var ret;\n    ret = crc24_to_base64(compute_crc24(data), pad);\n    return ret;\n  };\n\n  exports.crc24_to_base64 = crc24_to_base64 = function(c, pad) {\n    if (pad == null) {\n      pad = true;\n    }\n    return (pad ? \"=\" : '') + uint_to_buffer(32, c).slice(1, 4).toString('base64');\n  };\n\n  formatCheckSum = function(data) {\n    return make_line(getCheckSum(data, true));\n  };\n\n  verifyCheckSum = function(data, checksum) {\n    return getCheckSum(data, false) === checksum;\n  };\n\n  exports.Message = Message = (function() {\n    function Message(_arg) {\n      this.body = _arg.body, this.type = _arg.type, this.comment = _arg.comment, this.version = _arg.version, this.pre = _arg.pre, this.post = _arg.post;\n      this.lines = [];\n      this.fields = {};\n      this.payload = null;\n    }\n\n    Message.prototype.unsplit = function(lines) {\n      return lines.join(\"\\n\");\n    };\n\n    Message.prototype.raw = function() {\n      return this.unsplit(this.lines);\n    };\n\n    Message.prototype.finish_unframe = function(_arg) {\n      var post, pre;\n      pre = _arg.pre, post = _arg.post;\n      this.pre = this.unsplit(pre);\n      this.post = this.unsplit(post);\n      if (this.clearsign != null) {\n        return this.clearsign.body = this.unsplit(this.clearsign.lines);\n      }\n    };\n\n    Message.prototype.make_clearsign = function() {\n      return this.clearsign = {\n        headers: {},\n        lines: [],\n        body: null\n      };\n    };\n\n    return Message;\n\n  })();\n\n  exports.Parser = Parser = (function() {\n    function Parser(data) {\n      this.init(data);\n    }\n\n    Parser.prototype.init = function(data) {\n      this.data = Buffer.isBuffer(data) ? data.toString('utf8') : data;\n      this.lines = this.data.split(/\\r?\\n/);\n      this.checksum = null;\n      this.body = null;\n      this.type = null;\n      this.ret = null;\n      return this.last_type = null;\n    };\n\n    Parser.prototype.parse = function() {\n      this.ret = new Message({});\n      this.unframe();\n      this.pop_headers();\n      this.parse_type();\n      this.strip_empties_in_footer();\n      this.trim_lines();\n      this.find_checksum();\n      this.read_body();\n      this.check_checksum();\n      return this.ret;\n    };\n\n    Parser.prototype.parse_type = function() {\n      return this.ret.type = this.ret.fields.type = this.type;\n    };\n\n    Parser.prototype.last_line = function() {\n      return this.payload.slice(-1)[0];\n    };\n\n    Parser.prototype.mparse = function() {\n      var go, obj, out;\n      out = [];\n      go = true;\n      while (go) {\n        this.skip();\n        if (this.lines.length) {\n          obj = this.parse();\n          out.push(obj);\n          this.init(obj.post);\n        } else {\n          go = false;\n        }\n      }\n      return out;\n    };\n\n    Parser.prototype.skip = function() {\n      var _results;\n      _results = [];\n      while (this.lines.length) {\n        if (this.lines[0].match(/\\S+/)) {\n          break;\n        }\n        _results.push(this.lines.shift());\n      }\n      return _results;\n    };\n\n    Parser.prototype.read_body = function() {\n      var dat;\n      this.ret.payload = this.payload.join(\"\\n\");\n      dat = this.payload.join('');\n      return this.ret.body = new Buffer(dat, 'base64');\n    };\n\n    Parser.prototype.check_checksum = function() {\n      this.ret.fields.checksum = this.checksum;\n      if ((this.checksum != null) && !verifyCheckSum(this.ret.body, this.checksum)) {\n        throw new Error(\"checksum mismatch\");\n      }\n    };\n\n    Parser.prototype.pop_headers = function() {\n      var l, m, _results;\n      _results = [];\n      while (this.payload.length) {\n        l = this.payload.shift();\n        if ((m = l.match(/Version: (.*)/))) {\n          _results.push(this.ret.version = m[1]);\n        } else if ((m = l.match(/Comment: (.*)/)) != null) {\n          _results.push(this.ret.comment = m[1]);\n        } else if ((l == null) || (l.length === 0) || (l.match(/^\\s+$/))) {\n          break;\n        } else {\n          _results.push(void 0);\n        }\n      }\n      return _results;\n    };\n\n    Parser.prototype.strip_empties_in_footer = function() {\n      var _ref1, _results;\n      _results = [];\n      while ((_ref1 = this.last_line()) != null ? _ref1.match(/^\\s*$/) : void 0) {\n        _results.push(this.payload.pop());\n      }\n      return _results;\n    };\n\n    Parser.prototype.trim_lines = function() {\n      var p;\n      return this.payload = (function() {\n        var _i, _len, _ref1, _results;\n        _ref1 = this.payload;\n        _results = [];\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          p = _ref1[_i];\n          _results.push(trim(p));\n        }\n        return _results;\n      }).call(this);\n    };\n\n    Parser.prototype.find_checksum = function() {\n      var l;\n      if (((l = this.last_line()) != null) && l[0] === '=') {\n        return this.checksum = this.payload.pop().slice(1);\n      }\n    };\n\n    Parser.prototype.v_unframe = function(pre) {\n      return true;\n    };\n\n    Parser.prototype.unframe = function() {\n      var found_pre, found_pre_clearsign, found_pre_std, go, line, m, payload, post, pre, ret, rxx, rxx_b, rxx_e, stage, type;\n      rxx_b = /^(-{5}BEGIN PGP (.*?)-{5}.*$)/;\n      rxx_e = /^(-{5}END PGP (.*?)-{5})(.*)$/m;\n      rxx = rxx_b;\n      payload = [];\n      stage = 0;\n      type = null;\n      ret = null;\n      go = true;\n      pre = [];\n      post = [];\n      found_pre_std = function(l, is_last) {\n        return pre.push(l);\n      };\n      found_pre_clearsign = (function(_this) {\n        return function(l, is_last) {\n          return _this.ret.clearsign.lines.push(l);\n        };\n      })(this);\n      found_pre = found_pre_std;\n      while (this.lines.length && go) {\n        line = this.lines.shift();\n        switch (stage) {\n          case -1:\n            if ((m = line.match(/^([^:]+): (.*)$/))) {\n              this.ret.clearsign.headers[m[1].toLowerCase()] = m[2];\n            } else if (line.match(/^\\s*$/)) {\n              stage++;\n              found_pre = found_pre_clearsign;\n            } else {\n              throw new Error(\"Bad line in clearsign header\");\n            }\n            this.ret.lines.push(line);\n            break;\n          case 0:\n            if ((m = line.match(rxx_b)) != null) {\n              found_pre('', true);\n              this.ret.lines.push((this.ret.clearsign ? line : m[1]));\n              if (this.type == null) {\n                this.type = m[2];\n              }\n              this.last_type = m[2];\n              if (m[2] === \"SIGNED MESSAGE\") {\n                stage--;\n                this.ret.make_clearsign();\n              } else {\n                stage++;\n              }\n            } else {\n              if (this.ret.clearsign) {\n                this.ret.lines.push(line);\n              }\n              found_pre(line, false);\n            }\n            break;\n          case 1:\n            if ((m = line.match(rxx_e))) {\n              this.ret.lines.push(m[1]);\n              if (m[2] !== this.last_type) {\n                throw new Error(\"type mismatch -- begin \" + this.last_type + \" w/ end \" + m[1]);\n              }\n              stage++;\n              post = [m[3]].concat(this.lines);\n              this.lines = [];\n              go = false;\n            } else {\n              this.ret.lines.push(line);\n              payload.push(line);\n            }\n        }\n      }\n      if (stage === 0) {\n        throw new Error(\"no header found\");\n      } else if (stage === 1) {\n        throw new Error(\"no tailer found\");\n      } else {\n        this.payload = payload;\n        return this.ret.finish_unframe({\n          pre: pre,\n          post: post\n        });\n      }\n    };\n\n    return Parser;\n\n  })();\n\n  exports.decode = decode = function(data) {\n    return katch(function() {\n      return (new Parser(data)).parse();\n    });\n  };\n\n  exports.mdecode = decode = function(data) {\n    return katch(function() {\n      return (new Parser(data)).mparse();\n    });\n  };\n\n  exports.compute_crc24 = compute_crc24;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./util\":165,\"buffer\":80}],163:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-e\n(function() {\n  exports.armor = require('./armor');\n\n  exports.util = require('./util');\n\n  exports.userid = require('./userid');\n\n}).call(this);\n\n},{\"./armor\":162,\"./userid\":164,\"./util\":165}],164:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-e\n(function() {\n  exports.parse = function(input) {\n    var components, m, x;\n    components = null;\n    x = /^([^(<]*?)(?:\\s*\\((.*?)\\))?(?:\\s*<(.*?)>)?$/;\n    if ((m = input.match(x)) != null) {\n      components = {\n        username: m[1],\n        comment: m[2],\n        email: m[3]\n      };\n    }\n    return components;\n  };\n\n  exports.format = function(d) {\n    var parts, _ref, _ref1, _ref2;\n    parts = [];\n    if ((_ref = d.username) != null ? _ref.length : void 0) {\n      parts.push(d.username);\n    }\n    if ((_ref1 = d.comment) != null ? _ref1.length : void 0) {\n      parts.push(\"(\" + d.comment + \")\");\n    }\n    if ((_ref2 = d.email) != null ? _ref2.length : void 0) {\n      parts.push(\"<\" + d.email + \">\");\n    }\n    return parts.join(' ');\n  };\n\n}).call(this);\n\n},{}],165:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var ASP, Canceler, Warnings, assert, assert_no_nulls, asyncify, bufeq_secure, buffer_to_ui8a, bufferify, iced, katch, obj_extract, strip, trim, ui32a_to_ui8a, ui8Ga_to_ui32a, xxd, __iced_k, __iced_k_noop,\n    __slice = [].slice;\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  Canceler = require('iced-error').Canceler;\n\n  assert = require('assert');\n\n  exports.uint_to_buffer = function(nbits, i) {\n    var ret;\n    ret = null;\n    switch (nbits) {\n      case 16:\n        ret = new Buffer(2);\n        ret.writeUInt16BE(i, 0);\n        break;\n      case 32:\n        ret = new Buffer(4);\n        ret.writeUInt32BE(i, 0);\n        break;\n      case 8:\n        ret = new Buffer(1);\n        ret.writeUInt8(i, 0);\n        break;\n      default:\n        throw new Error(\"Bit types not found: \" + nbit);\n    }\n    return ret;\n  };\n\n  exports.ASP = ASP = (function() {\n    function ASP(_arg) {\n      var canceler, delay, progress_hook;\n      progress_hook = _arg.progress_hook, delay = _arg.delay, canceler = _arg.canceler;\n      this._delay = delay != null ? delay : 2;\n      this._canceler = canceler || (new Canceler());\n      this._progress_hook = progress_hook || (function(obj) {});\n      this._section = null;\n    }\n\n    ASP.prototype.section = function(s) {\n      this._section = s;\n      return this;\n    };\n\n    ASP.prototype.progress = function(o, cb) {\n      var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      if (this._section) {\n        o.section = this._section;\n      }\n      this._progress_hook(o);\n      if (cb != null) {\n        (function(_this) {\n          return (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/pgp-utils/src/util.iced\",\n              funcname: \"ASP.progress\"\n            });\n            _this.delay(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return err = arguments[0];\n                };\n              })(),\n              lineno: 43\n            }));\n            __iced_deferrals._fulfill();\n          });\n        })(this)((function(_this) {\n          return function() {\n            return __iced_k(cb(err));\n          };\n        })(this));\n      } else {\n        return __iced_k();\n      }\n    };\n\n    ASP.prototype.delay = function(cb) {\n      var ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/pgp-utils/src/util.iced\",\n            funcname: \"ASP.delay\"\n          });\n          setTimeout(__iced_deferrals.defer({\n            lineno: 47\n          }), _this.delay);\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(_this._canceler.err());\n        };\n      })(this));\n    };\n\n    ASP.prototype.canceler = function() {\n      return this._canceler;\n    };\n\n    ASP.prototype.progress_hook = function() {\n      return this._progress_hook;\n    };\n\n    ASP.make = function(asp) {\n      return asp || (new ASP({}));\n    };\n\n    return ASP;\n\n  })();\n\n  exports.Warnings = Warnings = (function() {\n    function Warnings() {\n      this._w = [];\n    }\n\n    Warnings.prototype.push = function() {\n      var args, _ref;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return (_ref = this._w).push.apply(_ref, args);\n    };\n\n    Warnings.prototype.warnings = function() {\n      return this._w;\n    };\n\n    return Warnings;\n\n  })();\n\n  exports.bufeq_fast = function(x, y) {\n    var i, _i, _ref;\n    if ((x == null) && (y == null)) {\n      return true;\n    }\n    if ((x == null) || (y == null)) {\n      return false;\n    }\n    if (x.length !== y.length) {\n      return false;\n    }\n    for (i = _i = 0, _ref = x.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n      if (x.readUInt8(i) !== y.readUInt8(i)) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  exports.bufeq_secure = bufeq_secure = function(x, y) {\n    var check, i, ret;\n    ret = (function() {\n      var _i, _ref;\n      if ((x == null) && (y == null)) {\n        return true;\n      } else if ((x == null) || (y == null)) {\n        return false;\n      } else if (x.length !== y.length) {\n        return false;\n      } else {\n        check = 0;\n        for (i = _i = 0, _ref = x.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n          check |= x.readUInt8(i) ^ y.readUInt8(i);\n        }\n        return check === 0;\n      }\n    })();\n    return ret;\n  };\n\n  exports.streq_secure = function(x, y) {\n    var B;\n    B = function(x) {\n      if (x != null) {\n        return bufferify(x);\n      } else {\n        return null;\n      }\n    };\n    return bufeq_secure(B(x), B(y));\n  };\n\n  exports.bufferify = bufferify = function(s) {\n    if (Buffer.isBuffer(s)) {\n      return s;\n    } else if (typeof s === 'string') {\n      return new Buffer(s, 'utf8');\n    } else {\n      throw new Error(\"Cannot convert to buffer: \" + s);\n    }\n  };\n\n  exports.katch = katch = function(fn) {\n    var e, err, ret;\n    ret = err = null;\n    try {\n      ret = fn();\n    } catch (_error) {\n      e = _error;\n      err = e;\n    }\n    return [err, ret];\n  };\n\n  exports.akatch = function(fn, cb) {\n    return asyncify(katch(fn), cb);\n  };\n\n  exports.buffer_to_ui8a = buffer_to_ui8a = function(b) {\n    var i, l, ret, _i;\n    l = b.length;\n    ret = new Uint8Array(l);\n    for (i = _i = 0; 0 <= l ? _i < l : _i > l; i = 0 <= l ? ++_i : --_i) {\n      ret[i] = b.readUInt8(i);\n    }\n    return ret;\n  };\n\n  exports.ui32a_to_ui8a = ui32a_to_ui8a = function(v, out) {\n    var k, w, _i, _len;\n    if (out == null) {\n      out = null;\n    }\n    out || (out = new Uint8Array(v.length * 4));\n    k = 0;\n    for (_i = 0, _len = v.length; _i < _len; _i++) {\n      w = v[_i];\n      out[k++] = (w >> 24) & 0xff;\n      out[k++] = (w >> 16) & 0xff;\n      out[k++] = (w >> 8) & 0xff;\n      out[k++] = w & 0xff;\n    }\n    return out;\n  };\n\n  exports.ui8a_to_ui32a = ui8Ga_to_ui32a = function(v, out) {\n    var b, i, k, tmp, _i, _len;\n    if (out == null) {\n      out = null;\n    }\n    out || (out = new Uint32Array(v.length >> 2));\n    k = 0;\n    for (i = _i = 0, _len = v.length; _i < _len; i = _i += 4) {\n      b = v[i];\n      tmp = (b << 24) + (v[i + 1] << 16) + (v[i + 2] << 8) + v[i + 3];\n      out[k++] = tmp;\n    }\n    return out;\n  };\n\n  exports.unix_time = function() {\n    return Math.floor(Date.now() / 1000);\n  };\n\n  exports.json_stringify_sorted = function(o, opts) {\n    var i, json_safe, lb, o2, sort_fn, space_it, spaces, str;\n    opts = opts || {};\n    sort_fn = opts.sort_fn || null;\n    spaces = opts.spaces || null;\n    lb = opts.spaces != null ? \"\\n\" : \"\";\n    if ((typeof spaces) === \"number\") {\n      spaces = ((function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; 0 <= spaces ? _i < spaces : _i > spaces; i = 0 <= spaces ? ++_i : --_i) {\n          _results.push(\" \");\n        }\n        return _results;\n      })()).join(\"\");\n    }\n    space_it = function(depth) {\n      if (spaces == null) {\n        return \"\";\n      }\n      return \"\\n\" + ((function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; 0 <= depth ? _i < depth : _i > depth; i = 0 <= depth ? ++_i : --_i) {\n          _results.push(spaces);\n        }\n        return _results;\n      })()).join(\"\");\n    };\n    json_safe = function(os, depth) {\n      var k, keys, s, sp, spp, v;\n      if (Array.isArray(os)) {\n        s = \"[\" + ((function() {\n          var _i, _len, _results;\n          _results = [];\n          for (_i = 0, _len = os.length; _i < _len; _i++) {\n            v = os[_i];\n            _results.push(json_safe(v, depth + 1));\n          }\n          return _results;\n        })()).join(',') + \"]\";\n      } else if ((typeof os) === \"object\") {\n        if (!os) {\n          s = JSON.stringify(os);\n        } else {\n          sp = space_it(depth);\n          spp = space_it(depth + 1);\n          keys = (function() {\n            var _results;\n            _results = [];\n            for (k in os) {\n              _results.push(k);\n            }\n            return _results;\n          })();\n          if (sort_fn) {\n            keys.sort(sort_fn);\n          } else {\n            keys.sort();\n          }\n          s = \"{\" + ((function() {\n            var _i, _len, _results;\n            _results = [];\n            for (_i = 0, _len = keys.length; _i < _len; _i++) {\n              k = keys[_i];\n              _results.push(spp + JSON.stringify(k) + \":\" + json_safe(os[k], depth + 1));\n            }\n            return _results;\n          })()).join(',') + sp + \"}\";\n        }\n      } else {\n        s = JSON.stringify(os);\n      }\n      return s;\n    };\n    str = JSON.stringify(o);\n    if (str === void 0) {\n      return str;\n    } else {\n      o2 = JSON.parse(str);\n      return json_safe(o2, 0);\n    }\n  };\n\n  exports.obj_extract = obj_extract = function(o, keys) {\n    var k, ret, _i, _len;\n    ret = {};\n    for (_i = 0, _len = keys.length; _i < _len; _i++) {\n      k = keys[_i];\n      ret[k] = o[k];\n    }\n    return ret;\n  };\n\n  exports.base64u = {\n    encode: function(b) {\n      return b.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n    },\n    decode: function(b) {\n      b = (b + Array(5 - b.length % 4).join('=')).replace(/\\-/g, '+').replace(/\\_/g, '/');\n      return new Buffer(b, 'base64');\n    },\n    verify: function(b) {\n      return /^[A-Za-z0-9\\-_]+$/.test(b);\n    }\n  };\n\n  exports.assert_no_nulls = assert_no_nulls = function(v) {\n    var e, ok, _i, _len;\n    ok = true;\n    for (_i = 0, _len = v.length; _i < _len; _i++) {\n      e = v[_i];\n      if (e == null) {\n        ok = false;\n      }\n    }\n    if (!ok) {\n      console.error(\"Found 1 or more nulls in vector: \");\n      console.error(v);\n      return assert(false);\n    }\n  };\n\n  exports.athrow = function(err, cb) {\n    return cb(err);\n  };\n\n  exports.asyncify = asyncify = function(args, cb) {\n    return cb.apply(null, args);\n  };\n\n  exports.format_fingerprint = function(raw) {\n    var hex, i, parts;\n    hex = raw.toString('hex').toUpperCase();\n    parts = (function() {\n      var _i, _ref, _results;\n      _results = [];\n      for (i = _i = 0, _ref = hex.length; _i < _ref; i = _i += 4) {\n        _results.push(hex.slice(i, i + 4));\n      }\n      return _results;\n    })();\n    return parts.join(' ');\n  };\n\n  exports.format_pgp_fingerprint_2 = function(buf, opts) {\n    var hex, i, length, parts, spc;\n    if (opts == null) {\n      opts = {};\n    }\n    hex = buf.toString('hex');\n    length = (opts != null ? opts.length : void 0) || 40;\n    spc = (opts != null ? opts.space : void 0) || ' ';\n    hex = hex.toUpperCase().slice(-length);\n    if (hex.length === 40) {\n      parts = (function() {\n        var _i, _ref, _results;\n        _results = [];\n        for (i = _i = 0, _ref = hex.length; _i < _ref; i = _i += 4) {\n          _results.push(hex.slice(i, i + 4));\n        }\n        return _results;\n      })();\n      parts = (function() {\n        var _i, _ref, _results;\n        _results = [];\n        for (i = _i = 0, _ref = parts.length; _i < _ref; i = _i += 5) {\n          _results.push(parts.slice(i, i + 5).join(spc));\n        }\n        return _results;\n      })();\n      return parts.join(spc + spc);\n    } else if (hex.length > 8) {\n      parts = (function() {\n        var _i, _ref, _results;\n        _results = [];\n        for (i = _i = 0, _ref = hex.length; _i < _ref; i = _i += 4) {\n          _results.push(hex.slice(i, i + 4));\n        }\n        return _results;\n      })();\n      return parts.join(spc);\n    } else {\n      return hex;\n    }\n  };\n\n  exports.fingerprint_to_key_id_64 = function(fp) {\n    return fp.slice(-16);\n  };\n\n  exports.strip = strip = function(x) {\n    return x.split(/\\s+/).join('');\n  };\n\n  exports.trim = trim = function(x) {\n    var m;\n    if ((m = x != null ? x.match(/^\\s+(.*?)$/) : void 0)) {\n      x = m[1];\n    }\n    if ((m = x != null ? x.match(/^(.*?)\\s+$/) : void 0)) {\n      x = m[1];\n    }\n    return x;\n  };\n\n  exports.fpeq = function(fp1, fp2) {\n    return strip(fp1).toLowerCase() === strip(fp2).toLowerCase();\n  };\n\n  exports.xxd = xxd = function(buf, opts) {\n    var i, line, lines, p, pad, q, quartets, v;\n    if (opts == null) {\n      opts = {};\n    }\n    q = opts.q || 8;\n    p = opts.p || 7;\n    buf = buf.toString('hex');\n    quartets = (function() {\n      var _i, _ref, _results;\n      _results = [];\n      for (i = _i = 0, _ref = buf.length; _i < _ref; i = _i += 4) {\n        _results.push(buf.slice(i, i + 4));\n      }\n      return _results;\n    })();\n    lines = (function() {\n      var _i, _ref, _results;\n      _results = [];\n      for (i = _i = 0, _ref = quartets.length; q > 0 ? _i < _ref : _i > _ref; i = _i += q) {\n        _results.push(quartets.slice(i, i + q).join(' '));\n      }\n      return _results;\n    })();\n    pad = function(s, n) {\n      return ((function() {\n        var _i, _ref, _results;\n        _results = [];\n        for (_i = 0, _ref = n - s.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--) {\n          _results.push('0');\n        }\n        return _results;\n      })()).join('') + s;\n    };\n    v = (function() {\n      var _i, _len, _results;\n      _results = [];\n      for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {\n        line = lines[i];\n        _results.push(pad((i * 2 * q).toString(16), p) + \": \" + line);\n      }\n      return _results;\n    })();\n    return v.join(\"\\n\");\n  };\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"assert\":75,\"buffer\":80,\"iced-error\":115,\"iced-runtime\":118}],166:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-b\n(function() {\n  var NativeBuffer, PpBuffer, twos_compl_inv;\n\n  twos_compl_inv = require('./util').twos_compl_inv;\n\n  NativeBuffer = Buffer;\n\n  exports.PpBuffer = PpBuffer = (function() {\n    function PpBuffer(buf) {\n      if (buf == null) {\n        this._frozen_buf = null;\n        this._sub_buffers = [];\n        this._limits = [];\n        this._sz = 0x400;\n        this._small_buf_sz = 0x100;\n        this._logsz = 10;\n        this._i = 0;\n        this._tot = 0;\n      } else {\n        this._freeze_to(buf);\n      }\n    }\n\n    PpBuffer.prototype._nb = function() {\n      return this._sub_buffers.length;\n    };\n\n    PpBuffer.prototype._ab = function() {\n      return this._sub_buffers[this._nb() - 1];\n    };\n\n    PpBuffer.prototype._lib = function() {\n      return 0;\n    };\n\n    PpBuffer.prototype._finish_sub_buffer = function() {\n      this._limits.push(this._i);\n      return this._i = 0;\n    };\n\n    PpBuffer.prototype._push_sub_buffer = function(b) {\n      if (this._sub_buffers.length) {\n        this._finish_sub_buffer();\n      }\n      this._lib = function() {\n        return b.length - this._i;\n      };\n      this._sub_buffers.push(b);\n      return b;\n    };\n\n    PpBuffer.prototype._make_room = function() {\n      return this._push_sub_buffer(new NativeBuffer(this._sz));\n    };\n\n    PpBuffer.prototype._make_room_for_n_bytes = function(n) {\n      if (this._lib() < n) {\n        return this._make_room();\n      }\n    };\n\n    PpBuffer.prototype.push_uint8 = function(b) {\n      var n;\n      n = 1;\n      this._make_room_for_n_bytes(n);\n      this._ab().writeUInt8(b, this._i);\n      this._i += n;\n      return this._tot += n;\n    };\n\n    PpBuffer.prototype.push_int8 = function(b) {\n      var n;\n      n = 1;\n      this._make_room_for_n_bytes(n);\n      this._ab().writeInt8(b, this._i);\n      this._i += n;\n      return this._tot += n;\n    };\n\n    PpBuffer.prototype.push_uint16 = function(s) {\n      var n;\n      n = 2;\n      this._make_room_for_n_bytes(n);\n      this._ab().writeUInt16BE(s, this._i);\n      this._i += n;\n      return this._tot += n;\n    };\n\n    PpBuffer.prototype.push_uint32 = function(w) {\n      var n;\n      n = 4;\n      this._make_room_for_n_bytes(n);\n      this._ab().writeUInt32BE(w, this._i);\n      this._i += n;\n      return this._tot += n;\n    };\n\n    PpBuffer.prototype.push_int16 = function(s) {\n      var n;\n      n = 2;\n      this._make_room_for_n_bytes(n);\n      this._ab().writeInt16BE(s, this._i);\n      this._i += n;\n      return this._tot += n;\n    };\n\n    PpBuffer.prototype.push_int32 = function(w) {\n      var n;\n      n = 4;\n      this._make_room_for_n_bytes(n);\n      this._ab().writeInt32BE(w, this._i);\n      this._i += n;\n      return this._tot += n;\n    };\n\n    PpBuffer.prototype.push_float64 = function(f) {\n      var n;\n      n = 8;\n      this._make_room_for_n_bytes(n);\n      this._ab().writeDoubleBE(f, this._i);\n      this._i += n;\n      return this._tot += n;\n    };\n\n    PpBuffer.prototype.push_float32 = function(f) {\n      var n;\n      n = 4;\n      this._make_room_for_n_bytes(n);\n      this._ab().writeFloatBE(f, this._i);\n      this._i += n;\n      return this._tot += n;\n    };\n\n    PpBuffer.prototype.push_raw_bytes = function(s) {\n      return this.push_buffer(new NativeBuffer(s, 'binary'));\n    };\n\n    PpBuffer.prototype.prepare_utf8 = function(s) {\n      return new NativeBuffer(s, 'utf8');\n    };\n\n    PpBuffer.prototype.push_buffer = function(b) {\n      var diff, n;\n      if (b.length > this._small_buf_sz) {\n        this._push_sub_buffer(b);\n        this._i = b.length;\n        this._tot += b.length;\n      } else {\n        n = Math.min(b.length, this._lib());\n        if (n > 0) {\n          b.copy(this._ab(), this._i, 0, n);\n          this._i += n;\n          this._tot += n;\n        }\n        if (n < b.length) {\n          this._make_room();\n          b.copy(this._ab(), this._i, n, b.length);\n          diff = b.length - n;\n          this._i += diff;\n          this._tot += diff;\n        }\n      }\n      return this;\n    };\n\n    PpBuffer.prototype.freeze = function() {\n      var b, i, l, lst, _i, _len, _ref;\n      if (this._frozen_buf == null) {\n        this._finish_sub_buffer();\n        lst = [];\n        _ref = this._sub_buffers;\n        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n          b = _ref[i];\n          if ((l = this._limits[i]) === b.length) {\n            lst.push(b);\n          } else if (l > 0) {\n            lst.push(b.slice(0, l));\n          }\n        }\n        this._sub_buffers = [];\n        this._frozen_buf = NativeBuffer.concat(lst, this._tot);\n      }\n      return this._frozen_buf;\n    };\n\n    PpBuffer.prototype._freeze_to = function(b) {\n      this._frozen_buf = b;\n      this._tot = b.length;\n      this._sub_buffers = [];\n      this._cp = 0;\n      return this;\n    };\n\n    PpBuffer.prototype.bytes_left = function() {\n      return this._tot - this._cp;\n    };\n\n    PpBuffer.prototype._get = function(i) {\n      if (i < this._tot) {\n        return this._frozen_buf.readUInt8(i);\n      } else {\n        return 0;\n      }\n    };\n\n    PpBuffer.prototype.read_uint8 = function() {\n      return this._get(this._cp++);\n    };\n\n    PpBuffer.prototype.read_int8 = function() {\n      return twos_compl_inv(this.read_uint8(), 8);\n    };\n\n    PpBuffer.prototype.read_uint16 = function() {\n      var ret;\n      ret = this._frozen_buf.readUInt16BE(this._cp);\n      this._cp += 2;\n      return ret;\n    };\n\n    PpBuffer.prototype.read_uint32 = function() {\n      var ret;\n      ret = this._frozen_buf.readUInt32BE(this._cp);\n      this._cp += 4;\n      return ret;\n    };\n\n    PpBuffer.prototype.read_int16 = function() {\n      var ret;\n      ret = this._frozen_buf.readInt16BE(this._cp);\n      this._cp += 2;\n      return ret;\n    };\n\n    PpBuffer.prototype.read_int32 = function() {\n      var ret;\n      ret = this._frozen_buf.readInt32BE(this._cp);\n      this._cp += 4;\n      return ret;\n    };\n\n    PpBuffer.prototype.read_float64 = function() {\n      var ret;\n      ret = this._frozen_buf.readDoubleBE(this._cp);\n      this._cp += 8;\n      return ret;\n    };\n\n    PpBuffer.prototype.read_float32 = function() {\n      var ret;\n      ret = this._frozen_buf.readFloatBE(this._cp);\n      this._cp += 4;\n      return ret;\n    };\n\n    PpBuffer.prototype.read_buffer = function(n) {\n      var bl, e, ret;\n      bl = this.bytes_left();\n      if (n > bl) {\n        throw new Error(\"Corruption: asked for \" + n + \" bytes, but only \" + bl + \" available\");\n      }\n      e = this._cp + n;\n      ret = this._frozen_buf.slice(this._cp, e);\n      this._cp = e;\n      return ret;\n    };\n\n    PpBuffer.isBuffer = function(b) {\n      return NativeBuffer.isBuffer(b);\n    };\n\n    return PpBuffer;\n\n  })();\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./util\":172,\"buffer\":80}],167:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-b\n(function() {\n  exports.C = {\n    \"null\": 0xc0,\n    \"false\": 0xc2,\n    \"true\": 0xc3,\n    bin8: 0xc4,\n    bin16: 0xc5,\n    bin32: 0xc6,\n    ext8: 0xc7,\n    ext16: 0xc8,\n    ext32: 0xc9,\n    float: 0xca,\n    double: 0xcb,\n    uint8: 0xcc,\n    uint16: 0xcd,\n    uint32: 0xce,\n    uint64: 0xcf,\n    int8: 0xd0,\n    int16: 0xd1,\n    int32: 0xd2,\n    int64: 0xd3,\n    fix_ext1: 0xd4,\n    fix_ext2: 0xd5,\n    fix_ext4: 0xd6,\n    fix_ext8: 0xd7,\n    fix_ext16: 0xd8,\n    str8: 0xd9,\n    str16: 0xda,\n    str32: 0xdb,\n    array16: 0xdc,\n    array32: 0xdd,\n    map16: 0xde,\n    map32: 0xdf,\n    fix_str_min: 0xa0,\n    fix_str_max: 0xbf,\n    fix_array_min: 0x90,\n    fix_array_max: 0x9f,\n    fix_map_min: 0x80,\n    fix_map_max: 0x8f,\n    fix_array_count_mask: 0xf,\n    fix_map_count_mask: 0xf,\n    fix_str_count_mask: 0x1f,\n    negative_fix_min: 0xe0,\n    negative_fix_max: 0xff,\n    negative_fix_mask: 0x1f,\n    negative_fix_offset: 0x20,\n    positive_fix_max: 0x7f,\n    rpc_request: 0x00,\n    rpc_response: 0x01,\n    rpc_notify: 0x02\n  };\n\n}).call(this);\n\n},{}],168:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-b\n(function() {\n  var C, frame_len, pack, unpack;\n\n  pack = require('./pack').pack;\n\n  unpack = require('./unpack').unpack;\n\n  C = require('./const').C;\n\n  exports.pack = function(x, opts) {\n    var b1, b2;\n    if (opts == null) {\n      opts = {};\n    }\n    b2 = pack(x, opts);\n    b1 = pack(b2.length);\n    return Buffer.concat([b1, b2]);\n  };\n\n  exports.frame_len = frame_len = function(c) {\n    if (c <= C.positive_fix_max) {\n      return 1;\n    } else if (c === C.uint8) {\n      return 2;\n    } else if (c === C.uint16) {\n      return 3;\n    } else if (c === C.uint32) {\n      return 5;\n    } else {\n      return 0;\n    }\n  };\n\n  exports.unpack = function(x, opts) {\n    var buf, c, flen, plen, rem, ret;\n    if (opts == null) {\n      opts = {};\n    }\n    if (x.length < 1) {\n      throw new Error(\"need a buffer > 1 bytes\");\n    }\n    c = x.readUInt8(0);\n    flen = frame_len(c);\n    if (flen === 0) {\n      throw new Error(\"no data frame found\");\n    }\n    if (x.length < flen) {\n      throw new Error(\"not enough bytes to read frame: \" + x.length + \" < \" + flen);\n    }\n    buf = x.slice(0, flen);\n    plen = unpack(buf);\n    x = x.slice(flen);\n    if (x.length < plen) {\n      throw new Error(\"not enough bytes to unframe: \" + x.length + \" < \" + plen);\n    }\n    rem = x.slice(plen);\n    x = x.slice(0, plen);\n    ret = unpack(x);\n    return [ret, rem];\n  };\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./const\":167,\"./pack\":170,\"./unpack\":171,\"buffer\":80}],169:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-b\n(function() {\n  exports.pack = require('./pack').pack;\n\n  exports.unpack = require('./unpack').unpack;\n\n  exports.Buffer = require('./buffer').PpBuffer;\n\n  exports.frame = require('./frame');\n\n}).call(this);\n\n},{\"./buffer\":166,\"./frame\":168,\"./pack\":170,\"./unpack\":171}],170:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-b\n(function() {\n  var C, Packer, PpBuffer, U32MAX, is_array, is_int, u64max_minus_i;\n\n  C = require('./const').C;\n\n  PpBuffer = require('./buffer').PpBuffer;\n\n  U32MAX = require('./util').U32MAX;\n\n  is_array = function(x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n\n  is_int = function(f) {\n    return Math.floor(f) === f;\n  };\n\n  u64max_minus_i = function(i) {\n    var a, b, x, y;\n    x = Math.floor(i / U32MAX);\n    y = i % U32MAX;\n    a = U32MAX - x - (y > 0 ? 1 : 0);\n    b = y === 0 ? 0 : U32MAX - y;\n    return [a, b];\n  };\n\n  exports.Packer = Packer = (function() {\n    function Packer(_opts) {\n      this._opts = _opts != null ? _opts : {};\n      this._buffer = new PpBuffer();\n    }\n\n    Packer.prototype.output = function() {\n      return this._buffer.freeze();\n    };\n\n    Packer.prototype.p = function(o) {\n      switch (typeof o) {\n        case 'number':\n          return this.p_number(o);\n        case 'string':\n          return this.p_str(o);\n        case 'boolean':\n          return this.p_boolean(o);\n        case 'undefined':\n          return this.p_null();\n        case 'object':\n          if (o == null) {\n            return this.p_null();\n          } else if (is_array(o)) {\n            return this.p_array(o);\n          } else if (PpBuffer.isBuffer(o)) {\n            return this.p_bin(o);\n          } else if (!this.p_ext(o)) {\n            return this.p_obj(o);\n          }\n      }\n    };\n\n    Packer.prototype.p_number = function(n) {\n      if (!is_int(n)) {\n        return this.p_pack_double(n);\n      } else if (n >= 0) {\n        return this.p_positive_int(n);\n      } else {\n        return this.p_negative_int(n);\n      }\n    };\n\n    Packer.prototype.p_pack_double = function(d) {\n      if (this._opts.floats != null) {\n        this.p_uint8(C.float);\n        return this._buffer.push_float32(d);\n      } else {\n        this.p_uint8(C.double);\n        return this._buffer.push_float64(d);\n      }\n    };\n\n    Packer.prototype.p_uint8 = function(b) {\n      return this._buffer.push_uint8(b);\n    };\n\n    Packer.prototype.p_uint16 = function(s) {\n      return this._buffer.push_uint16(s);\n    };\n\n    Packer.prototype.p_uint32 = function(w) {\n      return this._buffer.push_uint32(w);\n    };\n\n    Packer.prototype.p_int8 = function(b) {\n      return this._buffer.push_int8(b);\n    };\n\n    Packer.prototype.p_int16 = function(s) {\n      return this._buffer.push_int16(s);\n    };\n\n    Packer.prototype.p_int32 = function(w) {\n      return this._buffer.push_int32(w);\n    };\n\n    Packer.prototype.p_neg_int64 = function(i) {\n      var a, abs_i, b, _ref;\n      abs_i = 0 - i;\n      _ref = u64max_minus_i(abs_i), a = _ref[0], b = _ref[1];\n      this.p_uint32(a);\n      return this.p_uint32(b);\n    };\n\n    Packer.prototype.p_boolean = function(b) {\n      return this.p_uint8(b ? C[\"true\"] : C[\"false\"]);\n    };\n\n    Packer.prototype.p_null = function() {\n      return this.p_uint8(C[\"null\"]);\n    };\n\n    Packer.prototype.p_array = function(a) {\n      var e, _i, _len, _results;\n      this.p_len(a.length, C.fix_array_min, C.fix_array_max, C.array16, C.array32);\n      _results = [];\n      for (_i = 0, _len = a.length; _i < _len; _i++) {\n        e = a[_i];\n        _results.push(this.p(e));\n      }\n      return _results;\n    };\n\n    Packer.prototype.p_obj = function(o) {\n      var k, keys, n, _i, _len, _results;\n      keys = Object.keys(o);\n      n = keys.length;\n      this.p_len(n, C.fix_map_min, C.fix_map_max, C.map16, C.map32);\n      if (this._opts.sort_keys) {\n        keys.sort();\n      }\n      _results = [];\n      for (_i = 0, _len = keys.length; _i < _len; _i++) {\n        k = keys[_i];\n        this.p(k);\n        _results.push(this.p(o[k]));\n      }\n      return _results;\n    };\n\n    Packer.prototype.p_positive_int = function(i) {\n      if (i <= 0x7f) {\n        return this.p_uint8(i);\n      } else if (i <= 0xff) {\n        this.p_uint8(C.uint8);\n        return this.p_uint8(i);\n      } else if (i <= 0xffff) {\n        this.p_uint8(C.uint16);\n        return this.p_uint16(i);\n      } else if (i < U32MAX) {\n        this.p_uint8(C.uint32);\n        return this.p_uint32(i);\n      } else {\n        this.p_uint8(C.uint64);\n        this.p_uint32(Math.floor(i / U32MAX));\n        return this.p_uint32(i % U32MAX);\n      }\n    };\n\n    Packer.prototype.p_negative_int = function(i) {\n      if (i >= -32) {\n        return this.p_int8(i);\n      } else if (i >= -128) {\n        this.p_uint8(C.int8);\n        return this.p_int8(i);\n      } else if (i >= -32768) {\n        this.p_uint8(C.int16);\n        return this.p_int16(i);\n      } else if (i >= -2147483648) {\n        this.p_uint8(C.int32);\n        return this.p_int32(i);\n      } else {\n        this.p_uint8(C.int64);\n        return this.p_neg_int64(i);\n      }\n    };\n\n    Packer.prototype.p_buffer = function(b) {\n      return this._buffer.push_buffer(b);\n    };\n\n    Packer.prototype.p_bin = function(r) {\n      this.p_len(r.length, null, null, C.bin16, C.bin32, C.bin8);\n      return this.p_buffer(r);\n    };\n\n    Packer.prototype.p_str = function(s) {\n      var b, str8;\n      b = this._buffer.prepare_utf8(s);\n      str8 = this._opts.no_str8 ? null : C.str8;\n      this.p_len(b.length, C.fix_str_min, C.fix_str_max, C.str16, C.str32, str8);\n      return this.p_buffer(b);\n    };\n\n    Packer.prototype.p_len = function(l, fixmin, fixmax, m, b, s) {\n      if (s == null) {\n        s = null;\n      }\n      if ((fixmin != null) && (fixmax != null) && l <= (fixmax - fixmin)) {\n        return this.p_uint8(l | fixmin);\n      } else if ((s != null) && l <= 0xff) {\n        this.p_uint8(s);\n        return this.p_uint8(l);\n      } else if (l <= 0xffff) {\n        this.p_uint8(m);\n        return this.p_uint16(l);\n      } else {\n        this.p_uint8(b);\n        return this.p_uint32(l);\n      }\n    };\n\n    Packer.prototype.p_ext = function(o) {\n      var buf, l, ret, type;\n      if (this._opts.ext == null) {\n        return false;\n      } else if (!(ret = this._opts.ext(o))) {\n        return false;\n      } else {\n        type = ret[0], buf = ret[1];\n        switch ((l = buf.length)) {\n          case 1:\n            this.p_uint8(C.fix_ext1);\n            break;\n          case 2:\n            this.p_uint8(C.fix_ext2);\n            break;\n          case 4:\n            this.p_uint8(C.fix_ext4);\n            break;\n          case 8:\n            this.p_uint8(C.fix_ext8);\n            break;\n          case 16:\n            this.p_uint8(C.fix_ext16);\n            break;\n          default:\n            if (l <= 0xff) {\n              this.p_uint8(C.ext8);\n              this.p_uint8(l);\n            } else if (l <= 0xffff) {\n              this.p_uint8(C.ext16);\n              this.p_uint16(l);\n            } else {\n              this.p_uint8(C.ext32);\n              this.p_uint32(l);\n            }\n        }\n        this.p_uint8(type);\n        this.p_buffer(buf);\n        return true;\n      }\n    };\n\n    return Packer;\n\n  })();\n\n  exports.pack = function(x, opts) {\n    var packer;\n    if (opts == null) {\n      opts = {};\n    }\n    packer = new Packer(opts);\n    packer.p(x);\n    return packer.output();\n  };\n\n}).call(this);\n\n},{\"./buffer\":166,\"./const\":167,\"./util\":172}],171:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-b\n(function() {\n  var C, PpBuffer, U32MAX, Unpacker, default_ext, modes, pow2, twos_compl_inv, _ref;\n\n  C = require('./const').C;\n\n  PpBuffer = require('./buffer').PpBuffer;\n\n  _ref = require('./util'), pow2 = _ref.pow2, twos_compl_inv = _ref.twos_compl_inv, U32MAX = _ref.U32MAX;\n\n  modes = {\n    NONE: 0,\n    BINARY: 1,\n    START: 2\n  };\n\n  default_ext = function(type, raw) {\n    return {\n      type: type,\n      raw: raw\n    };\n  };\n\n  exports.Unpacker = Unpacker = (function() {\n    function Unpacker(b, _opts) {\n      this._opts = _opts != null ? _opts : {};\n      this._buffer = new PpBuffer(b);\n      this._ext = this._opts.ext || (this._opts.no_ext ? null : default_ext);\n    }\n\n    Unpacker.prototype.u_buf = function(n) {\n      return this._buffer.read_buffer(n);\n    };\n\n    Unpacker.prototype.u_str = function(n) {\n      return this.u_buf(n).toString('utf8');\n    };\n\n    Unpacker.prototype.u_bin = function(n) {\n      return this.u_buf(n);\n    };\n\n    Unpacker.prototype.u_ext = function(n) {\n      var buf, typ;\n      typ = this.u_uint8();\n      buf = this.u_buf(n);\n      if (this._opts.ext != null) {\n        return this._opts.ext(typ, buf);\n      } else {\n        throw new Error(\"No ext hook but got message type: \" + typ);\n      }\n    };\n\n    Unpacker.prototype.u_array = function(n) {\n      var i, _i, _results;\n      _results = [];\n      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {\n        _results.push(this.u());\n      }\n      return _results;\n    };\n\n    Unpacker.prototype.u_map = function(n) {\n      var i, ret, _i;\n      ret = {};\n      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {\n        ret[this.u()] = this.u();\n      }\n      return ret;\n    };\n\n    Unpacker.prototype.u_uint8 = function() {\n      return this._buffer.read_uint8();\n    };\n\n    Unpacker.prototype.u_uint16 = function() {\n      return this._buffer.read_uint16();\n    };\n\n    Unpacker.prototype.u_uint32 = function() {\n      return this._buffer.read_uint32();\n    };\n\n    Unpacker.prototype.u_int8 = function() {\n      return this._buffer.read_int8();\n    };\n\n    Unpacker.prototype.u_int16 = function() {\n      return this._buffer.read_int16();\n    };\n\n    Unpacker.prototype.u_int32 = function() {\n      return this._buffer.read_int32();\n    };\n\n    Unpacker.prototype.u_uint64 = function() {\n      return (this.u_uint32() * U32MAX) + this.u_uint32();\n    };\n\n    Unpacker.prototype.u_double = function() {\n      return this._buffer.read_float64();\n    };\n\n    Unpacker.prototype.u_float = function() {\n      return this._buffer.read_float32();\n    };\n\n    Unpacker.prototype.u_int64 = function() {\n      var a, b, i, _ref1;\n      _ref1 = (function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; _i < 2; i = ++_i) {\n          _results.push(this.u_uint32());\n        }\n        return _results;\n      }).call(this), a = _ref1[0], b = _ref1[1];\n      return U32MAX * (a - U32MAX) + b;\n    };\n\n    Unpacker.prototype.u = function() {\n      var b, l;\n      if ((b = this.u_uint8()) <= C.positive_fix_max) {\n        return b;\n      } else if (b >= C.negative_fix_min && b <= C.negative_fix_max) {\n        return twos_compl_inv(b, 8);\n      } else if (b >= C.fix_str_min && b <= C.fix_str_max) {\n        l = b & C.fix_str_count_mask;\n        return this.u_str(l);\n      } else if (b >= C.fix_array_min && b <= C.fix_array_max) {\n        l = b & C.fix_array_count_mask;\n        return this.u_array(l);\n      } else if (b >= C.fix_map_min && b <= C.fix_map_max) {\n        l = b & C.fix_map_count_mask;\n        return this.u_map(l);\n      } else {\n        switch (b) {\n          case C[\"null\"]:\n            return null;\n          case C[\"true\"]:\n            return true;\n          case C[\"false\"]:\n            return false;\n          case C.uint8:\n            return this.u_uint8();\n          case C.uint16:\n            return this.u_uint16();\n          case C.uint32:\n            return this.u_uint32();\n          case C.uint64:\n            return this.u_uint64();\n          case C.int8:\n            return this.u_int8();\n          case C.int16:\n            return this.u_int16();\n          case C.int32:\n            return this.u_int32();\n          case C.int64:\n            return this.u_int64();\n          case C.double:\n            return this.u_double();\n          case C.float:\n            return this.u_float();\n          case C.str8:\n            return this.u_str(this.u_uint8());\n          case C.str16:\n            return this.u_str(this.u_uint16());\n          case C.str32:\n            return this.u_str(this.u_uint32());\n          case C.bin8:\n            return this.u_bin(this.u_uint8());\n          case C.bin16:\n            return this.u_bin(this.u_uint16());\n          case C.bin32:\n            return this.u_bin(this.u_uint32());\n          case C.array16:\n            return this.u_array(this.u_uint16());\n          case C.array32:\n            return this.u_array(this.u_uint32());\n          case C.map16:\n            return this.u_map(this.u_uint16());\n          case C.map32:\n            return this.u_map(this.u_uint32());\n          case C.fix_ext1:\n            return this.u_ext(1);\n          case C.fix_ext2:\n            return this.u_ext(2);\n          case C.fix_ext4:\n            return this.u_ext(4);\n          case C.fix_ext8:\n            return this.u_ext(8);\n          case C.fix_ext16:\n            return this.u_ext(16);\n          case C.ext8:\n            return this.u_ext(this.u_uint8());\n          case C.ext16:\n            return this.u_ext(this.u_uint16());\n          case C.ext32:\n            return this.u_ext(this.u_uint32());\n          default:\n            throw new Error(\"unhandled type \" + b);\n        }\n      }\n    };\n\n    return Unpacker;\n\n  })();\n\n  exports.unpack = function(x, opts) {\n    var unpacker;\n    if (opts == null) {\n      opts = {};\n    }\n    unpacker = new Unpacker(x, opts);\n    return unpacker.u();\n  };\n\n}).call(this);\n\n},{\"./buffer\":166,\"./const\":167,\"./util\":172}],172:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-b\n(function() {\n  var U32MAX, pow2;\n\n  exports.pow2 = pow2 = function(n) {\n    if (n < 31) {\n      return 1 << n;\n    } else {\n      return Math.pow(2, n);\n    }\n  };\n\n  exports.U32MAX = U32MAX = pow2(32);\n\n  exports.rshift = function(b, n) {\n    if (n < 31) {\n      return b >> n;\n    } else {\n      return Math.floor(b / Math.pow(2, n));\n    }\n  };\n\n  exports.twos_compl = function(x, n) {\n    if (x < 0) {\n      return pow2(n) - Math.abs(x);\n    } else {\n      return x;\n    }\n  };\n\n  exports.twos_compl_inv = function(x, n) {\n    return x - pow2(n);\n  };\n\n}).call(this);\n\n},{}],173:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var AES, BlockCipher, G, Global, scrub_vec,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  BlockCipher = require('./algbase').BlockCipher;\n\n  scrub_vec = require('./util').scrub_vec;\n\n  Global = (function() {\n    function Global() {\n      var i;\n      this.SBOX = [];\n      this.INV_SBOX = [];\n      this.SUB_MIX = (function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; _i < 4; i = ++_i) {\n          _results.push([]);\n        }\n        return _results;\n      })();\n      this.INV_SUB_MIX = (function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; _i < 4; i = ++_i) {\n          _results.push([]);\n        }\n        return _results;\n      })();\n      this.init();\n      this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n    }\n\n    Global.prototype.init = function() {\n      var d, i, sx, t, x, x2, x4, x8, xi, _i;\n      d = (function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; _i < 256; i = ++_i) {\n          if (i < 128) {\n            _results.push(i << 1);\n          } else {\n            _results.push((i << 1) ^ 0x11b);\n          }\n        }\n        return _results;\n      })();\n      x = 0;\n      xi = 0;\n      for (i = _i = 0; _i < 256; i = ++_i) {\n        sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n        sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n        this.SBOX[x] = sx;\n        this.INV_SBOX[sx] = x;\n        x2 = d[x];\n        x4 = d[x2];\n        x8 = d[x4];\n        t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n        this.SUB_MIX[0][x] = (t << 24) | (t >>> 8);\n        this.SUB_MIX[1][x] = (t << 16) | (t >>> 16);\n        this.SUB_MIX[2][x] = (t << 8) | (t >>> 24);\n        this.SUB_MIX[3][x] = t;\n        t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n        this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8);\n        this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16);\n        this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24);\n        this.INV_SUB_MIX[3][sx] = t;\n        if (x === 0) {\n          x = xi = 1;\n        } else {\n          x = x2 ^ d[d[d[x8 ^ x2]]];\n          xi ^= d[d[xi]];\n        }\n      }\n      return true;\n    };\n\n    return Global;\n\n  })();\n\n  G = new Global();\n\n  AES = (function(_super) {\n    __extends(AES, _super);\n\n    AES.blockSize = 4 * 4;\n\n    AES.prototype.blockSize = AES.blockSize;\n\n    AES.keySize = 256 / 8;\n\n    AES.prototype.keySize = AES.keySize;\n\n    AES.ivSize = AES.blockSize;\n\n    AES.prototype.ivSize = AES.ivSize;\n\n    function AES(key) {\n      this._key = key.clone();\n      this._doReset();\n    }\n\n    AES.prototype._doReset = function() {\n      var invKsRow, keySize, keyWords, ksRow, ksRows, t, _i, _j;\n      keyWords = this._key.words;\n      keySize = this._key.sigBytes / 4;\n      this._nRounds = keySize + 6;\n      ksRows = (this._nRounds + 1) * 4;\n      this._keySchedule = [];\n      for (ksRow = _i = 0; 0 <= ksRows ? _i < ksRows : _i > ksRows; ksRow = 0 <= ksRows ? ++_i : --_i) {\n        this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t);\n      }\n      this._invKeySchedule = [];\n      for (invKsRow = _j = 0; 0 <= ksRows ? _j < ksRows : _j > ksRows; invKsRow = 0 <= ksRows ? ++_j : --_j) {\n        ksRow = ksRows - invKsRow;\n        t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)];\n        this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]];\n      }\n      return true;\n    };\n\n    AES.prototype.encryptBlock = function(M, offset) {\n      if (offset == null) {\n        offset = 0;\n      }\n      return this._doCryptBlock(M, offset, this._keySchedule, G.SUB_MIX, G.SBOX);\n    };\n\n    AES.prototype.decryptBlock = function(M, offset) {\n      var _ref, _ref1;\n      if (offset == null) {\n        offset = 0;\n      }\n      _ref = [M[offset + 3], M[offset + 1]], M[offset + 1] = _ref[0], M[offset + 3] = _ref[1];\n      this._doCryptBlock(M, offset, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX);\n      return _ref1 = [M[offset + 3], M[offset + 1]], M[offset + 1] = _ref1[0], M[offset + 3] = _ref1[1], _ref1;\n    };\n\n    AES.prototype.scrub = function() {\n      scrub_vec(this._keySchedule);\n      scrub_vec(this._invKeySchedule);\n      return this._key.scrub();\n    };\n\n    AES.prototype._doCryptBlock = function(M, offset, keySchedule, SUB_MIX, SBOX) {\n      var ksRow, round, s0, s1, s2, s3, t0, t1, t2, t3, _i, _ref;\n      s0 = M[offset] ^ keySchedule[0];\n      s1 = M[offset + 1] ^ keySchedule[1];\n      s2 = M[offset + 2] ^ keySchedule[2];\n      s3 = M[offset + 3] ^ keySchedule[3];\n      ksRow = 4;\n      for (round = _i = 1, _ref = this._nRounds; 1 <= _ref ? _i < _ref : _i > _ref; round = 1 <= _ref ? ++_i : --_i) {\n        t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++];\n        t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++];\n        t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++];\n        t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++];\n        s0 = t0;\n        s1 = t1;\n        s2 = t2;\n        s3 = t3;\n      }\n      t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];\n      t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];\n      t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];\n      t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];\n      M[offset] = t0;\n      M[offset + 1] = t1;\n      M[offset + 2] = t2;\n      return M[offset + 3] = t3;\n    };\n\n    return AES;\n\n  })(BlockCipher);\n\n  exports.AES = AES;\n\n}).call(this);\n\n},{\"./algbase\":174,\"./util\":195}],174:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var BlockCipher, BufferedBlockAlgorithm, Hasher, StreamCipher, WordArray, util,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  WordArray = require('./wordarray').WordArray;\n\n  util = require('./util');\n\n  BufferedBlockAlgorithm = (function() {\n    BufferedBlockAlgorithm.prototype._minBufferSize = 0;\n\n    function BufferedBlockAlgorithm() {\n      this.reset();\n    }\n\n    BufferedBlockAlgorithm.prototype.reset = function() {\n      this._data = new WordArray();\n      return this._nDataBytes = 0;\n    };\n\n    BufferedBlockAlgorithm.prototype._append = function(data) {\n      this._data.concat(data);\n      return this._nDataBytes += data.sigBytes;\n    };\n\n    BufferedBlockAlgorithm.prototype._process = function(doFlush) {\n      var blockSizeBytes, data, dataSigBytes, dataWords, nBlocksReady, nBytesReady, nWordsReady, offset, processedWords, _i, _ref;\n      data = this._data;\n      dataWords = data.words;\n      dataSigBytes = data.sigBytes;\n      blockSizeBytes = this.blockSize * 4;\n      nBlocksReady = dataSigBytes / blockSizeBytes;\n      if (doFlush) {\n        nBlocksReady = Math.ceil(nBlocksReady);\n      } else {\n        nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n      }\n      nWordsReady = nBlocksReady * this.blockSize;\n      nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n      if (nWordsReady) {\n        for (offset = _i = 0, _ref = this.blockSize; _ref > 0 ? _i < nWordsReady : _i > nWordsReady; offset = _i += _ref) {\n          this._doProcessBlock(dataWords, offset);\n        }\n        processedWords = dataWords.splice(0, nWordsReady);\n        data.sigBytes -= nBytesReady;\n      }\n      return new WordArray(processedWords, nBytesReady);\n    };\n\n    BufferedBlockAlgorithm.prototype.copy_to = function(out) {\n      out._data = this._data.clone();\n      return out._nDataBytes = this._nDataBytes;\n    };\n\n    BufferedBlockAlgorithm.prototype.clone = function() {\n      var obj;\n      obj = new BufferedBlockAlgorithm();\n      this.copy_to(obj);\n      return obj;\n    };\n\n    return BufferedBlockAlgorithm;\n\n  })();\n\n  Hasher = (function(_super) {\n    __extends(Hasher, _super);\n\n    function Hasher() {\n      Hasher.__super__.constructor.call(this);\n    }\n\n    Hasher.prototype.reset = function() {\n      Hasher.__super__.reset.call(this);\n      this._doReset();\n      return this;\n    };\n\n    Hasher.prototype.update = function(messageUpdate) {\n      this._append(messageUpdate);\n      this._process();\n      return this;\n    };\n\n    Hasher.prototype.finalize = function(messageUpdate) {\n      if (messageUpdate) {\n        this._append(messageUpdate);\n      }\n      return this._doFinalize();\n    };\n\n    Hasher.prototype.bufhash = function(input) {\n      var out, wa_in, wa_out;\n      wa_in = WordArray.from_buffer(input);\n      wa_out = this.finalize(wa_in);\n      out = wa_out.to_buffer();\n      wa_in.scrub();\n      wa_out.scrub();\n      return out;\n    };\n\n    return Hasher;\n\n  })(BufferedBlockAlgorithm);\n\n  exports.BlockCipher = BlockCipher = (function() {\n    function BlockCipher(key) {}\n\n    BlockCipher.prototype.encryptBlock = function(M, offset) {};\n\n    return BlockCipher;\n\n  })();\n\n  StreamCipher = (function() {\n    function StreamCipher() {}\n\n    StreamCipher.prototype.encryptBlock = function(word_array, dst_offset) {\n      var n_words, pad;\n      if (dst_offset == null) {\n        dst_offset = 0;\n      }\n      pad = this.get_pad();\n      n_words = Math.min(word_array.words.length - dst_offset, this.bsiw);\n      word_array.xor(pad, {\n        dst_offset: dst_offset,\n        n_words: n_words\n      });\n      pad.scrub();\n      return this.bsiw;\n    };\n\n    StreamCipher.prototype.encrypt = function(word_array) {\n      var i, _i, _ref, _ref1;\n      for (i = _i = 0, _ref = word_array.words.length, _ref1 = this.bsiw; _ref1 > 0 ? _i < _ref : _i > _ref; i = _i += _ref1) {\n        this.encryptBlock(word_array, i);\n      }\n      return word_array;\n    };\n\n    StreamCipher.prototype.bulk_encrypt = function(_arg, cb) {\n      var async_args, input, progress_hook, slice_args, what;\n      input = _arg.input, progress_hook = _arg.progress_hook, what = _arg.what;\n      slice_args = {\n        update: (function(_this) {\n          return function(lo, hi) {\n            var i, _i, _ref, _results;\n            _results = [];\n            for (i = _i = lo, _ref = _this.bsiw; _ref > 0 ? _i < hi : _i > hi; i = _i += _ref) {\n              _results.push(_this.encryptBlock(input, i));\n            }\n            return _results;\n          };\n        })(this),\n        finalize: function() {\n          return input;\n        },\n        default_n: this.bsiw * 1024\n      };\n      async_args = {\n        progress_hook: progress_hook,\n        cb: cb,\n        what: what\n      };\n      return util.bulk(input.sigBytes, slice_args, async_args);\n    };\n\n    return StreamCipher;\n\n  })();\n\n  exports.BlockCipher = BlockCipher;\n\n  exports.Hasher = Hasher;\n\n  exports.BufferedBlockAlgorithm = BufferedBlockAlgorithm;\n\n  exports.StreamCipher = StreamCipher;\n\n}).call(this);\n\n},{\"./util\":195,\"./wordarray\":196}],175:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var CombineBase, Concat, HMAC, SHA3, SHA512, WordArray, XOR, bulk_sign, _ref,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  _ref = require('./hmac'), HMAC = _ref.HMAC, bulk_sign = _ref.bulk_sign;\n\n  SHA512 = require('./sha512').SHA512;\n\n  SHA3 = require('./sha3').SHA3;\n\n  WordArray = require('./wordarray').WordArray;\n\n  CombineBase = (function() {\n    function CombineBase() {\n      this.hasherBlockSize = this.hashers[0].hasherBlockSize;\n      this.hasherBlockSizeBytes = this.hasherBlockSize * 4;\n      this.reset();\n    }\n\n    CombineBase.prototype.reset = function() {\n      var h, _i, _len, _ref1;\n      _ref1 = this.hashers;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        h = _ref1[_i];\n        h.reset();\n      }\n      return this;\n    };\n\n    CombineBase.prototype.update = function(w) {\n      var h, _i, _len, _ref1;\n      _ref1 = this.hashers;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        h = _ref1[_i];\n        h.update(w);\n      }\n      return this;\n    };\n\n    CombineBase.prototype.scrub = function() {\n      var h, _i, _len, _ref1;\n      _ref1 = this.hashers;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        h = _ref1[_i];\n        h.scrub();\n      }\n      return this;\n    };\n\n    CombineBase.prototype.finalize = function(w) {\n      var h, hashes, out, _i, _len, _ref1;\n      hashes = (function() {\n        var _i, _len, _ref1, _results;\n        _ref1 = this.hashers;\n        _results = [];\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          h = _ref1[_i];\n          _results.push(h.finalize(w));\n        }\n        return _results;\n      }).call(this);\n      out = hashes[0];\n      _ref1 = hashes.slice(1);\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        h = _ref1[_i];\n        this._coalesce(out, h);\n        h.scrub();\n      }\n      return out;\n    };\n\n    return CombineBase;\n\n  })();\n\n  Concat = (function(_super) {\n    __extends(Concat, _super);\n\n    function Concat(key, klasses) {\n      var hm, i, klass, subkey, subkeys;\n      if (klasses == null) {\n        klasses = [SHA512, SHA3];\n      }\n      subkeys = key.split(klasses.length);\n      this.hashers = (function() {\n        var _i, _len, _results;\n        _results = [];\n        for (i = _i = 0, _len = klasses.length; _i < _len; i = ++_i) {\n          klass = klasses[i];\n          subkey = subkeys[i];\n          hm = new HMAC(subkey, klass);\n          subkey.scrub();\n          _results.push(hm);\n        }\n        return _results;\n      })();\n      Concat.__super__.constructor.call(this);\n    }\n\n    Concat.get_output_size = function() {\n      return SHA512.output_size + SHA3.output_size;\n    };\n\n    Concat.prototype._coalesce = function(out, h) {\n      return out.concat(h);\n    };\n\n    Concat.prototype.get_output_size = function() {\n      var h, tot, _i, _len, _ref1;\n      tot = 0;\n      _ref1 = this.hashers;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        h = _ref1[_i];\n        tot += h.get_output_size();\n      }\n      return tot;\n    };\n\n    Concat.sign = function(_arg) {\n      var input, key;\n      key = _arg.key, input = _arg.input;\n      return (new Concat(key)).finalize(input);\n    };\n\n    Concat.bulk_sign = function(args, cb) {\n      args.klass = Concat;\n      args.what = \"HMAC-SHA512-SHA3\";\n      return bulk_sign(args, cb);\n    };\n\n    return Concat;\n\n  })(CombineBase);\n\n  XOR = (function(_super) {\n    __extends(XOR, _super);\n\n    function XOR(key, klasses) {\n      var klass;\n      if (klasses == null) {\n        klasses = [SHA512, SHA3];\n      }\n      this.hashers = (function() {\n        var _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = klasses.length; _i < _len; _i++) {\n          klass = klasses[_i];\n          _results.push(new HMAC(key, klass));\n        }\n        return _results;\n      })();\n      XOR.__super__.constructor.call(this);\n    }\n\n    XOR.prototype.reset = function() {\n      var h, i, _i, _len, _ref1;\n      XOR.__super__.reset.call(this);\n      _ref1 = this.hashers;\n      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {\n        h = _ref1[i];\n        h.update(new WordArray([i]));\n      }\n      return this;\n    };\n\n    XOR.get_output_size = function() {\n      return Math.max(SHA512.output_size, SHA3.output_size);\n    };\n\n    XOR.prototype._coalesce = function(out, h) {\n      return out.xor(h, {});\n    };\n\n    XOR.prototype.get_output_size = function() {\n      var h;\n      return Math.max.apply(Math, (function() {\n        var _i, _len, _ref1, _results;\n        _ref1 = this.hashers;\n        _results = [];\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          h = _ref1[_i];\n          _results.push(h.get_output_size());\n        }\n        return _results;\n      }).call(this));\n    };\n\n    XOR.sign = function(_arg) {\n      var input, key;\n      key = _arg.key, input = _arg.input;\n      return (new XOR(key)).finalize(input);\n    };\n\n    XOR.bulk_sign = function(arg, cb) {\n      arg.klass = XOR;\n      arg.what = \"HMAC-SHA512-XOR-SHA3\";\n      return bulk_sign(arg, cb);\n    };\n\n    return XOR;\n\n  })(CombineBase);\n\n  exports.Concat = Concat;\n\n  exports.XOR = XOR;\n\n}).call(this);\n\n},{\"./hmac\":180,\"./sha3\":191,\"./sha512\":193,\"./wordarray\":196}],176:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var Cipher, Counter, StreamCipher, WordArray, bulk_encrypt, encrypt, iced, __iced_k, __iced_k_noop,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  WordArray = require('./wordarray').WordArray;\n\n  StreamCipher = require('./algbase').StreamCipher;\n\n  Counter = (function() {\n    Counter.prototype.WORD_MAX = 0xffffffff;\n\n    function Counter(_arg) {\n      var i, len, value;\n      value = _arg.value, len = _arg.len;\n      this._value = value != null ? value.clone() : (len == null ? len = 2 : void 0, new WordArray((function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {\n          _results.push(0);\n        }\n        return _results;\n      })()));\n    }\n\n    Counter.prototype.inc = function() {\n      var go, i;\n      go = true;\n      i = this._value.words.length - 1;\n      while (go && i >= 0) {\n        if ((++this._value.words[i]) > Counter.WORD_MAX) {\n          this._value.words[i] = 0;\n        } else {\n          go = false;\n        }\n        i--;\n      }\n      return this;\n    };\n\n    Counter.prototype.inc_le = function() {\n      var go, i;\n      go = true;\n      i = 0;\n      while (go && i < this._value.words.length) {\n        if ((++this._value.words[i]) > Counter.WORD_MAX) {\n          this._value.words[i] = 0;\n        } else {\n          go = false;\n        }\n        i++;\n      }\n      return this;\n    };\n\n    Counter.prototype.get = function() {\n      return this._value;\n    };\n\n    Counter.prototype.copy = function() {\n      return this._value.clone();\n    };\n\n    return Counter;\n\n  })();\n\n  Cipher = (function(_super) {\n    __extends(Cipher, _super);\n\n    function Cipher(_arg) {\n      this.block_cipher = _arg.block_cipher, this.iv = _arg.iv;\n      Cipher.__super__.constructor.call(this);\n      this.bsiw = this.block_cipher.blockSize / 4;\n      if (!(this.iv.sigBytes === this.block_cipher.blockSize)) {\n        throw new Error(\"IV is wrong length (\" + this.iv.sigBytes + \")\");\n      }\n      this.ctr = new Counter({\n        value: this.iv\n      });\n    }\n\n    Cipher.prototype.scrub = function() {\n      return this.block_cipher.scrub();\n    };\n\n    Cipher.prototype.get_pad = function() {\n      var pad;\n      pad = this.ctr.copy();\n      this.ctr.inc();\n      this.block_cipher.encryptBlock(pad.words);\n      return pad;\n    };\n\n    return Cipher;\n\n  })(StreamCipher);\n\n  encrypt = function(_arg) {\n    var block_cipher, cipher, input, iv, ret;\n    block_cipher = _arg.block_cipher, iv = _arg.iv, input = _arg.input;\n    cipher = new Cipher({\n      block_cipher: block_cipher,\n      iv: iv\n    });\n    ret = cipher.encrypt(input);\n    cipher.scrub();\n    return ret;\n  };\n\n  bulk_encrypt = function(_arg, cb) {\n    var block_cipher, cipher, input, iv, progress_hook, ret, what, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    block_cipher = _arg.block_cipher, iv = _arg.iv, input = _arg.input, progress_hook = _arg.progress_hook, what = _arg.what;\n    cipher = new Cipher({\n      block_cipher: block_cipher,\n      iv: iv\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/home/max/src/keybase/triplesec/src/ctr.iced\"\n        });\n        cipher.bulk_encrypt({\n          input: input,\n          progress_hook: progress_hook,\n          what: what\n        }, __iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              return ret = arguments[0];\n            };\n          })(),\n          lineno: 121\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(ret);\n      };\n    })(this));\n  };\n\n  exports.Counter = Counter;\n\n  exports.Cipher = Cipher;\n\n  exports.encrypt = encrypt;\n\n  exports.bulk_encrypt = bulk_encrypt;\n\n}).call(this);\n\n},{\"./algbase\":174,\"./wordarray\":196,\"iced-runtime\":118}],177:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var AES, Base, Concat, Decryptor, SHA512, Salsa20, TwoFish, V, WordArray, ctr, decrypt, iced, make_esc, salsa20, __iced_k, __iced_k_noop, _ref,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  WordArray = require('./wordarray').WordArray;\n\n  salsa20 = require('./salsa20');\n\n  AES = require('./aes').AES;\n\n  TwoFish = require('./twofish').TwoFish;\n\n  ctr = require('./ctr');\n\n  Concat = require('./combine').Concat;\n\n  SHA512 = require('./sha512').SHA512;\n\n  Salsa20 = require('./salsa20').Salsa20;\n\n  _ref = require('./enc'), Base = _ref.Base, V = _ref.V;\n\n  make_esc = require('iced-error').make_esc;\n\n  Decryptor = (function(_super) {\n    __extends(Decryptor, _super);\n\n    function Decryptor(_arg) {\n      var enc, key;\n      key = _arg.key, enc = _arg.enc;\n      Decryptor.__super__.constructor.call(this, {\n        key: key\n      });\n      if (enc != null) {\n        this.key = enc.key;\n        this.derived_keys = enc.derived_keys;\n      }\n    }\n\n    Decryptor.prototype.read_header = function(cb) {\n      var err, wa;\n      err = (wa = this.ct.unshift(2)) == null ? new Error(\"Ciphertext underrun in header\") : (this.version = V[wa.words[1]]) == null ? new Error(\"bad header; couldn't find a good version (got \" + wa.words[1] + \")\") : wa.words[0] !== this.version.header[0] ? new Error(\"Bad header: unrecognized magic value\") : null;\n      return cb(err);\n    };\n\n    Decryptor.prototype.verify_sig = function(key, cb) {\n      var computed, err, received, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          if ((received = _this.ct.unshift(Concat.get_output_size() / 4)) == null) {\n            return __iced_k(err = new Error(\"Ciphertext underrun in signature\"));\n          } else {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/triplesec/src/dec.iced\",\n                funcname: \"Decryptor.verify_sig\"\n              });\n              _this.sign({\n                input: _this.ct,\n                key: key,\n                salt: _this.salt\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return computed = arguments[1];\n                  };\n                })(),\n                lineno: 63\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return __iced_k(err = err != null ? err : received.equal(computed) ? null : new Error('Signature mismatch or bad decryption key'));\n            });\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    Decryptor.prototype.unshift_iv = function(n_bytes, which, cb) {\n      var err, iv;\n      err = (iv = this.ct.unshift(n_bytes / 4)) != null ? null : new Error(\"Ciphertext underrun in \" + which);\n      return cb(err, iv);\n    };\n\n    Decryptor.prototype.read_salt = function(cb) {\n      var err;\n      err = (this.salt = this.ct.unshift(this.version.salt_size / 4)) == null ? new Error(\"Ciphertext underrrun in read_salt\") : null;\n      return cb(err);\n    };\n\n    Decryptor.prototype.generate_keys = function(_arg, cb) {\n      var err, keys, progress_hook, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      progress_hook = _arg.progress_hook;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/triplesec/src/dec.iced\",\n            funcname: \"Decryptor.generate_keys\"\n          });\n          _this.kdf({\n            salt: _this.salt,\n            progress_hook: progress_hook\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return keys = arguments[1];\n              };\n            })(),\n            lineno: 114\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, keys);\n        };\n      })(this));\n    };\n\n    Decryptor.prototype.run = function(_arg, cb) {\n      var ct1, ct2, data, esc, iv, progress_hook, pt, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      data = _arg.data, progress_hook = _arg.progress_hook;\n      esc = make_esc(cb, \"Decryptor::run\");\n      this.ct = WordArray.from_buffer(data);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/triplesec/src/dec.iced\",\n            funcname: \"Decryptor.run\"\n          });\n          _this.read_header(esc(__iced_deferrals.defer({\n            lineno: 141\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/triplesec/src/dec.iced\",\n              funcname: \"Decryptor.run\"\n            });\n            _this.read_salt(esc(__iced_deferrals.defer({\n              lineno: 142\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/triplesec/src/dec.iced\",\n                funcname: \"Decryptor.run\"\n              });\n              _this.generate_keys({\n                progress_hook: progress_hook\n              }, esc(__iced_deferrals.defer({\n                assign_fn: (function(__slot_1) {\n                  return function() {\n                    return __slot_1.keys = arguments[0];\n                  };\n                })(_this),\n                lineno: 143\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/max/src/keybase/triplesec/src/dec.iced\",\n                  funcname: \"Decryptor.run\"\n                });\n                _this.verify_sig(_this.keys.hmac, esc(__iced_deferrals.defer({\n                  lineno: 144\n                })));\n                __iced_deferrals._fulfill();\n              })(function() {\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/home/max/src/keybase/triplesec/src/dec.iced\",\n                    funcname: \"Decryptor.run\"\n                  });\n                  _this.unshift_iv(AES.ivSize, \"AES\", esc(__iced_deferrals.defer({\n                    assign_fn: (function() {\n                      return function() {\n                        return iv = arguments[0];\n                      };\n                    })(),\n                    lineno: 145\n                  })));\n                  __iced_deferrals._fulfill();\n                })(function() {\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/home/max/src/keybase/triplesec/src/dec.iced\",\n                      funcname: \"Decryptor.run\"\n                    });\n                    _this.run_aes({\n                      iv: iv,\n                      input: _this.ct,\n                      key: _this.keys.aes,\n                      progress_hook: progress_hook\n                    }, esc(__iced_deferrals.defer({\n                      assign_fn: (function() {\n                        return function() {\n                          return ct2 = arguments[0];\n                        };\n                      })(),\n                      lineno: 146\n                    })));\n                    __iced_deferrals._fulfill();\n                  })(function() {\n                    (function(__iced_k) {\n                      __iced_deferrals = new iced.Deferrals(__iced_k, {\n                        parent: ___iced_passed_deferral,\n                        filename: \"/home/max/src/keybase/triplesec/src/dec.iced\",\n                        funcname: \"Decryptor.run\"\n                      });\n                      _this.unshift_iv(TwoFish.ivSize, \"2fish\", esc(__iced_deferrals.defer({\n                        assign_fn: (function() {\n                          return function() {\n                            return iv = arguments[0];\n                          };\n                        })(),\n                        lineno: 147\n                      })));\n                      __iced_deferrals._fulfill();\n                    })(function() {\n                      (function(__iced_k) {\n                        __iced_deferrals = new iced.Deferrals(__iced_k, {\n                          parent: ___iced_passed_deferral,\n                          filename: \"/home/max/src/keybase/triplesec/src/dec.iced\",\n                          funcname: \"Decryptor.run\"\n                        });\n                        _this.run_twofish({\n                          iv: iv,\n                          input: _this.ct,\n                          key: _this.keys.twofish,\n                          progress_hook: progress_hook\n                        }, esc(__iced_deferrals.defer({\n                          assign_fn: (function() {\n                            return function() {\n                              return ct1 = arguments[0];\n                            };\n                          })(),\n                          lineno: 148\n                        })));\n                        __iced_deferrals._fulfill();\n                      })(function() {\n                        (function(__iced_k) {\n                          __iced_deferrals = new iced.Deferrals(__iced_k, {\n                            parent: ___iced_passed_deferral,\n                            filename: \"/home/max/src/keybase/triplesec/src/dec.iced\",\n                            funcname: \"Decryptor.run\"\n                          });\n                          _this.unshift_iv(Salsa20.ivSize, \"Salsa\", esc(__iced_deferrals.defer({\n                            assign_fn: (function() {\n                              return function() {\n                                return iv = arguments[0];\n                              };\n                            })(),\n                            lineno: 149\n                          })));\n                          __iced_deferrals._fulfill();\n                        })(function() {\n                          (function(__iced_k) {\n                            __iced_deferrals = new iced.Deferrals(__iced_k, {\n                              parent: ___iced_passed_deferral,\n                              filename: \"/home/max/src/keybase/triplesec/src/dec.iced\",\n                              funcname: \"Decryptor.run\"\n                            });\n                            _this.run_salsa20({\n                              iv: iv,\n                              input: _this.ct,\n                              key: _this.keys.salsa20,\n                              output_iv: false,\n                              progress_hook: progress_hook\n                            }, esc(__iced_deferrals.defer({\n                              assign_fn: (function() {\n                                return function() {\n                                  return pt = arguments[0];\n                                };\n                              })(),\n                              lineno: 150\n                            })));\n                            __iced_deferrals._fulfill();\n                          })(function() {\n                            return cb(null, pt.to_buffer());\n                          });\n                        });\n                      });\n                    });\n                  });\n                });\n              });\n            });\n          });\n        };\n      })(this));\n    };\n\n    return Decryptor;\n\n  })(Base);\n\n  decrypt = function(_arg, cb) {\n    var data, dec, err, key, progress_hook, pt, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    key = _arg.key, data = _arg.data, progress_hook = _arg.progress_hook;\n    dec = new Decryptor({\n      key: key\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/home/max/src/keybase/triplesec/src/dec.iced\"\n        });\n        dec.run({\n          data: data,\n          progress_hook: progress_hook\n        }, __iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              err = arguments[0];\n              return pt = arguments[1];\n            };\n          })(),\n          lineno: 168\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        dec.scrub();\n        return cb(err, pt);\n      };\n    })(this));\n  };\n\n  exports.Decryptor = Decryptor;\n\n  exports.decrypt = decrypt;\n\n}).call(this);\n\n},{\"./aes\":173,\"./combine\":175,\"./ctr\":176,\"./enc\":179,\"./salsa20\":186,\"./sha512\":193,\"./twofish\":194,\"./wordarray\":196,\"iced-error\":115,\"iced-runtime\":118}],178:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var ADRBG, DRBG, Lock, WordArray, XOR, hmac, iced, sha3, sha512, __iced_k, __iced_k_noop;\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  hmac = require('./hmac');\n\n  XOR = require('./combine').XOR;\n\n  sha512 = require('./sha512');\n\n  sha3 = require('./sha3');\n\n  WordArray = require('./wordarray').WordArray;\n\n  Lock = require('iced-lock').Lock;\n\n  DRBG = (function() {\n    function DRBG(entropy, personalization_string, hmac_func) {\n      this.hmac = hmac_func || hmac.sign;\n      this.security_strength = 256;\n      entropy = this.check_entropy(entropy);\n      personalization_string || (personalization_string = new WordArray([]));\n      this._instantiate(entropy, personalization_string);\n    }\n\n    DRBG.prototype.check_entropy = function(entropy, reseed) {\n      if (reseed == null) {\n        reseed = false;\n      }\n      if ((entropy.sigBytes * 8 * 2) < ((reseed ? 2 : 3) * this.security_strength)) {\n        throw new Error(\"entropy must be at least \" + (1.5 * this.security_strength) + \" bits.\");\n      }\n      return entropy;\n    };\n\n    DRBG.prototype._hmac = function(key, input) {\n      return this.hmac({\n        key: key,\n        input: input\n      });\n    };\n\n    DRBG.prototype._update = function(provided_data) {\n      var V, V_in;\n      V = new WordArray([0], 1);\n      if (provided_data != null) {\n        V = V.concat(provided_data);\n      }\n      V_in = this.V.clone().concat(V);\n      this.K = this._hmac(this.K, V_in);\n      V_in.scrub();\n      V.scrub();\n      this.V = this._hmac(this.K, this.V);\n      if (provided_data != null) {\n        V_in = this.V.clone().concat(new WordArray([1 << 24], 1)).concat(provided_data);\n        this.K = this._hmac(this.K, V_in);\n        V_in.scrub();\n        this.V = this._hmac(this.K, this.V);\n      }\n      return provided_data != null ? provided_data.scrub() : void 0;\n    };\n\n    DRBG.prototype._instantiate = function(entropy, personalization_string) {\n      var i, n, seed_material;\n      seed_material = entropy.concat(personalization_string);\n      n = 64;\n      this.K = WordArray.from_buffer(new Buffer((function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {\n          _results.push(0);\n        }\n        return _results;\n      })()));\n      this.V = WordArray.from_buffer(new Buffer((function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {\n          _results.push(1);\n        }\n        return _results;\n      })()));\n      this._update(seed_material);\n      entropy.scrub();\n      return this.reseed_counter = 1;\n    };\n\n    DRBG.prototype.reseed = function(entropy) {\n      this._update(this.check_entropy(entropy, true));\n      return this.reseed_counter = 1;\n    };\n\n    DRBG.prototype.generate = function(num_bytes) {\n      var i, tmp, _ref;\n      if ((num_bytes * 8) > 7500) {\n        throw new Error(\"generate cannot generate > 7500 bits in 1 call.\");\n      }\n      if (this.reseed_counter >= 10000) {\n        throw new Error(\"Need a reseed!\");\n      }\n      tmp = [];\n      i = 0;\n      while ((tmp.length === 0) || (tmp.length * tmp[0].length * 4) < num_bytes) {\n        this.V = this._hmac(this.K, this.V);\n        tmp.push(this.V.words);\n      }\n      this._update();\n      this.reseed_counter += 1;\n      return (new WordArray((_ref = []).concat.apply(_ref, tmp))).truncate(num_bytes);\n    };\n\n    return DRBG;\n\n  })();\n\n  ADRBG = (function() {\n    function ADRBG(gen_seed, hmac) {\n      this.gen_seed = gen_seed;\n      this.hmac = hmac;\n      this.drbg = null;\n      this.lock = new Lock();\n    }\n\n    ADRBG.prototype.generate = function(n, cb) {\n      var ret, seed, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/triplesec/src/drbg.iced\",\n            funcname: \"ADRBG.generate\"\n          });\n          _this.lock.acquire(__iced_deferrals.defer({\n            lineno: 148\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            if (_this.drbg == null) {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/max/src/keybase/triplesec/src/drbg.iced\",\n                  funcname: \"ADRBG.generate\"\n                });\n                _this.gen_seed(256, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return seed = arguments[0];\n                    };\n                  })(),\n                  lineno: 150\n                }));\n                __iced_deferrals._fulfill();\n              })(function() {\n                return __iced_k(_this.drbg = new DRBG(seed, null, _this.hmac));\n              });\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            (function(__iced_k) {\n              if (_this.drbg.reseed_counter > 100) {\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/home/max/src/keybase/triplesec/src/drbg.iced\",\n                    funcname: \"ADRBG.generate\"\n                  });\n                  _this.gen_seed(256, __iced_deferrals.defer({\n                    assign_fn: (function() {\n                      return function() {\n                        return seed = arguments[0];\n                      };\n                    })(),\n                    lineno: 153\n                  }));\n                  __iced_deferrals._fulfill();\n                })(function() {\n                  return __iced_k(_this.drbg.reseed(seed));\n                });\n              } else {\n                return __iced_k();\n              }\n            })(function() {\n              ret = _this.drbg.generate(n);\n              _this.lock.release();\n              return cb(ret);\n            });\n          });\n        };\n      })(this));\n    };\n\n    return ADRBG;\n\n  })();\n\n  exports.DRBG = DRBG;\n\n  exports.ADRBG = ADRBG;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./combine\":175,\"./hmac\":180,\"./sha3\":191,\"./sha512\":193,\"./wordarray\":196,\"buffer\":80,\"iced-lock\":197,\"iced-runtime\":118}],179:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var AES, Base, CURRENT_VERSION, Concat, Encryptor, HMAC_SHA256, PBKDF2, SHA512, Scrypt, TwoFish, V, WordArray, XOR, ctr, encrypt, iced, make_esc, prng, salsa20, util, __iced_k, __iced_k_noop, _ref,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  WordArray = require('./wordarray').WordArray;\n\n  salsa20 = require('./salsa20');\n\n  AES = require('./aes').AES;\n\n  TwoFish = require('./twofish').TwoFish;\n\n  ctr = require('./ctr');\n\n  _ref = require('./combine'), XOR = _ref.XOR, Concat = _ref.Concat;\n\n  SHA512 = require('./sha512').SHA512;\n\n  PBKDF2 = require('./pbkdf2').PBKDF2;\n\n  Scrypt = require('./scrypt').Scrypt;\n\n  util = require('./util');\n\n  prng = require('./prng');\n\n  make_esc = require('iced-error').make_esc;\n\n  HMAC_SHA256 = require('./hmac').HMAC_SHA256;\n\n  V = {\n    \"1\": {\n      header: [0x1c94d7de, 1],\n      salt_size: 8,\n      xsalsa20_rev: true,\n      kdf: {\n        klass: PBKDF2,\n        opts: {\n          c: 1024,\n          klass: XOR\n        }\n      },\n      hmac_key_size: 768 / 8\n    },\n    \"2\": {\n      header: [0x1c94d7de, 2],\n      salt_size: 16,\n      xsalsa20_rev: true,\n      kdf: {\n        klass: Scrypt,\n        opts: {\n          c: 64,\n          klass: XOR,\n          N: 12,\n          r: 8,\n          p: 1\n        }\n      },\n      hmac_key_size: 768 / 8\n    },\n    \"3\": {\n      header: [0x1c94d7de, 3],\n      salt_size: 16,\n      xsalsa20_rev: false,\n      kdf: {\n        klass: Scrypt,\n        opts: {\n          c: 1,\n          klass: HMAC_SHA256,\n          N: 15,\n          r: 8,\n          p: 1\n        }\n      },\n      hmac_key_size: 768 / 8\n    }\n  };\n\n  exports.CURRENT_VERSION = CURRENT_VERSION = 3;\n\n  Base = (function() {\n    function Base(_arg) {\n      var key, version;\n      key = _arg.key, version = _arg.version;\n      this.version = V[version != null ? version : CURRENT_VERSION];\n      if (this.version == null) {\n        throw new Error(\"unknown version: \" + version);\n      }\n      this.set_key(key);\n      this.derived_keys = {};\n    }\n\n    Base.prototype.kdf = function(_arg, cb) {\n      var args, dkLen, end, extra_keymaterial, i, k, key, keys, len, lens, order, progress_hook, raw, salt, salt_hex, v, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      salt = _arg.salt, extra_keymaterial = _arg.extra_keymaterial, progress_hook = _arg.progress_hook;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/triplesec/src/enc.iced\",\n            funcname: \"Base.kdf\"\n          });\n          _this._check_scrubbed(_this.key, \"in KDF\", cb, __iced_deferrals.defer({\n            lineno: 94\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          salt_hex = salt.to_hex();\n          key = _this.key.clone();\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/triplesec/src/enc.iced\",\n              funcname: \"Base.kdf\"\n            });\n            _this._check_scrubbed(key, \"KDF\", cb, __iced_deferrals.defer({\n              lineno: 102\n            }));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              if ((keys = _this.derived_keys[salt_hex]) == null) {\n                _this._kdf = new _this.version.kdf.klass(_this.version.kdf.opts);\n                lens = {\n                  hmac: _this.version.hmac_key_size,\n                  aes: AES.keySize,\n                  twofish: TwoFish.keySize,\n                  salsa20: salsa20.Salsa20.keySize\n                };\n                order = ['hmac', 'aes', 'twofish', 'salsa20'];\n                dkLen = extra_keymaterial || 0;\n                for (k in lens) {\n                  v = lens[k];\n                  dkLen += v;\n                }\n                args = {\n                  dkLen: dkLen,\n                  key: key,\n                  progress_hook: progress_hook,\n                  salt: salt\n                };\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/home/max/src/keybase/triplesec/src/enc.iced\",\n                    funcname: \"Base.kdf\"\n                  });\n                  _this._kdf.run(args, __iced_deferrals.defer({\n                    assign_fn: (function() {\n                      return function() {\n                        return raw = arguments[0];\n                      };\n                    })(),\n                    lineno: 121\n                  }));\n                  __iced_deferrals._fulfill();\n                })(function() {\n                  var _i, _len;\n                  keys = {};\n                  i = 0;\n                  for (_i = 0, _len = order.length; _i < _len; _i++) {\n                    k = order[_i];\n                    v = lens[k];\n                    len = v / 4;\n                    end = i + len;\n                    keys[k] = new WordArray(raw.words.slice(i, end));\n                    i = end;\n                  }\n                  keys.extra = (new WordArray(raw.words.slice(end))).to_buffer();\n                  return __iced_k(_this.derived_keys[salt_hex] = keys);\n                });\n              } else {\n                return __iced_k();\n              }\n            })(function() {\n              return cb(null, keys);\n            });\n          });\n        };\n      })(this));\n    };\n\n    Base.prototype.set_key = function(key) {\n      var wakey;\n      if (key != null) {\n        wakey = WordArray.from_buffer(key);\n        if (!this.key || !this.key.equal(wakey)) {\n          this.scrub();\n          return this.key = wakey;\n        }\n      } else {\n        return this.scrub();\n      }\n    };\n\n    Base.prototype._check_scrubbed = function(key, where, ecb, okcb) {\n      if ((key != null) && !key.is_scrubbed()) {\n        return okcb();\n      } else {\n        return ecb(new Error(\"\" + where + \": Failed due to scrubbed key!\"), null);\n      }\n    };\n\n    Base.prototype.sign = function(_arg, cb) {\n      var input, key, out, progress_hook, salt, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      input = _arg.input, key = _arg.key, salt = _arg.salt, progress_hook = _arg.progress_hook;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/triplesec/src/enc.iced\",\n            funcname: \"Base.sign\"\n          });\n          _this._check_scrubbed(key, \"HMAC\", cb, __iced_deferrals.defer({\n            lineno: 179\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          input = (new WordArray(_this.version.header)).concat(salt).concat(input);\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/triplesec/src/enc.iced\",\n              funcname: \"Base.sign\"\n            });\n            Concat.bulk_sign({\n              key: key,\n              input: input,\n              progress_hook: progress_hook\n            }, __iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return out = arguments[0];\n                };\n              })(),\n              lineno: 181\n            }));\n            __iced_deferrals._fulfill();\n          })(function() {\n            input.scrub();\n            return cb(null, out);\n          });\n        };\n      })(this));\n    };\n\n    Base.prototype.run_salsa20 = function(_arg, cb) {\n      var args, ct, input, iv, key, output_iv, progress_hook, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      input = _arg.input, key = _arg.key, iv = _arg.iv, output_iv = _arg.output_iv, progress_hook = _arg.progress_hook;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/triplesec/src/enc.iced\",\n            funcname: \"Base.run_salsa20\"\n          });\n          _this._check_scrubbed(key, \"Salsa20\", cb, __iced_deferrals.defer({\n            lineno: 197\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          args = {\n            input: input,\n            progress_hook: progress_hook,\n            key: key,\n            iv: iv\n          };\n          if (_this.version.xsalsa20_rev) {\n            args.key = key.clone().endian_reverse();\n            args.iv = iv.clone().endian_reverse();\n          }\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/triplesec/src/enc.iced\",\n              funcname: \"Base.run_salsa20\"\n            });\n            salsa20.bulk_encrypt(args, __iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return ct = arguments[0];\n                };\n              })(),\n              lineno: 209\n            }));\n            __iced_deferrals._fulfill();\n          })(function() {\n            if (output_iv) {\n              ct = iv.clone().concat(ct);\n            }\n            if (_this.version.xsalsa20_rev) {\n              args.key.scrub();\n              args.iv.scrub();\n            }\n            return cb(null, ct);\n          });\n        };\n      })(this));\n    };\n\n    Base.prototype.run_twofish = function(_arg, cb) {\n      var block_cipher, ct, input, iv, key, progress_hook, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      input = _arg.input, key = _arg.key, iv = _arg.iv, progress_hook = _arg.progress_hook;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/triplesec/src/enc.iced\",\n            funcname: \"Base.run_twofish\"\n          });\n          _this._check_scrubbed(key, \"TwoFish\", cb, __iced_deferrals.defer({\n            lineno: 232\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          block_cipher = new TwoFish(key);\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/triplesec/src/enc.iced\",\n              funcname: \"Base.run_twofish\"\n            });\n            ctr.bulk_encrypt({\n              block_cipher: block_cipher,\n              iv: iv,\n              input: input,\n              progress_hook: progress_hook,\n              what: \"twofish\"\n            }, __iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return ct = arguments[0];\n                };\n              })(),\n              lineno: 234\n            }));\n            __iced_deferrals._fulfill();\n          })(function() {\n            block_cipher.scrub();\n            return cb(null, iv.clone().concat(ct));\n          });\n        };\n      })(this));\n    };\n\n    Base.prototype.run_aes = function(_arg, cb) {\n      var block_cipher, ct, input, iv, key, progress_hook, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      input = _arg.input, key = _arg.key, iv = _arg.iv, progress_hook = _arg.progress_hook;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/triplesec/src/enc.iced\",\n            funcname: \"Base.run_aes\"\n          });\n          _this._check_scrubbed(key, \"AES\", cb, __iced_deferrals.defer({\n            lineno: 249\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          block_cipher = new AES(key);\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/triplesec/src/enc.iced\",\n              funcname: \"Base.run_aes\"\n            });\n            ctr.bulk_encrypt({\n              block_cipher: block_cipher,\n              iv: iv,\n              input: input,\n              progress_hook: progress_hook,\n              what: \"aes\"\n            }, __iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return ct = arguments[0];\n                };\n              })(),\n              lineno: 251\n            }));\n            __iced_deferrals._fulfill();\n          })(function() {\n            block_cipher.scrub();\n            return cb(null, iv.clone().concat(ct));\n          });\n        };\n      })(this));\n    };\n\n    Base.prototype.scrub = function() {\n      var key, key_ring, salt, _i, _len, _ref1;\n      if (this.key != null) {\n        this.key.scrub();\n      }\n      if (this.derived_keys != null) {\n        _ref1 = this.derived_keys;\n        for (salt in _ref1) {\n          key_ring = _ref1[salt];\n          for (_i = 0, _len = key_ring.length; _i < _len; _i++) {\n            key = key_ring[_i];\n            key.scrub();\n          }\n        }\n      }\n      this.derived_keys = {};\n      if (this.salt != null) {\n        this.salt.scrub();\n      }\n      this.salt = null;\n      return this.key = null;\n    };\n\n    return Base;\n\n  })();\n\n  Encryptor = (function(_super) {\n    __extends(Encryptor, _super);\n\n    function Encryptor(_arg) {\n      var key, rng, version;\n      key = _arg.key, rng = _arg.rng, version = _arg.version;\n      Encryptor.__super__.constructor.call(this, {\n        key: key,\n        version: version\n      });\n      this.rng = rng || prng.generate;\n    }\n\n    Encryptor.prototype.pick_random_ivs = function(_arg, cb) {\n      var iv_lens, ivs, k, progress_hook, v, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      progress_hook = _arg.progress_hook;\n      iv_lens = {\n        aes: AES.ivSize,\n        twofish: TwoFish.ivSize,\n        salsa20: salsa20.Salsa20.ivSize\n      };\n      ivs = {};\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _k, _keys, _ref1, _results, _while;\n          _ref1 = iv_lens;\n          _keys = (function() {\n            var _results1;\n            _results1 = [];\n            for (_k in _ref1) {\n              _results1.push(_k);\n            }\n            return _results1;\n          })();\n          _i = 0;\n          _results = [];\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = function() {\n              return __iced_k(_results);\n            };\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++_i;\n                return _while(__iced_k);\n              });\n            };\n            _next = function(__iced_next_arg) {\n              _results.push(__iced_next_arg);\n              return _continue();\n            };\n            if (!(_i < _keys.length)) {\n              return _break();\n            } else {\n              k = _keys[_i];\n              v = _ref1[k];\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/max/src/keybase/triplesec/src/enc.iced\",\n                  funcname: \"Encryptor.pick_random_ivs\"\n                });\n                _this.rng(v, __iced_deferrals.defer({\n                  assign_fn: (function(__slot_1, __slot_2) {\n                    return function() {\n                      return __slot_1[__slot_2] = arguments[0];\n                    };\n                  })(ivs, k),\n                  lineno: 353\n                }));\n                __iced_deferrals._fulfill();\n              })(_next);\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(ivs);\n        };\n      })(this));\n    };\n\n    Encryptor.prototype.resalt = function(_arg, cb) {\n      var err, extra_keymaterial, progress_hook, salt, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      salt = _arg.salt, extra_keymaterial = _arg.extra_keymaterial, progress_hook = _arg.progress_hook;\n      err = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (salt == null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/triplesec/src/enc.iced\",\n                funcname: \"Encryptor.resalt\"\n              });\n              _this.rng(_this.version.salt_size, __iced_deferrals.defer({\n                assign_fn: (function(__slot_1) {\n                  return function() {\n                    return __slot_1.salt = arguments[0];\n                  };\n                })(_this),\n                lineno: 369\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k(salt.length !== _this.version.salt_size ? err = new Error(\"Need a salt of exactly \" + _this.version.salt_size + \" bytes (got \" + salt.length + \")\") : _this.salt = WordArray.alloc(salt));\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            if (err == null) {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/max/src/keybase/triplesec/src/enc.iced\",\n                  funcname: \"Encryptor.resalt\"\n                });\n                _this.kdf({\n                  extra_keymaterial: extra_keymaterial,\n                  progress_hook: progress_hook,\n                  salt: _this.salt\n                }, __iced_deferrals.defer({\n                  assign_fn: (function(__slot_1) {\n                    return function() {\n                      err = arguments[0];\n                      return __slot_1.keys = arguments[1];\n                    };\n                  })(_this),\n                  lineno: 375\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            return cb(err, _this.keys);\n          });\n        };\n      })(this));\n    };\n\n    Encryptor.prototype.run = function(_arg, cb) {\n      var ct1, ct2, ct3, data, esc, extra_keymaterial, ivs, progress_hook, pt, ret, salt, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      data = _arg.data, salt = _arg.salt, extra_keymaterial = _arg.extra_keymaterial, progress_hook = _arg.progress_hook;\n      esc = make_esc(cb, \"Encryptor::run\");\n      (function(_this) {\n        return (function(__iced_k) {\n          if ((salt != null) || (_this.salt == null)) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/triplesec/src/enc.iced\",\n                funcname: \"Encryptor.run\"\n              });\n              _this.resalt({\n                salt: salt,\n                extra_keymaterial: extra_keymaterial,\n                progress_hook: progress_hook\n              }, esc(__iced_deferrals.defer({\n                lineno: 406\n              })));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/triplesec/src/enc.iced\",\n              funcname: \"Encryptor.run\"\n            });\n            _this.pick_random_ivs({\n              progress_hook: progress_hook\n            }, __iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return ivs = arguments[0];\n                };\n              })(),\n              lineno: 407\n            }));\n            __iced_deferrals._fulfill();\n          })(function() {\n            pt = WordArray.from_buffer(data);\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/triplesec/src/enc.iced\",\n                funcname: \"Encryptor.run\"\n              });\n              _this.run_salsa20({\n                input: pt,\n                key: _this.keys.salsa20,\n                progress_hook: progress_hook,\n                iv: ivs.salsa20,\n                output_iv: true\n              }, esc(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return ct1 = arguments[0];\n                  };\n                })(),\n                lineno: 409\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/max/src/keybase/triplesec/src/enc.iced\",\n                  funcname: \"Encryptor.run\"\n                });\n                _this.run_twofish({\n                  input: ct1,\n                  key: _this.keys.twofish,\n                  progress_hook: progress_hook,\n                  iv: ivs.twofish\n                }, esc(__iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return ct2 = arguments[0];\n                    };\n                  })(),\n                  lineno: 410\n                })));\n                __iced_deferrals._fulfill();\n              })(function() {\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/home/max/src/keybase/triplesec/src/enc.iced\",\n                    funcname: \"Encryptor.run\"\n                  });\n                  _this.run_aes({\n                    input: ct2,\n                    key: _this.keys.aes,\n                    progress_hook: progress_hook,\n                    iv: ivs.aes\n                  }, esc(__iced_deferrals.defer({\n                    assign_fn: (function() {\n                      return function() {\n                        return ct3 = arguments[0];\n                      };\n                    })(),\n                    lineno: 411\n                  })));\n                  __iced_deferrals._fulfill();\n                })(function() {\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/home/max/src/keybase/triplesec/src/enc.iced\",\n                      funcname: \"Encryptor.run\"\n                    });\n                    _this.sign({\n                      input: ct3,\n                      key: _this.keys.hmac,\n                      progress_hook: progress_hook,\n                      salt: _this.salt\n                    }, esc(__iced_deferrals.defer({\n                      assign_fn: (function() {\n                        return function() {\n                          return sig = arguments[0];\n                        };\n                      })(),\n                      lineno: 412\n                    })));\n                    __iced_deferrals._fulfill();\n                  })(function() {\n                    ret = (new WordArray(_this.version.header)).concat(_this.salt).concat(sig).concat(ct3).to_buffer();\n                    util.scrub_buffer(data);\n                    return cb(null, ret);\n                  });\n                });\n              });\n            });\n          });\n        };\n      })(this));\n    };\n\n    return Encryptor;\n\n  })(Base);\n\n  encrypt = function(_arg, cb) {\n    var data, enc, err, key, progress_hook, ret, rng, version, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    key = _arg.key, data = _arg.data, rng = _arg.rng, progress_hook = _arg.progress_hook, version = _arg.version;\n    enc = new Encryptor({\n      key: key,\n      rng: rng,\n      version: version\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/home/max/src/keybase/triplesec/src/enc.iced\"\n        });\n        enc.run({\n          data: data,\n          progress_hook: progress_hook\n        }, __iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              err = arguments[0];\n              return ret = arguments[1];\n            };\n          })(),\n          lineno: 440\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        enc.scrub();\n        return cb(err, ret);\n      };\n    })(this));\n  };\n\n  exports.V = V;\n\n  exports.encrypt = encrypt;\n\n  exports.Base = Base;\n\n  exports.Encryptor = Encryptor;\n\n}).call(this);\n\n},{\"./aes\":173,\"./combine\":175,\"./ctr\":176,\"./hmac\":180,\"./pbkdf2\":183,\"./prng\":184,\"./salsa20\":186,\"./scrypt\":187,\"./sha512\":193,\"./twofish\":194,\"./util\":195,\"./wordarray\":196,\"iced-error\":115,\"iced-runtime\":118}],180:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var HMAC, HMAC_SHA256, SHA256, SHA512, bulk_sign, iced, sign, util, __iced_k, __iced_k_noop,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  SHA512 = require('./sha512').SHA512;\n\n  SHA256 = require('./sha256').SHA256;\n\n  util = require('./util');\n\n  HMAC = (function() {\n    HMAC.outputSize = 512 / 8;\n\n    HMAC.prototype.outputSize = HMAC.outputSize;\n\n    function HMAC(key, klass) {\n      var i, _i, _ref;\n      if (klass == null) {\n        klass = SHA512;\n      }\n      this.key = key.clone();\n      this.hasher = new klass();\n      this.hasherBlockSize = this.hasher.blockSize;\n      this.hasherBlockSizeBytes = this.hasherBlockSize * 4;\n      if (this.key.sigBytes > this.hasherBlockSizeBytes) {\n        this.key = this.hasher.finalize(this.key);\n      }\n      this.key.clamp();\n      this._oKey = this.key.clone();\n      this._iKey = this.key.clone();\n      for (i = _i = 0, _ref = this.hasherBlockSize; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n        this._oKey.words[i] ^= 0x5c5c5c5c;\n        this._iKey.words[i] ^= 0x36363636;\n      }\n      this._oKey.sigBytes = this._iKey.sigBytes = this.hasherBlockSizeBytes;\n      this.reset();\n    }\n\n    HMAC.prototype.get_output_size = function() {\n      return this.hasher.output_size;\n    };\n\n    HMAC.prototype.reset = function() {\n      return this.hasher.reset().update(this._iKey);\n    };\n\n    HMAC.prototype.update = function(wa) {\n      this.hasher.update(wa);\n      return this;\n    };\n\n    HMAC.prototype.finalize = function(wa) {\n      var innerHash, innerHash2, out;\n      innerHash = this.hasher.finalize(wa);\n      this.hasher.reset();\n      innerHash2 = this._oKey.clone().concat(innerHash);\n      out = this.hasher.finalize(innerHash2);\n      innerHash.scrub();\n      innerHash2.scrub();\n      return out;\n    };\n\n    HMAC.prototype.scrub = function() {\n      this.key.scrub();\n      this._iKey.scrub();\n      return this._oKey.scrub();\n    };\n\n    return HMAC;\n\n  })();\n\n  sign = function(_arg) {\n    var eng, hash_class, input, key, out;\n    key = _arg.key, input = _arg.input, hash_class = _arg.hash_class;\n    eng = new HMAC(key, hash_class);\n    out = eng.finalize(input.clamp());\n    eng.scrub();\n    return out;\n  };\n\n  bulk_sign = function(_arg, cb) {\n    var eng, input, key, klass, progress_hook, res, slice_args, what, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    key = _arg.key, input = _arg.input, progress_hook = _arg.progress_hook, klass = _arg.klass, what = _arg.what;\n    klass || (klass = HMAC);\n    what || (what = \"hmac_sha512\");\n    eng = new klass(key);\n    input.clamp();\n    slice_args = {\n      update: function(lo, hi) {\n        return eng.update(input.slice(lo, hi));\n      },\n      finalize: function() {\n        return eng.finalize();\n      },\n      default_n: eng.hasherBlockSize * 1000\n    };\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/home/max/src/keybase/triplesec/src/hmac.iced\"\n        });\n        util.bulk(input.sigBytes, slice_args, {\n          what: what,\n          progress_hook: progress_hook,\n          cb: __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return res = arguments[0];\n              };\n            })(),\n            lineno: 137\n          })\n        });\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        eng.scrub();\n        return cb(res);\n      };\n    })(this));\n  };\n\n  exports.HMAC_SHA256 = HMAC_SHA256 = (function(_super) {\n    __extends(HMAC_SHA256, _super);\n\n    function HMAC_SHA256(key) {\n      HMAC_SHA256.__super__.constructor.call(this, key, SHA256);\n    }\n\n    return HMAC_SHA256;\n\n  })(HMAC);\n\n  exports.HMAC = HMAC;\n\n  exports.sign = sign;\n\n  exports.bulk_sign = bulk_sign;\n\n}).call(this);\n\n},{\"./sha256\":190,\"./sha512\":193,\"./util\":195,\"iced-runtime\":118}],181:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var hmac, k, v, _ref, _ref1;\n\n  _ref = require('./enc');\n  for (k in _ref) {\n    v = _ref[k];\n    exports[k] = v;\n  }\n\n  _ref1 = require('./dec');\n  for (k in _ref1) {\n    v = _ref1[k];\n    exports[k] = v;\n  }\n\n  exports.prng = require('./prng');\n\n  exports.Buffer = Buffer;\n\n  exports.WordArray = require('./wordarray').WordArray;\n\n  exports.util = require('./util');\n\n  exports.ciphers = {\n    AES: require('./aes').AES,\n    TwoFish: require('./twofish').TwoFish,\n    Salsa20: require('./salsa20').Salsa20\n  };\n\n  exports.hash = {\n    SHA1: require('./sha1').SHA1,\n    SHA224: require('./sha224').SHA224,\n    SHA256: require('./sha256').SHA256,\n    SHA384: require('./sha384').SHA384,\n    SHA512: require('./sha512').SHA512,\n    SHA3: require('./sha3').SHA3,\n    MD5: require('./md5').MD5,\n    RIPEMD160: require('./ripemd160').RIPEMD160\n  };\n\n  exports.modes = {\n    CTR: require('./ctr')\n  };\n\n  exports.scrypt = require('./scrypt').scrypt;\n\n  exports.pbkdf2 = require('./pbkdf2').pbkdf2;\n\n  exports.hmac = hmac = require('./hmac');\n\n  exports.HMAC_SHA256 = hmac.HMAC_SHA256;\n\n  exports.HMAC = hmac.HMAC;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./aes\":173,\"./ctr\":176,\"./dec\":177,\"./enc\":179,\"./hmac\":180,\"./md5\":182,\"./pbkdf2\":183,\"./prng\":184,\"./ripemd160\":185,\"./salsa20\":186,\"./scrypt\":187,\"./sha1\":188,\"./sha224\":189,\"./sha256\":190,\"./sha3\":191,\"./sha384\":192,\"./sha512\":193,\"./twofish\":194,\"./util\":195,\"./wordarray\":196,\"buffer\":80}],182:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var FF, GG, Global, HH, Hasher, II, MD5, WordArray, glbl,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  WordArray = require('./wordarray').WordArray;\n\n  Hasher = require('./algbase').Hasher;\n\n  Global = (function() {\n    function Global() {\n      var i;\n      this.T = (function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; _i < 64; i = ++_i) {\n          _results.push((Math.abs(Math.sin(i + 1)) * 0x100000000) | 0);\n        }\n        return _results;\n      })();\n    }\n\n    return Global;\n\n  })();\n\n  glbl = new Global();\n\n  exports.MD5 = MD5 = (function(_super) {\n    __extends(MD5, _super);\n\n    function MD5() {\n      return MD5.__super__.constructor.apply(this, arguments);\n    }\n\n    MD5.blockSize = 512 / 32;\n\n    MD5.prototype.blockSize = MD5.blockSize;\n\n    MD5.output_size = 16;\n\n    MD5.prototype.output_size = MD5.output_size;\n\n    MD5.prototype._doReset = function() {\n      return this._hash = new WordArray([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]);\n    };\n\n    MD5.prototype._doProcessBlock = function(M, offset) {\n      var H, M_offset_0, M_offset_1, M_offset_10, M_offset_11, M_offset_12, M_offset_13, M_offset_14, M_offset_15, M_offset_2, M_offset_3, M_offset_4, M_offset_5, M_offset_6, M_offset_7, M_offset_8, M_offset_9, M_offset_i, a, b, c, d, i, offset_i, _i;\n      for (i = _i = 0; _i < 16; i = ++_i) {\n        offset_i = offset + i;\n        M_offset_i = M[offset_i];\n        M[offset_i] = (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00);\n      }\n      H = this._hash.words;\n      M_offset_0 = M[offset + 0];\n      M_offset_1 = M[offset + 1];\n      M_offset_2 = M[offset + 2];\n      M_offset_3 = M[offset + 3];\n      M_offset_4 = M[offset + 4];\n      M_offset_5 = M[offset + 5];\n      M_offset_6 = M[offset + 6];\n      M_offset_7 = M[offset + 7];\n      M_offset_8 = M[offset + 8];\n      M_offset_9 = M[offset + 9];\n      M_offset_10 = M[offset + 10];\n      M_offset_11 = M[offset + 11];\n      M_offset_12 = M[offset + 12];\n      M_offset_13 = M[offset + 13];\n      M_offset_14 = M[offset + 14];\n      M_offset_15 = M[offset + 15];\n      a = H[0];\n      b = H[1];\n      c = H[2];\n      d = H[3];\n      a = FF(a, b, c, d, M_offset_0, 7, glbl.T[0]);\n      d = FF(d, a, b, c, M_offset_1, 12, glbl.T[1]);\n      c = FF(c, d, a, b, M_offset_2, 17, glbl.T[2]);\n      b = FF(b, c, d, a, M_offset_3, 22, glbl.T[3]);\n      a = FF(a, b, c, d, M_offset_4, 7, glbl.T[4]);\n      d = FF(d, a, b, c, M_offset_5, 12, glbl.T[5]);\n      c = FF(c, d, a, b, M_offset_6, 17, glbl.T[6]);\n      b = FF(b, c, d, a, M_offset_7, 22, glbl.T[7]);\n      a = FF(a, b, c, d, M_offset_8, 7, glbl.T[8]);\n      d = FF(d, a, b, c, M_offset_9, 12, glbl.T[9]);\n      c = FF(c, d, a, b, M_offset_10, 17, glbl.T[10]);\n      b = FF(b, c, d, a, M_offset_11, 22, glbl.T[11]);\n      a = FF(a, b, c, d, M_offset_12, 7, glbl.T[12]);\n      d = FF(d, a, b, c, M_offset_13, 12, glbl.T[13]);\n      c = FF(c, d, a, b, M_offset_14, 17, glbl.T[14]);\n      b = FF(b, c, d, a, M_offset_15, 22, glbl.T[15]);\n      a = GG(a, b, c, d, M_offset_1, 5, glbl.T[16]);\n      d = GG(d, a, b, c, M_offset_6, 9, glbl.T[17]);\n      c = GG(c, d, a, b, M_offset_11, 14, glbl.T[18]);\n      b = GG(b, c, d, a, M_offset_0, 20, glbl.T[19]);\n      a = GG(a, b, c, d, M_offset_5, 5, glbl.T[20]);\n      d = GG(d, a, b, c, M_offset_10, 9, glbl.T[21]);\n      c = GG(c, d, a, b, M_offset_15, 14, glbl.T[22]);\n      b = GG(b, c, d, a, M_offset_4, 20, glbl.T[23]);\n      a = GG(a, b, c, d, M_offset_9, 5, glbl.T[24]);\n      d = GG(d, a, b, c, M_offset_14, 9, glbl.T[25]);\n      c = GG(c, d, a, b, M_offset_3, 14, glbl.T[26]);\n      b = GG(b, c, d, a, M_offset_8, 20, glbl.T[27]);\n      a = GG(a, b, c, d, M_offset_13, 5, glbl.T[28]);\n      d = GG(d, a, b, c, M_offset_2, 9, glbl.T[29]);\n      c = GG(c, d, a, b, M_offset_7, 14, glbl.T[30]);\n      b = GG(b, c, d, a, M_offset_12, 20, glbl.T[31]);\n      a = HH(a, b, c, d, M_offset_5, 4, glbl.T[32]);\n      d = HH(d, a, b, c, M_offset_8, 11, glbl.T[33]);\n      c = HH(c, d, a, b, M_offset_11, 16, glbl.T[34]);\n      b = HH(b, c, d, a, M_offset_14, 23, glbl.T[35]);\n      a = HH(a, b, c, d, M_offset_1, 4, glbl.T[36]);\n      d = HH(d, a, b, c, M_offset_4, 11, glbl.T[37]);\n      c = HH(c, d, a, b, M_offset_7, 16, glbl.T[38]);\n      b = HH(b, c, d, a, M_offset_10, 23, glbl.T[39]);\n      a = HH(a, b, c, d, M_offset_13, 4, glbl.T[40]);\n      d = HH(d, a, b, c, M_offset_0, 11, glbl.T[41]);\n      c = HH(c, d, a, b, M_offset_3, 16, glbl.T[42]);\n      b = HH(b, c, d, a, M_offset_6, 23, glbl.T[43]);\n      a = HH(a, b, c, d, M_offset_9, 4, glbl.T[44]);\n      d = HH(d, a, b, c, M_offset_12, 11, glbl.T[45]);\n      c = HH(c, d, a, b, M_offset_15, 16, glbl.T[46]);\n      b = HH(b, c, d, a, M_offset_2, 23, glbl.T[47]);\n      a = II(a, b, c, d, M_offset_0, 6, glbl.T[48]);\n      d = II(d, a, b, c, M_offset_7, 10, glbl.T[49]);\n      c = II(c, d, a, b, M_offset_14, 15, glbl.T[50]);\n      b = II(b, c, d, a, M_offset_5, 21, glbl.T[51]);\n      a = II(a, b, c, d, M_offset_12, 6, glbl.T[52]);\n      d = II(d, a, b, c, M_offset_3, 10, glbl.T[53]);\n      c = II(c, d, a, b, M_offset_10, 15, glbl.T[54]);\n      b = II(b, c, d, a, M_offset_1, 21, glbl.T[55]);\n      a = II(a, b, c, d, M_offset_8, 6, glbl.T[56]);\n      d = II(d, a, b, c, M_offset_15, 10, glbl.T[57]);\n      c = II(c, d, a, b, M_offset_6, 15, glbl.T[58]);\n      b = II(b, c, d, a, M_offset_13, 21, glbl.T[59]);\n      a = II(a, b, c, d, M_offset_4, 6, glbl.T[60]);\n      d = II(d, a, b, c, M_offset_11, 10, glbl.T[61]);\n      c = II(c, d, a, b, M_offset_2, 15, glbl.T[62]);\n      b = II(b, c, d, a, M_offset_9, 21, glbl.T[63]);\n      H[0] = (H[0] + a) | 0;\n      H[1] = (H[1] + b) | 0;\n      H[2] = (H[2] + c) | 0;\n      return H[3] = (H[3] + d) | 0;\n    };\n\n    MD5.prototype._doFinalize = function() {\n      var H, H_i, data, dataWords, hash, i, nBitsLeft, nBitsTotal, nBitsTotalH, nBitsTotalL, _i;\n      data = this._data;\n      dataWords = data.words;\n      nBitsTotal = this._nDataBytes * 8;\n      nBitsLeft = data.sigBytes * 8;\n      dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n      nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n      nBitsTotalL = nBitsTotal;\n      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 0x00ff00ff) | (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 0xff00ff00);\n      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 0x00ff00ff) | (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 0xff00ff00);\n      data.sigBytes = (dataWords.length + 1) * 4;\n      this._process();\n      hash = this._hash;\n      H = hash.words;\n      for (i = _i = 0; _i < 4; i = ++_i) {\n        H_i = H[i];\n        H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) | (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);\n      }\n      return hash;\n    };\n\n    MD5.prototype.copy_to = function(obj) {\n      MD5.__super__.copy_to.call(this, obj);\n      return obj._hash = this._hash.clone();\n    };\n\n    MD5.prototype.clone = function() {\n      var out;\n      out = new MD5();\n      this.copy_to(out);\n      return out;\n    };\n\n    return MD5;\n\n  })(Hasher);\n\n  FF = function(a, b, c, d, x, s, t) {\n    var n;\n    n = a + ((b & c) | (~b & d)) + x + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n  };\n\n  GG = function(a, b, c, d, x, s, t) {\n    var n;\n    n = a + ((b & d) | (c & ~d)) + x + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n  };\n\n  HH = function(a, b, c, d, x, s, t) {\n    var n;\n    n = a + (b ^ c ^ d) + x + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n  };\n\n  II = function(a, b, c, d, x, s, t) {\n    var n;\n    n = a + (c ^ (b | ~d)) + x + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n  };\n\n  exports.transform = function(x) {\n    var out;\n    out = (new MD5).finalize(x);\n    x.scrub();\n    return out;\n  };\n\n}).call(this);\n\n},{\"./algbase\":174,\"./wordarray\":196}],183:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var HMAC, PBKDF2, WordArray, iced, pbkdf2, util, __iced_k, __iced_k_noop;\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  HMAC = require('./hmac').HMAC;\n\n  WordArray = require('./wordarray').WordArray;\n\n  util = require('./util');\n\n  PBKDF2 = (function() {\n    function PBKDF2(_arg) {\n      this.klass = _arg.klass, this.c = _arg.c;\n      this.c || (this.c = 1024);\n      this.klass || (this.klass = HMAC);\n    }\n\n    PBKDF2.prototype._PRF = function(input) {\n      this.prf.reset();\n      return this.prf.finalize(input);\n    };\n\n    PBKDF2.prototype._gen_T_i = function(_arg, cb) {\n      var U, i, progress_hook, ret, salt, seed, stop, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      salt = _arg.salt, i = _arg.i, progress_hook = _arg.progress_hook;\n      progress_hook(0);\n      seed = salt.clone().concat(new WordArray([i]));\n      U = this._PRF(seed);\n      ret = U.clone();\n      i = 1;\n      (function(_this) {\n        return (function(__iced_k) {\n          var _results, _while;\n          _results = [];\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = function() {\n              return __iced_k(_results);\n            };\n            _continue = function() {\n              return iced.trampoline(function() {\n                return _while(__iced_k);\n              });\n            };\n            _next = function(__iced_next_arg) {\n              _results.push(__iced_next_arg);\n              return _continue();\n            };\n            if (!(i < _this.c)) {\n              return _break();\n            } else {\n              stop = Math.min(_this.c, i + 128);\n              while (i < stop) {\n                U = _this._PRF(U);\n                ret.xor(U, {});\n                i++;\n              }\n              progress_hook(i);\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/max/src/keybase/triplesec/src/pbkdf2.iced\",\n                  funcname: \"PBKDF2._gen_T_i\"\n                });\n                util.default_delay(0, 0, __iced_deferrals.defer({\n                  lineno: 57\n                }));\n                __iced_deferrals._fulfill();\n              })(function() {\n                return _next(null);\n              });\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          progress_hook(i);\n          return cb(ret);\n        };\n      })(this));\n    };\n\n    PBKDF2.prototype.run = function(_arg, cb) {\n      var bs, dkLen, flat, i, key, n, ph, progress_hook, salt, tmp, tph, words, ___iced_passed_deferral, __iced_deferrals, __iced_k, _begin, _end, _positive;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      key = _arg.key, salt = _arg.salt, dkLen = _arg.dkLen, progress_hook = _arg.progress_hook;\n      this.prf = new this.klass(key);\n      bs = this.prf.get_output_size();\n      n = Math.ceil(dkLen / bs);\n      words = [];\n      tph = null;\n      ph = (function(_this) {\n        return function(block) {\n          return function(iter) {\n            return typeof progress_hook === \"function\" ? progress_hook({\n              what: \"pbkdf2\",\n              total: n * _this.c,\n              i: block * _this.c + iter\n            }) : void 0;\n          };\n        };\n      })(this);\n      ph(0)(0);\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _results, _while;\n          i = 1;\n          _begin = 1;\n          _end = n;\n          _positive = _end > _begin;\n          _results = [];\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = function() {\n              return __iced_k(_results);\n            };\n            _continue = function() {\n              return iced.trampoline(function() {\n                if (_positive) {\n                  i += 1;\n                } else {\n                  i -= 1;\n                }\n                return _while(__iced_k);\n              });\n            };\n            _next = function(__iced_next_arg) {\n              _results.push(__iced_next_arg);\n              return _continue();\n            };\n            if (!!((_positive === true && i > n) || (_positive === false && i < n))) {\n              return _break();\n            } else {\n\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/max/src/keybase/triplesec/src/pbkdf2.iced\",\n                  funcname: \"PBKDF2.run\"\n                });\n                _this._gen_T_i({\n                  salt: salt,\n                  i: i,\n                  progress_hook: ph(i - 1)\n                }, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return tmp = arguments[0];\n                    };\n                  })(),\n                  lineno: 80\n                }));\n                __iced_deferrals._fulfill();\n              })(function() {\n                return _next(words.push(tmp.words));\n              });\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          var _ref;\n          ph(n)(0);\n          flat = (_ref = []).concat.apply(_ref, words);\n          key.scrub();\n          _this.prf.scrub();\n          _this.prf = null;\n          return cb(new WordArray(flat, dkLen));\n        };\n      })(this));\n    };\n\n    return PBKDF2;\n\n  })();\n\n  pbkdf2 = function(_arg, cb) {\n    var c, dkLen, eng, key, klass, out, progress_hook, salt, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    key = _arg.key, salt = _arg.salt, klass = _arg.klass, c = _arg.c, dkLen = _arg.dkLen, progress_hook = _arg.progress_hook;\n    eng = new PBKDF2({\n      klass: klass,\n      c: c\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/home/max/src/keybase/triplesec/src/pbkdf2.iced\"\n        });\n        eng.run({\n          key: key,\n          salt: salt,\n          dkLen: dkLen,\n          progress_hook: progress_hook\n        }, __iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              return out = arguments[0];\n            };\n          })(),\n          lineno: 106\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(out);\n      };\n    })(this));\n  };\n\n  exports.pbkdf2 = pbkdf2;\n\n  exports.PBKDF2 = PBKDF2;\n\n}).call(this);\n\n},{\"./hmac\":180,\"./util\":195,\"./wordarray\":196,\"iced-runtime\":118}],184:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var ADRBG, PRNG, WordArray, XOR, browser_rng, e, generate, iced, m, more_entropy, native_rng, rng, util, __iced_k, __iced_k_noop, _browser_rng_primitive, _native_rng, _prng, _ref, _ref1;\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  more_entropy = require('more-entropy');\n\n  ADRBG = require('./drbg').ADRBG;\n\n  WordArray = require('./wordarray').WordArray;\n\n  XOR = require('./combine').XOR;\n\n  util = require('./util');\n\n  _browser_rng_primitive = null;\n\n  browser_rng = function(n) {\n    var v;\n    v = new Uint8Array(n);\n    _browser_rng_primitive(v);\n    return new Buffer(v);\n  };\n\n  _browser_rng_primitive = (m = typeof window !== \"undefined\" && window !== null ? (_ref = window.crypto) != null ? _ref.getRandomValues : void 0 : void 0) != null ? m.bind(window.crypto) : (m = typeof window !== \"undefined\" && window !== null ? (_ref1 = window.msCrypto) != null ? _ref1.getRandomValues : void 0 : void 0) != null ? m.bind(window.msCrypto) : null;\n\n  if (_browser_rng_primitive != null) {\n    _native_rng = browser_rng;\n  } else {\n    try {\n      rng = require('cry' + 'pto').rng;\n      if (rng != null) {\n        _native_rng = rng;\n      }\n    } catch (_error) {\n      e = _error;\n    }\n  }\n\n  native_rng = function(x) {\n    if (_native_rng == null) {\n      throw new Error('No rng found; tried requiring \"crypto\" and window.crypto');\n    }\n    return _native_rng(x);\n  };\n\n  PRNG = (function() {\n    function PRNG() {\n      this.meg = new more_entropy.Generator();\n      this.adrbg = new ADRBG(((function(_this) {\n        return function(n, cb) {\n          return _this.gen_seed(n, cb);\n        };\n      })(this)), XOR.sign);\n    }\n\n    PRNG.prototype.now_to_buffer = function() {\n      var buf, d, ms, s;\n      d = Date.now();\n      ms = d % 1000;\n      s = Math.floor(d / 1000);\n      buf = new Buffer(8);\n      buf.writeUInt32BE(s, 0);\n      buf.writeUInt32BE(ms, 4);\n      return buf;\n    };\n\n    PRNG.prototype.gen_seed = function(nbits, cb) {\n      var b, bufs, cat, nbytes, wa, words, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      nbytes = nbits / 8;\n      bufs = [];\n      bufs.push(this.now_to_buffer());\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/chris/git/keybase/triplesec/src/prng.iced\",\n            funcname: \"PRNG.gen_seed\"\n          });\n          _this.meg.generate(nbits, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return words = arguments[0];\n              };\n            })(),\n            lineno: 83\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          var _i, _len;\n          bufs.push(_this.now_to_buffer());\n          bufs.push(new Buffer(words));\n          bufs.push(native_rng(nbytes));\n          bufs.push(_this.now_to_buffer());\n          cat = Buffer.concat(bufs);\n          wa = WordArray.from_buffer(cat);\n          util.scrub_buffer(cat);\n          for (_i = 0, _len = bufs.length; _i < _len; _i++) {\n            b = bufs[_i];\n            util.scrub_buffer(b);\n          }\n          return cb(wa);\n        };\n      })(this));\n    };\n\n    PRNG.prototype.generate = function(n, cb) {\n      return this.adrbg.generate(n, cb);\n    };\n\n    return PRNG;\n\n  })();\n\n  _prng = null;\n\n  generate = function(n, cb) {\n    if (_prng == null) {\n      _prng = new PRNG();\n    }\n    return _prng.generate(n, cb);\n  };\n\n  exports.PRNG = PRNG;\n\n  exports.generate = generate;\n\n  exports.native_rng = native_rng;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./combine\":175,\"./drbg\":178,\"./util\":195,\"./wordarray\":196,\"buffer\":80,\"iced-runtime\":118,\"more-entropy\":199}],185:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var G, Global, Hasher, RIPEMD160, WordArray, X64Word, X64WordArray, f1, f2, f3, f4, f5, rotl, transform, _ref,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  _ref = require('./wordarray'), WordArray = _ref.WordArray, X64Word = _ref.X64Word, X64WordArray = _ref.X64WordArray;\n\n  Hasher = require('./algbase').Hasher;\n\n  Global = (function() {\n    function Global() {\n      this._zl = new WordArray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]);\n      this._zr = new WordArray([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]);\n      this._sl = new WordArray([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]);\n      this._sr = new WordArray([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]);\n      this._hl = new WordArray([0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);\n      this._hr = new WordArray([0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);\n    }\n\n    return Global;\n\n  })();\n\n  G = new Global();\n\n  RIPEMD160 = (function(_super) {\n    __extends(RIPEMD160, _super);\n\n    function RIPEMD160() {\n      return RIPEMD160.__super__.constructor.apply(this, arguments);\n    }\n\n    RIPEMD160.blockSize = 512 / 32;\n\n    RIPEMD160.prototype.blockSize = RIPEMD160.blockSize;\n\n    RIPEMD160.output_size = 160 / 8;\n\n    RIPEMD160.prototype.output_size = RIPEMD160.output_size;\n\n    RIPEMD160.prototype._doReset = function() {\n      return this._hash = new WordArray([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);\n    };\n\n    RIPEMD160.prototype.get_output_size = function() {\n      return this.output_size;\n    };\n\n    RIPEMD160.prototype._doProcessBlock = function(M, offset) {\n      var H, M_offset_i, al, ar, bl, br, cl, cr, dl, dr, el, er, hl, hr, i, offset_i, sl, sr, t, zl, zr, _i, _j;\n      for (i = _i = 0; _i < 16; i = ++_i) {\n        offset_i = offset + i;\n        M_offset_i = M[offset_i];\n        M[offset_i] = (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00);\n      }\n      H = this._hash.words;\n      hl = G._hl.words;\n      hr = G._hr.words;\n      zl = G._zl.words;\n      zr = G._zr.words;\n      sl = G._sl.words;\n      sr = G._sr.words;\n      ar = al = H[0];\n      br = bl = H[1];\n      cr = cl = H[2];\n      dr = dl = H[3];\n      er = el = H[4];\n      for (i = _j = 0; _j < 80; i = ++_j) {\n        t = (al + M[offset + zl[i]]) | 0;\n        if (i < 16) {\n          t += f1(bl, cl, dl) + hl[0];\n        } else if (i < 32) {\n          t += f2(bl, cl, dl) + hl[1];\n        } else if (i < 48) {\n          t += f3(bl, cl, dl) + hl[2];\n        } else if (i < 64) {\n          t += f4(bl, cl, dl) + hl[3];\n        } else {\n          t += f5(bl, cl, dl) + hl[4];\n        }\n        t = t | 0;\n        t = rotl(t, sl[i]);\n        t = (t + el) | 0;\n        al = el;\n        el = dl;\n        dl = rotl(cl, 10);\n        cl = bl;\n        bl = t;\n        t = (ar + M[offset + zr[i]]) | 0;\n        if (i < 16) {\n          t += f5(br, cr, dr) + hr[0];\n        } else if (i < 32) {\n          t += f4(br, cr, dr) + hr[1];\n        } else if (i < 48) {\n          t += f3(br, cr, dr) + hr[2];\n        } else if (i < 64) {\n          t += f2(br, cr, dr) + hr[3];\n        } else {\n          t += f1(br, cr, dr) + hr[4];\n        }\n        t = t | 0;\n        t = rotl(t, sr[i]);\n        t = (t + er) | 0;\n        ar = er;\n        er = dr;\n        dr = rotl(cr, 10);\n        cr = br;\n        br = t;\n      }\n      t = (H[1] + cl + dr) | 0;\n      H[1] = (H[2] + dl + er) | 0;\n      H[2] = (H[3] + el + ar) | 0;\n      H[3] = (H[4] + al + br) | 0;\n      H[4] = (H[0] + bl + cr) | 0;\n      return H[0] = t;\n    };\n\n    RIPEMD160.prototype._doFinalize = function() {\n      var H, H_i, data, dataWords, hash, i, nBitsLeft, nBitsTotal, _i;\n      data = this._data;\n      dataWords = data.words;\n      nBitsTotal = this._nDataBytes * 8;\n      nBitsLeft = data.sigBytes * 8;\n      dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) | (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00);\n      data.sigBytes = (dataWords.length + 1) * 4;\n      this._process();\n      hash = this._hash;\n      H = hash.words;\n      for (i = _i = 0; _i < 5; i = ++_i) {\n        H_i = H[i];\n        H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) | (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);\n      }\n      return hash;\n    };\n\n    RIPEMD160.prototype.scrub = function() {\n      return this._hash.scrub();\n    };\n\n    RIPEMD160.prototype.copy_to = function(obj) {\n      RIPEMD160.__super__.copy_to.call(this, obj);\n      return obj._hash = this._hash.clone();\n    };\n\n    RIPEMD160.prototype.clone = function() {\n      var out;\n      out = new RIPEMD160();\n      this.copy_to(out);\n      return out;\n    };\n\n    return RIPEMD160;\n\n  })(Hasher);\n\n  f1 = function(x, y, z) {\n    return x ^ y ^ z;\n  };\n\n  f2 = function(x, y, z) {\n    return (x & y) | ((~x) & z);\n  };\n\n  f3 = function(x, y, z) {\n    return (x | (~y)) ^ z;\n  };\n\n  f4 = function(x, y, z) {\n    return (x & z) | (y & (~z));\n  };\n\n  f5 = function(x, y, z) {\n    return x ^ (y | (~z));\n  };\n\n  rotl = function(x, n) {\n    return (x << n) | (x >>> (32 - n));\n  };\n\n  transform = function(x) {\n    var out;\n    out = (new RIPEMD160).finalize(x);\n    x.scrub();\n    return out;\n  };\n\n  exports.RIPEMD160 = RIPEMD160;\n\n  exports.transform = transform;\n\n}).call(this);\n\n},{\"./algbase\":174,\"./wordarray\":196}],186:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var Cipher, Counter, Salsa20, Salsa20Core, Salsa20InnerCore, Salsa20WordStream, StreamCipher, WordArray, asum, bulk_encrypt, encrypt, endian_reverse, fixup_uint32, iced, util, __iced_k, __iced_k_noop, _ref,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  _ref = require('./wordarray'), endian_reverse = _ref.endian_reverse, WordArray = _ref.WordArray;\n\n  Counter = require('./ctr').Counter;\n\n  fixup_uint32 = require('./util').fixup_uint32;\n\n  StreamCipher = require('./algbase').StreamCipher;\n\n  util = require('./util');\n\n  asum = function(out, v) {\n    var e, i, _i, _len;\n    for (i = _i = 0, _len = v.length; _i < _len; i = ++_i) {\n      e = v[i];\n      out[i] += e;\n    }\n    return false;\n  };\n\n  Salsa20InnerCore = (function() {\n    function Salsa20InnerCore(rounds) {\n      this.rounds = rounds;\n    }\n\n    Salsa20InnerCore.prototype._core = function(v) {\n      \"use asm\";\n      var i, u, x0, x1, x10, x11, x12, x13, x14, x15, x2, x3, x4, x5, x6, x7, x8, x9, _i, _ref1;\n      x0 = v[0], x1 = v[1], x2 = v[2], x3 = v[3], x4 = v[4], x5 = v[5], x6 = v[6], x7 = v[7], x8 = v[8], x9 = v[9], x10 = v[10], x11 = v[11], x12 = v[12], x13 = v[13], x14 = v[14], x15 = v[15];\n      for (i = _i = 0, _ref1 = this.rounds; _i < _ref1; i = _i += 2) {\n        u = (x0 + x12) | 0;\n        x4 ^= (u << 7) | (u >>> 25);\n        u = (x4 + x0) | 0;\n        x8 ^= (u << 9) | (u >>> 23);\n        u = (x8 + x4) | 0;\n        x12 ^= (u << 13) | (u >>> 19);\n        u = (x12 + x8) | 0;\n        x0 ^= (u << 18) | (u >>> 14);\n        u = (x5 + x1) | 0;\n        x9 ^= (u << 7) | (u >>> 25);\n        u = (x9 + x5) | 0;\n        x13 ^= (u << 9) | (u >>> 23);\n        u = (x13 + x9) | 0;\n        x1 ^= (u << 13) | (u >>> 19);\n        u = (x1 + x13) | 0;\n        x5 ^= (u << 18) | (u >>> 14);\n        u = (x10 + x6) | 0;\n        x14 ^= (u << 7) | (u >>> 25);\n        u = (x14 + x10) | 0;\n        x2 ^= (u << 9) | (u >>> 23);\n        u = (x2 + x14) | 0;\n        x6 ^= (u << 13) | (u >>> 19);\n        u = (x6 + x2) | 0;\n        x10 ^= (u << 18) | (u >>> 14);\n        u = (x15 + x11) | 0;\n        x3 ^= (u << 7) | (u >>> 25);\n        u = (x3 + x15) | 0;\n        x7 ^= (u << 9) | (u >>> 23);\n        u = (x7 + x3) | 0;\n        x11 ^= (u << 13) | (u >>> 19);\n        u = (x11 + x7) | 0;\n        x15 ^= (u << 18) | (u >>> 14);\n        u = (x0 + x3) | 0;\n        x1 ^= (u << 7) | (u >>> 25);\n        u = (x1 + x0) | 0;\n        x2 ^= (u << 9) | (u >>> 23);\n        u = (x2 + x1) | 0;\n        x3 ^= (u << 13) | (u >>> 19);\n        u = (x3 + x2) | 0;\n        x0 ^= (u << 18) | (u >>> 14);\n        u = (x5 + x4) | 0;\n        x6 ^= (u << 7) | (u >>> 25);\n        u = (x6 + x5) | 0;\n        x7 ^= (u << 9) | (u >>> 23);\n        u = (x7 + x6) | 0;\n        x4 ^= (u << 13) | (u >>> 19);\n        u = (x4 + x7) | 0;\n        x5 ^= (u << 18) | (u >>> 14);\n        u = (x10 + x9) | 0;\n        x11 ^= (u << 7) | (u >>> 25);\n        u = (x11 + x10) | 0;\n        x8 ^= (u << 9) | (u >>> 23);\n        u = (x8 + x11) | 0;\n        x9 ^= (u << 13) | (u >>> 19);\n        u = (x9 + x8) | 0;\n        x10 ^= (u << 18) | (u >>> 14);\n        u = (x15 + x14) | 0;\n        x12 ^= (u << 7) | (u >>> 25);\n        u = (x12 + x15) | 0;\n        x13 ^= (u << 9) | (u >>> 23);\n        u = (x13 + x12) | 0;\n        x14 ^= (u << 13) | (u >>> 19);\n        u = (x14 + x13) | 0;\n        x15 ^= (u << 18) | (u >>> 14);\n      }\n      return [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15];\n    };\n\n    return Salsa20InnerCore;\n\n  })();\n\n  Salsa20Core = (function(_super) {\n    __extends(Salsa20Core, _super);\n\n    Salsa20Core.prototype.sigma = WordArray.from_buffer_le(new Buffer(\"expand 32-byte k\"));\n\n    Salsa20Core.prototype.tau = WordArray.from_buffer_le(new Buffer(\"expand 16-byte k\"));\n\n    Salsa20Core.blockSize = 64;\n\n    Salsa20Core.prototype.blockSize = Salsa20Core.blockSize;\n\n    Salsa20Core.keySize = 32;\n\n    Salsa20Core.prototype.keySize = Salsa20Core.keySize;\n\n    Salsa20Core.ivSize = 192 / 8;\n\n    Salsa20Core.prototype.ivSize = Salsa20Core.ivSize;\n\n    function Salsa20Core(key, nonce) {\n      var _ref1;\n      Salsa20Core.__super__.constructor.call(this, 20);\n      this.key = key.clone().endian_reverse();\n      this.nonce = nonce.clone().endian_reverse();\n      if (!(((this.key.sigBytes === 16) && (this.nonce.sigBytes === 8)) || ((this.key.sigBytes === 32) && ((_ref1 = this.nonce.sigBytes) === 8 || _ref1 === 24)))) {\n        throw new Error(\"Bad key/nonce lengths\");\n      }\n      if (this.nonce.sigBytes === 24) {\n        this.xsalsa_setup();\n      }\n      this.input = this.key_iv_setup(this.nonce, this.key);\n      this._reset();\n    }\n\n    Salsa20Core.prototype.scrub = function() {\n      this.key.scrub();\n      this.nonce.scrub();\n      return util.scrub_vec(this.input);\n    };\n\n    Salsa20Core.prototype.xsalsa_setup = function() {\n      var n0, n1;\n      n0 = new WordArray(this.nonce.words.slice(0, 4));\n      this.nonce = n1 = new WordArray(this.nonce.words.slice(4));\n      return this.key = this.hsalsa20(n0, this.key);\n    };\n\n    Salsa20Core.prototype.hsalsa20 = function(nonce, key) {\n      var i, indexes, input, v;\n      input = this.key_iv_setup(nonce, key);\n      input[8] = nonce.words[2];\n      input[9] = nonce.words[3];\n      v = this._core(input);\n      indexes = [0, 5, 10, 15, 6, 7, 8, 9];\n      v = (function() {\n        var _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = indexes.length; _i < _len; _i++) {\n          i = indexes[_i];\n          _results.push(fixup_uint32(v[i]));\n        }\n        return _results;\n      })();\n      util.scrub_vec(input);\n      return new WordArray(v);\n    };\n\n    Salsa20Core.prototype.key_iv_setup = function(nonce, key) {\n      var A, C, i, out, _i, _j, _k, _ref1;\n      out = [];\n      for (i = _i = 0; _i < 4; i = ++_i) {\n        out[i + 1] = key.words[i];\n      }\n      _ref1 = key.sigBytes === 32 ? [this.sigma, key.words.slice(4)] : [this.tau, key.words], C = _ref1[0], A = _ref1[1];\n      for (i = _j = 0; _j < 4; i = ++_j) {\n        out[i + 11] = A[i];\n      }\n      for (i = _k = 0; _k < 4; i = ++_k) {\n        out[i * 5] = C.words[i];\n      }\n      out[6] = nonce.words[0];\n      out[7] = nonce.words[1];\n      return out;\n    };\n\n    Salsa20Core.prototype.counter_setup = function() {\n      this.input[8] = this.counter.get().words[0];\n      return this.input[9] = this.counter.get().words[1];\n    };\n\n    Salsa20Core.prototype._reset = function() {\n      return this.counter = new Counter({\n        len: 2\n      });\n    };\n\n    Salsa20Core.prototype._generateBlock = function() {\n      var v;\n      this.counter_setup();\n      v = this._core(this.input);\n      asum(v, this.input);\n      this.counter.inc_le();\n      return v;\n    };\n\n    return Salsa20Core;\n\n  })(Salsa20InnerCore);\n\n  exports.Salsa20WordStream = Salsa20WordStream = (function(_super) {\n    __extends(Salsa20WordStream, _super);\n\n    function Salsa20WordStream() {\n      return Salsa20WordStream.__super__.constructor.apply(this, arguments);\n    }\n\n    Salsa20WordStream.prototype._reset = function() {\n      return Salsa20WordStream.__super__._reset.call(this);\n    };\n\n    Salsa20WordStream.prototype.getWordArray = function(nbytes) {\n      var blocks, i, nblocks, w, words, _i, _len, _ref1;\n      if ((nbytes == null) || nbytes === this.blockSize) {\n        words = this._generateBlock();\n      } else {\n        nblocks = Math.ceil(nbytes / this.blockSize);\n        blocks = (function() {\n          var _i, _results;\n          _results = [];\n          for (i = _i = 0; 0 <= nblocks ? _i < nblocks : _i > nblocks; i = 0 <= nblocks ? ++_i : --_i) {\n            _results.push(this._generateBlock());\n          }\n          return _results;\n        }).call(this);\n        words = (_ref1 = []).concat.apply(_ref1, blocks);\n      }\n      for (i = _i = 0, _len = words.length; _i < _len; i = ++_i) {\n        w = words[i];\n        words[i] = endian_reverse(w);\n      }\n      return new WordArray(words, nbytes);\n    };\n\n    return Salsa20WordStream;\n\n  })(Salsa20Core);\n\n  exports.Salsa20 = Salsa20 = (function(_super) {\n    __extends(Salsa20, _super);\n\n    function Salsa20() {\n      return Salsa20.__super__.constructor.apply(this, arguments);\n    }\n\n    Salsa20.prototype._reset = function() {\n      Salsa20.__super__._reset.call(this);\n      return this._i = this.blockSize;\n    };\n\n    Salsa20.prototype.getBytes = function(needed) {\n      var bsz, n, v;\n      if (needed == null) {\n        needed = this.blockSize;\n      }\n      v = [];\n      bsz = this.blockSize;\n      if ((this._i === bsz) && (needed === bsz)) {\n        return this._generateBlockBuffer();\n      } else {\n        while (needed > 0) {\n          if (this._i === bsz) {\n            this._generateBlockBuffer();\n            this._i = 0;\n          }\n          n = Math.min(needed, bsz - this._i);\n          v.push((n === bsz ? this._buf : this._buf.slice(this._i, this._i + n)));\n          this._i += n;\n          needed -= n;\n        }\n        return Buffer.concat(v);\n      }\n    };\n\n    Salsa20.prototype._generateBlockBuffer = function() {\n      var e, i, v, _i, _len;\n      this._buf = new Buffer(this.blockSize);\n      v = this._generateBlock();\n      for (i = _i = 0, _len = v.length; _i < _len; i = ++_i) {\n        e = v[i];\n        this._buf.writeUInt32LE(fixup_uint32(e), i * 4);\n      }\n      return this._buf;\n    };\n\n    return Salsa20;\n\n  })(Salsa20Core);\n\n  exports.Cipher = Cipher = (function(_super) {\n    __extends(Cipher, _super);\n\n    function Cipher(_arg) {\n      var iv, key;\n      key = _arg.key, iv = _arg.iv;\n      Cipher.__super__.constructor.call(this);\n      this.salsa = new Salsa20WordStream(key, iv);\n      this.bsiw = this.salsa.blockSize / 4;\n    }\n\n    Cipher.prototype.scrub = function() {\n      return this.salsa.scrub();\n    };\n\n    Cipher.prototype.get_pad = function() {\n      var pad;\n      pad = this.salsa.getWordArray();\n      return pad;\n    };\n\n    return Cipher;\n\n  })(StreamCipher);\n\n  exports.encrypt = encrypt = function(_arg) {\n    var cipher, input, iv, key, ret;\n    key = _arg.key, iv = _arg.iv, input = _arg.input;\n    cipher = new Cipher({\n      key: key,\n      iv: iv\n    });\n    ret = cipher.encrypt(input);\n    cipher.scrub();\n    return ret;\n  };\n\n  exports.bulk_encrypt = bulk_encrypt = function(_arg, cb) {\n    var cipher, input, iv, key, progress_hook, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    key = _arg.key, iv = _arg.iv, input = _arg.input, progress_hook = _arg.progress_hook;\n    cipher = new Cipher({\n      key: key,\n      iv: iv\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/home/max/src/keybase/triplesec/src/salsa20.iced\"\n        });\n        cipher.bulk_encrypt({\n          input: input,\n          progress_hook: progress_hook,\n          what: \"salsa20\"\n        }, __iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              return ret = arguments[0];\n            };\n          })(),\n          lineno: 257\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        cipher.scrub();\n        return cb(ret);\n      };\n    })(this));\n  };\n\n  exports.Salsa20InnerCore = Salsa20InnerCore;\n\n  exports.endian_reverse = endian_reverse;\n\n  exports.asum = asum;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./algbase\":174,\"./ctr\":176,\"./util\":195,\"./wordarray\":196,\"buffer\":80,\"iced-runtime\":118}],187:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var HMAC_SHA256, Salsa20InnerCore, Scrypt, Timer, WordArray, blkcpy, blkxor, default_delay, endian_reverse, fixup_uint32, iced, pbkdf2, scrub_vec, scrypt, timer, ui8a_to_buffer, v_endian_reverse, __iced_k, __iced_k_noop, _ref, _ref1, _ref2;\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  HMAC_SHA256 = require('./hmac').HMAC_SHA256;\n\n  pbkdf2 = require('./pbkdf2').pbkdf2;\n\n  _ref = require('./salsa20'), endian_reverse = _ref.endian_reverse, Salsa20InnerCore = _ref.Salsa20InnerCore;\n\n  _ref1 = require('./wordarray'), ui8a_to_buffer = _ref1.ui8a_to_buffer, WordArray = _ref1.WordArray;\n\n  _ref2 = require('./util'), fixup_uint32 = _ref2.fixup_uint32, default_delay = _ref2.default_delay, scrub_vec = _ref2.scrub_vec;\n\n  Timer = (function() {\n    function Timer() {\n      this.tot = 0;\n    }\n\n    Timer.prototype.start = function() {\n      return this._t = Date.now();\n    };\n\n    Timer.prototype.stop = function() {\n      return this.tot += Date.now() - this._t;\n    };\n\n    return Timer;\n\n  })();\n\n  timer = new Timer();\n\n  blkcpy = function(D, S, d_offset, s_offset, len) {\n    \"use asm\";\n    var end, i, j;\n    j = (d_offset << 4) | 0;\n    i = (s_offset << 4) | 0;\n    end = (i + (len << 4)) | 0;\n    while (i < end) {\n      D[j] = S[i];\n      D[j + 1] = S[i + 1];\n      D[j + 2] = S[i + 2];\n      D[j + 3] = S[i + 3];\n      D[j + 4] = S[i + 4];\n      D[j + 5] = S[i + 5];\n      D[j + 6] = S[i + 6];\n      D[j + 7] = S[i + 7];\n      D[j + 8] = S[i + 8];\n      D[j + 9] = S[i + 9];\n      D[j + 10] = S[i + 10];\n      D[j + 11] = S[i + 11];\n      D[j + 12] = S[i + 12];\n      D[j + 13] = S[i + 13];\n      D[j + 14] = S[i + 14];\n      D[j + 15] = S[i + 15];\n      i += 16;\n      j += 16;\n    }\n    return true;\n  };\n\n  blkxor = function(D, S, s_offset, len) {\n    \"use asm\";\n    var i, j;\n    len = (len << 4) | 0;\n    i = 0;\n    j = (s_offset << 4) | 0;\n    while (i < len) {\n      D[i] ^= S[j];\n      D[i + 1] ^= S[j + 1];\n      D[i + 2] ^= S[j + 2];\n      D[i + 3] ^= S[j + 3];\n      D[i + 4] ^= S[j + 4];\n      D[i + 5] ^= S[j + 5];\n      D[i + 6] ^= S[j + 6];\n      D[i + 7] ^= S[j + 7];\n      D[i + 8] ^= S[j + 8];\n      D[i + 9] ^= S[j + 9];\n      D[i + 10] ^= S[j + 10];\n      D[i + 11] ^= S[j + 11];\n      D[i + 12] ^= S[j + 12];\n      D[i + 13] ^= S[j + 13];\n      D[i + 14] ^= S[j + 14];\n      D[i + 15] ^= S[j + 15];\n      i += 16;\n      j += 16;\n    }\n    return true;\n  };\n\n  v_endian_reverse = function(v) {\n    var e, i, _i, _len;\n    for (i = _i = 0, _len = v.length; _i < _len; i = ++_i) {\n      e = v[i];\n      v[i] = endian_reverse(e);\n    }\n    return true;\n  };\n\n  Scrypt = (function() {\n    function Scrypt(_arg) {\n      var N, c, c0, c1;\n      N = _arg.N, this.r = _arg.r, this.p = _arg.p, c = _arg.c, c0 = _arg.c0, c1 = _arg.c1, this.klass = _arg.klass;\n      this.N || (this.N = 1 << (N || 15));\n      this.r || (this.r = 8);\n      this.p || (this.p = 1);\n      this.c0 = c0 || c || 1;\n      this.c1 = c1 || c || 1;\n      this.klass || (this.klass = HMAC_SHA256);\n      this.X16_tmp = new Int32Array(0x10);\n      this.s20ic = new Salsa20InnerCore(8);\n    }\n\n    Scrypt.prototype.salsa20_8 = function(B) {\n      var X, i, x, _i, _len;\n      X = this.s20ic._core(B);\n      for (i = _i = 0, _len = X.length; _i < _len; i = ++_i) {\n        x = X[i];\n        B[i] += x;\n      }\n      return true;\n    };\n\n    Scrypt.prototype.pbkdf2 = function(_arg, cb) {\n      var c, dkLen, key, progress_hook, salt, wa, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      key = _arg.key, salt = _arg.salt, dkLen = _arg.dkLen, progress_hook = _arg.progress_hook, c = _arg.c;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/triplesec/src/scrypt.iced\",\n            funcname: \"Scrypt.pbkdf2\"\n          });\n          pbkdf2({\n            key: key,\n            salt: salt,\n            c: c,\n            dkLen: dkLen,\n            klass: _this.klass,\n            progress_hook: progress_hook\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return wa = arguments[0];\n              };\n            })(),\n            lineno: 113\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(wa);\n        };\n      })(this));\n    };\n\n    Scrypt.prototype.blockmix_salsa8 = function(B, Y) {\n      var X, i, _i, _ref3;\n      X = this.X16_tmp;\n      blkcpy(X, B, 0, 2 * this.r - 1, 1);\n      for (i = _i = 0, _ref3 = 2 * this.r; 0 <= _ref3 ? _i < _ref3 : _i > _ref3; i = 0 <= _ref3 ? ++_i : --_i) {\n        blkxor(X, B, i, 1);\n        this.salsa20_8(X);\n        blkcpy(Y, X, i, 0, 1);\n      }\n      i = 0;\n      while (i < this.r) {\n        blkcpy(B, Y, i, i * 2, 1);\n        i++;\n      }\n      i = 0;\n      while (i < this.r) {\n        blkcpy(B, Y, i + this.r, i * 2 + 1, 1);\n        i++;\n      }\n      return true;\n    };\n\n    Scrypt.prototype.smix = function(_arg, cb) {\n      var B, V, X, XY, Y, i, j, lim, progress_hook, stop, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      B = _arg.B, V = _arg.V, XY = _arg.XY, progress_hook = _arg.progress_hook;\n      X = XY;\n      lim = 2 * this.r;\n      Y = XY.subarray(0x10 * lim);\n      blkcpy(X, B, 0, 0, lim);\n      i = 0;\n      (function(_this) {\n        return (function(__iced_k) {\n          var _results, _while;\n          _results = [];\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = function() {\n              return __iced_k(_results);\n            };\n            _continue = function() {\n              return iced.trampoline(function() {\n                return _while(__iced_k);\n              });\n            };\n            _next = function(__iced_next_arg) {\n              _results.push(__iced_next_arg);\n              return _continue();\n            };\n            if (!(i < _this.N)) {\n              return _break();\n            } else {\n              stop = Math.min(_this.N, i + 2048);\n              while (i < stop) {\n                blkcpy(V, X, lim * i, 0, lim);\n                _this.blockmix_salsa8(X, Y);\n                i++;\n              }\n              if (typeof progress_hook === \"function\") {\n                progress_hook(i);\n              }\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/max/src/keybase/triplesec/src/scrypt.iced\",\n                  funcname: \"Scrypt.smix\"\n                });\n                default_delay(0, 0, __iced_deferrals.defer({\n                  lineno: 170\n                }));\n                __iced_deferrals._fulfill();\n              })(_next);\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          i = 0;\n          (function(__iced_k) {\n            var _results, _while;\n            _results = [];\n            _while = function(__iced_k) {\n              var _break, _continue, _next;\n              _break = function() {\n                return __iced_k(_results);\n              };\n              _continue = function() {\n                return iced.trampoline(function() {\n                  return _while(__iced_k);\n                });\n              };\n              _next = function(__iced_next_arg) {\n                _results.push(__iced_next_arg);\n                return _continue();\n              };\n              if (!(i < _this.N)) {\n                return _break();\n              } else {\n                stop = Math.min(_this.N, i + 256);\n                while (i < stop) {\n                  j = fixup_uint32(X[0x10 * (lim - 1)]) & (_this.N - 1);\n                  blkxor(X, V, j * lim, lim);\n                  _this.blockmix_salsa8(X, Y);\n                  i++;\n                }\n                if (typeof progress_hook === \"function\") {\n                  progress_hook(i + _this.N);\n                }\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/home/max/src/keybase/triplesec/src/scrypt.iced\",\n                    funcname: \"Scrypt.smix\"\n                  });\n                  default_delay(0, 0, __iced_deferrals.defer({\n                    lineno: 187\n                  }));\n                  __iced_deferrals._fulfill();\n                })(_next);\n              }\n            };\n            _while(__iced_k);\n          })(function() {\n            blkcpy(B, X, 0, 0, lim);\n            return cb();\n          });\n        };\n      })(this));\n    };\n\n    Scrypt.prototype.run = function(_arg, cb) {\n      var B, MAX, V, XY, dkLen, err, j, key, lph, out, progress_hook, ret, salt, ___iced_passed_deferral, __iced_deferrals, __iced_k, _begin, _end, _positive;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      key = _arg.key, salt = _arg.salt, dkLen = _arg.dkLen, progress_hook = _arg.progress_hook;\n      MAX = 0xffffffff;\n      err = ret = null;\n      err = dkLen > MAX ? err = new Error(\"asked for too much data\") : this.r * this.p >= (1 << 30) ? new Error(\"r & p are too big\") : (this.r > MAX / 128 / this.p) || (this.r > MAX / 256) || (this.N > MAX / 128 / this.r) ? new Error(\"N is too big\") : null;\n      XY = new Int32Array(64 * this.r);\n      V = new Int32Array(32 * this.r * this.N);\n      lph = function(o) {\n        o.what += \" (pass 1)\";\n        return typeof progress_hook === \"function\" ? progress_hook(o) : void 0;\n      };\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/max/src/keybase/triplesec/src/scrypt.iced\",\n            funcname: \"Scrypt.run\"\n          });\n          _this.pbkdf2({\n            key: key.clone(),\n            salt: salt,\n            dkLen: 128 * _this.r * _this.p,\n            c: _this.c0,\n            progress_hook: lph\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return B = arguments[0];\n              };\n            })(),\n            lineno: 218\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          B = new Int32Array(B.words);\n          v_endian_reverse(B);\n          lph = function(j) {\n            return function(i) {\n              return typeof progress_hook === \"function\" ? progress_hook({\n                i: i + j * _this.N * 2,\n                what: \"scrypt\",\n                total: _this.p * _this.N * 2\n              }) : void 0;\n            };\n          };\n          (function(__iced_k) {\n            var _i, _results, _while;\n            j = 0;\n            _begin = 0;\n            _end = _this.p;\n            _positive = _end > _begin;\n            _results = [];\n            _while = function(__iced_k) {\n              var _break, _continue, _next;\n              _break = function() {\n                return __iced_k(_results);\n              };\n              _continue = function() {\n                return iced.trampoline(function() {\n                  if (_positive) {\n                    j += 1;\n                  } else {\n                    j -= 1;\n                  }\n                  return _while(__iced_k);\n                });\n              };\n              _next = function(__iced_next_arg) {\n                _results.push(__iced_next_arg);\n                return _continue();\n              };\n              if (!!((_positive === true && j >= _this.p) || (_positive === false && j <= _this.p))) {\n                return _break();\n              } else {\n\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/home/max/src/keybase/triplesec/src/scrypt.iced\",\n                    funcname: \"Scrypt.run\"\n                  });\n                  _this.smix({\n                    B: B.subarray(32 * _this.r * j),\n                    V: V,\n                    XY: XY,\n                    progress_hook: lph(j)\n                  }, __iced_deferrals.defer({\n                    lineno: 225\n                  }));\n                  __iced_deferrals._fulfill();\n                })(_next);\n              }\n            };\n            _while(__iced_k);\n          })(function() {\n            v_endian_reverse(B);\n            lph = function(o) {\n              o.what += \" (pass 2)\";\n              return typeof progress_hook === \"function\" ? progress_hook(o) : void 0;\n            };\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/triplesec/src/scrypt.iced\",\n                funcname: \"Scrypt.run\"\n              });\n              _this.pbkdf2({\n                key: key,\n                salt: WordArray.from_i32a(B),\n                dkLen: dkLen,\n                c: _this.c1,\n                progress_hook: lph\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return out = arguments[0];\n                  };\n                })(),\n                lineno: 233\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              scrub_vec(XY);\n              scrub_vec(V);\n              scrub_vec(B);\n              key.scrub();\n              return cb(out);\n            });\n          });\n        };\n      })(this));\n    };\n\n    return Scrypt;\n\n  })();\n\n  scrypt = function(_arg, cb) {\n    var N, c, c0, c1, dkLen, eng, key, klass, p, progress_hook, r, salt, wa, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    key = _arg.key, salt = _arg.salt, r = _arg.r, N = _arg.N, p = _arg.p, c0 = _arg.c0, c1 = _arg.c1, c = _arg.c, klass = _arg.klass, progress_hook = _arg.progress_hook, dkLen = _arg.dkLen;\n    eng = new Scrypt({\n      r: r,\n      N: N,\n      p: p,\n      c: c,\n      c0: c0,\n      c1: c1,\n      klass: klass\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/home/max/src/keybase/triplesec/src/scrypt.iced\"\n        });\n        eng.run({\n          key: key,\n          salt: salt,\n          progress_hook: progress_hook,\n          dkLen: dkLen\n        }, __iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              return wa = arguments[0];\n            };\n          })(),\n          lineno: 263\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(wa);\n      };\n    })(this));\n  };\n\n  exports.Scrypt = Scrypt;\n\n  exports.scrypt = scrypt;\n\n  exports.v_endian_reverse = v_endian_reverse;\n\n}).call(this);\n\n},{\"./hmac\":180,\"./pbkdf2\":183,\"./salsa20\":186,\"./util\":195,\"./wordarray\":196,\"iced-runtime\":118}],188:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var Hasher, SHA1, W, WordArray, transform,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  WordArray = require('./wordarray').WordArray;\n\n  Hasher = require('./algbase').Hasher;\n\n  W = [];\n\n  SHA1 = (function(_super) {\n    __extends(SHA1, _super);\n\n    function SHA1() {\n      return SHA1.__super__.constructor.apply(this, arguments);\n    }\n\n    SHA1.blockSize = 512 / 32;\n\n    SHA1.prototype.blockSize = SHA1.blockSize;\n\n    SHA1.output_size = 20;\n\n    SHA1.prototype.output_size = SHA1.output_size;\n\n    SHA1.prototype._doReset = function() {\n      return this._hash = new WordArray([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]);\n    };\n\n    SHA1.prototype._doProcessBlock = function(M, offset) {\n      var H, a, b, c, d, e, i, n, t, _i;\n      H = this._hash.words;\n      a = H[0];\n      b = H[1];\n      c = H[2];\n      d = H[3];\n      e = H[4];\n      for (i = _i = 0; _i < 80; i = ++_i) {\n        if (i < 16) {\n          W[i] = M[offset + i] | 0;\n        } else {\n          n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n          W[i] = (n << 1) | (n >>> 31);\n        }\n        t = ((a << 5) | (a >>> 27)) + e + W[i];\n        if (i < 20) {\n          t += ((b & c) | (~b & d)) + 0x5a827999;\n        } else if (i < 40) {\n          t += (b ^ c ^ d) + 0x6ed9eba1;\n        } else if (i < 60) {\n          t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;\n        } else {\n          t += (b ^ c ^ d) - 0x359d3e2a;\n        }\n        e = d;\n        d = c;\n        c = (b << 30) | (b >>> 2);\n        b = a;\n        a = t;\n      }\n      H[0] = (H[0] + a) | 0;\n      H[1] = (H[1] + b) | 0;\n      H[2] = (H[2] + c) | 0;\n      H[3] = (H[3] + d) | 0;\n      return H[4] = (H[4] + e) | 0;\n    };\n\n    SHA1.prototype._doFinalize = function() {\n      var data, dataWords, nBitsLeft, nBitsTotal;\n      data = this._data;\n      dataWords = data.words;\n      nBitsTotal = this._nDataBytes * 8;\n      nBitsLeft = data.sigBytes * 8;\n      dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n      data.sigBytes = dataWords.length * 4;\n      this._process();\n      return this._hash;\n    };\n\n    SHA1.prototype.copy_to = function(obj) {\n      SHA1.__super__.copy_to.call(this, obj);\n      return obj._hash = this._hash.clone();\n    };\n\n    SHA1.prototype.clone = function() {\n      var out;\n      out = new SHA1();\n      this.copy_to(out);\n      return out;\n    };\n\n    return SHA1;\n\n  })(Hasher);\n\n  transform = transform = function(x) {\n    var out;\n    out = (new SHA1).finalize(x);\n    x.scrub();\n    return out;\n  };\n\n  exports.SHA1 = SHA1;\n\n  exports.transform = transform;\n\n}).call(this);\n\n},{\"./algbase\":174,\"./wordarray\":196}],189:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var SHA224, SHA256, WordArray, transform,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  WordArray = require('./wordarray').WordArray;\n\n  SHA256 = require('./sha256').SHA256;\n\n  SHA224 = (function(_super) {\n    __extends(SHA224, _super);\n\n    function SHA224() {\n      return SHA224.__super__.constructor.apply(this, arguments);\n    }\n\n    SHA224.output_size = 224 / 8;\n\n    SHA224.prototype.output_size = SHA224.output_size;\n\n    SHA224.prototype._doReset = function() {\n      return this._hash = new WordArray([0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4]);\n    };\n\n    SHA224.prototype._doFinalize = function() {\n      var hash;\n      hash = SHA224.__super__._doFinalize.call(this);\n      hash.sigBytes -= 4;\n      return hash;\n    };\n\n    SHA224.prototype.clone = function() {\n      var out;\n      out = new SHA224();\n      this.copy_to(out);\n      return out;\n    };\n\n    return SHA224;\n\n  })(SHA256);\n\n  transform = function(x) {\n    var out;\n    out = (new SHA224).finalize(x);\n    x.scrub();\n    return out;\n  };\n\n  exports.SHA224 = SHA224;\n\n  exports.transform = transform;\n\n}).call(this);\n\n},{\"./sha256\":190,\"./wordarray\":196}],190:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var Global, Hasher, SHA256, WordArray, glbl, transform,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  WordArray = require('./wordarray').WordArray;\n\n  Hasher = require('./algbase').Hasher;\n\n  Global = (function() {\n    function Global() {\n      this.H = [];\n      this.K = [];\n      this.W = [];\n      this.init();\n    }\n\n    Global.prototype.isPrime = function(n) {\n      var f, sqn, _i;\n      if (n === 2 || n === 3 || n === 5 || n === 7) {\n        return true;\n      }\n      if (n === 1 || n === 4 || n === 6 || n === 8 || n === 9) {\n        return false;\n      }\n      sqn = Math.ceil(Math.sqrt(n));\n      for (f = _i = 2; 2 <= sqn ? _i <= sqn : _i >= sqn; f = 2 <= sqn ? ++_i : --_i) {\n        if ((n % f) === 0) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    Global.prototype.getFractionalBits = function(n) {\n      return ((n - (n | 0)) * 0x100000000) | 0;\n    };\n\n    Global.prototype.init = function() {\n      var n, nPrime, _results;\n      n = 2;\n      nPrime = 0;\n      _results = [];\n      while (nPrime < 64) {\n        if (this.isPrime(n)) {\n          if (nPrime < 8) {\n            this.H[nPrime] = this.getFractionalBits(Math.pow(n, 1 / 2));\n          }\n          this.K[nPrime] = this.getFractionalBits(Math.pow(n, 1 / 3));\n          nPrime++;\n        }\n        _results.push(n++);\n      }\n      return _results;\n    };\n\n    return Global;\n\n  })();\n\n  glbl = new Global();\n\n  SHA256 = (function(_super) {\n    __extends(SHA256, _super);\n\n    function SHA256() {\n      return SHA256.__super__.constructor.apply(this, arguments);\n    }\n\n    SHA256.blockSize = 512 / 32;\n\n    SHA256.prototype.blockSize = SHA256.blockSize;\n\n    SHA256.output_size = 256 / 8;\n\n    SHA256.prototype.output_size = SHA256.output_size;\n\n    SHA256.prototype._doReset = function() {\n      return this._hash = new WordArray(glbl.H.slice(0));\n    };\n\n    SHA256.prototype.get_output_size = function() {\n      return this.output_size;\n    };\n\n    SHA256.prototype._doProcessBlock = function(M, offset) {\n      var H, K, W, a, b, c, ch, d, e, f, g, gamma0, gamma0x, gamma1, gamma1x, h, i, maj, sigma0, sigma1, t1, t2, _i;\n      H = this._hash.words;\n      W = glbl.W;\n      K = glbl.K;\n      a = H[0];\n      b = H[1];\n      c = H[2];\n      d = H[3];\n      e = H[4];\n      f = H[5];\n      g = H[6];\n      h = H[7];\n      for (i = _i = 0; _i < 64; i = ++_i) {\n        if (i < 16) {\n          W[i] = M[offset + i] | 0;\n        } else {\n          gamma0x = W[i - 15];\n          gamma0 = ((gamma0x << 25) | (gamma0x >>> 7)) ^ ((gamma0x << 14) | (gamma0x >>> 18)) ^ (gamma0x >>> 3);\n          gamma1x = W[i - 2];\n          gamma1 = ((gamma1x << 15) | (gamma1x >>> 17)) ^ ((gamma1x << 13) | (gamma1x >>> 19)) ^ (gamma1x >>> 10);\n          W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n        }\n        ch = (e & f) ^ (~e & g);\n        maj = (a & b) ^ (a & c) ^ (b & c);\n        sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n        sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7) | (e >>> 25));\n        t1 = h + sigma1 + ch + K[i] + W[i];\n        t2 = sigma0 + maj;\n        h = g;\n        g = f;\n        f = e;\n        e = (d + t1) | 0;\n        d = c;\n        c = b;\n        b = a;\n        a = (t1 + t2) | 0;\n      }\n      H[0] = (H[0] + a) | 0;\n      H[1] = (H[1] + b) | 0;\n      H[2] = (H[2] + c) | 0;\n      H[3] = (H[3] + d) | 0;\n      H[4] = (H[4] + e) | 0;\n      H[5] = (H[5] + f) | 0;\n      H[6] = (H[6] + g) | 0;\n      return H[7] = (H[7] + h) | 0;\n    };\n\n    SHA256.prototype._doFinalize = function() {\n      var data, dataWords, nBitsLeft, nBitsTotal;\n      data = this._data;\n      dataWords = data.words;\n      nBitsTotal = this._nDataBytes * 8;\n      nBitsLeft = data.sigBytes * 8;\n      dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n      data.sigBytes = dataWords.length * 4;\n      this._process();\n      return this._hash;\n    };\n\n    SHA256.prototype.scrub = function() {\n      return this._hash.scrub();\n    };\n\n    SHA256.prototype.copy_to = function(obj) {\n      SHA256.__super__.copy_to.call(this, obj);\n      return obj._hash = this._hash.clone();\n    };\n\n    SHA256.prototype.clone = function() {\n      var out;\n      out = new SHA256();\n      this.copy_to(out);\n      return out;\n    };\n\n    return SHA256;\n\n  })(Hasher);\n\n  transform = function(x) {\n    var out;\n    out = (new SHA256).finalize(x);\n    x.scrub();\n    return out;\n  };\n\n  exports.SHA256 = SHA256;\n\n  exports.transform = transform;\n\n}).call(this);\n\n},{\"./algbase\":174,\"./wordarray\":196}],191:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var Global, Hasher, SHA3, WordArray, X64Word, X64WordArray, glbl, _ref,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  _ref = require('./wordarray'), WordArray = _ref.WordArray, X64Word = _ref.X64Word, X64WordArray = _ref.X64WordArray;\n\n  Hasher = require('./algbase').Hasher;\n\n  Global = (function() {\n    function Global() {\n      this.RHO_OFFSETS = [];\n      this.PI_INDEXES = [];\n      this.ROUND_CONSTANTS = [];\n      this.T = [];\n      this.compute_rho_offsets();\n      this.compute_pi_indexes();\n      this.compute_round_constants();\n      this.make_reusables();\n    }\n\n    Global.prototype.compute_rho_offsets = function() {\n      var newX, newY, t, x, y, _i, _results;\n      x = 1;\n      y = 0;\n      _results = [];\n      for (t = _i = 0; _i < 24; t = ++_i) {\n        this.RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;\n        newX = y % 5;\n        newY = (2 * x + 3 * y) % 5;\n        x = newX;\n        _results.push(y = newY);\n      }\n      return _results;\n    };\n\n    Global.prototype.compute_pi_indexes = function() {\n      var x, y, _i, _results;\n      _results = [];\n      for (x = _i = 0; _i < 5; x = ++_i) {\n        _results.push((function() {\n          var _j, _results1;\n          _results1 = [];\n          for (y = _j = 0; _j < 5; y = ++_j) {\n            _results1.push(this.PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5);\n          }\n          return _results1;\n        }).call(this));\n      }\n      return _results;\n    };\n\n    Global.prototype.compute_round_constants = function() {\n      var LFSR, bitPosition, i, j, roundConstantLsw, roundConstantMsw, _i, _j, _results;\n      LFSR = 0x01;\n      _results = [];\n      for (i = _i = 0; _i < 24; i = ++_i) {\n        roundConstantMsw = 0;\n        roundConstantLsw = 0;\n        for (j = _j = 0; _j < 7; j = ++_j) {\n          if (LFSR & 0x01) {\n            bitPosition = (1 << j) - 1;\n            if (bitPosition < 32) {\n              roundConstantLsw ^= 1 << bitPosition;\n            } else {\n              roundConstantMsw ^= 1 << (bitPosition - 32);\n            }\n          }\n          if (LFSR & 0x80) {\n            LFSR = (LFSR << 1) ^ 0x71;\n          } else {\n            LFSR <<= 1;\n          }\n        }\n        _results.push(this.ROUND_CONSTANTS[i] = new X64Word(roundConstantMsw, roundConstantLsw));\n      }\n      return _results;\n    };\n\n    Global.prototype.make_reusables = function() {\n      var i;\n      return this.T = (function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; _i < 25; i = ++_i) {\n          _results.push(new X64Word(0, 0));\n        }\n        return _results;\n      })();\n    };\n\n    return Global;\n\n  })();\n\n  glbl = new Global();\n\n  exports.SHA3 = SHA3 = (function(_super) {\n    __extends(SHA3, _super);\n\n    function SHA3() {\n      return SHA3.__super__.constructor.apply(this, arguments);\n    }\n\n    SHA3.outputLength = 512;\n\n    SHA3.prototype.outputLength = SHA3.outputLength;\n\n    SHA3.blockSize = (1600 - 2 * SHA3.outputLength) / 32;\n\n    SHA3.prototype.blockSize = SHA3.blockSize;\n\n    SHA3.output_size = SHA3.outputLength / 8;\n\n    SHA3.prototype.output_size = SHA3.output_size;\n\n    SHA3.prototype._doReset = function() {\n      var i;\n      return this._state = (function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; _i < 25; i = ++_i) {\n          _results.push(new X64Word(0, 0));\n        }\n        return _results;\n      })();\n    };\n\n    SHA3.prototype._doProcessBlock = function(M, offset) {\n      var G, M2i, M2i1, T0, TLane, TPiLane, Tx, Tx1, Tx1Lane, Tx1Lsw, Tx1Msw, Tx2Lane, Tx4, i, lane, laneIndex, laneLsw, laneMsw, nBlockSizeLanes, rhoOffset, round, roundConstant, state, state0, tLsw, tMsw, x, y, _i, _j, _k, _l, _m, _n, _o, _p, _q, _results;\n      G = glbl;\n      state = this._state;\n      nBlockSizeLanes = this.blockSize / 2;\n      for (i = _i = 0; 0 <= nBlockSizeLanes ? _i < nBlockSizeLanes : _i > nBlockSizeLanes; i = 0 <= nBlockSizeLanes ? ++_i : --_i) {\n        M2i = M[offset + 2 * i];\n        M2i1 = M[offset + 2 * i + 1];\n        M2i = (((M2i << 8) | (M2i >>> 24)) & 0x00ff00ff) | (((M2i << 24) | (M2i >>> 8)) & 0xff00ff00);\n        M2i1 = (((M2i1 << 8) | (M2i1 >>> 24)) & 0x00ff00ff) | (((M2i1 << 24) | (M2i1 >>> 8)) & 0xff00ff00);\n        lane = state[i];\n        lane.high ^= M2i1;\n        lane.low ^= M2i;\n      }\n      _results = [];\n      for (round = _j = 0; _j < 24; round = ++_j) {\n        for (x = _k = 0; _k < 5; x = ++_k) {\n          tMsw = tLsw = 0;\n          for (y = _l = 0; _l < 5; y = ++_l) {\n            lane = state[x + 5 * y];\n            tMsw ^= lane.high;\n            tLsw ^= lane.low;\n          }\n          Tx = G.T[x];\n          Tx.high = tMsw;\n          Tx.low = tLsw;\n        }\n        for (x = _m = 0; _m < 5; x = ++_m) {\n          Tx4 = G.T[(x + 4) % 5];\n          Tx1 = G.T[(x + 1) % 5];\n          Tx1Msw = Tx1.high;\n          Tx1Lsw = Tx1.low;\n          tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));\n          tLsw = Tx4.low ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));\n          for (y = _n = 0; _n < 5; y = ++_n) {\n            lane = state[x + 5 * y];\n            lane.high ^= tMsw;\n            lane.low ^= tLsw;\n          }\n        }\n        for (laneIndex = _o = 1; _o < 25; laneIndex = ++_o) {\n          lane = state[laneIndex];\n          laneMsw = lane.high;\n          laneLsw = lane.low;\n          rhoOffset = G.RHO_OFFSETS[laneIndex];\n          if (rhoOffset < 32) {\n            tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));\n            tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));\n          } else {\n            tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));\n            tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));\n          }\n          TPiLane = G.T[G.PI_INDEXES[laneIndex]];\n          TPiLane.high = tMsw;\n          TPiLane.low = tLsw;\n        }\n        T0 = G.T[0];\n        state0 = state[0];\n        T0.high = state0.high;\n        T0.low = state0.low;\n        for (x = _p = 0; _p < 5; x = ++_p) {\n          for (y = _q = 0; _q < 5; y = ++_q) {\n            laneIndex = x + 5 * y;\n            lane = state[laneIndex];\n            TLane = G.T[laneIndex];\n            Tx1Lane = G.T[((x + 1) % 5) + 5 * y];\n            Tx2Lane = G.T[((x + 2) % 5) + 5 * y];\n            lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);\n            lane.low = TLane.low ^ (~Tx1Lane.low & Tx2Lane.low);\n          }\n        }\n        lane = state[0];\n        roundConstant = G.ROUND_CONSTANTS[round];\n        lane.high ^= roundConstant.high;\n        _results.push(lane.low ^= roundConstant.low);\n      }\n      return _results;\n    };\n\n    SHA3.prototype._doFinalize = function() {\n      var blockSizeBits, data, dataWords, hashWords, i, lane, laneLsw, laneMsw, nBitsLeft, nBitsTotal, outputLengthBytes, outputLengthLanes, state, _i;\n      data = this._data;\n      dataWords = data.words;\n      nBitsTotal = this._nDataBytes * 8;\n      nBitsLeft = data.sigBytes * 8;\n      blockSizeBits = this.blockSize * 32;\n      dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);\n      dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;\n      data.sigBytes = dataWords.length * 4;\n      this._process();\n      state = this._state;\n      outputLengthBytes = this.outputLength / 8;\n      outputLengthLanes = outputLengthBytes / 8;\n      hashWords = [];\n      for (i = _i = 0; 0 <= outputLengthLanes ? _i < outputLengthLanes : _i > outputLengthLanes; i = 0 <= outputLengthLanes ? ++_i : --_i) {\n        lane = state[i];\n        laneMsw = lane.high;\n        laneLsw = lane.low;\n        laneMsw = (((laneMsw << 8) | (laneMsw >>> 24)) & 0x00ff00ff) | (((laneMsw << 24) | (laneMsw >>> 8)) & 0xff00ff00);\n        laneLsw = (((laneLsw << 8) | (laneLsw >>> 24)) & 0x00ff00ff) | (((laneLsw << 24) | (laneLsw >>> 8)) & 0xff00ff00);\n        hashWords.push(laneLsw);\n        hashWords.push(laneMsw);\n      }\n      return new WordArray(hashWords, outputLengthBytes);\n    };\n\n    SHA3.prototype.copy_to = function(obj) {\n      var s;\n      SHA3.__super__.copy_to.call(this, obj);\n      return obj._state = (function() {\n        var _i, _len, _ref1, _results;\n        _ref1 = this._state;\n        _results = [];\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          s = _ref1[_i];\n          _results.push(s.clone());\n        }\n        return _results;\n      }).call(this);\n    };\n\n    SHA3.prototype.scrub = function() {};\n\n    SHA3.prototype.clone = function() {\n      var out;\n      out = new SHA3();\n      this.copy_to(out);\n      return out;\n    };\n\n    return SHA3;\n\n  })(Hasher);\n\n  exports.transform = function(x) {\n    var out;\n    out = (new SHA3).finalize(x);\n    x.scrub();\n    return out;\n  };\n\n}).call(this);\n\n},{\"./algbase\":174,\"./wordarray\":196}],192:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var Global, SHA384, SHA512, WordArray, X64WordArray, transform, _ref, _ref1,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  _ref = require('./wordarray'), X64WordArray = _ref.X64WordArray, WordArray = _ref.WordArray;\n\n  _ref1 = require('./sha512'), SHA512 = _ref1.SHA512, Global = _ref1.Global;\n\n  SHA384 = (function(_super) {\n    __extends(SHA384, _super);\n\n    function SHA384() {\n      return SHA384.__super__.constructor.apply(this, arguments);\n    }\n\n    SHA384.output_size = 384 / 8;\n\n    SHA384.prototype.output_size = SHA384.output_size;\n\n    SHA384.prototype._doReset = function() {\n      return this._hash = new X64WordArray(Global.convert([0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939, 0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4]));\n    };\n\n    SHA384.prototype._doFinalize = function() {\n      var hash;\n      hash = SHA384.__super__._doFinalize.call(this);\n      hash.sigBytes -= 16;\n      return hash;\n    };\n\n    SHA384.prototype.clone = function() {\n      var out;\n      out = new SHA384();\n      this.copy_to(out);\n      return out;\n    };\n\n    return SHA384;\n\n  })(SHA512);\n\n  transform = function(x) {\n    var out;\n    out = (new SHA384).finalize(x);\n    x.scrub();\n    return out;\n  };\n\n  exports.SHA384 = SHA384;\n\n  exports.transform = transform;\n\n}).call(this);\n\n},{\"./sha512\":193,\"./wordarray\":196}],193:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var Global, Hasher, SHA512, X64Word, X64WordArray, glbl, _ref,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  _ref = require('./wordarray'), X64Word = _ref.X64Word, X64WordArray = _ref.X64WordArray;\n\n  Hasher = require('./algbase').Hasher;\n\n  Global = (function() {\n    Global.convert = function(raw) {\n      var i, _i, _ref1, _results;\n      _results = [];\n      for (i = _i = 0, _ref1 = raw.length; _i < _ref1; i = _i += 2) {\n        _results.push(new X64Word(raw[i], raw[i + 1]));\n      }\n      return _results;\n    };\n\n    Global.prototype.convert = function(raw) {\n      return Global.convert(raw);\n    };\n\n    function Global() {\n      var i;\n      this.K = this.convert([0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817]);\n      this.I = new X64WordArray(this.convert([0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1, 0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179]));\n      this.W = (function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; _i < 80; i = ++_i) {\n          _results.push(new X64Word(0, 0));\n        }\n        return _results;\n      })();\n    }\n\n    return Global;\n\n  })();\n\n  exports.Global = Global;\n\n  glbl = new Global();\n\n  exports.SHA512 = SHA512 = (function(_super) {\n    __extends(SHA512, _super);\n\n    function SHA512() {\n      return SHA512.__super__.constructor.apply(this, arguments);\n    }\n\n    SHA512.blockSize = 1024 / 32;\n\n    SHA512.prototype.blockSize = SHA512.blockSize;\n\n    SHA512.output_size = 512 / 8;\n\n    SHA512.prototype.output_size = SHA512.output_size;\n\n    SHA512.prototype._doReset = function() {\n      return this._hash = glbl.I.clone();\n    };\n\n    SHA512.prototype._doProcessBlock = function(M, offset) {\n      var H, H0, H0h, H0l, H1, H1h, H1l, H2, H2h, H2l, H3, H3h, H3l, H4, H4h, H4l, H5, H5h, H5l, H6, H6h, H6l, H7, H7h, H7l, Ki, Kih, Kil, W, Wi, Wi16, Wi16h, Wi16l, Wi7, Wi7h, Wi7l, Wih, Wil, ah, al, bh, bl, ch, chh, chl, cl, dh, dl, eh, el, fh, fl, gamma0h, gamma0l, gamma0x, gamma0xh, gamma0xl, gamma1h, gamma1l, gamma1x, gamma1xh, gamma1xl, gh, gl, hh, hl, i, majh, majl, sigma0h, sigma0l, sigma1h, sigma1l, t1h, t1l, t2h, t2l, _i;\n      H = this._hash.words;\n      W = glbl.W;\n      H0 = H[0];\n      H1 = H[1];\n      H2 = H[2];\n      H3 = H[3];\n      H4 = H[4];\n      H5 = H[5];\n      H6 = H[6];\n      H7 = H[7];\n      H0h = H0.high;\n      H0l = H0.low;\n      H1h = H1.high;\n      H1l = H1.low;\n      H2h = H2.high;\n      H2l = H2.low;\n      H3h = H3.high;\n      H3l = H3.low;\n      H4h = H4.high;\n      H4l = H4.low;\n      H5h = H5.high;\n      H5l = H5.low;\n      H6h = H6.high;\n      H6l = H6.low;\n      H7h = H7.high;\n      H7l = H7.low;\n      ah = H0h;\n      al = H0l;\n      bh = H1h;\n      bl = H1l;\n      ch = H2h;\n      cl = H2l;\n      dh = H3h;\n      dl = H3l;\n      eh = H4h;\n      el = H4l;\n      fh = H5h;\n      fl = H5l;\n      gh = H6h;\n      gl = H6l;\n      hh = H7h;\n      hl = H7l;\n      for (i = _i = 0; _i < 80; i = ++_i) {\n        Wi = W[i];\n        if (i < 16) {\n          Wih = Wi.high = M[offset + i * 2] | 0;\n          Wil = Wi.low = M[offset + i * 2 + 1] | 0;\n        } else {\n          gamma0x = W[i - 15];\n          gamma0xh = gamma0x.high;\n          gamma0xl = gamma0x.low;\n          gamma0h = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);\n          gamma0l = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));\n          gamma1x = W[i - 2];\n          gamma1xh = gamma1x.high;\n          gamma1xl = gamma1x.low;\n          gamma1h = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);\n          gamma1l = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));\n          Wi7 = W[i - 7];\n          Wi7h = Wi7.high;\n          Wi7l = Wi7.low;\n          Wi16 = W[i - 16];\n          Wi16h = Wi16.high;\n          Wi16l = Wi16.low;\n          Wil = gamma0l + Wi7l;\n          Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);\n          Wil = Wil + gamma1l;\n          Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);\n          Wil = Wil + Wi16l;\n          Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);\n          Wi.high = Wih;\n          Wi.low = Wil;\n        }\n        chh = (eh & fh) ^ (~eh & gh);\n        chl = (el & fl) ^ (~el & gl);\n        majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);\n        majl = (al & bl) ^ (al & cl) ^ (bl & cl);\n        sigma0h = ((ah >>> 28) | (al << 4)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));\n        sigma0l = ((al >>> 28) | (ah << 4)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));\n        sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));\n        sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));\n        Ki = glbl.K[i];\n        Kih = Ki.high;\n        Kil = Ki.low;\n        t1l = hl + sigma1l;\n        t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);\n        t1l = t1l + chl;\n        t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);\n        t1l = t1l + Kil;\n        t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);\n        t1l = t1l + Wil;\n        t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);\n        t2l = sigma0l + majl;\n        t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);\n        hh = gh;\n        hl = gl;\n        gh = fh;\n        gl = fl;\n        fh = eh;\n        fl = el;\n        el = (dl + t1l) | 0;\n        eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n        dh = ch;\n        dl = cl;\n        ch = bh;\n        cl = bl;\n        bh = ah;\n        bl = al;\n        al = (t1l + t2l) | 0;\n        ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;\n      }\n      H0l = H0.low = H0l + al;\n      H0.high = H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0);\n      H1l = H1.low = H1l + bl;\n      H1.high = H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0);\n      H2l = H2.low = H2l + cl;\n      H2.high = H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0);\n      H3l = H3.low = H3l + dl;\n      H3.high = H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0);\n      H4l = H4.low = H4l + el;\n      H4.high = H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0);\n      H5l = H5.low = H5l + fl;\n      H5.high = H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0);\n      H6l = H6.low = H6l + gl;\n      H6.high = H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0);\n      H7l = H7.low = H7l + hl;\n      return H7.high = H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0);\n    };\n\n    SHA512.prototype._doFinalize = function() {\n      var dataWords, nBitsLeft, nBitsTotal;\n      dataWords = this._data.words;\n      nBitsTotal = this._nDataBytes * 8;\n      nBitsLeft = this._data.sigBytes * 8;\n      dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n      dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);\n      dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;\n      this._data.sigBytes = dataWords.length * 4;\n      this._process();\n      return this._hash.toX32();\n    };\n\n    SHA512.prototype.copy_to = function(obj) {\n      SHA512.__super__.copy_to.call(this, obj);\n      return obj._hash = this._hash.clone();\n    };\n\n    SHA512.prototype.clone = function() {\n      var out;\n      out = new SHA512();\n      this.copy_to(out);\n      return out;\n    };\n\n    return SHA512;\n\n  })(Hasher);\n\n  exports.transform = function(x) {\n    var out;\n    out = (new SHA512).finalize(x);\n    x.scrub();\n    return out;\n  };\n\n}).call(this);\n\n},{\"./algbase\":174,\"./wordarray\":196}],194:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var BlockCipher, G, Global, TwoFish, scrub_vec,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  BlockCipher = require('./algbase').BlockCipher;\n\n  scrub_vec = require('./util').scrub_vec;\n\n  Global = (function() {\n    function Global() {\n      this.P = [[0xA9, 0x67, 0xB3, 0xE8, 0x04, 0xFD, 0xA3, 0x76, 0x9A, 0x92, 0x80, 0x78, 0xE4, 0xDD, 0xD1, 0x38, 0x0D, 0xC6, 0x35, 0x98, 0x18, 0xF7, 0xEC, 0x6C, 0x43, 0x75, 0x37, 0x26, 0xFA, 0x13, 0x94, 0x48, 0xF2, 0xD0, 0x8B, 0x30, 0x84, 0x54, 0xDF, 0x23, 0x19, 0x5B, 0x3D, 0x59, 0xF3, 0xAE, 0xA2, 0x82, 0x63, 0x01, 0x83, 0x2E, 0xD9, 0x51, 0x9B, 0x7C, 0xA6, 0xEB, 0xA5, 0xBE, 0x16, 0x0C, 0xE3, 0x61, 0xC0, 0x8C, 0x3A, 0xF5, 0x73, 0x2C, 0x25, 0x0B, 0xBB, 0x4E, 0x89, 0x6B, 0x53, 0x6A, 0xB4, 0xF1, 0xE1, 0xE6, 0xBD, 0x45, 0xE2, 0xF4, 0xB6, 0x66, 0xCC, 0x95, 0x03, 0x56, 0xD4, 0x1C, 0x1E, 0xD7, 0xFB, 0xC3, 0x8E, 0xB5, 0xE9, 0xCF, 0xBF, 0xBA, 0xEA, 0x77, 0x39, 0xAF, 0x33, 0xC9, 0x62, 0x71, 0x81, 0x79, 0x09, 0xAD, 0x24, 0xCD, 0xF9, 0xD8, 0xE5, 0xC5, 0xB9, 0x4D, 0x44, 0x08, 0x86, 0xE7, 0xA1, 0x1D, 0xAA, 0xED, 0x06, 0x70, 0xB2, 0xD2, 0x41, 0x7B, 0xA0, 0x11, 0x31, 0xC2, 0x27, 0x90, 0x20, 0xF6, 0x60, 0xFF, 0x96, 0x5C, 0xB1, 0xAB, 0x9E, 0x9C, 0x52, 0x1B, 0x5F, 0x93, 0x0A, 0xEF, 0x91, 0x85, 0x49, 0xEE, 0x2D, 0x4F, 0x8F, 0x3B, 0x47, 0x87, 0x6D, 0x46, 0xD6, 0x3E, 0x69, 0x64, 0x2A, 0xCE, 0xCB, 0x2F, 0xFC, 0x97, 0x05, 0x7A, 0xAC, 0x7F, 0xD5, 0x1A, 0x4B, 0x0E, 0xA7, 0x5A, 0x28, 0x14, 0x3F, 0x29, 0x88, 0x3C, 0x4C, 0x02, 0xB8, 0xDA, 0xB0, 0x17, 0x55, 0x1F, 0x8A, 0x7D, 0x57, 0xC7, 0x8D, 0x74, 0xB7, 0xC4, 0x9F, 0x72, 0x7E, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34, 0x6E, 0x50, 0xDE, 0x68, 0x65, 0xBC, 0xDB, 0xF8, 0xC8, 0xA8, 0x2B, 0x40, 0xDC, 0xFE, 0x32, 0xA4, 0xCA, 0x10, 0x21, 0xF0, 0xD3, 0x5D, 0x0F, 0x00, 0x6F, 0x9D, 0x36, 0x42, 0x4A, 0x5E, 0xC1, 0xE0], [0x75, 0xF3, 0xC6, 0xF4, 0xDB, 0x7B, 0xFB, 0xC8, 0x4A, 0xD3, 0xE6, 0x6B, 0x45, 0x7D, 0xE8, 0x4B, 0xD6, 0x32, 0xD8, 0xFD, 0x37, 0x71, 0xF1, 0xE1, 0x30, 0x0F, 0xF8, 0x1B, 0x87, 0xFA, 0x06, 0x3F, 0x5E, 0xBA, 0xAE, 0x5B, 0x8A, 0x00, 0xBC, 0x9D, 0x6D, 0xC1, 0xB1, 0x0E, 0x80, 0x5D, 0xD2, 0xD5, 0xA0, 0x84, 0x07, 0x14, 0xB5, 0x90, 0x2C, 0xA3, 0xB2, 0x73, 0x4C, 0x54, 0x92, 0x74, 0x36, 0x51, 0x38, 0xB0, 0xBD, 0x5A, 0xFC, 0x60, 0x62, 0x96, 0x6C, 0x42, 0xF7, 0x10, 0x7C, 0x28, 0x27, 0x8C, 0x13, 0x95, 0x9C, 0xC7, 0x24, 0x46, 0x3B, 0x70, 0xCA, 0xE3, 0x85, 0xCB, 0x11, 0xD0, 0x93, 0xB8, 0xA6, 0x83, 0x20, 0xFF, 0x9F, 0x77, 0xC3, 0xCC, 0x03, 0x6F, 0x08, 0xBF, 0x40, 0xE7, 0x2B, 0xE2, 0x79, 0x0C, 0xAA, 0x82, 0x41, 0x3A, 0xEA, 0xB9, 0xE4, 0x9A, 0xA4, 0x97, 0x7E, 0xDA, 0x7A, 0x17, 0x66, 0x94, 0xA1, 0x1D, 0x3D, 0xF0, 0xDE, 0xB3, 0x0B, 0x72, 0xA7, 0x1C, 0xEF, 0xD1, 0x53, 0x3E, 0x8F, 0x33, 0x26, 0x5F, 0xEC, 0x76, 0x2A, 0x49, 0x81, 0x88, 0xEE, 0x21, 0xC4, 0x1A, 0xEB, 0xD9, 0xC5, 0x39, 0x99, 0xCD, 0xAD, 0x31, 0x8B, 0x01, 0x18, 0x23, 0xDD, 0x1F, 0x4E, 0x2D, 0xF9, 0x48, 0x4F, 0xF2, 0x65, 0x8E, 0x78, 0x5C, 0x58, 0x19, 0x8D, 0xE5, 0x98, 0x57, 0x67, 0x7F, 0x05, 0x64, 0xAF, 0x63, 0xB6, 0xFE, 0xF5, 0xB7, 0x3C, 0xA5, 0xCE, 0xE9, 0x68, 0x44, 0xE0, 0x4D, 0x43, 0x69, 0x29, 0x2E, 0xAC, 0x15, 0x59, 0xA8, 0x0A, 0x9E, 0x6E, 0x47, 0xDF, 0x34, 0x35, 0x6A, 0xCF, 0xDC, 0x22, 0xC9, 0xC0, 0x9B, 0x89, 0xD4, 0xED, 0xAB, 0x12, 0xA2, 0x0D, 0x52, 0xBB, 0x02, 0x2F, 0xA9, 0xD7, 0x61, 0x1E, 0xB4, 0x50, 0x04, 0xF6, 0xC2, 0x16, 0x25, 0x86, 0x56, 0x55, 0x09, 0xBE, 0x91]];\n      this.P_00 = 1;\n      this.P_01 = 0;\n      this.P_02 = 0;\n      this.P_03 = 1;\n      this.P_04 = 1;\n      this.P_10 = 0;\n      this.P_11 = 0;\n      this.P_12 = 1;\n      this.P_13 = 1;\n      this.P_14 = 0;\n      this.P_20 = 1;\n      this.P_21 = 1;\n      this.P_22 = 0;\n      this.P_23 = 0;\n      this.P_24 = 0;\n      this.P_30 = 0;\n      this.P_31 = 1;\n      this.P_32 = 1;\n      this.P_33 = 0;\n      this.P_34 = 1;\n      this.GF256_FDBK = 0x169;\n      this.GF256_FDBK_2 = this.GF256_FDBK / 2;\n      this.GF256_FDBK_4 = this.GF256_FDBK / 4;\n      this.RS_GF_FDBK = 0x14D;\n      this.SK_STEP = 0x02020202;\n      this.SK_BUMP = 0x01010101;\n      this.SK_ROTL = 9;\n    }\n\n    return Global;\n\n  })();\n\n  G = new Global();\n\n  exports.TwoFish = TwoFish = (function(_super) {\n    __extends(TwoFish, _super);\n\n    TwoFish.blockSize = 4 * 4;\n\n    TwoFish.prototype.blockSize = TwoFish.blockSize;\n\n    TwoFish.keySize = 256 / 8;\n\n    TwoFish.prototype.keySize = TwoFish.keySize;\n\n    TwoFish.ivSize = TwoFish.blockSize;\n\n    TwoFish.prototype.ivSize = TwoFish.ivSize;\n\n    function TwoFish(key) {\n      this._key = key.clone();\n      this.gMDS0 = [];\n      this.gMDS1 = [];\n      this.gMDS2 = [];\n      this.gMDS3 = [];\n      this.gSubKeys = [];\n      this.gSBox = [];\n      this.k64Cnt = 0;\n      this._doReset();\n    }\n\n    TwoFish.prototype.getByte = function(x, n) {\n      return (x >>> (n * 8)) & 0xFF;\n    };\n\n    TwoFish.prototype.switchEndianness = function(word) {\n      return ((word & 0xff) << 24) | (((word >> 8) & 0xff) << 16) | (((word >> 16) & 0xff) << 8) | ((word >> 24) & 0xff);\n    };\n\n    TwoFish.prototype.LFSR1 = function(x) {\n      return (x >> 1) ^ ((x & 0x01) !== 0 ? G.GF256_FDBK_2 : 0);\n    };\n\n    TwoFish.prototype.LFSR2 = function(x) {\n      return (x >> 2) ^ ((x & 0x02) !== 0 ? G.GF256_FDBK_2 : 0) ^ ((x & 0x01) !== 0 ? G.GF256_FDBK_4 : 0);\n    };\n\n    TwoFish.prototype.Mx_X = function(x) {\n      return x ^ this.LFSR2(x);\n    };\n\n    TwoFish.prototype.Mx_Y = function(x) {\n      return x ^ this.LFSR1(x) ^ this.LFSR2(x);\n    };\n\n    TwoFish.prototype.RS_rem = function(x) {\n      var b, g2, g3;\n      b = (x >>> 24) & 0xff;\n      g2 = ((b << 1) ^ ((b & 0x80) !== 0 ? G.RS_GF_FDBK : 0)) & 0xff;\n      g3 = ((b >>> 1) ^ ((b & 0x01) !== 0 ? G.RS_GF_FDBK >>> 1 : 0)) ^ g2;\n      return (x << 8) ^ (g3 << 24) ^ (g2 << 16) ^ (g3 << 8) ^ b;\n    };\n\n    TwoFish.prototype.RS_MDS_Encode = function(k0, k1) {\n      var i, r, _i, _j;\n      r = k1;\n      for (i = _i = 0; _i < 4; i = ++_i) {\n        r = this.RS_rem(r);\n      }\n      r ^= k0;\n      for (i = _j = 0; _j < 4; i = ++_j) {\n        r = this.RS_rem(r);\n      }\n      return r;\n    };\n\n    TwoFish.prototype.F32 = function(x, k32) {\n      var b0, b1, b2, b3, k0, k1, k2, k3, m, res;\n      b0 = this.getByte(x, 0);\n      b1 = this.getByte(x, 1);\n      b2 = this.getByte(x, 2);\n      b3 = this.getByte(x, 3);\n      k0 = k32[0];\n      k1 = k32[1];\n      k2 = k32[2];\n      k3 = k32[3];\n      m = this.k64Cnt & 3;\n      res = m === 1 ? this.gMDS0[(G.P[G.P_01][b0] & 0xff) ^ this.getByte(k0, 0)] ^ this.gMDS1[(G.P[G.P_11][b1] & 0xff) ^ this.getByte(k0, 1)] ^ this.gMDS2[(G.P[G.P_21][b2] & 0xff) ^ this.getByte(k0, 2)] ^ this.gMDS3[(G.P[G.P_31][b3] & 0xff) ^ this.getByte(k0, 3)] : (m === 0 ? (b0 = (G.P[G.P_04][b0] & 0xff) ^ this.getByte(k3, 0), b1 = (G.P[G.P_14][b1] & 0xff) ^ this.getByte(k3, 1), b2 = (G.P[G.P_24][b2] & 0xff) ^ this.getByte(k3, 2), b3 = (G.P[G.P_34][b3] & 0xff) ^ this.getByte(k3, 3)) : void 0, m === 0 || m === 3 ? (b0 = (G.P[G.P_03][b0] & 0xff) ^ this.getByte(k2, 0), b1 = (G.P[G.P_13][b1] & 0xff) ^ this.getByte(k2, 1), b2 = (G.P[G.P_23][b2] & 0xff) ^ this.getByte(k2, 2), b3 = (G.P[G.P_33][b3] & 0xff) ^ this.getByte(k2, 3)) : void 0, this.gMDS0[(G.P[G.P_01][(G.P[G.P_02][b0] & 0xff) ^ this.getByte(k1, 0)] & 0xff) ^ this.getByte(k0, 0)] ^ this.gMDS1[(G.P[G.P_11][(G.P[G.P_12][b1] & 0xff) ^ this.getByte(k1, 1)] & 0xff) ^ this.getByte(k0, 1)] ^ this.gMDS2[(G.P[G.P_21][(G.P[G.P_22][b2] & 0xff) ^ this.getByte(k1, 2)] & 0xff) ^ this.getByte(k0, 2)] ^ this.gMDS3[(G.P[G.P_31][(G.P[G.P_32][b3] & 0xff) ^ this.getByte(k1, 3)] & 0xff) ^ this.getByte(k0, 3)]);\n      return res;\n    };\n\n    TwoFish.prototype.Fe32_0 = function(x) {\n      return this.gSBox[0x000 + 2 * (x & 0xff)] ^ this.gSBox[0x001 + 2 * ((x >>> 8) & 0xff)] ^ this.gSBox[0x200 + 2 * ((x >>> 16) & 0xff)] ^ this.gSBox[0x201 + 2 * ((x >>> 24) & 0xff)];\n    };\n\n    TwoFish.prototype.Fe32_3 = function(x) {\n      return this.gSBox[0x000 + 2 * ((x >>> 24) & 0xff)] ^ this.gSBox[0x001 + 2 * (x & 0xff)] ^ this.gSBox[0x200 + 2 * ((x >>> 8) & 0xff)] ^ this.gSBox[0x201 + 2 * ((x >>> 16) & 0xff)];\n    };\n\n    TwoFish.prototype._doReset = function() {\n      var A, B, b0, b1, b2, b3, i, j, k0, k1, k2, k3, k32e, k32o, m, m1, mX, mY, p, q, sBoxKeys, _i, _j, _k, _l, _ref, _ref1, _results;\n      k32e = [];\n      k32o = [];\n      sBoxKeys = [];\n      m1 = [];\n      mX = [];\n      mY = [];\n      this.k64Cnt = this._key.words.length / 2;\n      if (this.k64Cnt < 1) {\n        throw \"Key size less than 64 bits\";\n      }\n      if (this.k64Cnt > 4) {\n        throw \"Key size larger than 256 bits\";\n      }\n      for (i = _i = 0; _i < 256; i = ++_i) {\n        j = G.P[0][i] & 0xff;\n        m1[0] = j;\n        mX[0] = this.Mx_X(j) & 0xff;\n        mY[0] = this.Mx_Y(j) & 0xff;\n        j = G.P[1][i] & 0xff;\n        m1[1] = j;\n        mX[1] = this.Mx_X(j) & 0xff;\n        mY[1] = this.Mx_Y(j) & 0xff;\n        this.gMDS0[i] = m1[G.P_00] | mX[G.P_00] << 8 | mY[G.P_00] << 16 | mY[G.P_00] << 24;\n        this.gMDS1[i] = mY[G.P_10] | mY[G.P_10] << 8 | mX[G.P_10] << 16 | m1[G.P_10] << 24;\n        this.gMDS2[i] = mX[G.P_20] | mY[G.P_20] << 8 | m1[G.P_20] << 16 | mY[G.P_20] << 24;\n        this.gMDS3[i] = mX[G.P_30] | m1[G.P_30] << 8 | mY[G.P_30] << 16 | mX[G.P_30] << 24;\n      }\n      for (i = _j = 0, _ref = this.k64Cnt; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {\n        p = i * 2;\n        k32e[i] = this.switchEndianness(this._key.words[p]);\n        k32o[i] = this.switchEndianness(this._key.words[p + 1]);\n        sBoxKeys[this.k64Cnt - 1 - i] = this.RS_MDS_Encode(k32e[i], k32o[i]);\n      }\n      for (i = _k = 0, _ref1 = 40 / 2; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {\n        q = i * G.SK_STEP;\n        A = this.F32(q, k32e);\n        B = this.F32(q + G.SK_BUMP, k32o);\n        B = B << 8 | B >>> 24;\n        A += B;\n        this.gSubKeys[i * 2] = A;\n        A += B;\n        this.gSubKeys[i * 2 + 1] = A << G.SK_ROTL | A >>> (32 - G.SK_ROTL);\n      }\n      k0 = sBoxKeys[0];\n      k1 = sBoxKeys[1];\n      k2 = sBoxKeys[2];\n      k3 = sBoxKeys[3];\n      this.gSBox = [];\n      _results = [];\n      for (i = _l = 0; _l < 256; i = ++_l) {\n        b0 = b1 = b2 = b3 = i;\n        m = this.k64Cnt & 3;\n        if (m === 1) {\n          this.gSBox[i * 2] = this.gMDS0[(G.P[G.P_01][b0] & 0xff) ^ this.getByte(k0, 0)];\n          this.gSBox[i * 2 + 1] = this.gMDS1[(G.P[G.P_11][b1] & 0xff) ^ this.getByte(k0, 1)];\n          this.gSBox[i * 2 + 0x200] = this.gMDS2[(G.P[G.P_21][b2] & 0xff) ^ this.getByte(k0, 2)];\n          _results.push(this.gSBox[i * 2 + 0x201] = this.gMDS3[(G.P[G.P_31][b3] & 0xff) ^ this.getByte(k0, 3)]);\n        } else {\n          if (m === 0) {\n            b0 = (G.P[G.P_04][b0] & 0xff) ^ this.getByte(k3, 0);\n            b1 = (G.P[G.P_14][b1] & 0xff) ^ this.getByte(k3, 1);\n            b2 = (G.P[G.P_24][b2] & 0xff) ^ this.getByte(k3, 2);\n            b3 = (G.P[G.P_34][b3] & 0xff) ^ this.getByte(k3, 3);\n          }\n          if (m === 0 || m === 3) {\n            b0 = (G.P[G.P_03][b0] & 0xff) ^ this.getByte(k2, 0);\n            b1 = (G.P[G.P_13][b1] & 0xff) ^ this.getByte(k2, 1);\n            b2 = (G.P[G.P_23][b2] & 0xff) ^ this.getByte(k2, 2);\n            b3 = (G.P[G.P_33][b3] & 0xff) ^ this.getByte(k2, 3);\n          }\n          this.gSBox[i * 2] = this.gMDS0[(G.P[G.P_01][(G.P[G.P_02][b0] & 0xff) ^ this.getByte(k1, 0)] & 0xff) ^ this.getByte(k0, 0)];\n          this.gSBox[i * 2 + 1] = this.gMDS1[(G.P[G.P_11][(G.P[G.P_12][b1] & 0xff) ^ this.getByte(k1, 1)] & 0xff) ^ this.getByte(k0, 1)];\n          this.gSBox[i * 2 + 0x200] = this.gMDS2[(G.P[G.P_21][(G.P[G.P_22][b2] & 0xff) ^ this.getByte(k1, 2)] & 0xff) ^ this.getByte(k0, 2)];\n          _results.push(this.gSBox[i * 2 + 0x201] = this.gMDS3[(G.P[G.P_31][(G.P[G.P_32][b3] & 0xff) ^ this.getByte(k1, 3)] & 0xff) ^ this.getByte(k0, 3)]);\n        }\n      }\n      return _results;\n    };\n\n    TwoFish.prototype.scrub = function() {\n      scrub_vec(this.gSubKeys);\n      scrub_vec(this.gSBox);\n      return this._key.scrub();\n    };\n\n    TwoFish.prototype.decryptBlock = function(M, offset) {\n      var k, r, t0, t1, x0, x1, x2, x3, _i;\n      if (offset == null) {\n        offset = 0;\n      }\n      x2 = this.switchEndianness(M[offset]) ^ this.gSubKeys[4];\n      x3 = this.switchEndianness(M[offset + 1]) ^ this.gSubKeys[5];\n      x0 = this.switchEndianness(M[offset + 2]) ^ this.gSubKeys[6];\n      x1 = this.switchEndianness(M[offset + 3]) ^ this.gSubKeys[7];\n      k = 8 + 2 * 16 - 1;\n      for (r = _i = 0; _i < 16; r = _i += 2) {\n        t0 = this.Fe32_0(x2);\n        t1 = this.Fe32_3(x3);\n        x1 ^= t0 + 2 * t1 + this.gSubKeys[k--];\n        x0 = (x0 << 1 | x0 >>> 31) ^ (t0 + t1 + this.gSubKeys[k--]);\n        x1 = x1 >>> 1 | x1 << 31;\n        t0 = this.Fe32_0(x0);\n        t1 = this.Fe32_3(x1);\n        x3 ^= t0 + 2 * t1 + this.gSubKeys[k--];\n        x2 = (x2 << 1 | x2 >>> 31) ^ (t0 + t1 + this.gSubKeys[k--]);\n        x3 = x3 >>> 1 | x3 << 31;\n      }\n      M[offset] = this.switchEndianness(x0 ^ this.gSubKeys[0]);\n      M[offset + 1] = this.switchEndianness(x1 ^ this.gSubKeys[1]);\n      M[offset + 2] = this.switchEndianness(x2 ^ this.gSubKeys[2]);\n      return M[offset + 3] = this.switchEndianness(x3 ^ this.gSubKeys[3]);\n    };\n\n    TwoFish.prototype.encryptBlock = function(M, offset) {\n      var k, r, t0, t1, x0, x1, x2, x3, _i;\n      if (offset == null) {\n        offset = 0;\n      }\n      x0 = this.switchEndianness(M[offset]) ^ this.gSubKeys[0];\n      x1 = this.switchEndianness(M[offset + 1]) ^ this.gSubKeys[1];\n      x2 = this.switchEndianness(M[offset + 2]) ^ this.gSubKeys[2];\n      x3 = this.switchEndianness(M[offset + 3]) ^ this.gSubKeys[3];\n      k = 8;\n      for (r = _i = 0; _i < 16; r = _i += 2) {\n        t0 = this.Fe32_0(x0);\n        t1 = this.Fe32_3(x1);\n        x2 ^= t0 + t1 + this.gSubKeys[k++];\n        x2 = x2 >>> 1 | x2 << 31;\n        x3 = (x3 << 1 | x3 >>> 31) ^ (t0 + 2 * t1 + this.gSubKeys[k++]);\n        t0 = this.Fe32_0(x2);\n        t1 = this.Fe32_3(x3);\n        x0 ^= t0 + t1 + this.gSubKeys[k++];\n        x0 = x0 >>> 1 | x0 << 31;\n        x1 = (x1 << 1 | x1 >>> 31) ^ (t0 + 2 * t1 + this.gSubKeys[k++]);\n      }\n      M[offset] = this.switchEndianness(x2 ^ this.gSubKeys[4]);\n      M[offset + 1] = this.switchEndianness(x3 ^ this.gSubKeys[5]);\n      M[offset + 2] = this.switchEndianness(x0 ^ this.gSubKeys[6]);\n      return M[offset + 3] = this.switchEndianness(x1 ^ this.gSubKeys[7]);\n    };\n\n    return TwoFish;\n\n  })(BlockCipher);\n\n}).call(this);\n\n},{\"./algbase\":174,\"./util\":195}],195:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var default_delay, iced, uint_max, __iced_k, __iced_k_noop;\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  uint_max = Math.pow(2, 32);\n\n  exports.fixup_uint32 = function(x) {\n    var ret, x_pos;\n    ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x;\n    return ret;\n  };\n\n  exports.scrub_buffer = function(b) {\n    var i, n_full_words;\n    n_full_words = b.length >> 2;\n    i = 0;\n    while (i < n_full_words) {\n      b.writeUInt32LE(0, i);\n      i += 4;\n    }\n    while (i < b.length) {\n      b.writeUInt8(0, i);\n      i++;\n    }\n    return false;\n  };\n\n  exports.scrub_vec = function(v) {\n    var i, _i, _ref;\n    for (i = _i = 0, _ref = v.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n      v[i] = 0;\n    }\n    return false;\n  };\n\n  exports.default_delay = default_delay = function(i, n, cb) {\n    var ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    (function(_this) {\n      return (function(__iced_k) {\n        if (typeof setImmediate !== \"undefined\" && setImmediate !== null) {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/triplesec/src/util.iced\"\n            });\n            setImmediate(__iced_deferrals.defer({\n              lineno: 37\n            }));\n            __iced_deferrals._fulfill();\n          })(__iced_k);\n        } else {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/max/src/keybase/triplesec/src/util.iced\"\n            });\n            setTimeout(__iced_deferrals.defer({\n              lineno: 39\n            }), 1);\n            __iced_deferrals._fulfill();\n          })(__iced_k);\n        }\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb();\n      };\n    })(this));\n  };\n\n  exports.buffer_cmp_ule = function(b1, b2) {\n    var I, J, i, j, x, y;\n    i = j = 0;\n    I = b1.length;\n    J = b2.length;\n    while (i < I && b1.readUInt8(i) === 0) {\n      i++;\n    }\n    while (j < J && b2.readUInt8(j) === 0) {\n      j++;\n    }\n    if ((I - i) > (J - j)) {\n      return 1;\n    } else if ((J - j) > (I - i)) {\n      return -1;\n    }\n    while (i < I) {\n      if ((x = b1.readUInt8(i)) < (y = b2.readUInt8(j))) {\n        return -1;\n      } else if (y < x) {\n        return 1;\n      }\n      i++;\n      j++;\n    }\n    return 0;\n  };\n\n  exports.bulk = function(n_input_bytes, _arg, _arg1) {\n    var call_ph, cb, default_n, delay, finalize, i, left, n, n_words, progress_hook, ret, total_words, update, what, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    update = _arg.update, finalize = _arg.finalize, default_n = _arg.default_n;\n    delay = _arg1.delay, n = _arg1.n, cb = _arg1.cb, what = _arg1.what, progress_hook = _arg1.progress_hook;\n    i = 0;\n    left = 0;\n    total_words = Math.ceil(n_input_bytes / 4);\n    delay || (delay = default_delay);\n    n || (n = default_n);\n    call_ph = function(i) {\n      return typeof progress_hook === \"function\" ? progress_hook({\n        what: what,\n        i: i,\n        total: total_words\n      }) : void 0;\n    };\n    call_ph(0);\n    (function(_this) {\n      return (function(__iced_k) {\n        var _results, _while;\n        _results = [];\n        _while = function(__iced_k) {\n          var _break, _continue, _next;\n          _break = function() {\n            return __iced_k(_results);\n          };\n          _continue = function() {\n            return iced.trampoline(function() {\n              return _while(__iced_k);\n            });\n          };\n          _next = function(__iced_next_arg) {\n            _results.push(__iced_next_arg);\n            return _continue();\n          };\n          if (!((left = total_words - i) > 0)) {\n            return _break();\n          } else {\n            n_words = Math.min(n, left);\n            update(i, i + n_words);\n            call_ph(i);\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/keybase/triplesec/src/util.iced\",\n                funcname: \"bulk\"\n              });\n              delay(i, total_words, __iced_deferrals.defer({\n                lineno: 97\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return _next(i += n_words);\n            });\n          }\n        };\n        _while(__iced_k);\n      });\n    })(this)((function(_this) {\n      return function() {\n        call_ph(total_words);\n        ret = finalize();\n        return cb(ret);\n      };\n    })(this));\n  };\n\n}).call(this);\n\n},{\"iced-runtime\":118}],196:[function(require,module,exports){\n(function (Buffer){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var WordArray, X64Word, X64WordArray, buffer_to_ui8a, endian_reverse, ui8a_to_buffer, util;\n\n  util = require('./util');\n\n  buffer_to_ui8a = function(b) {\n    var i, ret, _i, _ref;\n    ret = new Uint8Array(b.length);\n    for (i = _i = 0, _ref = b.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n      ret[i] = b.readUInt8(i);\n    }\n    return ret;\n  };\n\n  ui8a_to_buffer = function(v) {\n    var i, ret, _i, _ref;\n    ret = new Buffer(v.length);\n    for (i = _i = 0, _ref = v.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n      ret.writeUInt8(v[i], i);\n    }\n    return ret;\n  };\n\n  endian_reverse = function(x) {\n    return ((x >>> 24) & 0xff) | (((x >>> 16) & 0xff) << 8) | (((x >>> 8) & 0xff) << 16) | ((x & 0xff) << 24);\n  };\n\n  exports.WordArray = WordArray = (function() {\n    function WordArray(words, sigBytes) {\n      this.words = words || [];\n      this.sigBytes = sigBytes != null ? sigBytes : this.words.length * 4;\n    }\n\n    WordArray.prototype.concat = function(wordArray) {\n      var i, thatByte, thatSigBytes, thatWords, _i;\n      thatWords = wordArray.words;\n      thatSigBytes = wordArray.sigBytes;\n      this.clamp();\n      if (this.sigBytes % 4) {\n        for (i = _i = 0; 0 <= thatSigBytes ? _i < thatSigBytes : _i > thatSigBytes; i = 0 <= thatSigBytes ? ++_i : --_i) {\n          thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n          this.words[(this.sigBytes + i) >>> 2] |= thatByte << (24 - ((this.sigBytes + i) % 4) * 8);\n        }\n      } else {\n        this.words = this.words.concat(thatWords);\n      }\n      this.sigBytes += thatSigBytes;\n      return this;\n    };\n\n    WordArray.prototype.clamp = function() {\n      this.words[this.sigBytes >>> 2] &= 0xffffffff << (32 - (this.sigBytes % 4) * 8);\n      this.words.length = Math.ceil(this.sigBytes / 4);\n      return this;\n    };\n\n    WordArray.prototype.clone = function() {\n      return new WordArray(this.words.slice(0), this.sigBytes);\n    };\n\n    WordArray.prototype.to_buffer = function() {\n      var ch, out, p, w, _i, _len, _ref;\n      out = new Buffer(this.sigBytes);\n      p = 0;\n      _ref = this.words;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        w = _ref[_i];\n        if (!((this.sigBytes - p) >= 4)) {\n          continue;\n        }\n        w = util.fixup_uint32(w);\n        out.writeUInt32BE(w, p);\n        p += 4;\n      }\n      while (p < this.sigBytes) {\n        ch = (this.words[p >>> 2] >>> (24 - (p % 4) * 8)) & 0xff;\n        out.writeUInt8(ch, p);\n        p++;\n      }\n      return out;\n    };\n\n    WordArray.prototype.endian_reverse = function() {\n      var i, w, _i, _len, _ref;\n      _ref = this.words;\n      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n        w = _ref[i];\n        this.words[i] = endian_reverse(w);\n      }\n      return this;\n    };\n\n    WordArray.prototype.split = function(n) {\n      var i, out, sz;\n      if (!(((this.sigBytes % 4) === 0) && ((this.words.length % n) === 0))) {\n        throw new Error(\"bad key alignment\");\n      }\n      sz = this.words.length / n;\n      out = (function() {\n        var _i, _ref, _results;\n        _results = [];\n        for (i = _i = 0, _ref = this.words.length; sz > 0 ? _i < _ref : _i > _ref; i = _i += sz) {\n          _results.push(new WordArray(this.words.slice(i, i + sz)));\n        }\n        return _results;\n      }).call(this);\n      return out;\n    };\n\n    WordArray.prototype.to_utf8 = function() {\n      return this.to_buffer().toString('utf8');\n    };\n\n    WordArray.prototype.to_hex = function() {\n      return this.to_buffer().toString('hex');\n    };\n\n    WordArray.prototype.to_ui8a = function() {\n      return buffer_to_ui8a(this.to_buffer());\n    };\n\n    WordArray.alloc = function(b) {\n      if (Buffer.isBuffer(b)) {\n        return WordArray.from_buffer(b);\n      } else if ((typeof b === 'object') && (b instanceof WordArray)) {\n        return b;\n      } else if (typeof b === 'string') {\n        return WordArray.from_hex(b);\n      } else {\n        return null;\n      }\n    };\n\n    WordArray.from_buffer = function(b) {\n      var ch, last, p, words;\n      words = [];\n      p = 0;\n      while ((b.length - p) >= 4) {\n        words.push(b.readUInt32BE(p));\n        p += 4;\n      }\n      if (p < b.length) {\n        last = 0;\n        while (p < b.length) {\n          ch = b.readUInt8(p);\n          last |= ch << (24 - (p % 4) * 8);\n          p++;\n        }\n        last = util.fixup_uint32(last);\n        words.push(last);\n      }\n      return new WordArray(words, b.length);\n    };\n\n    WordArray.from_buffer_le = function(b) {\n      var ch, last, p, words;\n      words = [];\n      p = 0;\n      while ((b.length - p) >= 4) {\n        words.push(b.readUInt32LE(p));\n        p += 4;\n      }\n      if (p < b.length) {\n        last = 0;\n        while (p < b.length) {\n          ch = b.readUInt8(p);\n          last |= ch << ((p % 4) * 8);\n          p++;\n        }\n        last = util.fixup_uint32(last);\n        words.push(last);\n      }\n      return new WordArray(words, b.length);\n    };\n\n    WordArray.from_utf8 = function(s) {\n      return WordArray.from_buffer(new Buffer(s, 'utf8'));\n    };\n\n    WordArray.from_utf8_le = function(s) {\n      return WordArray.from_buffer_le(new Buffer(s, 'utf8'));\n    };\n\n    WordArray.from_hex = function(s) {\n      return WordArray.from_buffer(new Buffer(s, 'hex'));\n    };\n\n    WordArray.from_hex_le = function(s) {\n      return WordArray.from_buffer_le(new Buffer(s, 'hex'));\n    };\n\n    WordArray.from_ui8a = function(v) {\n      return WordArray.from_buffer(ui8a_to_buffer(v));\n    };\n\n    WordArray.from_i32a = function(v) {\n      return new WordArray(Array.apply([], v));\n    };\n\n    WordArray.prototype.equal = function(wa) {\n      var i, ret, w, _i, _len, _ref;\n      ret = true;\n      if (wa.sigBytes !== this.sigBytes) {\n        ret = false;\n      } else {\n        _ref = this.words;\n        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n          w = _ref[i];\n          if (util.fixup_uint32(w) !== util.fixup_uint32(wa.words[i])) {\n            ret = false;\n          }\n        }\n      }\n      return ret;\n    };\n\n    WordArray.prototype.xor = function(wa2, _arg) {\n      var dst_offset, i, n_words, src_offset, tmp, _i;\n      dst_offset = _arg.dst_offset, src_offset = _arg.src_offset, n_words = _arg.n_words;\n      if (!dst_offset) {\n        dst_offset = 0;\n      }\n      if (!src_offset) {\n        src_offset = 0;\n      }\n      if (n_words == null) {\n        n_words = wa2.words.length - src_offset;\n      }\n      if (this.words.length < dst_offset + n_words) {\n        throw new Error(\"dest range exceeded (\" + this.words.length + \" < \" + (dst_offset + n_words) + \")\");\n      }\n      if (wa2.words.length < src_offset + n_words) {\n        throw new Error(\"source range exceeded\");\n      }\n      for (i = _i = 0; 0 <= n_words ? _i < n_words : _i > n_words; i = 0 <= n_words ? ++_i : --_i) {\n        tmp = this.words[dst_offset + i] ^ wa2.words[src_offset + i];\n        this.words[dst_offset + i] = util.fixup_uint32(tmp);\n      }\n      return this;\n    };\n\n    WordArray.prototype.truncate = function(n_bytes) {\n      var n_words;\n      if (!(n_bytes <= this.sigBytes)) {\n        throw new Error(\"Cannot truncate: \" + n_bytes + \" > \" + this.sigBytes);\n      }\n      n_words = Math.ceil(n_bytes / 4);\n      return new WordArray(this.words.slice(0, n_words), n_bytes);\n    };\n\n    WordArray.prototype.unshift = function(n_words) {\n      var ret;\n      if (this.words.length >= n_words) {\n        ret = this.words.splice(0, n_words);\n        this.sigBytes -= n_words * 4;\n        return new WordArray(ret);\n      } else {\n        return null;\n      }\n    };\n\n    WordArray.prototype.is_scrubbed = function() {\n      var w, _i, _len, _ref;\n      _ref = this.words;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        w = _ref[_i];\n        if (w !== 0) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    WordArray.prototype.scrub = function() {\n      return util.scrub_vec(this.words);\n    };\n\n    WordArray.prototype.cmp_ule = function(wa2) {\n      return util.buffer_cmp_ule(this.to_buffer(), wa2.to_buffer());\n    };\n\n    WordArray.prototype.slice = function(low, hi) {\n      var n, sb;\n      n = this.words.length;\n      if (!((low < hi) && (hi <= n))) {\n        throw new Error(\"Bad WordArray slice [\" + low + \",\" + hi + \")] when only \" + n + \" avail\");\n      }\n      sb = (hi - low) * 4;\n      if (hi === n) {\n        sb -= n * 4 - this.sigBytes;\n      }\n      return new WordArray(this.words.slice(low, hi), sb);\n    };\n\n    return WordArray;\n\n  })();\n\n  exports.X64Word = X64Word = (function() {\n    function X64Word(high, low) {\n      this.high = high;\n      this.low = low;\n    }\n\n    X64Word.prototype.clone = function() {\n      return new X64Word(this.high, this.low);\n    };\n\n    return X64Word;\n\n  })();\n\n  exports.X64WordArray = X64WordArray = (function() {\n    function X64WordArray(words, sigBytes) {\n      this.sigBytes = sigBytes;\n      this.words = words || [];\n      if (!this.sigBytes) {\n        this.sigBytes = this.words.length * 8;\n      }\n    }\n\n    X64WordArray.prototype.toX32 = function() {\n      var v, w, _i, _len, _ref;\n      v = [];\n      _ref = this.words;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        w = _ref[_i];\n        v.push(w.high);\n        v.push(w.low);\n      }\n      return new WordArray(v, this.sigBytes);\n    };\n\n    X64WordArray.prototype.clone = function() {\n      var w;\n      return new X64WordArray((function() {\n        var _i, _len, _ref, _results;\n        _ref = this.words;\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          w = _ref[_i];\n          _results.push(w.clone());\n        }\n        return _results;\n      }).call(this), this.sigBytes);\n    };\n\n    return X64WordArray;\n\n  })();\n\n  exports.buffer_to_ui8a = buffer_to_ui8a;\n\n  exports.ui8a_to_buffer = ui8a_to_buffer;\n\n  exports.endian_reverse = endian_reverse;\n\n}).call(this);\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./util\":195,\"buffer\":80}],197:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var Lock, NamedLock, Table, iced, __iced_k, __iced_k_noop,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  exports.Lock = Lock = (function() {\n    function Lock() {\n      this._open = true;\n      this._waiters = [];\n    }\n\n    Lock.prototype.acquire = function(cb) {\n      if (this._open) {\n        this._open = false;\n        return cb();\n      } else {\n        return this._waiters.push(cb);\n      }\n    };\n\n    Lock.prototype.release = function() {\n      var w;\n      if (this._waiters.length) {\n        w = this._waiters.shift();\n        return w();\n      } else {\n        return this._open = true;\n      }\n    };\n\n    Lock.prototype.open = function() {\n      return this._open;\n    };\n\n    return Lock;\n\n  })();\n\n  NamedLock = (function(_super) {\n    __extends(NamedLock, _super);\n\n    function NamedLock(tab, name) {\n      this.tab = tab;\n      this.name = name;\n      NamedLock.__super__.constructor.call(this);\n      this.refs = 0;\n    }\n\n    NamedLock.prototype.incref = function() {\n      return ++this.refs;\n    };\n\n    NamedLock.prototype.decref = function() {\n      return --this.refs;\n    };\n\n    NamedLock.prototype.release = function() {\n      NamedLock.__super__.release.call(this);\n      if (this.decref() === 0) {\n        return delete this.tab.locks[this.name];\n      }\n    };\n\n    return NamedLock;\n\n  })(Lock);\n\n  exports.Table = Table = (function() {\n    function Table() {\n      this.locks = {};\n    }\n\n    Table.prototype.create = function(name) {\n      var l;\n      l = new NamedLock(this, name);\n      return this.locks[name] = l;\n    };\n\n    Table.prototype.acquire = function(name, cb, wait) {\n      var l, was_open, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      l = this.locks[name] || this.create(name);\n      was_open = l._open;\n      l.incref();\n      (function(_this) {\n        return (function(__iced_k) {\n          if (wait || l._open) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/max/src/iced/iced-lock/index.iced\",\n                funcname: \"Table.acquire\"\n              });\n              l.acquire(__iced_deferrals.defer({\n                lineno: 47\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k(l = null);\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(l, was_open);\n        };\n      })(this));\n    };\n\n    Table.prototype.lookup = function(name) {\n      return this.locks[name];\n    };\n\n    return Table;\n\n  })();\n\n}).call(this);\n\n},{\"iced-runtime\":118}],198:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-f\n(function() {\n  var Generator, iced, __iced_k, __iced_k_noop;\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  Generator = Generator = (function() {\n    function Generator(opts) {\n      opts = opts || {};\n      this.lazy_loop_delay = opts.lazy_loop_delay || 30;\n      this.loop_delay = opts.loop_delay || 5;\n      this.work_min = opts.work_min || 1;\n      this.auto_stop_bits = opts.auto_stop_bits || 4096;\n      this.max_bits_per_delta = opts.max_bits_per_delta || 4;\n      this.auto_stop = opts.auto_stop ? opts.auto_stop : true;\n      this.entropies = [];\n      this.running = true;\n      this.is_generating = false;\n      this.timer_race_loop();\n    }\n\n    Generator.prototype.generate = function(bits_wanted, cb) {\n      var e, harvested_bits, res, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      this.is_generating = true;\n      if (!this.running) {\n        this.resume();\n      }\n      harvested_bits = 0;\n      res = [];\n      (function(_this) {\n        return (function(__iced_k) {\n          var _results, _while;\n          _results = [];\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = function() {\n              return __iced_k(_results);\n            };\n            _continue = function() {\n              return iced.trampoline(function() {\n                return _while(__iced_k);\n              });\n            };\n            _next = function(__iced_next_arg) {\n              _results.push(__iced_next_arg);\n              return _continue();\n            };\n            if (!(harvested_bits < bits_wanted)) {\n              return _break();\n            } else {\n              (function(__iced_k) {\n                if (_this.entropies.length) {\n                  e = _this.entropies.splice(0, 1)[0];\n                  harvested_bits += e[1];\n                  return __iced_k(res.push(e[0]));\n                } else {\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/Users/chris/git/more-entropy/src/generator.iced\",\n                      funcname: \"Generator.generate\"\n                    });\n                    _this.delay(__iced_deferrals.defer({\n                      lineno: 28\n                    }));\n                    __iced_deferrals._fulfill();\n                  })(__iced_k);\n                }\n              })(_next);\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (_this.auto_stop) {\n            _this.stop();\n          }\n          _this.is_generating = false;\n          return cb(res);\n        };\n      })(this));\n    };\n\n    Generator.prototype.stop = function() {\n      return this.running = false;\n    };\n\n    Generator.prototype.resume = function() {\n      this.running = true;\n      return this.timer_race_loop();\n    };\n\n    Generator.prototype.reset = function() {\n      this.entropies = [];\n      return this.total_bits = 0;\n    };\n\n    Generator.prototype.count_unused_bits = function() {\n      var bits, e, _i, _len, _ref;\n      bits = 0;\n      _ref = this.entropies;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        e = _ref[_i];\n        bits += e[1];\n      }\n      return bits;\n    };\n\n    Generator.prototype.delay = function(cb) {\n      var delay, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      delay = this.is_generating ? this.loop_delay : this.lazy_loop_delay;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/chris/git/more-entropy/src/generator.iced\",\n            funcname: \"Generator.delay\"\n          });\n          setTimeout(__iced_deferrals.defer({\n            lineno: 50\n          }), delay);\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb();\n        };\n      })(this));\n    };\n\n    Generator.prototype.timer_race_loop = function() {\n      var ___iced_passed_deferral, __iced_k, _results, _while;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      this._last_count = null;\n      _results = [];\n      _while = (function(_this) {\n        var count, delta, entropy, v, __iced_deferrals;\n        return function(__iced_k) {\n          var _break, _continue, _next;\n          _break = function() {\n            return __iced_k(_results);\n          };\n          _continue = function() {\n            return iced.trampoline(function() {\n              return _while(__iced_k);\n            });\n          };\n          _next = function(__iced_next_arg) {\n            _results.push(__iced_next_arg);\n            return _continue();\n          };\n          if (!_this.running) {\n            return _break();\n          } else {\n            if (_this.count_unused_bits() < _this.auto_stop_bits) {\n              count = _this.millisecond_count();\n              if ((_this._last_count != null) && (delta = count - _this._last_count)) {\n                entropy = Math.floor(_this.log_2(Math.abs(delta)));\n                entropy = Math.min(_this.max_bits_per_delta, entropy);\n                v = [delta, entropy];\n                _this.entropies.push(v);\n              }\n              _this._last_count = count;\n            }\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/chris/git/more-entropy/src/generator.iced\",\n                funcname: \"Generator.timer_race_loop\"\n              });\n              _this.delay(__iced_deferrals.defer({\n                lineno: 64\n              }));\n              __iced_deferrals._fulfill();\n            })(_next);\n          }\n        };\n      })(this);\n      _while(__iced_k);\n    };\n\n    Generator.prototype.log_2 = function(x) {\n      return Math.log(x) / Math.LN2;\n    };\n\n    Generator.prototype.millisecond_count = function() {\n      var d, i, x;\n      d = Date.now();\n      i = x = 0;\n      while (Date.now() < d + this.work_min + 1) {\n        i++;\n        x = Math.sin(Math.sqrt(Math.log(i + x)));\n      }\n      return i;\n    };\n\n    return Generator;\n\n  })();\n\n  if (typeof window !== \"undefined\" && window !== null) {\n    window.Generator = Generator;\n  }\n\n  if (typeof exports !== \"undefined\" && exports !== null) {\n    exports.Generator = Generator;\n  }\n\n}).call(this);\n\n},{\"iced-runtime\":118}],199:[function(require,module,exports){\n// Generated by IcedCoffeeScript 1.7.1-c\n(function() {\n  exports.Generator = require('../lib/generator').Generator;\n\n}).call(this);\n\n},{\"../lib/generator\":198}],200:[function(require,module,exports){\n(function (Buffer){\n(function(nacl) {\n'use strict';\n\n// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.\n// Public domain.\n//\n// Implementation derived from TweetNaCl version 20140427.\n// See for details: http://tweetnacl.cr.yp.to/\n\n/* jshint newcap: false */\n\nvar gf = function(init) {\n  var i, r = new Float64Array(16);\n  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];\n  return r;\n};\n\n//  Pluggable, initialized in high-level API below.\nvar randombytes = function(/* x, n */) { throw new Error('no PRNG'); };\n\nvar _0 = new Uint8Array(16);\nvar _9 = new Uint8Array(32); _9[0] = 9;\n\nvar gf0 = gf(),\n    gf1 = gf([1]),\n    _121665 = gf([0xdb41, 1]),\n    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),\n    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),\n    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),\n    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),\n    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);\n\nfunction ts64(x, i, h, l) {\n  x[i]   = (h >> 24) & 0xff;\n  x[i+1] = (h >> 16) & 0xff;\n  x[i+2] = (h >>  8) & 0xff;\n  x[i+3] = h & 0xff;\n  x[i+4] = (l >> 24)  & 0xff;\n  x[i+5] = (l >> 16)  & 0xff;\n  x[i+6] = (l >>  8)  & 0xff;\n  x[i+7] = l & 0xff;\n}\n\nfunction vn(x, xi, y, yi, n) {\n  var i,d = 0;\n  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];\n  return (1 & ((d - 1) >>> 8)) - 1;\n}\n\nfunction crypto_verify_16(x, xi, y, yi) {\n  return vn(x,xi,y,yi,16);\n}\n\nfunction crypto_verify_32(x, xi, y, yi) {\n  return vn(x,xi,y,yi,32);\n}\n\nfunction core_salsa20(o, p, k, c) {\n  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,\n      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,\n      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,\n      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,\n      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,\n      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,\n      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,\n      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,\n      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,\n      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,\n      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,\n      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,\n      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,\n      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,\n      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,\n      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;\n\n  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,\n      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,\n      x15 = j15, u;\n\n  for (var i = 0; i < 20; i += 2) {\n    u = x0 + x12 | 0;\n    x4 ^= u<<7 | u>>>(32-7);\n    u = x4 + x0 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x4 | 0;\n    x12 ^= u<<13 | u>>>(32-13);\n    u = x12 + x8 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x1 | 0;\n    x9 ^= u<<7 | u>>>(32-7);\n    u = x9 + x5 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x9 | 0;\n    x1 ^= u<<13 | u>>>(32-13);\n    u = x1 + x13 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x6 | 0;\n    x14 ^= u<<7 | u>>>(32-7);\n    u = x14 + x10 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x14 | 0;\n    x6 ^= u<<13 | u>>>(32-13);\n    u = x6 + x2 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x11 | 0;\n    x3 ^= u<<7 | u>>>(32-7);\n    u = x3 + x15 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x3 | 0;\n    x11 ^= u<<13 | u>>>(32-13);\n    u = x11 + x7 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n\n    u = x0 + x3 | 0;\n    x1 ^= u<<7 | u>>>(32-7);\n    u = x1 + x0 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x1 | 0;\n    x3 ^= u<<13 | u>>>(32-13);\n    u = x3 + x2 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x4 | 0;\n    x6 ^= u<<7 | u>>>(32-7);\n    u = x6 + x5 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x6 | 0;\n    x4 ^= u<<13 | u>>>(32-13);\n    u = x4 + x7 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x9 | 0;\n    x11 ^= u<<7 | u>>>(32-7);\n    u = x11 + x10 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x11 | 0;\n    x9 ^= u<<13 | u>>>(32-13);\n    u = x9 + x8 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x14 | 0;\n    x12 ^= u<<7 | u>>>(32-7);\n    u = x12 + x15 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x12 | 0;\n    x14 ^= u<<13 | u>>>(32-13);\n    u = x14 + x13 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n  }\n   x0 =  x0 +  j0 | 0;\n   x1 =  x1 +  j1 | 0;\n   x2 =  x2 +  j2 | 0;\n   x3 =  x3 +  j3 | 0;\n   x4 =  x4 +  j4 | 0;\n   x5 =  x5 +  j5 | 0;\n   x6 =  x6 +  j6 | 0;\n   x7 =  x7 +  j7 | 0;\n   x8 =  x8 +  j8 | 0;\n   x9 =  x9 +  j9 | 0;\n  x10 = x10 + j10 | 0;\n  x11 = x11 + j11 | 0;\n  x12 = x12 + j12 | 0;\n  x13 = x13 + j13 | 0;\n  x14 = x14 + j14 | 0;\n  x15 = x15 + j15 | 0;\n\n  o[ 0] = x0 >>>  0 & 0xff;\n  o[ 1] = x0 >>>  8 & 0xff;\n  o[ 2] = x0 >>> 16 & 0xff;\n  o[ 3] = x0 >>> 24 & 0xff;\n\n  o[ 4] = x1 >>>  0 & 0xff;\n  o[ 5] = x1 >>>  8 & 0xff;\n  o[ 6] = x1 >>> 16 & 0xff;\n  o[ 7] = x1 >>> 24 & 0xff;\n\n  o[ 8] = x2 >>>  0 & 0xff;\n  o[ 9] = x2 >>>  8 & 0xff;\n  o[10] = x2 >>> 16 & 0xff;\n  o[11] = x2 >>> 24 & 0xff;\n\n  o[12] = x3 >>>  0 & 0xff;\n  o[13] = x3 >>>  8 & 0xff;\n  o[14] = x3 >>> 16 & 0xff;\n  o[15] = x3 >>> 24 & 0xff;\n\n  o[16] = x4 >>>  0 & 0xff;\n  o[17] = x4 >>>  8 & 0xff;\n  o[18] = x4 >>> 16 & 0xff;\n  o[19] = x4 >>> 24 & 0xff;\n\n  o[20] = x5 >>>  0 & 0xff;\n  o[21] = x5 >>>  8 & 0xff;\n  o[22] = x5 >>> 16 & 0xff;\n  o[23] = x5 >>> 24 & 0xff;\n\n  o[24] = x6 >>>  0 & 0xff;\n  o[25] = x6 >>>  8 & 0xff;\n  o[26] = x6 >>> 16 & 0xff;\n  o[27] = x6 >>> 24 & 0xff;\n\n  o[28] = x7 >>>  0 & 0xff;\n  o[29] = x7 >>>  8 & 0xff;\n  o[30] = x7 >>> 16 & 0xff;\n  o[31] = x7 >>> 24 & 0xff;\n\n  o[32] = x8 >>>  0 & 0xff;\n  o[33] = x8 >>>  8 & 0xff;\n  o[34] = x8 >>> 16 & 0xff;\n  o[35] = x8 >>> 24 & 0xff;\n\n  o[36] = x9 >>>  0 & 0xff;\n  o[37] = x9 >>>  8 & 0xff;\n  o[38] = x9 >>> 16 & 0xff;\n  o[39] = x9 >>> 24 & 0xff;\n\n  o[40] = x10 >>>  0 & 0xff;\n  o[41] = x10 >>>  8 & 0xff;\n  o[42] = x10 >>> 16 & 0xff;\n  o[43] = x10 >>> 24 & 0xff;\n\n  o[44] = x11 >>>  0 & 0xff;\n  o[45] = x11 >>>  8 & 0xff;\n  o[46] = x11 >>> 16 & 0xff;\n  o[47] = x11 >>> 24 & 0xff;\n\n  o[48] = x12 >>>  0 & 0xff;\n  o[49] = x12 >>>  8 & 0xff;\n  o[50] = x12 >>> 16 & 0xff;\n  o[51] = x12 >>> 24 & 0xff;\n\n  o[52] = x13 >>>  0 & 0xff;\n  o[53] = x13 >>>  8 & 0xff;\n  o[54] = x13 >>> 16 & 0xff;\n  o[55] = x13 >>> 24 & 0xff;\n\n  o[56] = x14 >>>  0 & 0xff;\n  o[57] = x14 >>>  8 & 0xff;\n  o[58] = x14 >>> 16 & 0xff;\n  o[59] = x14 >>> 24 & 0xff;\n\n  o[60] = x15 >>>  0 & 0xff;\n  o[61] = x15 >>>  8 & 0xff;\n  o[62] = x15 >>> 16 & 0xff;\n  o[63] = x15 >>> 24 & 0xff;\n}\n\nfunction core_hsalsa20(o,p,k,c) {\n  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,\n      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,\n      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,\n      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,\n      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,\n      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,\n      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,\n      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,\n      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,\n      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,\n      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,\n      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,\n      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,\n      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,\n      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,\n      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;\n\n  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,\n      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,\n      x15 = j15, u;\n\n  for (var i = 0; i < 20; i += 2) {\n    u = x0 + x12 | 0;\n    x4 ^= u<<7 | u>>>(32-7);\n    u = x4 + x0 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x4 | 0;\n    x12 ^= u<<13 | u>>>(32-13);\n    u = x12 + x8 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x1 | 0;\n    x9 ^= u<<7 | u>>>(32-7);\n    u = x9 + x5 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x9 | 0;\n    x1 ^= u<<13 | u>>>(32-13);\n    u = x1 + x13 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x6 | 0;\n    x14 ^= u<<7 | u>>>(32-7);\n    u = x14 + x10 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x14 | 0;\n    x6 ^= u<<13 | u>>>(32-13);\n    u = x6 + x2 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x11 | 0;\n    x3 ^= u<<7 | u>>>(32-7);\n    u = x3 + x15 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x3 | 0;\n    x11 ^= u<<13 | u>>>(32-13);\n    u = x11 + x7 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n\n    u = x0 + x3 | 0;\n    x1 ^= u<<7 | u>>>(32-7);\n    u = x1 + x0 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x1 | 0;\n    x3 ^= u<<13 | u>>>(32-13);\n    u = x3 + x2 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x4 | 0;\n    x6 ^= u<<7 | u>>>(32-7);\n    u = x6 + x5 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x6 | 0;\n    x4 ^= u<<13 | u>>>(32-13);\n    u = x4 + x7 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x9 | 0;\n    x11 ^= u<<7 | u>>>(32-7);\n    u = x11 + x10 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x11 | 0;\n    x9 ^= u<<13 | u>>>(32-13);\n    u = x9 + x8 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x14 | 0;\n    x12 ^= u<<7 | u>>>(32-7);\n    u = x12 + x15 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x12 | 0;\n    x14 ^= u<<13 | u>>>(32-13);\n    u = x14 + x13 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n  }\n\n  o[ 0] = x0 >>>  0 & 0xff;\n  o[ 1] = x0 >>>  8 & 0xff;\n  o[ 2] = x0 >>> 16 & 0xff;\n  o[ 3] = x0 >>> 24 & 0xff;\n\n  o[ 4] = x5 >>>  0 & 0xff;\n  o[ 5] = x5 >>>  8 & 0xff;\n  o[ 6] = x5 >>> 16 & 0xff;\n  o[ 7] = x5 >>> 24 & 0xff;\n\n  o[ 8] = x10 >>>  0 & 0xff;\n  o[ 9] = x10 >>>  8 & 0xff;\n  o[10] = x10 >>> 16 & 0xff;\n  o[11] = x10 >>> 24 & 0xff;\n\n  o[12] = x15 >>>  0 & 0xff;\n  o[13] = x15 >>>  8 & 0xff;\n  o[14] = x15 >>> 16 & 0xff;\n  o[15] = x15 >>> 24 & 0xff;\n\n  o[16] = x6 >>>  0 & 0xff;\n  o[17] = x6 >>>  8 & 0xff;\n  o[18] = x6 >>> 16 & 0xff;\n  o[19] = x6 >>> 24 & 0xff;\n\n  o[20] = x7 >>>  0 & 0xff;\n  o[21] = x7 >>>  8 & 0xff;\n  o[22] = x7 >>> 16 & 0xff;\n  o[23] = x7 >>> 24 & 0xff;\n\n  o[24] = x8 >>>  0 & 0xff;\n  o[25] = x8 >>>  8 & 0xff;\n  o[26] = x8 >>> 16 & 0xff;\n  o[27] = x8 >>> 24 & 0xff;\n\n  o[28] = x9 >>>  0 & 0xff;\n  o[29] = x9 >>>  8 & 0xff;\n  o[30] = x9 >>> 16 & 0xff;\n  o[31] = x9 >>> 24 & 0xff;\n}\n\nfunction crypto_core_salsa20(out,inp,k,c) {\n  core_salsa20(out,inp,k,c);\n}\n\nfunction crypto_core_hsalsa20(out,inp,k,c) {\n  core_hsalsa20(out,inp,k,c);\n}\n\nvar sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);\n            // \"expand 32-byte k\"\n\nfunction crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {\n  var z = new Uint8Array(16), x = new Uint8Array(64);\n  var u, i;\n  for (i = 0; i < 16; i++) z[i] = 0;\n  for (i = 0; i < 8; i++) z[i] = n[i];\n  while (b >= 64) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];\n    u = 1;\n    for (i = 8; i < 16; i++) {\n      u = u + (z[i] & 0xff) | 0;\n      z[i] = u & 0xff;\n      u >>>= 8;\n    }\n    b -= 64;\n    cpos += 64;\n    mpos += 64;\n  }\n  if (b > 0) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];\n  }\n  return 0;\n}\n\nfunction crypto_stream_salsa20(c,cpos,b,n,k) {\n  var z = new Uint8Array(16), x = new Uint8Array(64);\n  var u, i;\n  for (i = 0; i < 16; i++) z[i] = 0;\n  for (i = 0; i < 8; i++) z[i] = n[i];\n  while (b >= 64) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < 64; i++) c[cpos+i] = x[i];\n    u = 1;\n    for (i = 8; i < 16; i++) {\n      u = u + (z[i] & 0xff) | 0;\n      z[i] = u & 0xff;\n      u >>>= 8;\n    }\n    b -= 64;\n    cpos += 64;\n  }\n  if (b > 0) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < b; i++) c[cpos+i] = x[i];\n  }\n  return 0;\n}\n\nfunction crypto_stream(c,cpos,d,n,k) {\n  var s = new Uint8Array(32);\n  crypto_core_hsalsa20(s,n,k,sigma);\n  var sn = new Uint8Array(8);\n  for (var i = 0; i < 8; i++) sn[i] = n[i+16];\n  return crypto_stream_salsa20(c,cpos,d,sn,s);\n}\n\nfunction crypto_stream_xor(c,cpos,m,mpos,d,n,k) {\n  var s = new Uint8Array(32);\n  crypto_core_hsalsa20(s,n,k,sigma);\n  var sn = new Uint8Array(8);\n  for (var i = 0; i < 8; i++) sn[i] = n[i+16];\n  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);\n}\n\n/*\n* Port of Andrew Moon's Poly1305-donna-16. Public domain.\n* https://github.com/floodyberry/poly1305-donna\n*/\n\nvar poly1305 = function(key) {\n  this.buffer = new Uint8Array(16);\n  this.r = new Uint16Array(10);\n  this.h = new Uint16Array(10);\n  this.pad = new Uint16Array(8);\n  this.leftover = 0;\n  this.fin = 0;\n\n  var t0, t1, t2, t3, t4, t5, t6, t7;\n\n  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;\n  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;\n  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;\n  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;\n  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;\n  this.r[5] = ((t4 >>>  1)) & 0x1ffe;\n  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;\n  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;\n  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;\n  this.r[9] = ((t7 >>>  5)) & 0x007f;\n\n  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;\n  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;\n  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;\n  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;\n  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;\n  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;\n  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;\n  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;\n};\n\npoly1305.prototype.blocks = function(m, mpos, bytes) {\n  var hibit = this.fin ? 0 : (1 << 11);\n  var t0, t1, t2, t3, t4, t5, t6, t7, c;\n  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;\n\n  var h0 = this.h[0],\n      h1 = this.h[1],\n      h2 = this.h[2],\n      h3 = this.h[3],\n      h4 = this.h[4],\n      h5 = this.h[5],\n      h6 = this.h[6],\n      h7 = this.h[7],\n      h8 = this.h[8],\n      h9 = this.h[9];\n\n  var r0 = this.r[0],\n      r1 = this.r[1],\n      r2 = this.r[2],\n      r3 = this.r[3],\n      r4 = this.r[4],\n      r5 = this.r[5],\n      r6 = this.r[6],\n      r7 = this.r[7],\n      r8 = this.r[8],\n      r9 = this.r[9];\n\n  while (bytes >= 16) {\n    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;\n    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;\n    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;\n    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;\n    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;\n    h5 += ((t4 >>>  1)) & 0x1fff;\n    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;\n    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;\n    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;\n    h9 += ((t7 >>> 5)) | hibit;\n\n    c = 0;\n\n    d0 = c;\n    d0 += h0 * r0;\n    d0 += h1 * (5 * r9);\n    d0 += h2 * (5 * r8);\n    d0 += h3 * (5 * r7);\n    d0 += h4 * (5 * r6);\n    c = (d0 >>> 13); d0 &= 0x1fff;\n    d0 += h5 * (5 * r5);\n    d0 += h6 * (5 * r4);\n    d0 += h7 * (5 * r3);\n    d0 += h8 * (5 * r2);\n    d0 += h9 * (5 * r1);\n    c += (d0 >>> 13); d0 &= 0x1fff;\n\n    d1 = c;\n    d1 += h0 * r1;\n    d1 += h1 * r0;\n    d1 += h2 * (5 * r9);\n    d1 += h3 * (5 * r8);\n    d1 += h4 * (5 * r7);\n    c = (d1 >>> 13); d1 &= 0x1fff;\n    d1 += h5 * (5 * r6);\n    d1 += h6 * (5 * r5);\n    d1 += h7 * (5 * r4);\n    d1 += h8 * (5 * r3);\n    d1 += h9 * (5 * r2);\n    c += (d1 >>> 13); d1 &= 0x1fff;\n\n    d2 = c;\n    d2 += h0 * r2;\n    d2 += h1 * r1;\n    d2 += h2 * r0;\n    d2 += h3 * (5 * r9);\n    d2 += h4 * (5 * r8);\n    c = (d2 >>> 13); d2 &= 0x1fff;\n    d2 += h5 * (5 * r7);\n    d2 += h6 * (5 * r6);\n    d2 += h7 * (5 * r5);\n    d2 += h8 * (5 * r4);\n    d2 += h9 * (5 * r3);\n    c += (d2 >>> 13); d2 &= 0x1fff;\n\n    d3 = c;\n    d3 += h0 * r3;\n    d3 += h1 * r2;\n    d3 += h2 * r1;\n    d3 += h3 * r0;\n    d3 += h4 * (5 * r9);\n    c = (d3 >>> 13); d3 &= 0x1fff;\n    d3 += h5 * (5 * r8);\n    d3 += h6 * (5 * r7);\n    d3 += h7 * (5 * r6);\n    d3 += h8 * (5 * r5);\n    d3 += h9 * (5 * r4);\n    c += (d3 >>> 13); d3 &= 0x1fff;\n\n    d4 = c;\n    d4 += h0 * r4;\n    d4 += h1 * r3;\n    d4 += h2 * r2;\n    d4 += h3 * r1;\n    d4 += h4 * r0;\n    c = (d4 >>> 13); d4 &= 0x1fff;\n    d4 += h5 * (5 * r9);\n    d4 += h6 * (5 * r8);\n    d4 += h7 * (5 * r7);\n    d4 += h8 * (5 * r6);\n    d4 += h9 * (5 * r5);\n    c += (d4 >>> 13); d4 &= 0x1fff;\n\n    d5 = c;\n    d5 += h0 * r5;\n    d5 += h1 * r4;\n    d5 += h2 * r3;\n    d5 += h3 * r2;\n    d5 += h4 * r1;\n    c = (d5 >>> 13); d5 &= 0x1fff;\n    d5 += h5 * r0;\n    d5 += h6 * (5 * r9);\n    d5 += h7 * (5 * r8);\n    d5 += h8 * (5 * r7);\n    d5 += h9 * (5 * r6);\n    c += (d5 >>> 13); d5 &= 0x1fff;\n\n    d6 = c;\n    d6 += h0 * r6;\n    d6 += h1 * r5;\n    d6 += h2 * r4;\n    d6 += h3 * r3;\n    d6 += h4 * r2;\n    c = (d6 >>> 13); d6 &= 0x1fff;\n    d6 += h5 * r1;\n    d6 += h6 * r0;\n    d6 += h7 * (5 * r9);\n    d6 += h8 * (5 * r8);\n    d6 += h9 * (5 * r7);\n    c += (d6 >>> 13); d6 &= 0x1fff;\n\n    d7 = c;\n    d7 += h0 * r7;\n    d7 += h1 * r6;\n    d7 += h2 * r5;\n    d7 += h3 * r4;\n    d7 += h4 * r3;\n    c = (d7 >>> 13); d7 &= 0x1fff;\n    d7 += h5 * r2;\n    d7 += h6 * r1;\n    d7 += h7 * r0;\n    d7 += h8 * (5 * r9);\n    d7 += h9 * (5 * r8);\n    c += (d7 >>> 13); d7 &= 0x1fff;\n\n    d8 = c;\n    d8 += h0 * r8;\n    d8 += h1 * r7;\n    d8 += h2 * r6;\n    d8 += h3 * r5;\n    d8 += h4 * r4;\n    c = (d8 >>> 13); d8 &= 0x1fff;\n    d8 += h5 * r3;\n    d8 += h6 * r2;\n    d8 += h7 * r1;\n    d8 += h8 * r0;\n    d8 += h9 * (5 * r9);\n    c += (d8 >>> 13); d8 &= 0x1fff;\n\n    d9 = c;\n    d9 += h0 * r9;\n    d9 += h1 * r8;\n    d9 += h2 * r7;\n    d9 += h3 * r6;\n    d9 += h4 * r5;\n    c = (d9 >>> 13); d9 &= 0x1fff;\n    d9 += h5 * r4;\n    d9 += h6 * r3;\n    d9 += h7 * r2;\n    d9 += h8 * r1;\n    d9 += h9 * r0;\n    c += (d9 >>> 13); d9 &= 0x1fff;\n\n    c = (((c << 2) + c)) | 0;\n    c = (c + d0) | 0;\n    d0 = c & 0x1fff;\n    c = (c >>> 13);\n    d1 += c;\n\n    h0 = d0;\n    h1 = d1;\n    h2 = d2;\n    h3 = d3;\n    h4 = d4;\n    h5 = d5;\n    h6 = d6;\n    h7 = d7;\n    h8 = d8;\n    h9 = d9;\n\n    mpos += 16;\n    bytes -= 16;\n  }\n  this.h[0] = h0;\n  this.h[1] = h1;\n  this.h[2] = h2;\n  this.h[3] = h3;\n  this.h[4] = h4;\n  this.h[5] = h5;\n  this.h[6] = h6;\n  this.h[7] = h7;\n  this.h[8] = h8;\n  this.h[9] = h9;\n};\n\npoly1305.prototype.finish = function(mac, macpos) {\n  var g = new Uint16Array(10);\n  var c, mask, f, i;\n\n  if (this.leftover) {\n    i = this.leftover;\n    this.buffer[i++] = 1;\n    for (; i < 16; i++) this.buffer[i] = 0;\n    this.fin = 1;\n    this.blocks(this.buffer, 0, 16);\n  }\n\n  c = this.h[1] >>> 13;\n  this.h[1] &= 0x1fff;\n  for (i = 2; i < 10; i++) {\n    this.h[i] += c;\n    c = this.h[i] >>> 13;\n    this.h[i] &= 0x1fff;\n  }\n  this.h[0] += (c * 5);\n  c = this.h[0] >>> 13;\n  this.h[0] &= 0x1fff;\n  this.h[1] += c;\n  c = this.h[1] >>> 13;\n  this.h[1] &= 0x1fff;\n  this.h[2] += c;\n\n  g[0] = this.h[0] + 5;\n  c = g[0] >>> 13;\n  g[0] &= 0x1fff;\n  for (i = 1; i < 10; i++) {\n    g[i] = this.h[i] + c;\n    c = g[i] >>> 13;\n    g[i] &= 0x1fff;\n  }\n  g[9] -= (1 << 13);\n\n  mask = (g[9] >>> ((2 * 8) - 1)) - 1;\n  for (i = 0; i < 10; i++) g[i] &= mask;\n  mask = ~mask;\n  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];\n\n  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;\n  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;\n  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;\n  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;\n  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;\n  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;\n  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;\n  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;\n\n  f = this.h[0] + this.pad[0];\n  this.h[0] = f & 0xffff;\n  for (i = 1; i < 8; i++) {\n    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;\n    this.h[i] = f & 0xffff;\n  }\n\n  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;\n  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;\n  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;\n  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;\n  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;\n  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;\n  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;\n  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;\n  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;\n  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;\n  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;\n  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;\n  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;\n  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;\n  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;\n  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;\n};\n\npoly1305.prototype.update = function(m, mpos, bytes) {\n  var i, want;\n\n  if (this.leftover) {\n    want = (16 - this.leftover);\n    if (want > bytes)\n      want = bytes;\n    for (i = 0; i < want; i++)\n      this.buffer[this.leftover + i] = m[mpos+i];\n    bytes -= want;\n    mpos += want;\n    this.leftover += want;\n    if (this.leftover < 16)\n      return;\n    this.blocks(buffer, 0, 16);\n    this.leftover = 0;\n  }\n\n  if (bytes >= 16) {\n    want = bytes - (bytes % 16);\n    this.blocks(m, mpos, want);\n    mpos += want;\n    bytes -= want;\n  }\n\n  if (bytes) {\n    for (i = 0; i < bytes; i++)\n      this.buffer[this.leftover + i] = m[mpos+i];\n    this.leftover += bytes;\n  }\n};\n\nfunction crypto_onetimeauth(out, outpos, m, mpos, n, k) {\n  var s = new poly1305(k);\n  s.update(m, mpos, n);\n  s.finish(out, outpos);\n  return 0;\n}\n\nfunction crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {\n  var x = new Uint8Array(16);\n  crypto_onetimeauth(x,0,m,mpos,n,k);\n  return crypto_verify_16(h,hpos,x,0);\n}\n\nfunction crypto_secretbox(c,m,d,n,k) {\n  var i;\n  if (d < 32) return -1;\n  crypto_stream_xor(c,0,m,0,d,n,k);\n  crypto_onetimeauth(c, 16, c, 32, d - 32, c);\n  for (i = 0; i < 16; i++) c[i] = 0;\n  return 0;\n}\n\nfunction crypto_secretbox_open(m,c,d,n,k) {\n  var i;\n  var x = new Uint8Array(32);\n  if (d < 32) return -1;\n  crypto_stream(x,0,32,n,k);\n  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;\n  crypto_stream_xor(m,0,c,0,d,n,k);\n  for (i = 0; i < 32; i++) m[i] = 0;\n  return 0;\n}\n\nfunction set25519(r, a) {\n  var i;\n  for (i = 0; i < 16; i++) r[i] = a[i]|0;\n}\n\nfunction car25519(o) {\n  var i, v, c = 1;\n  for (i = 0; i < 16; i++) {\n    v = o[i] + c + 65535;\n    c = Math.floor(v / 65536);\n    o[i] = v - c * 65536;\n  }\n  o[0] += c-1 + 37 * (c-1);\n}\n\nfunction sel25519(p, q, b) {\n  var t, c = ~(b-1);\n  for (var i = 0; i < 16; i++) {\n    t = c & (p[i] ^ q[i]);\n    p[i] ^= t;\n    q[i] ^= t;\n  }\n}\n\nfunction pack25519(o, n) {\n  var i, j, b;\n  var m = gf(), t = gf();\n  for (i = 0; i < 16; i++) t[i] = n[i];\n  car25519(t);\n  car25519(t);\n  car25519(t);\n  for (j = 0; j < 2; j++) {\n    m[0] = t[0] - 0xffed;\n    for (i = 1; i < 15; i++) {\n      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);\n      m[i-1] &= 0xffff;\n    }\n    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);\n    b = (m[15]>>16) & 1;\n    m[14] &= 0xffff;\n    sel25519(t, m, 1-b);\n  }\n  for (i = 0; i < 16; i++) {\n    o[2*i] = t[i] & 0xff;\n    o[2*i+1] = t[i]>>8;\n  }\n}\n\nfunction neq25519(a, b) {\n  var c = new Uint8Array(32), d = new Uint8Array(32);\n  pack25519(c, a);\n  pack25519(d, b);\n  return crypto_verify_32(c, 0, d, 0);\n}\n\nfunction par25519(a) {\n  var d = new Uint8Array(32);\n  pack25519(d, a);\n  return d[0] & 1;\n}\n\nfunction unpack25519(o, n) {\n  var i;\n  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);\n  o[15] &= 0x7fff;\n}\n\nfunction A(o, a, b) {\n  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];\n}\n\nfunction Z(o, a, b) {\n  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];\n}\n\nfunction M(o, a, b) {\n  var v, c,\n     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,\n     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,\n    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,\n    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,\n    b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3],\n    b4 = b[4],\n    b5 = b[5],\n    b6 = b[6],\n    b7 = b[7],\n    b8 = b[8],\n    b9 = b[9],\n    b10 = b[10],\n    b11 = b[11],\n    b12 = b[12],\n    b13 = b[13],\n    b14 = b[14],\n    b15 = b[15];\n\n  v = a[0];\n  t0 += v * b0;\n  t1 += v * b1;\n  t2 += v * b2;\n  t3 += v * b3;\n  t4 += v * b4;\n  t5 += v * b5;\n  t6 += v * b6;\n  t7 += v * b7;\n  t8 += v * b8;\n  t9 += v * b9;\n  t10 += v * b10;\n  t11 += v * b11;\n  t12 += v * b12;\n  t13 += v * b13;\n  t14 += v * b14;\n  t15 += v * b15;\n  v = a[1];\n  t1 += v * b0;\n  t2 += v * b1;\n  t3 += v * b2;\n  t4 += v * b3;\n  t5 += v * b4;\n  t6 += v * b5;\n  t7 += v * b6;\n  t8 += v * b7;\n  t9 += v * b8;\n  t10 += v * b9;\n  t11 += v * b10;\n  t12 += v * b11;\n  t13 += v * b12;\n  t14 += v * b13;\n  t15 += v * b14;\n  t16 += v * b15;\n  v = a[2];\n  t2 += v * b0;\n  t3 += v * b1;\n  t4 += v * b2;\n  t5 += v * b3;\n  t6 += v * b4;\n  t7 += v * b5;\n  t8 += v * b6;\n  t9 += v * b7;\n  t10 += v * b8;\n  t11 += v * b9;\n  t12 += v * b10;\n  t13 += v * b11;\n  t14 += v * b12;\n  t15 += v * b13;\n  t16 += v * b14;\n  t17 += v * b15;\n  v = a[3];\n  t3 += v * b0;\n  t4 += v * b1;\n  t5 += v * b2;\n  t6 += v * b3;\n  t7 += v * b4;\n  t8 += v * b5;\n  t9 += v * b6;\n  t10 += v * b7;\n  t11 += v * b8;\n  t12 += v * b9;\n  t13 += v * b10;\n  t14 += v * b11;\n  t15 += v * b12;\n  t16 += v * b13;\n  t17 += v * b14;\n  t18 += v * b15;\n  v = a[4];\n  t4 += v * b0;\n  t5 += v * b1;\n  t6 += v * b2;\n  t7 += v * b3;\n  t8 += v * b4;\n  t9 += v * b5;\n  t10 += v * b6;\n  t11 += v * b7;\n  t12 += v * b8;\n  t13 += v * b9;\n  t14 += v * b10;\n  t15 += v * b11;\n  t16 += v * b12;\n  t17 += v * b13;\n  t18 += v * b14;\n  t19 += v * b15;\n  v = a[5];\n  t5 += v * b0;\n  t6 += v * b1;\n  t7 += v * b2;\n  t8 += v * b3;\n  t9 += v * b4;\n  t10 += v * b5;\n  t11 += v * b6;\n  t12 += v * b7;\n  t13 += v * b8;\n  t14 += v * b9;\n  t15 += v * b10;\n  t16 += v * b11;\n  t17 += v * b12;\n  t18 += v * b13;\n  t19 += v * b14;\n  t20 += v * b15;\n  v = a[6];\n  t6 += v * b0;\n  t7 += v * b1;\n  t8 += v * b2;\n  t9 += v * b3;\n  t10 += v * b4;\n  t11 += v * b5;\n  t12 += v * b6;\n  t13 += v * b7;\n  t14 += v * b8;\n  t15 += v * b9;\n  t16 += v * b10;\n  t17 += v * b11;\n  t18 += v * b12;\n  t19 += v * b13;\n  t20 += v * b14;\n  t21 += v * b15;\n  v = a[7];\n  t7 += v * b0;\n  t8 += v * b1;\n  t9 += v * b2;\n  t10 += v * b3;\n  t11 += v * b4;\n  t12 += v * b5;\n  t13 += v * b6;\n  t14 += v * b7;\n  t15 += v * b8;\n  t16 += v * b9;\n  t17 += v * b10;\n  t18 += v * b11;\n  t19 += v * b12;\n  t20 += v * b13;\n  t21 += v * b14;\n  t22 += v * b15;\n  v = a[8];\n  t8 += v * b0;\n  t9 += v * b1;\n  t10 += v * b2;\n  t11 += v * b3;\n  t12 += v * b4;\n  t13 += v * b5;\n  t14 += v * b6;\n  t15 += v * b7;\n  t16 += v * b8;\n  t17 += v * b9;\n  t18 += v * b10;\n  t19 += v * b11;\n  t20 += v * b12;\n  t21 += v * b13;\n  t22 += v * b14;\n  t23 += v * b15;\n  v = a[9];\n  t9 += v * b0;\n  t10 += v * b1;\n  t11 += v * b2;\n  t12 += v * b3;\n  t13 += v * b4;\n  t14 += v * b5;\n  t15 += v * b6;\n  t16 += v * b7;\n  t17 += v * b8;\n  t18 += v * b9;\n  t19 += v * b10;\n  t20 += v * b11;\n  t21 += v * b12;\n  t22 += v * b13;\n  t23 += v * b14;\n  t24 += v * b15;\n  v = a[10];\n  t10 += v * b0;\n  t11 += v * b1;\n  t12 += v * b2;\n  t13 += v * b3;\n  t14 += v * b4;\n  t15 += v * b5;\n  t16 += v * b6;\n  t17 += v * b7;\n  t18 += v * b8;\n  t19 += v * b9;\n  t20 += v * b10;\n  t21 += v * b11;\n  t22 += v * b12;\n  t23 += v * b13;\n  t24 += v * b14;\n  t25 += v * b15;\n  v = a[11];\n  t11 += v * b0;\n  t12 += v * b1;\n  t13 += v * b2;\n  t14 += v * b3;\n  t15 += v * b4;\n  t16 += v * b5;\n  t17 += v * b6;\n  t18 += v * b7;\n  t19 += v * b8;\n  t20 += v * b9;\n  t21 += v * b10;\n  t22 += v * b11;\n  t23 += v * b12;\n  t24 += v * b13;\n  t25 += v * b14;\n  t26 += v * b15;\n  v = a[12];\n  t12 += v * b0;\n  t13 += v * b1;\n  t14 += v * b2;\n  t15 += v * b3;\n  t16 += v * b4;\n  t17 += v * b5;\n  t18 += v * b6;\n  t19 += v * b7;\n  t20 += v * b8;\n  t21 += v * b9;\n  t22 += v * b10;\n  t23 += v * b11;\n  t24 += v * b12;\n  t25 += v * b13;\n  t26 += v * b14;\n  t27 += v * b15;\n  v = a[13];\n  t13 += v * b0;\n  t14 += v * b1;\n  t15 += v * b2;\n  t16 += v * b3;\n  t17 += v * b4;\n  t18 += v * b5;\n  t19 += v * b6;\n  t20 += v * b7;\n  t21 += v * b8;\n  t22 += v * b9;\n  t23 += v * b10;\n  t24 += v * b11;\n  t25 += v * b12;\n  t26 += v * b13;\n  t27 += v * b14;\n  t28 += v * b15;\n  v = a[14];\n  t14 += v * b0;\n  t15 += v * b1;\n  t16 += v * b2;\n  t17 += v * b3;\n  t18 += v * b4;\n  t19 += v * b5;\n  t20 += v * b6;\n  t21 += v * b7;\n  t22 += v * b8;\n  t23 += v * b9;\n  t24 += v * b10;\n  t25 += v * b11;\n  t26 += v * b12;\n  t27 += v * b13;\n  t28 += v * b14;\n  t29 += v * b15;\n  v = a[15];\n  t15 += v * b0;\n  t16 += v * b1;\n  t17 += v * b2;\n  t18 += v * b3;\n  t19 += v * b4;\n  t20 += v * b5;\n  t21 += v * b6;\n  t22 += v * b7;\n  t23 += v * b8;\n  t24 += v * b9;\n  t25 += v * b10;\n  t26 += v * b11;\n  t27 += v * b12;\n  t28 += v * b13;\n  t29 += v * b14;\n  t30 += v * b15;\n\n  t0  += 38 * t16;\n  t1  += 38 * t17;\n  t2  += 38 * t18;\n  t3  += 38 * t19;\n  t4  += 38 * t20;\n  t5  += 38 * t21;\n  t6  += 38 * t22;\n  t7  += 38 * t23;\n  t8  += 38 * t24;\n  t9  += 38 * t25;\n  t10 += 38 * t26;\n  t11 += 38 * t27;\n  t12 += 38 * t28;\n  t13 += 38 * t29;\n  t14 += 38 * t30;\n  // t15 left as is\n\n  // first car\n  c = 1;\n  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\n  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\n  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\n  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\n  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\n  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\n  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\n  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\n  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\n  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\n  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\n  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\n  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\n  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\n  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\n  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\n  t0 += c-1 + 37 * (c-1);\n\n  // second car\n  c = 1;\n  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\n  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\n  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\n  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\n  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\n  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\n  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\n  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\n  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\n  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\n  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\n  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\n  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\n  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\n  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\n  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\n  t0 += c-1 + 37 * (c-1);\n\n  o[ 0] = t0;\n  o[ 1] = t1;\n  o[ 2] = t2;\n  o[ 3] = t3;\n  o[ 4] = t4;\n  o[ 5] = t5;\n  o[ 6] = t6;\n  o[ 7] = t7;\n  o[ 8] = t8;\n  o[ 9] = t9;\n  o[10] = t10;\n  o[11] = t11;\n  o[12] = t12;\n  o[13] = t13;\n  o[14] = t14;\n  o[15] = t15;\n}\n\nfunction S(o, a) {\n  M(o, a, a);\n}\n\nfunction inv25519(o, i) {\n  var c = gf();\n  var a;\n  for (a = 0; a < 16; a++) c[a] = i[a];\n  for (a = 253; a >= 0; a--) {\n    S(c, c);\n    if(a !== 2 && a !== 4) M(c, c, i);\n  }\n  for (a = 0; a < 16; a++) o[a] = c[a];\n}\n\nfunction pow2523(o, i) {\n  var c = gf();\n  var a;\n  for (a = 0; a < 16; a++) c[a] = i[a];\n  for (a = 250; a >= 0; a--) {\n      S(c, c);\n      if(a !== 1) M(c, c, i);\n  }\n  for (a = 0; a < 16; a++) o[a] = c[a];\n}\n\nfunction crypto_scalarmult(q, n, p) {\n  var z = new Uint8Array(32);\n  var x = new Float64Array(80), r, i;\n  var a = gf(), b = gf(), c = gf(),\n      d = gf(), e = gf(), f = gf();\n  for (i = 0; i < 31; i++) z[i] = n[i];\n  z[31]=(n[31]&127)|64;\n  z[0]&=248;\n  unpack25519(x,p);\n  for (i = 0; i < 16; i++) {\n    b[i]=x[i];\n    d[i]=a[i]=c[i]=0;\n  }\n  a[0]=d[0]=1;\n  for (i=254;i>=0;--i) {\n    r=(z[i>>>3]>>>(i&7))&1;\n    sel25519(a,b,r);\n    sel25519(c,d,r);\n    A(e,a,c);\n    Z(a,a,c);\n    A(c,b,d);\n    Z(b,b,d);\n    S(d,e);\n    S(f,a);\n    M(a,c,a);\n    M(c,b,e);\n    A(e,a,c);\n    Z(a,a,c);\n    S(b,a);\n    Z(c,d,f);\n    M(a,c,_121665);\n    A(a,a,d);\n    M(c,c,a);\n    M(a,d,f);\n    M(d,b,x);\n    S(b,e);\n    sel25519(a,b,r);\n    sel25519(c,d,r);\n  }\n  for (i = 0; i < 16; i++) {\n    x[i+16]=a[i];\n    x[i+32]=c[i];\n    x[i+48]=b[i];\n    x[i+64]=d[i];\n  }\n  var x32 = x.subarray(32);\n  var x16 = x.subarray(16);\n  inv25519(x32,x32);\n  M(x16,x16,x32);\n  pack25519(q,x16);\n  return 0;\n}\n\nfunction crypto_scalarmult_base(q, n) {\n  return crypto_scalarmult(q, n, _9);\n}\n\nfunction crypto_box_keypair(y, x) {\n  randombytes(x, 32);\n  return crypto_scalarmult_base(y, x);\n}\n\nfunction crypto_box_beforenm(k, y, x) {\n  var s = new Uint8Array(32);\n  crypto_scalarmult(s, x, y);\n  return crypto_core_hsalsa20(k, _0, s, sigma);\n}\n\nvar crypto_box_afternm = crypto_secretbox;\nvar crypto_box_open_afternm = crypto_secretbox_open;\n\nfunction crypto_box(c, m, d, n, y, x) {\n  var k = new Uint8Array(32);\n  crypto_box_beforenm(k, y, x);\n  return crypto_box_afternm(c, m, d, n, k);\n}\n\nfunction crypto_box_open(m, c, d, n, y, x) {\n  var k = new Uint8Array(32);\n  crypto_box_beforenm(k, y, x);\n  return crypto_box_open_afternm(m, c, d, n, k);\n}\n\nvar K = [\n  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n];\n\nfunction crypto_hashblocks_hl(hh, hl, m, n) {\n  var wh = new Int32Array(16), wl = new Int32Array(16),\n      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,\n      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,\n      th, tl, i, j, h, l, a, b, c, d;\n\n  var ah0 = hh[0],\n      ah1 = hh[1],\n      ah2 = hh[2],\n      ah3 = hh[3],\n      ah4 = hh[4],\n      ah5 = hh[5],\n      ah6 = hh[6],\n      ah7 = hh[7],\n\n      al0 = hl[0],\n      al1 = hl[1],\n      al2 = hl[2],\n      al3 = hl[3],\n      al4 = hl[4],\n      al5 = hl[5],\n      al6 = hl[6],\n      al7 = hl[7];\n\n  var pos = 0;\n  while (n >= 128) {\n    for (i = 0; i < 16; i++) {\n      j = 8 * i + pos;\n      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];\n      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];\n    }\n    for (i = 0; i < 80; i++) {\n      bh0 = ah0;\n      bh1 = ah1;\n      bh2 = ah2;\n      bh3 = ah3;\n      bh4 = ah4;\n      bh5 = ah5;\n      bh6 = ah6;\n      bh7 = ah7;\n\n      bl0 = al0;\n      bl1 = al1;\n      bl2 = al2;\n      bl3 = al3;\n      bl4 = al4;\n      bl5 = al5;\n      bl6 = al6;\n      bl7 = al7;\n\n      // add\n      h = ah7;\n      l = al7;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      // Sigma1\n      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));\n      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // Ch\n      h = (ah4 & ah5) ^ (~ah4 & ah6);\n      l = (al4 & al5) ^ (~al4 & al6);\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // K\n      h = K[i*2];\n      l = K[i*2+1];\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // w\n      h = wh[i%16];\n      l = wl[i%16];\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      th = c & 0xffff | d << 16;\n      tl = a & 0xffff | b << 16;\n\n      // add\n      h = th;\n      l = tl;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      // Sigma0\n      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));\n      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // Maj\n      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);\n      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      bh7 = (c & 0xffff) | (d << 16);\n      bl7 = (a & 0xffff) | (b << 16);\n\n      // add\n      h = bh3;\n      l = bl3;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      h = th;\n      l = tl;\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      bh3 = (c & 0xffff) | (d << 16);\n      bl3 = (a & 0xffff) | (b << 16);\n\n      ah1 = bh0;\n      ah2 = bh1;\n      ah3 = bh2;\n      ah4 = bh3;\n      ah5 = bh4;\n      ah6 = bh5;\n      ah7 = bh6;\n      ah0 = bh7;\n\n      al1 = bl0;\n      al2 = bl1;\n      al3 = bl2;\n      al4 = bl3;\n      al5 = bl4;\n      al6 = bl5;\n      al7 = bl6;\n      al0 = bl7;\n\n      if (i%16 === 15) {\n        for (j = 0; j < 16; j++) {\n          // add\n          h = wh[j];\n          l = wl[j];\n\n          a = l & 0xffff; b = l >>> 16;\n          c = h & 0xffff; d = h >>> 16;\n\n          h = wh[(j+9)%16];\n          l = wl[(j+9)%16];\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          // sigma0\n          th = wh[(j+1)%16];\n          tl = wl[(j+1)%16];\n          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);\n          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          // sigma1\n          th = wh[(j+14)%16];\n          tl = wl[(j+14)%16];\n          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);\n          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          b += a >>> 16;\n          c += b >>> 16;\n          d += c >>> 16;\n\n          wh[j] = (c & 0xffff) | (d << 16);\n          wl[j] = (a & 0xffff) | (b << 16);\n        }\n      }\n    }\n\n    // add\n    h = ah0;\n    l = al0;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[0];\n    l = hl[0];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[0] = ah0 = (c & 0xffff) | (d << 16);\n    hl[0] = al0 = (a & 0xffff) | (b << 16);\n\n    h = ah1;\n    l = al1;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[1];\n    l = hl[1];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[1] = ah1 = (c & 0xffff) | (d << 16);\n    hl[1] = al1 = (a & 0xffff) | (b << 16);\n\n    h = ah2;\n    l = al2;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[2];\n    l = hl[2];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[2] = ah2 = (c & 0xffff) | (d << 16);\n    hl[2] = al2 = (a & 0xffff) | (b << 16);\n\n    h = ah3;\n    l = al3;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[3];\n    l = hl[3];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[3] = ah3 = (c & 0xffff) | (d << 16);\n    hl[3] = al3 = (a & 0xffff) | (b << 16);\n\n    h = ah4;\n    l = al4;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[4];\n    l = hl[4];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[4] = ah4 = (c & 0xffff) | (d << 16);\n    hl[4] = al4 = (a & 0xffff) | (b << 16);\n\n    h = ah5;\n    l = al5;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[5];\n    l = hl[5];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[5] = ah5 = (c & 0xffff) | (d << 16);\n    hl[5] = al5 = (a & 0xffff) | (b << 16);\n\n    h = ah6;\n    l = al6;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[6];\n    l = hl[6];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[6] = ah6 = (c & 0xffff) | (d << 16);\n    hl[6] = al6 = (a & 0xffff) | (b << 16);\n\n    h = ah7;\n    l = al7;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[7];\n    l = hl[7];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[7] = ah7 = (c & 0xffff) | (d << 16);\n    hl[7] = al7 = (a & 0xffff) | (b << 16);\n\n    pos += 128;\n    n -= 128;\n  }\n\n  return n;\n}\n\nfunction crypto_hash(out, m, n) {\n  var hh = new Int32Array(8),\n      hl = new Int32Array(8),\n      x = new Uint8Array(256),\n      i, b = n;\n\n  hh[0] = 0x6a09e667;\n  hh[1] = 0xbb67ae85;\n  hh[2] = 0x3c6ef372;\n  hh[3] = 0xa54ff53a;\n  hh[4] = 0x510e527f;\n  hh[5] = 0x9b05688c;\n  hh[6] = 0x1f83d9ab;\n  hh[7] = 0x5be0cd19;\n\n  hl[0] = 0xf3bcc908;\n  hl[1] = 0x84caa73b;\n  hl[2] = 0xfe94f82b;\n  hl[3] = 0x5f1d36f1;\n  hl[4] = 0xade682d1;\n  hl[5] = 0x2b3e6c1f;\n  hl[6] = 0xfb41bd6b;\n  hl[7] = 0x137e2179;\n\n  crypto_hashblocks_hl(hh, hl, m, n);\n  n %= 128;\n\n  for (i = 0; i < n; i++) x[i] = m[b-n+i];\n  x[n] = 128;\n\n  n = 256-128*(n<112?1:0);\n  x[n-9] = 0;\n  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);\n  crypto_hashblocks_hl(hh, hl, x, n);\n\n  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);\n\n  return 0;\n}\n\nfunction add(p, q) {\n  var a = gf(), b = gf(), c = gf(),\n      d = gf(), e = gf(), f = gf(),\n      g = gf(), h = gf(), t = gf();\n\n  Z(a, p[1], p[0]);\n  Z(t, q[1], q[0]);\n  M(a, a, t);\n  A(b, p[0], p[1]);\n  A(t, q[0], q[1]);\n  M(b, b, t);\n  M(c, p[3], q[3]);\n  M(c, c, D2);\n  M(d, p[2], q[2]);\n  A(d, d, d);\n  Z(e, b, a);\n  Z(f, d, c);\n  A(g, d, c);\n  A(h, b, a);\n\n  M(p[0], e, f);\n  M(p[1], h, g);\n  M(p[2], g, f);\n  M(p[3], e, h);\n}\n\nfunction cswap(p, q, b) {\n  var i;\n  for (i = 0; i < 4; i++) {\n    sel25519(p[i], q[i], b);\n  }\n}\n\nfunction pack(r, p) {\n  var tx = gf(), ty = gf(), zi = gf();\n  inv25519(zi, p[2]);\n  M(tx, p[0], zi);\n  M(ty, p[1], zi);\n  pack25519(r, ty);\n  r[31] ^= par25519(tx) << 7;\n}\n\nfunction scalarmult(p, q, s) {\n  var b, i;\n  set25519(p[0], gf0);\n  set25519(p[1], gf1);\n  set25519(p[2], gf1);\n  set25519(p[3], gf0);\n  for (i = 255; i >= 0; --i) {\n    b = (s[(i/8)|0] >> (i&7)) & 1;\n    cswap(p, q, b);\n    add(q, p);\n    add(p, p);\n    cswap(p, q, b);\n  }\n}\n\nfunction scalarbase(p, s) {\n  var q = [gf(), gf(), gf(), gf()];\n  set25519(q[0], X);\n  set25519(q[1], Y);\n  set25519(q[2], gf1);\n  M(q[3], X, Y);\n  scalarmult(p, q, s);\n}\n\nfunction crypto_sign_keypair(pk, sk, seeded) {\n  var d = new Uint8Array(64);\n  var p = [gf(), gf(), gf(), gf()];\n  var i;\n\n  if (!seeded) randombytes(sk, 32);\n  crypto_hash(d, sk, 32);\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  scalarbase(p, d);\n  pack(pk, p);\n\n  for (i = 0; i < 32; i++) sk[i+32] = pk[i];\n  return 0;\n}\n\nvar L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);\n\nfunction modL(r, x) {\n  var carry, i, j, k;\n  for (i = 63; i >= 32; --i) {\n    carry = 0;\n    for (j = i - 32, k = i - 12; j < k; ++j) {\n      x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n      carry = (x[j] + 128) >> 8;\n      x[j] -= carry * 256;\n    }\n    x[j] += carry;\n    x[i] = 0;\n  }\n  carry = 0;\n  for (j = 0; j < 32; j++) {\n    x[j] += carry - (x[31] >> 4) * L[j];\n    carry = x[j] >> 8;\n    x[j] &= 255;\n  }\n  for (j = 0; j < 32; j++) x[j] -= carry * L[j];\n  for (i = 0; i < 32; i++) {\n    x[i+1] += x[i] >> 8;\n    r[i] = x[i] & 255;\n  }\n}\n\nfunction reduce(r) {\n  var x = new Float64Array(64), i;\n  for (i = 0; i < 64; i++) x[i] = r[i];\n  for (i = 0; i < 64; i++) r[i] = 0;\n  modL(r, x);\n}\n\n// Note: difference from C - smlen returned, not passed as argument.\nfunction crypto_sign(sm, m, n, sk) {\n  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);\n  var i, j, x = new Float64Array(64);\n  var p = [gf(), gf(), gf(), gf()];\n\n  crypto_hash(d, sk, 32);\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  var smlen = n + 64;\n  for (i = 0; i < n; i++) sm[64 + i] = m[i];\n  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];\n\n  crypto_hash(r, sm.subarray(32), n+32);\n  reduce(r);\n  scalarbase(p, r);\n  pack(sm, p);\n\n  for (i = 32; i < 64; i++) sm[i] = sk[i];\n  crypto_hash(h, sm, n + 64);\n  reduce(h);\n\n  for (i = 0; i < 64; i++) x[i] = 0;\n  for (i = 0; i < 32; i++) x[i] = r[i];\n  for (i = 0; i < 32; i++) {\n    for (j = 0; j < 32; j++) {\n      x[i+j] += h[i] * d[j];\n    }\n  }\n\n  modL(sm.subarray(32), x);\n  return smlen;\n}\n\nfunction unpackneg(r, p) {\n  var t = gf(), chk = gf(), num = gf(),\n      den = gf(), den2 = gf(), den4 = gf(),\n      den6 = gf();\n\n  set25519(r[2], gf1);\n  unpack25519(r[1], p);\n  S(num, r[1]);\n  M(den, num, D);\n  Z(num, num, r[2]);\n  A(den, r[2], den);\n\n  S(den2, den);\n  S(den4, den2);\n  M(den6, den4, den2);\n  M(t, den6, num);\n  M(t, t, den);\n\n  pow2523(t, t);\n  M(t, t, num);\n  M(t, t, den);\n  M(t, t, den);\n  M(r[0], t, den);\n\n  S(chk, r[0]);\n  M(chk, chk, den);\n  if (neq25519(chk, num)) M(r[0], r[0], I);\n\n  S(chk, r[0]);\n  M(chk, chk, den);\n  if (neq25519(chk, num)) return -1;\n\n  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);\n\n  M(r[3], r[0], r[1]);\n  return 0;\n}\n\nfunction crypto_sign_open(m, sm, n, pk) {\n  var i, mlen;\n  var t = new Uint8Array(32), h = new Uint8Array(64);\n  var p = [gf(), gf(), gf(), gf()],\n      q = [gf(), gf(), gf(), gf()];\n\n  mlen = -1;\n  if (n < 64) return -1;\n\n  if (unpackneg(q, pk)) return -1;\n\n  for (i = 0; i < n; i++) m[i] = sm[i];\n  for (i = 0; i < 32; i++) m[i+32] = pk[i];\n  crypto_hash(h, m, n);\n  reduce(h);\n  scalarmult(p, q, h);\n\n  scalarbase(q, sm.subarray(32));\n  add(p, q);\n  pack(t, p);\n\n  n -= 64;\n  if (crypto_verify_32(sm, 0, t, 0)) {\n    for (i = 0; i < n; i++) m[i] = 0;\n    return -1;\n  }\n\n  for (i = 0; i < n; i++) m[i] = sm[i + 64];\n  mlen = n;\n  return mlen;\n}\n\nvar crypto_secretbox_KEYBYTES = 32,\n    crypto_secretbox_NONCEBYTES = 24,\n    crypto_secretbox_ZEROBYTES = 32,\n    crypto_secretbox_BOXZEROBYTES = 16,\n    crypto_scalarmult_BYTES = 32,\n    crypto_scalarmult_SCALARBYTES = 32,\n    crypto_box_PUBLICKEYBYTES = 32,\n    crypto_box_SECRETKEYBYTES = 32,\n    crypto_box_BEFORENMBYTES = 32,\n    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,\n    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,\n    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,\n    crypto_sign_BYTES = 64,\n    crypto_sign_PUBLICKEYBYTES = 32,\n    crypto_sign_SECRETKEYBYTES = 64,\n    crypto_sign_SEEDBYTES = 32,\n    crypto_hash_BYTES = 64;\n\nnacl.lowlevel = {\n  crypto_core_hsalsa20: crypto_core_hsalsa20,\n  crypto_stream_xor : crypto_stream_xor,\n  crypto_stream : crypto_stream,\n  crypto_stream_salsa20_xor : crypto_stream_salsa20_xor,\n  crypto_stream_salsa20 : crypto_stream_salsa20,\n  crypto_onetimeauth : crypto_onetimeauth,\n  crypto_onetimeauth_verify : crypto_onetimeauth_verify,\n  crypto_verify_16 : crypto_verify_16,\n  crypto_verify_32 : crypto_verify_32,\n  crypto_secretbox : crypto_secretbox,\n  crypto_secretbox_open : crypto_secretbox_open,\n  crypto_scalarmult : crypto_scalarmult,\n  crypto_scalarmult_base : crypto_scalarmult_base,\n  crypto_box_beforenm : crypto_box_beforenm,\n  crypto_box_afternm : crypto_box_afternm,\n  crypto_box : crypto_box,\n  crypto_box_open : crypto_box_open,\n  crypto_box_keypair : crypto_box_keypair,\n  crypto_hash : crypto_hash,\n  crypto_sign : crypto_sign,\n  crypto_sign_keypair : crypto_sign_keypair,\n  crypto_sign_open : crypto_sign_open,\n\n  crypto_secretbox_KEYBYTES : crypto_secretbox_KEYBYTES,\n  crypto_secretbox_NONCEBYTES : crypto_secretbox_NONCEBYTES,\n  crypto_secretbox_ZEROBYTES : crypto_secretbox_ZEROBYTES,\n  crypto_secretbox_BOXZEROBYTES : crypto_secretbox_BOXZEROBYTES,\n  crypto_scalarmult_BYTES : crypto_scalarmult_BYTES,\n  crypto_scalarmult_SCALARBYTES : crypto_scalarmult_SCALARBYTES,\n  crypto_box_PUBLICKEYBYTES : crypto_box_PUBLICKEYBYTES,\n  crypto_box_SECRETKEYBYTES : crypto_box_SECRETKEYBYTES,\n  crypto_box_BEFORENMBYTES : crypto_box_BEFORENMBYTES,\n  crypto_box_NONCEBYTES : crypto_box_NONCEBYTES,\n  crypto_box_ZEROBYTES : crypto_box_ZEROBYTES,\n  crypto_box_BOXZEROBYTES : crypto_box_BOXZEROBYTES,\n  crypto_sign_BYTES : crypto_sign_BYTES,\n  crypto_sign_PUBLICKEYBYTES : crypto_sign_PUBLICKEYBYTES,\n  crypto_sign_SECRETKEYBYTES : crypto_sign_SECRETKEYBYTES,\n  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,\n  crypto_hash_BYTES : crypto_hash_BYTES\n};\n\n/* High-level API */\n\nfunction checkLengths(k, n) {\n  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');\n  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');\n}\n\nfunction checkBoxLengths(pk, sk) {\n  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');\n  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');\n}\n\nfunction checkArrayTypes() {\n  var type = {}.toString, t;\n  for (var i = 0; i < arguments.length; i++) {\n     if ((t = type.call(arguments[i])) !== '[object Uint8Array]')\n       throw new TypeError('unexpected type ' + t + ', use Uint8Array');\n  }\n}\n\nnacl.util = {};\n\nnacl.util.decodeUTF8 = function(s) {\n  var i, d = unescape(encodeURIComponent(s)), b = new Uint8Array(d.length);\n  for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);\n  return b;\n};\n\nnacl.util.encodeUTF8 = function(arr) {\n  var i, s = [];\n  for (i = 0; i < arr.length; i++) s.push(String.fromCharCode(arr[i]));\n  return decodeURIComponent(escape(s.join('')));\n};\n\nnacl.util.encodeBase64 = function(arr) {\n  if (typeof btoa === 'undefined') {\n    return (new Buffer(arr)).toString('base64');\n  } else {\n    var i, s = [], len = arr.length;\n    for (i = 0; i < len; i++) s.push(String.fromCharCode(arr[i]));\n    return btoa(s.join(''));\n  }\n};\n\nnacl.util.decodeBase64 = function(s) {\n  if (typeof atob === 'undefined') {\n    return new Uint8Array(Array.prototype.slice.call(new Buffer(s, 'base64'), 0));\n  } else {\n    var i, d = atob(s), b = new Uint8Array(d.length);\n    for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);\n    return b;\n  }\n};\n\nnacl.randomBytes = function(n) {\n  var b = new Uint8Array(n);\n  randombytes(b, n);\n  return b;\n};\n\nnacl.secretbox = function(msg, nonce, key) {\n  checkArrayTypes(msg, nonce, key);\n  checkLengths(key, nonce);\n  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);\n  var c = new Uint8Array(m.length);\n  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];\n  crypto_secretbox(c, m, m.length, nonce, key);\n  return c.subarray(crypto_secretbox_BOXZEROBYTES);\n};\n\nnacl.secretbox.open = function(box, nonce, key) {\n  checkArrayTypes(box, nonce, key);\n  checkLengths(key, nonce);\n  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);\n  var m = new Uint8Array(c.length);\n  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];\n  if (c.length < 32) return false;\n  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return false;\n  return m.subarray(crypto_secretbox_ZEROBYTES);\n};\n\nnacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;\nnacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;\nnacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;\n\nnacl.scalarMult = function(n, p) {\n  checkArrayTypes(n, p);\n  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');\n  var q = new Uint8Array(crypto_scalarmult_BYTES);\n  crypto_scalarmult(q, n, p);\n  return q;\n};\n\nnacl.scalarMult.base = function(n) {\n  checkArrayTypes(n);\n  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n  var q = new Uint8Array(crypto_scalarmult_BYTES);\n  crypto_scalarmult_base(q, n);\n  return q;\n};\n\nnacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;\nnacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;\n\nnacl.box = function(msg, nonce, publicKey, secretKey) {\n  var k = nacl.box.before(publicKey, secretKey);\n  return nacl.secretbox(msg, nonce, k);\n};\n\nnacl.box.before = function(publicKey, secretKey) {\n  checkArrayTypes(publicKey, secretKey);\n  checkBoxLengths(publicKey, secretKey);\n  var k = new Uint8Array(crypto_box_BEFORENMBYTES);\n  crypto_box_beforenm(k, publicKey, secretKey);\n  return k;\n};\n\nnacl.box.after = nacl.secretbox;\n\nnacl.box.open = function(msg, nonce, publicKey, secretKey) {\n  var k = nacl.box.before(publicKey, secretKey);\n  return nacl.secretbox.open(msg, nonce, k);\n};\n\nnacl.box.open.after = nacl.secretbox.open;\n\nnacl.box.keyPair = function() {\n  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);\n  crypto_box_keypair(pk, sk);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.box.keyPair.fromSecretKey = function(secretKey) {\n  checkArrayTypes(secretKey);\n  if (secretKey.length !== crypto_box_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n  crypto_scalarmult_base(pk, secretKey);\n  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};\n};\n\nnacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;\nnacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;\nnacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;\nnacl.box.nonceLength = crypto_box_NONCEBYTES;\nnacl.box.overheadLength = nacl.secretbox.overheadLength;\n\nnacl.sign = function(msg, secretKey) {\n  checkArrayTypes(msg, secretKey);\n  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);\n  crypto_sign(signedMsg, msg, msg.length, secretKey);\n  return signedMsg;\n};\n\nnacl.sign.open = function(signedMsg, publicKey) {\n  if (arguments.length !== 2)\n    throw new Error('nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?');\n  checkArrayTypes(signedMsg, publicKey);\n  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)\n    throw new Error('bad public key size');\n  var tmp = new Uint8Array(signedMsg.length);\n  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);\n  if (mlen < 0) return null;\n  var m = new Uint8Array(mlen);\n  for (var i = 0; i < m.length; i++) m[i] = tmp[i];\n  return m;\n};\n\nnacl.sign.detached = function(msg, secretKey) {\n  var signedMsg = nacl.sign(msg, secretKey);\n  var sig = new Uint8Array(crypto_sign_BYTES);\n  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];\n  return sig;\n};\n\nnacl.sign.detached.verify = function(msg, sig, publicKey) {\n  checkArrayTypes(msg, sig, publicKey);\n  if (sig.length !== crypto_sign_BYTES)\n    throw new Error('bad signature size');\n  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)\n    throw new Error('bad public key size');\n  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);\n  var m = new Uint8Array(crypto_sign_BYTES + msg.length);\n  var i;\n  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];\n  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];\n  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);\n};\n\nnacl.sign.keyPair = function() {\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n  crypto_sign_keypair(pk, sk);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.sign.keyPair.fromSecretKey = function(secretKey) {\n  checkArrayTypes(secretKey);\n  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];\n  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};\n};\n\nnacl.sign.keyPair.fromSeed = function(seed) {\n  checkArrayTypes(seed);\n  if (seed.length !== crypto_sign_SEEDBYTES)\n    throw new Error('bad seed size');\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n  for (var i = 0; i < 32; i++) sk[i] = seed[i];\n  crypto_sign_keypair(pk, sk, true);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;\nnacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;\nnacl.sign.seedLength = crypto_sign_SEEDBYTES;\nnacl.sign.signatureLength = crypto_sign_BYTES;\n\nnacl.hash = function(msg) {\n  checkArrayTypes(msg);\n  var h = new Uint8Array(crypto_hash_BYTES);\n  crypto_hash(h, msg, msg.length);\n  return h;\n};\n\nnacl.hash.hashLength = crypto_hash_BYTES;\n\nnacl.verify = function(x, y) {\n  checkArrayTypes(x, y);\n  // Zero length arguments are considered not equal.\n  if (x.length === 0 || y.length === 0) return false;\n  if (x.length !== y.length) return false;\n  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;\n};\n\nnacl.setPRNG = function(fn) {\n  randombytes = fn;\n};\n\n(function() {\n  // Initialize PRNG if environment provides CSPRNG.\n  // If not, methods calling randombytes will throw.\n  var crypto;\n  if (typeof window !== 'undefined') {\n    // Browser.\n    if (window.crypto && window.crypto.getRandomValues) {\n      crypto = window.crypto; // Standard\n    } else if (window.msCrypto && window.msCrypto.getRandomValues) {\n      crypto = window.msCrypto; // Internet Explorer 11+\n    }\n    if (crypto) {\n      nacl.setPRNG(function(x, n) {\n        var i, v = new Uint8Array(n);\n        crypto.getRandomValues(v);\n        for (i = 0; i < n; i++) x[i] = v[i];\n      });\n    }\n  } else if (typeof require !== 'undefined') {\n    // Node.js.\n    crypto = require('crypto');\n    if (crypto) {\n      nacl.setPRNG(function(x, n) {\n        var i, v = crypto.randomBytes(n);\n        for (i = 0; i < n; i++) x[i] = v[i];\n      });\n    }\n  }\n})();\n\n})(typeof module !== 'undefined' && module.exports ? module.exports : (window.nacl = window.nacl || {}));\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":80,\"crypto\":86}],201:[function(require,module,exports){\n(function (Buffer){\n(function(nacl) {\n'use strict';\n\n// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.\n// Public domain.\n//\n// Implementation derived from TweetNaCl version 20140427.\n// See for details: http://tweetnacl.cr.yp.to/\n\n/* jshint newcap: false */\n\nvar u64 = function (h, l) { this.hi = h|0 >>> 0; this.lo = l|0 >>> 0; };\nvar gf = function(init) {\n  var i, r = new Float64Array(16);\n  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];\n  return r;\n};\n\n//  Pluggable, initialized in high-level API below.\nvar randombytes = function(/* x, n */) { throw new Error('no PRNG'); };\n\nvar _0 = new Uint8Array(16);\nvar _9 = new Uint8Array(32); _9[0] = 9;\n\nvar gf0 = gf(),\n    gf1 = gf([1]),\n    _121665 = gf([0xdb41, 1]),\n    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),\n    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),\n    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),\n    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),\n    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);\n\nfunction L32(x, c) { return (x << c) | (x >>> (32 - c)); }\n\nfunction ld32(x, i) {\n  var u = x[i+3] & 0xff;\n  u = (u<<8)|(x[i+2] & 0xff);\n  u = (u<<8)|(x[i+1] & 0xff);\n  return (u<<8)|(x[i+0] & 0xff);\n}\n\nfunction dl64(x, i) {\n  var h = (x[i] << 24) | (x[i+1] << 16) | (x[i+2] << 8) | x[i+3];\n  var l = (x[i+4] << 24) | (x[i+5] << 16) | (x[i+6] << 8) | x[i+7];\n  return new u64(h, l);\n}\n\nfunction st32(x, j, u) {\n  var i;\n  for (i = 0; i < 4; i++) { x[j+i] = u & 255; u >>>= 8; }\n}\n\nfunction ts64(x, i, u) {\n  x[i]   = (u.hi >> 24) & 0xff;\n  x[i+1] = (u.hi >> 16) & 0xff;\n  x[i+2] = (u.hi >>  8) & 0xff;\n  x[i+3] = u.hi & 0xff;\n  x[i+4] = (u.lo >> 24)  & 0xff;\n  x[i+5] = (u.lo >> 16)  & 0xff;\n  x[i+6] = (u.lo >>  8)  & 0xff;\n  x[i+7] = u.lo & 0xff;\n}\n\nfunction vn(x, xi, y, yi, n) {\n  var i,d = 0;\n  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];\n  return (1 & ((d - 1) >>> 8)) - 1;\n}\n\nfunction crypto_verify_16(x, xi, y, yi) {\n  return vn(x,xi,y,yi,16);\n}\n\nfunction crypto_verify_32(x, xi, y, yi) {\n  return vn(x,xi,y,yi,32);\n}\n\nfunction core(out,inp,k,c,h) {\n  var w = new Uint32Array(16), x = new Uint32Array(16),\n      y = new Uint32Array(16), t = new Uint32Array(4);\n  var i, j, m;\n\n  for (i = 0; i < 4; i++) {\n    x[5*i] = ld32(c, 4*i);\n    x[1+i] = ld32(k, 4*i);\n    x[6+i] = ld32(inp, 4*i);\n    x[11+i] = ld32(k, 16+4*i);\n  }\n\n  for (i = 0; i < 16; i++) y[i] = x[i];\n\n  for (i = 0; i < 20; i++) {\n    for (j = 0; j < 4; j++) {\n      for (m = 0; m < 4; m++) t[m] = x[(5*j+4*m)%16];\n      t[1] ^= L32((t[0]+t[3])|0, 7);\n      t[2] ^= L32((t[1]+t[0])|0, 9);\n      t[3] ^= L32((t[2]+t[1])|0,13);\n      t[0] ^= L32((t[3]+t[2])|0,18);\n      for (m = 0; m < 4; m++) w[4*j+(j+m)%4] = t[m];\n    }\n    for (m = 0; m < 16; m++) x[m] = w[m];\n  }\n\n  if (h) {\n    for (i = 0; i < 16; i++) x[i] = (x[i] + y[i]) | 0;\n    for (i = 0; i < 4; i++) {\n      x[5*i] = (x[5*i] - ld32(c, 4*i)) | 0;\n      x[6+i] = (x[6+i] - ld32(inp, 4*i)) | 0;\n    }\n    for (i = 0; i < 4; i++) {\n      st32(out,4*i,x[5*i]);\n      st32(out,16+4*i,x[6+i]);\n    }\n  } else {\n    for (i = 0; i < 16; i++) st32(out, 4 * i, (x[i] + y[i]) | 0);\n  }\n}\n\nfunction crypto_core_salsa20(out,inp,k,c) {\n  core(out,inp,k,c,false);\n  return 0;\n}\n\nfunction crypto_core_hsalsa20(out,inp,k,c) {\n  core(out,inp,k,c,true);\n  return 0;\n}\n\nvar sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);\n            // \"expand 32-byte k\"\n\nfunction crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {\n  var z = new Uint8Array(16), x = new Uint8Array(64);\n  var u, i;\n  if (!b) return 0;\n  for (i = 0; i < 16; i++) z[i] = 0;\n  for (i = 0; i < 8; i++) z[i] = n[i];\n  while (b >= 64) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < 64; i++) c[cpos+i] = (m?m[mpos+i]:0) ^ x[i];\n    u = 1;\n    for (i = 8; i < 16; i++) {\n      u = u + (z[i] & 0xff) | 0;\n      z[i] = u & 0xff;\n      u >>>= 8;\n    }\n    b -= 64;\n    cpos += 64;\n    if (m) mpos += 64;\n  }\n  if (b > 0) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < b; i++) c[cpos+i] = (m?m[mpos+i]:0) ^ x[i];\n  }\n  return 0;\n}\n\nfunction crypto_stream_salsa20(c,cpos,d,n,k) {\n  return crypto_stream_salsa20_xor(c,cpos,null,0,d,n,k);\n}\n\nfunction crypto_stream(c,cpos,d,n,k) {\n  var s = new Uint8Array(32);\n  crypto_core_hsalsa20(s,n,k,sigma);\n  return crypto_stream_salsa20(c,cpos,d,n.subarray(16),s);\n}\n\nfunction crypto_stream_xor(c,cpos,m,mpos,d,n,k) {\n  var s = new Uint8Array(32);\n  crypto_core_hsalsa20(s,n,k,sigma);\n  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,n.subarray(16),s);\n}\n\nfunction add1305(h, c) {\n  var j, u = 0;\n  for (j = 0; j < 17; j++) {\n    u = (u + ((h[j] + c[j]) | 0)) | 0;\n    h[j] = u & 255;\n    u >>>= 8;\n  }\n}\n\nvar minusp = new Uint32Array([\n  5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 252\n]);\n\nfunction crypto_onetimeauth(out, outpos, m, mpos, n, k) {\n  var s, i, j, u;\n  var x = new Uint32Array(17), r = new Uint32Array(17),\n      h = new Uint32Array(17), c = new Uint32Array(17),\n      g = new Uint32Array(17);\n  for (j = 0; j < 17; j++) r[j]=h[j]=0;\n  for (j = 0; j < 16; j++) r[j]=k[j];\n  r[3]&=15;\n  r[4]&=252;\n  r[7]&=15;\n  r[8]&=252;\n  r[11]&=15;\n  r[12]&=252;\n  r[15]&=15;\n\n  while (n > 0) {\n    for (j = 0; j < 17; j++) c[j] = 0;\n    for (j = 0;(j < 16) && (j < n);++j) c[j] = m[mpos+j];\n    c[j] = 1;\n    mpos += j; n -= j;\n    add1305(h,c);\n    for (i = 0; i < 17; i++) {\n      x[i] = 0;\n      for (j = 0; j < 17; j++) x[i] = (x[i] + (h[j] * ((j <= i) ? r[i - j] : ((320 * r[i + 17 - j])|0))) | 0) | 0;\n    }\n    for (i = 0; i < 17; i++) h[i] = x[i];\n    u = 0;\n    for (j = 0; j < 16; j++) {\n      u = (u + h[j]) | 0;\n      h[j] = u & 255;\n      u >>>= 8;\n    }\n    u = (u + h[16]) | 0; h[16] = u & 3;\n    u = (5 * (u >>> 2)) | 0;\n    for (j = 0; j < 16; j++) {\n      u = (u + h[j]) | 0;\n      h[j] = u & 255;\n      u >>>= 8;\n    }\n    u = (u + h[16]) | 0; h[16] = u;\n  }\n\n  for (j = 0; j < 17; j++) g[j] = h[j];\n  add1305(h,minusp);\n  s = (-(h[16] >>> 7) | 0);\n  for (j = 0; j < 17; j++) h[j] ^= s & (g[j] ^ h[j]);\n\n  for (j = 0; j < 16; j++) c[j] = k[j + 16];\n  c[16] = 0;\n  add1305(h,c);\n  for (j = 0; j < 16; j++) out[outpos+j] = h[j];\n  return 0;\n}\n\nfunction crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {\n  var x = new Uint8Array(16);\n  crypto_onetimeauth(x,0,m,mpos,n,k);\n  return crypto_verify_16(h,hpos,x,0);\n}\n\nfunction crypto_secretbox(c,m,d,n,k) {\n  var i;\n  if (d < 32) return -1;\n  crypto_stream_xor(c,0,m,0,d,n,k);\n  crypto_onetimeauth(c, 16, c, 32, d - 32, c);\n  for (i = 0; i < 16; i++) c[i] = 0;\n  return 0;\n}\n\nfunction crypto_secretbox_open(m,c,d,n,k) {\n  var i;\n  var x = new Uint8Array(32);\n  if (d < 32) return -1;\n  crypto_stream(x,0,32,n,k);\n  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;\n  crypto_stream_xor(m,0,c,0,d,n,k);\n  for (i = 0; i < 32; i++) m[i] = 0;\n  return 0;\n}\n\nfunction set25519(r, a) {\n  var i;\n  for (i = 0; i < 16; i++) r[i] = a[i]|0;\n}\n\nfunction car25519(o) {\n  var c;\n  var i;\n  for (i = 0; i < 16; i++) {\n      o[i] += 65536;\n      c = Math.floor(o[i] / 65536);\n      o[(i+1)*(i<15?1:0)] += c - 1 + 37 * (c-1) * (i===15?1:0);\n      o[i] -= (c * 65536);\n  }\n}\n\nfunction sel25519(p, q, b) {\n  var t, c = ~(b-1);\n  for (var i = 0; i < 16; i++) {\n    t = c & (p[i] ^ q[i]);\n    p[i] ^= t;\n    q[i] ^= t;\n  }\n}\n\nfunction pack25519(o, n) {\n  var i, j, b;\n  var m = gf(), t = gf();\n  for (i = 0; i < 16; i++) t[i] = n[i];\n  car25519(t);\n  car25519(t);\n  car25519(t);\n  for (j = 0; j < 2; j++) {\n    m[0] = t[0] - 0xffed;\n    for (i = 1; i < 15; i++) {\n      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);\n      m[i-1] &= 0xffff;\n    }\n    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);\n    b = (m[15]>>16) & 1;\n    m[14] &= 0xffff;\n    sel25519(t, m, 1-b);\n  }\n  for (i = 0; i < 16; i++) {\n    o[2*i] = t[i] & 0xff;\n    o[2*i+1] = t[i]>>8;\n  }\n}\n\nfunction neq25519(a, b) {\n  var c = new Uint8Array(32), d = new Uint8Array(32);\n  pack25519(c, a);\n  pack25519(d, b);\n  return crypto_verify_32(c, 0, d, 0);\n}\n\nfunction par25519(a) {\n  var d = new Uint8Array(32);\n  pack25519(d, a);\n  return d[0] & 1;\n}\n\nfunction unpack25519(o, n) {\n  var i;\n  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);\n  o[15] &= 0x7fff;\n}\n\nfunction A(o, a, b) {\n  var i;\n  for (i = 0; i < 16; i++) o[i] = (a[i] + b[i])|0;\n}\n\nfunction Z(o, a, b) {\n  var i;\n  for (i = 0; i < 16; i++) o[i] = (a[i] - b[i])|0;\n}\n\nfunction M(o, a, b) {\n  var i, j, t = new Float64Array(31);\n  for (i = 0; i < 31; i++) t[i] = 0;\n  for (i = 0; i < 16; i++) {\n    for (j = 0; j < 16; j++) {\n      t[i+j] += a[i] * b[j];\n    }\n  }\n  for (i = 0; i < 15; i++) {\n    t[i] += 38 * t[i+16];\n  }\n  for (i = 0; i < 16; i++) o[i] = t[i];\n  car25519(o);\n  car25519(o);\n}\n\nfunction S(o, a) {\n  M(o, a, a);\n}\n\nfunction inv25519(o, i) {\n  var c = gf();\n  var a;\n  for (a = 0; a < 16; a++) c[a] = i[a];\n  for (a = 253; a >= 0; a--) {\n    S(c, c);\n    if(a !== 2 && a !== 4) M(c, c, i);\n  }\n  for (a = 0; a < 16; a++) o[a] = c[a];\n}\n\nfunction pow2523(o, i) {\n  var c = gf();\n  var a;\n  for (a = 0; a < 16; a++) c[a] = i[a];\n  for (a = 250; a >= 0; a--) {\n      S(c, c);\n      if(a !== 1) M(c, c, i);\n  }\n  for (a = 0; a < 16; a++) o[a] = c[a];\n}\n\nfunction crypto_scalarmult(q, n, p) {\n  var z = new Uint8Array(32);\n  var x = new Float64Array(80), r, i;\n  var a = gf(), b = gf(), c = gf(),\n      d = gf(), e = gf(), f = gf();\n  for (i = 0; i < 31; i++) z[i] = n[i];\n  z[31]=(n[31]&127)|64;\n  z[0]&=248;\n  unpack25519(x,p);\n  for (i = 0; i < 16; i++) {\n    b[i]=x[i];\n    d[i]=a[i]=c[i]=0;\n  }\n  a[0]=d[0]=1;\n  for (i=254;i>=0;--i) {\n    r=(z[i>>>3]>>>(i&7))&1;\n    sel25519(a,b,r);\n    sel25519(c,d,r);\n    A(e,a,c);\n    Z(a,a,c);\n    A(c,b,d);\n    Z(b,b,d);\n    S(d,e);\n    S(f,a);\n    M(a,c,a);\n    M(c,b,e);\n    A(e,a,c);\n    Z(a,a,c);\n    S(b,a);\n    Z(c,d,f);\n    M(a,c,_121665);\n    A(a,a,d);\n    M(c,c,a);\n    M(a,d,f);\n    M(d,b,x);\n    S(b,e);\n    sel25519(a,b,r);\n    sel25519(c,d,r);\n  }\n  for (i = 0; i < 16; i++) {\n    x[i+16]=a[i];\n    x[i+32]=c[i];\n    x[i+48]=b[i];\n    x[i+64]=d[i];\n  }\n  var x32 = x.subarray(32);\n  var x16 = x.subarray(16);\n  inv25519(x32,x32);\n  M(x16,x16,x32);\n  pack25519(q,x16);\n  return 0;\n}\n\nfunction crypto_scalarmult_base(q, n) {\n  return crypto_scalarmult(q, n, _9);\n}\n\nfunction crypto_box_keypair(y, x) {\n  randombytes(x, 32);\n  return crypto_scalarmult_base(y, x);\n}\n\nfunction crypto_box_beforenm(k, y, x) {\n  var s = new Uint8Array(32);\n  crypto_scalarmult(s, x, y);\n  return crypto_core_hsalsa20(k, _0, s, sigma);\n}\n\nvar crypto_box_afternm = crypto_secretbox;\nvar crypto_box_open_afternm = crypto_secretbox_open;\n\nfunction crypto_box(c, m, d, n, y, x) {\n  var k = new Uint8Array(32);\n  crypto_box_beforenm(k, y, x);\n  return crypto_box_afternm(c, m, d, n, k);\n}\n\nfunction crypto_box_open(m, c, d, n, y, x) {\n  var k = new Uint8Array(32);\n  crypto_box_beforenm(k, y, x);\n  return crypto_box_open_afternm(m, c, d, n, k);\n}\n\nfunction add64() {\n  var a = 0, b = 0, c = 0, d = 0, m16 = 65535, l, h, i;\n  for (i = 0; i < arguments.length; i++) {\n    l = arguments[i].lo;\n    h = arguments[i].hi;\n    a += (l & m16); b += (l >>> 16);\n    c += (h & m16); d += (h >>> 16);\n  }\n\n  b += (a >>> 16);\n  c += (b >>> 16);\n  d += (c >>> 16);\n\n  return new u64((c & m16) | (d << 16), (a & m16) | (b << 16));\n}\n\nfunction shr64(x, c) {\n  return new u64((x.hi >>> c), (x.lo >>> c) | (x.hi << (32 - c)));\n}\n\nfunction xor64() {\n  var l = 0, h = 0, i;\n  for (i = 0; i < arguments.length; i++) {\n    l ^= arguments[i].lo;\n    h ^= arguments[i].hi;\n  }\n  return new u64(h, l);\n}\n\nfunction R(x, c) {\n  var h, l, c1 = 32 - c;\n  if (c < 32) {\n    h = (x.hi >>> c) | (x.lo << c1);\n    l = (x.lo >>> c) | (x.hi << c1);\n  } else if (c < 64) {\n    h = (x.lo >>> c) | (x.hi << c1);\n    l = (x.hi >>> c) | (x.lo << c1);\n  }\n  return new u64(h, l);\n}\n\nfunction Ch(x, y, z) {\n  var h = (x.hi & y.hi) ^ (~x.hi & z.hi),\n      l = (x.lo & y.lo) ^ (~x.lo & z.lo);\n  return new u64(h, l);\n}\n\nfunction Maj(x, y, z) {\n  var h = (x.hi & y.hi) ^ (x.hi & z.hi) ^ (y.hi & z.hi),\n      l = (x.lo & y.lo) ^ (x.lo & z.lo) ^ (y.lo & z.lo);\n  return new u64(h, l);\n}\n\nfunction Sigma0(x) { return xor64(R(x,28), R(x,34), R(x,39)); }\nfunction Sigma1(x) { return xor64(R(x,14), R(x,18), R(x,41)); }\nfunction sigma0(x) { return xor64(R(x, 1), R(x, 8), shr64(x,7)); }\nfunction sigma1(x) { return xor64(R(x,19), R(x,61), shr64(x,6)); }\n\nvar K = [\n  new u64(0x428a2f98, 0xd728ae22), new u64(0x71374491, 0x23ef65cd),\n  new u64(0xb5c0fbcf, 0xec4d3b2f), new u64(0xe9b5dba5, 0x8189dbbc),\n  new u64(0x3956c25b, 0xf348b538), new u64(0x59f111f1, 0xb605d019),\n  new u64(0x923f82a4, 0xaf194f9b), new u64(0xab1c5ed5, 0xda6d8118),\n  new u64(0xd807aa98, 0xa3030242), new u64(0x12835b01, 0x45706fbe),\n  new u64(0x243185be, 0x4ee4b28c), new u64(0x550c7dc3, 0xd5ffb4e2),\n  new u64(0x72be5d74, 0xf27b896f), new u64(0x80deb1fe, 0x3b1696b1),\n  new u64(0x9bdc06a7, 0x25c71235), new u64(0xc19bf174, 0xcf692694),\n  new u64(0xe49b69c1, 0x9ef14ad2), new u64(0xefbe4786, 0x384f25e3),\n  new u64(0x0fc19dc6, 0x8b8cd5b5), new u64(0x240ca1cc, 0x77ac9c65),\n  new u64(0x2de92c6f, 0x592b0275), new u64(0x4a7484aa, 0x6ea6e483),\n  new u64(0x5cb0a9dc, 0xbd41fbd4), new u64(0x76f988da, 0x831153b5),\n  new u64(0x983e5152, 0xee66dfab), new u64(0xa831c66d, 0x2db43210),\n  new u64(0xb00327c8, 0x98fb213f), new u64(0xbf597fc7, 0xbeef0ee4),\n  new u64(0xc6e00bf3, 0x3da88fc2), new u64(0xd5a79147, 0x930aa725),\n  new u64(0x06ca6351, 0xe003826f), new u64(0x14292967, 0x0a0e6e70),\n  new u64(0x27b70a85, 0x46d22ffc), new u64(0x2e1b2138, 0x5c26c926),\n  new u64(0x4d2c6dfc, 0x5ac42aed), new u64(0x53380d13, 0x9d95b3df),\n  new u64(0x650a7354, 0x8baf63de), new u64(0x766a0abb, 0x3c77b2a8),\n  new u64(0x81c2c92e, 0x47edaee6), new u64(0x92722c85, 0x1482353b),\n  new u64(0xa2bfe8a1, 0x4cf10364), new u64(0xa81a664b, 0xbc423001),\n  new u64(0xc24b8b70, 0xd0f89791), new u64(0xc76c51a3, 0x0654be30),\n  new u64(0xd192e819, 0xd6ef5218), new u64(0xd6990624, 0x5565a910),\n  new u64(0xf40e3585, 0x5771202a), new u64(0x106aa070, 0x32bbd1b8),\n  new u64(0x19a4c116, 0xb8d2d0c8), new u64(0x1e376c08, 0x5141ab53),\n  new u64(0x2748774c, 0xdf8eeb99), new u64(0x34b0bcb5, 0xe19b48a8),\n  new u64(0x391c0cb3, 0xc5c95a63), new u64(0x4ed8aa4a, 0xe3418acb),\n  new u64(0x5b9cca4f, 0x7763e373), new u64(0x682e6ff3, 0xd6b2b8a3),\n  new u64(0x748f82ee, 0x5defb2fc), new u64(0x78a5636f, 0x43172f60),\n  new u64(0x84c87814, 0xa1f0ab72), new u64(0x8cc70208, 0x1a6439ec),\n  new u64(0x90befffa, 0x23631e28), new u64(0xa4506ceb, 0xde82bde9),\n  new u64(0xbef9a3f7, 0xb2c67915), new u64(0xc67178f2, 0xe372532b),\n  new u64(0xca273ece, 0xea26619c), new u64(0xd186b8c7, 0x21c0c207),\n  new u64(0xeada7dd6, 0xcde0eb1e), new u64(0xf57d4f7f, 0xee6ed178),\n  new u64(0x06f067aa, 0x72176fba), new u64(0x0a637dc5, 0xa2c898a6),\n  new u64(0x113f9804, 0xbef90dae), new u64(0x1b710b35, 0x131c471b),\n  new u64(0x28db77f5, 0x23047d84), new u64(0x32caab7b, 0x40c72493),\n  new u64(0x3c9ebe0a, 0x15c9bebc), new u64(0x431d67c4, 0x9c100d4c),\n  new u64(0x4cc5d4be, 0xcb3e42b6), new u64(0x597f299c, 0xfc657e2a),\n  new u64(0x5fcb6fab, 0x3ad6faec), new u64(0x6c44198c, 0x4a475817)\n];\n\nfunction crypto_hashblocks(x, m, n) {\n  var z = [], b = [], a = [], w = [], t, i, j;\n\n  for (i = 0; i < 8; i++) z[i] = a[i] = dl64(x, 8*i);\n\n  var pos = 0;\n  while (n >= 128) {\n    for (i = 0; i < 16; i++) w[i] = dl64(m, 8*i+pos);\n    for (i = 0; i < 80; i++) {\n      for (j = 0; j < 8; j++) b[j] = a[j];\n      t = add64(a[7], Sigma1(a[4]), Ch(a[4], a[5], a[6]), K[i], w[i%16]);\n      b[7] = add64(t, Sigma0(a[0]), Maj(a[0], a[1], a[2]));\n      b[3] = add64(b[3], t);\n      for (j = 0; j < 8; j++) a[(j+1)%8] = b[j];\n      if (i%16 === 15) {\n        for (j = 0; j < 16; j++) {\n          w[j] = add64(w[j], w[(j+9)%16], sigma0(w[(j+1)%16]), sigma1(w[(j+14)%16]));\n        }\n      }\n    }\n\n    for (i = 0; i < 8; i++) {\n      a[i] = add64(a[i], z[i]);\n      z[i] = a[i];\n    }\n\n    pos += 128;\n    n -= 128;\n  }\n\n  for (i = 0; i < 8; i++) ts64(x, 8*i, z[i]);\n  return n;\n}\n\nvar iv = new Uint8Array([\n  0x6a,0x09,0xe6,0x67,0xf3,0xbc,0xc9,0x08,\n  0xbb,0x67,0xae,0x85,0x84,0xca,0xa7,0x3b,\n  0x3c,0x6e,0xf3,0x72,0xfe,0x94,0xf8,0x2b,\n  0xa5,0x4f,0xf5,0x3a,0x5f,0x1d,0x36,0xf1,\n  0x51,0x0e,0x52,0x7f,0xad,0xe6,0x82,0xd1,\n  0x9b,0x05,0x68,0x8c,0x2b,0x3e,0x6c,0x1f,\n  0x1f,0x83,0xd9,0xab,0xfb,0x41,0xbd,0x6b,\n  0x5b,0xe0,0xcd,0x19,0x13,0x7e,0x21,0x79\n]);\n\nfunction crypto_hash(out, m, n) {\n  var h = new Uint8Array(64), x = new Uint8Array(256);\n  var i, b = n;\n\n  for (i = 0; i < 64; i++) h[i] = iv[i];\n\n  crypto_hashblocks(h, m, n);\n  n %= 128;\n\n  for (i = 0; i < 256; i++) x[i] = 0;\n  for (i = 0; i < n; i++) x[i] = m[b-n+i];\n  x[n] = 128;\n\n  n = 256-128*(n<112?1:0);\n  x[n-9] = 0;\n  ts64(x, n-8, new u64((b / 0x20000000) | 0, b << 3));\n  crypto_hashblocks(h, x, n);\n\n  for (i = 0; i < 64; i++) out[i] = h[i];\n\n  return 0;\n}\n\nfunction add(p, q) {\n  var a = gf(), b = gf(), c = gf(),\n      d = gf(), e = gf(), f = gf(),\n      g = gf(), h = gf(), t = gf();\n\n  Z(a, p[1], p[0]);\n  Z(t, q[1], q[0]);\n  M(a, a, t);\n  A(b, p[0], p[1]);\n  A(t, q[0], q[1]);\n  M(b, b, t);\n  M(c, p[3], q[3]);\n  M(c, c, D2);\n  M(d, p[2], q[2]);\n  A(d, d, d);\n  Z(e, b, a);\n  Z(f, d, c);\n  A(g, d, c);\n  A(h, b, a);\n\n  M(p[0], e, f);\n  M(p[1], h, g);\n  M(p[2], g, f);\n  M(p[3], e, h);\n}\n\nfunction cswap(p, q, b) {\n  var i;\n  for (i = 0; i < 4; i++) {\n    sel25519(p[i], q[i], b);\n  }\n}\n\nfunction pack(r, p) {\n  var tx = gf(), ty = gf(), zi = gf();\n  inv25519(zi, p[2]);\n  M(tx, p[0], zi);\n  M(ty, p[1], zi);\n  pack25519(r, ty);\n  r[31] ^= par25519(tx) << 7;\n}\n\nfunction scalarmult(p, q, s) {\n  var b, i;\n  set25519(p[0], gf0);\n  set25519(p[1], gf1);\n  set25519(p[2], gf1);\n  set25519(p[3], gf0);\n  for (i = 255; i >= 0; --i) {\n    b = (s[(i/8)|0] >> (i&7)) & 1;\n    cswap(p, q, b);\n    add(q, p);\n    add(p, p);\n    cswap(p, q, b);\n  }\n}\n\nfunction scalarbase(p, s) {\n  var q = [gf(), gf(), gf(), gf()];\n  set25519(q[0], X);\n  set25519(q[1], Y);\n  set25519(q[2], gf1);\n  M(q[3], X, Y);\n  scalarmult(p, q, s);\n}\n\nfunction crypto_sign_keypair(pk, sk, seeded) {\n  var d = new Uint8Array(64);\n  var p = [gf(), gf(), gf(), gf()];\n  var i;\n\n  if (!seeded) randombytes(sk, 32);\n  crypto_hash(d, sk, 32);\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  scalarbase(p, d);\n  pack(pk, p);\n\n  for (i = 0; i < 32; i++) sk[i+32] = pk[i];\n  return 0;\n}\n\nvar L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);\n\nfunction modL(r, x) {\n  var carry, i, j, k;\n  for (i = 63; i >= 32; --i) {\n    carry = 0;\n    for (j = i - 32, k = i - 12; j < k; ++j) {\n      x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n      carry = (x[j] + 128) >> 8;\n      x[j] -= carry * 256;\n    }\n    x[j] += carry;\n    x[i] = 0;\n  }\n  carry = 0;\n  for (j = 0; j < 32; j++) {\n    x[j] += carry - (x[31] >> 4) * L[j];\n    carry = x[j] >> 8;\n    x[j] &= 255;\n  }\n  for (j = 0; j < 32; j++) x[j] -= carry * L[j];\n  for (i = 0; i < 32; i++) {\n    x[i+1] += x[i] >> 8;\n    r[i] = x[i] & 255;\n  }\n}\n\nfunction reduce(r) {\n  var x = new Float64Array(64), i;\n  for (i = 0; i < 64; i++) x[i] = r[i];\n  for (i = 0; i < 64; i++) r[i] = 0;\n  modL(r, x);\n}\n\n// Note: difference from C - smlen returned, not passed as argument.\nfunction crypto_sign(sm, m, n, sk) {\n  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);\n  var i, j, x = new Float64Array(64);\n  var p = [gf(), gf(), gf(), gf()];\n\n  crypto_hash(d, sk, 32);\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  var smlen = n + 64;\n  for (i = 0; i < n; i++) sm[64 + i] = m[i];\n  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];\n\n  crypto_hash(r, sm.subarray(32), n+32);\n  reduce(r);\n  scalarbase(p, r);\n  pack(sm, p);\n\n  for (i = 32; i < 64; i++) sm[i] = sk[i];\n  crypto_hash(h, sm, n + 64);\n  reduce(h);\n\n  for (i = 0; i < 64; i++) x[i] = 0;\n  for (i = 0; i < 32; i++) x[i] = r[i];\n  for (i = 0; i < 32; i++) {\n    for (j = 0; j < 32; j++) {\n      x[i+j] += h[i] * d[j];\n    }\n  }\n\n  modL(sm.subarray(32), x);\n  return smlen;\n}\n\nfunction unpackneg(r, p) {\n  var t = gf(), chk = gf(), num = gf(),\n      den = gf(), den2 = gf(), den4 = gf(),\n      den6 = gf();\n\n  set25519(r[2], gf1);\n  unpack25519(r[1], p);\n  S(num, r[1]);\n  M(den, num, D);\n  Z(num, num, r[2]);\n  A(den, r[2], den);\n\n  S(den2, den);\n  S(den4, den2);\n  M(den6, den4, den2);\n  M(t, den6, num);\n  M(t, t, den);\n\n  pow2523(t, t);\n  M(t, t, num);\n  M(t, t, den);\n  M(t, t, den);\n  M(r[0], t, den);\n\n  S(chk, r[0]);\n  M(chk, chk, den);\n  if (neq25519(chk, num)) M(r[0], r[0], I);\n\n  S(chk, r[0]);\n  M(chk, chk, den);\n  if (neq25519(chk, num)) return -1;\n\n  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);\n\n  M(r[3], r[0], r[1]);\n  return 0;\n}\n\nfunction crypto_sign_open(m, sm, n, pk) {\n  var i, mlen;\n  var t = new Uint8Array(32), h = new Uint8Array(64);\n  var p = [gf(), gf(), gf(), gf()],\n      q = [gf(), gf(), gf(), gf()];\n\n  mlen = -1;\n  if (n < 64) return -1;\n\n  if (unpackneg(q, pk)) return -1;\n\n  for (i = 0; i < n; i++) m[i] = sm[i];\n  for (i = 0; i < 32; i++) m[i+32] = pk[i];\n  crypto_hash(h, m, n);\n  reduce(h);\n  scalarmult(p, q, h);\n\n  scalarbase(q, sm.subarray(32));\n  add(p, q);\n  pack(t, p);\n\n  n -= 64;\n  if (crypto_verify_32(sm, 0, t, 0)) {\n    for (i = 0; i < n; i++) m[i] = 0;\n    return -1;\n  }\n\n  for (i = 0; i < n; i++) m[i] = sm[i + 64];\n  mlen = n;\n  return mlen;\n}\n\nvar crypto_secretbox_KEYBYTES = 32,\n    crypto_secretbox_NONCEBYTES = 24,\n    crypto_secretbox_ZEROBYTES = 32,\n    crypto_secretbox_BOXZEROBYTES = 16,\n    crypto_scalarmult_BYTES = 32,\n    crypto_scalarmult_SCALARBYTES = 32,\n    crypto_box_PUBLICKEYBYTES = 32,\n    crypto_box_SECRETKEYBYTES = 32,\n    crypto_box_BEFORENMBYTES = 32,\n    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,\n    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,\n    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,\n    crypto_sign_BYTES = 64,\n    crypto_sign_PUBLICKEYBYTES = 32,\n    crypto_sign_SECRETKEYBYTES = 64,\n    crypto_sign_SEEDBYTES = 32,\n    crypto_hash_BYTES = 64;\n\nnacl.lowlevel = {\n  crypto_core_hsalsa20: crypto_core_hsalsa20,\n  crypto_stream_xor : crypto_stream_xor,\n  crypto_stream : crypto_stream,\n  crypto_stream_salsa20_xor : crypto_stream_salsa20_xor,\n  crypto_stream_salsa20 : crypto_stream_salsa20,\n  crypto_onetimeauth : crypto_onetimeauth,\n  crypto_onetimeauth_verify : crypto_onetimeauth_verify,\n  crypto_verify_16 : crypto_verify_16,\n  crypto_verify_32 : crypto_verify_32,\n  crypto_secretbox : crypto_secretbox,\n  crypto_secretbox_open : crypto_secretbox_open,\n  crypto_scalarmult : crypto_scalarmult,\n  crypto_scalarmult_base : crypto_scalarmult_base,\n  crypto_box_beforenm : crypto_box_beforenm,\n  crypto_box_afternm : crypto_box_afternm,\n  crypto_box : crypto_box,\n  crypto_box_open : crypto_box_open,\n  crypto_box_keypair : crypto_box_keypair,\n  crypto_hash : crypto_hash,\n  crypto_sign : crypto_sign,\n  crypto_sign_keypair : crypto_sign_keypair,\n  crypto_sign_open : crypto_sign_open,\n\n  crypto_secretbox_KEYBYTES : crypto_secretbox_KEYBYTES,\n  crypto_secretbox_NONCEBYTES : crypto_secretbox_NONCEBYTES,\n  crypto_secretbox_ZEROBYTES : crypto_secretbox_ZEROBYTES,\n  crypto_secretbox_BOXZEROBYTES : crypto_secretbox_BOXZEROBYTES,\n  crypto_scalarmult_BYTES : crypto_scalarmult_BYTES,\n  crypto_scalarmult_SCALARBYTES : crypto_scalarmult_SCALARBYTES,\n  crypto_box_PUBLICKEYBYTES : crypto_box_PUBLICKEYBYTES,\n  crypto_box_SECRETKEYBYTES : crypto_box_SECRETKEYBYTES,\n  crypto_box_BEFORENMBYTES : crypto_box_BEFORENMBYTES,\n  crypto_box_NONCEBYTES : crypto_box_NONCEBYTES,\n  crypto_box_ZEROBYTES : crypto_box_ZEROBYTES,\n  crypto_box_BOXZEROBYTES : crypto_box_BOXZEROBYTES,\n  crypto_sign_BYTES : crypto_sign_BYTES,\n  crypto_sign_PUBLICKEYBYTES : crypto_sign_PUBLICKEYBYTES,\n  crypto_sign_SECRETKEYBYTES : crypto_sign_SECRETKEYBYTES,\n  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,\n  crypto_hash_BYTES : crypto_hash_BYTES\n};\n\n/* High-level API */\n\nfunction checkLengths(k, n) {\n  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');\n  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');\n}\n\nfunction checkBoxLengths(pk, sk) {\n  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');\n  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');\n}\n\nfunction checkArrayTypes() {\n  var type = {}.toString, t;\n  for (var i = 0; i < arguments.length; i++) {\n     if ((t = type.call(arguments[i])) !== '[object Uint8Array]')\n       throw new TypeError('unexpected type ' + t + ', use Uint8Array');\n  }\n}\n\nnacl.util = {};\n\nnacl.util.decodeUTF8 = function(s) {\n  var i, d = unescape(encodeURIComponent(s)), b = new Uint8Array(d.length);\n  for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);\n  return b;\n};\n\nnacl.util.encodeUTF8 = function(arr) {\n  var i, s = [];\n  for (i = 0; i < arr.length; i++) s.push(String.fromCharCode(arr[i]));\n  return decodeURIComponent(escape(s.join('')));\n};\n\nnacl.util.encodeBase64 = function(arr) {\n  if (typeof btoa === 'undefined') {\n    return (new Buffer(arr)).toString('base64');\n  } else {\n    var i, s = [], len = arr.length;\n    for (i = 0; i < len; i++) s.push(String.fromCharCode(arr[i]));\n    return btoa(s.join(''));\n  }\n};\n\nnacl.util.decodeBase64 = function(s) {\n  if (typeof atob === 'undefined') {\n    return new Uint8Array(Array.prototype.slice.call(new Buffer(s, 'base64'), 0));\n  } else {\n    var i, d = atob(s), b = new Uint8Array(d.length);\n    for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);\n    return b;\n  }\n};\n\nnacl.randomBytes = function(n) {\n  var b = new Uint8Array(n);\n  randombytes(b, n);\n  return b;\n};\n\nnacl.secretbox = function(msg, nonce, key) {\n  checkArrayTypes(msg, nonce, key);\n  checkLengths(key, nonce);\n  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);\n  var c = new Uint8Array(m.length);\n  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];\n  crypto_secretbox(c, m, m.length, nonce, key);\n  return c.subarray(crypto_secretbox_BOXZEROBYTES);\n};\n\nnacl.secretbox.open = function(box, nonce, key) {\n  checkArrayTypes(box, nonce, key);\n  checkLengths(key, nonce);\n  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);\n  var m = new Uint8Array(c.length);\n  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];\n  if (c.length < 32) return false;\n  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return false;\n  return m.subarray(crypto_secretbox_ZEROBYTES);\n};\n\nnacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;\nnacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;\nnacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;\n\nnacl.scalarMult = function(n, p) {\n  checkArrayTypes(n, p);\n  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');\n  var q = new Uint8Array(crypto_scalarmult_BYTES);\n  crypto_scalarmult(q, n, p);\n  return q;\n};\n\nnacl.scalarMult.base = function(n) {\n  checkArrayTypes(n);\n  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n  var q = new Uint8Array(crypto_scalarmult_BYTES);\n  crypto_scalarmult_base(q, n);\n  return q;\n};\n\nnacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;\nnacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;\n\nnacl.box = function(msg, nonce, publicKey, secretKey) {\n  var k = nacl.box.before(publicKey, secretKey);\n  return nacl.secretbox(msg, nonce, k);\n};\n\nnacl.box.before = function(publicKey, secretKey) {\n  checkArrayTypes(publicKey, secretKey);\n  checkBoxLengths(publicKey, secretKey);\n  var k = new Uint8Array(crypto_box_BEFORENMBYTES);\n  crypto_box_beforenm(k, publicKey, secretKey);\n  return k;\n};\n\nnacl.box.after = nacl.secretbox;\n\nnacl.box.open = function(msg, nonce, publicKey, secretKey) {\n  var k = nacl.box.before(publicKey, secretKey);\n  return nacl.secretbox.open(msg, nonce, k);\n};\n\nnacl.box.open.after = nacl.secretbox.open;\n\nnacl.box.keyPair = function() {\n  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);\n  crypto_box_keypair(pk, sk);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.box.keyPair.fromSecretKey = function(secretKey) {\n  checkArrayTypes(secretKey);\n  if (secretKey.length !== crypto_box_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n  crypto_scalarmult_base(pk, secretKey);\n  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};\n};\n\nnacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;\nnacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;\nnacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;\nnacl.box.nonceLength = crypto_box_NONCEBYTES;\nnacl.box.overheadLength = nacl.secretbox.overheadLength;\n\nnacl.sign = function(msg, secretKey) {\n  checkArrayTypes(msg, secretKey);\n  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);\n  crypto_sign(signedMsg, msg, msg.length, secretKey);\n  return signedMsg;\n};\n\nnacl.sign.open = function(signedMsg, publicKey) {\n  if (arguments.length !== 2)\n    throw new Error('nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?');\n  checkArrayTypes(signedMsg, publicKey);\n  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)\n    throw new Error('bad public key size');\n  var tmp = new Uint8Array(signedMsg.length);\n  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);\n  if (mlen < 0) return null;\n  var m = new Uint8Array(mlen);\n  for (var i = 0; i < m.length; i++) m[i] = tmp[i];\n  return m;\n};\n\nnacl.sign.detached = function(msg, secretKey) {\n  var signedMsg = nacl.sign(msg, secretKey);\n  var sig = new Uint8Array(crypto_sign_BYTES);\n  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];\n  return sig;\n};\n\nnacl.sign.detached.verify = function(msg, sig, publicKey) {\n  checkArrayTypes(msg, sig, publicKey);\n  if (sig.length !== crypto_sign_BYTES)\n    throw new Error('bad signature size');\n  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)\n    throw new Error('bad public key size');\n  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);\n  var m = new Uint8Array(crypto_sign_BYTES + msg.length);\n  var i;\n  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];\n  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];\n  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);\n};\n\nnacl.sign.keyPair = function() {\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n  crypto_sign_keypair(pk, sk);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.sign.keyPair.fromSecretKey = function(secretKey) {\n  checkArrayTypes(secretKey);\n  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];\n  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};\n};\n\nnacl.sign.keyPair.fromSeed = function(seed) {\n  checkArrayTypes(seed);\n  if (seed.length !== crypto_sign_SEEDBYTES)\n    throw new Error('bad seed size');\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n  for (var i = 0; i < 32; i++) sk[i] = seed[i];\n  crypto_sign_keypair(pk, sk, true);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;\nnacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;\nnacl.sign.seedLength = crypto_sign_SEEDBYTES;\nnacl.sign.signatureLength = crypto_sign_BYTES;\n\nnacl.hash = function(msg) {\n  checkArrayTypes(msg);\n  var h = new Uint8Array(crypto_hash_BYTES);\n  crypto_hash(h, msg, msg.length);\n  return h;\n};\n\nnacl.hash.hashLength = crypto_hash_BYTES;\n\nnacl.verify = function(x, y) {\n  checkArrayTypes(x, y);\n  // Zero length arguments are considered not equal.\n  if (x.length === 0 || y.length === 0) return false;\n  if (x.length !== y.length) return false;\n  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;\n};\n\nnacl.setPRNG = function(fn) {\n  randombytes = fn;\n};\n\n(function() {\n  // Initialize PRNG if environment provides CSPRNG.\n  // If not, methods calling randombytes will throw.\n  var crypto;\n  if (typeof window !== 'undefined') {\n    // Browser.\n    if (window.crypto && window.crypto.getRandomValues) {\n      crypto = window.crypto; // Standard\n    } else if (window.msCrypto && window.msCrypto.getRandomValues) {\n      crypto = window.msCrypto; // Internet Explorer 11+\n    }\n    if (crypto) {\n      nacl.setPRNG(function(x, n) {\n        var i, v = new Uint8Array(n);\n        crypto.getRandomValues(v);\n        for (i = 0; i < n; i++) x[i] = v[i];\n      });\n    }\n  } else if (typeof require !== 'undefined') {\n    // Node.js.\n    crypto = require('crypto');\n    if (crypto) {\n      nacl.setPRNG(function(x, n) {\n        var i, v = crypto.randomBytes(n);\n        for (i = 0; i < n; i++) x[i] = v[i];\n      });\n    }\n  }\n})();\n\n})(typeof module !== 'undefined' && module.exports ? module.exports : (window.nacl = window.nacl || {}));\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":80,\"crypto\":86}],202:[function(require,module,exports){\nmodule.exports={\n  \"name\": \"kbpgp\",\n  \"description\": \"Keybase's PGP Implementation\",\n  \"keywords\": [\n    \"crypto\",\n    \"pgp\",\n    \"keybase\"\n  ],\n  \"author\": \"Maxwell Krohn\",\n  \"version\": \"2.0.9\",\n  \"license\": \"BSD-3-Clause\",\n  \"main\": \"./lib/main.js\",\n  \"directories\": {\n    \"lib\": \"lib/\"\n  },\n  \"homepage\": \"http://github.com/keybase/kbpgp\",\n  \"bugs\": \"https://github.com/keybase/kbpgp/issues\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/keybase/kbpgp.git\"\n  },\n  \"dependencies\": {\n    \"bn\": \"^1.0.0\",\n    \"deep-equal\": \">=0.2.1\",\n    \"iced-error\": \">=0.0.9\",\n    \"iced-runtime\": \">=0.0.1\",\n    \"keybase-compressjs\": \"^1.0.1-c\",\n    \"keybase-ecurve\": \"^1.0.0\",\n    \"pgp-utils\": \">=0.0.28\",\n    \"purepack\": \">=1.0.1\",\n    \"triplesec\": \">=3.0.19\",\n    \"tweetnacl\": \"^0.12.2\"\n  },\n  \"devDependencies\": {\n    \"browserify\": \"^5.9.1\",\n    \"colors\": \"0.6.2\",\n    \"iced-coffee-script\": \"1.7.1-c\",\n    \"iced-test\": \">=0.0.21\",\n    \"icsify\": \"0.6.0\",\n    \"minimist\": \"0.0.8\",\n    \"optimist\": \"0.6.1\",\n    \"uglify-js\": \"^2.4.13\"\n  }\n}\n},{}]},{},[29])(29)\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/kbpgp.js\n// module id = 5\n// module chunks = 0","var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\n// On some exotic environments, it's not clear which object `setimmeidate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/timers-browserify/main.js\n// module id = 6\n// module chunks = 0","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/setimmediate/setImmediate.js\n// module id = 7\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 8\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/url/url.js\n// module id = 9\n// module chunks = 0","/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/punycode/punycode.js\n// module id = 10\n// module chunks = 0","'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/url/util.js\n// module id = 11\n// module chunks = 0","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/querystring-es3/index.js\n// module id = 12\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/querystring-es3/decode.js\n// module id = 13\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/querystring-es3/encode.js\n// module id = 14\n// module chunks = 0","/**\n * Root reference for iframes.\n */\n\nvar root;\nif (typeof window !== 'undefined') { // Browser window\n  root = window;\n} else if (typeof self !== 'undefined') { // Web Worker\n  root = self;\n} else { // Other environments\n  console.warn(\"Using browser-only version of superagent in non-browser environment\");\n  root = this;\n}\n\nvar Emitter = require('component-emitter');\nvar RequestBase = require('./request-base');\nvar isObject = require('./is-object');\nvar ResponseBase = require('./response-base');\nvar shouldRetry = require('./should-retry');\n\n/**\n * Noop.\n */\n\nfunction noop(){};\n\n/**\n * Expose `request`.\n */\n\nvar request = exports = module.exports = function(method, url) {\n  // callback\n  if ('function' == typeof url) {\n    return new exports.Request('GET', method).end(url);\n  }\n\n  // url first\n  if (1 == arguments.length) {\n    return new exports.Request('GET', method);\n  }\n\n  return new exports.Request(method, url);\n}\n\nexports.Request = Request;\n\n/**\n * Determine XHR.\n */\n\nrequest.getXHR = function () {\n  if (root.XMLHttpRequest\n      && (!root.location || 'file:' != root.location.protocol\n          || !root.ActiveXObject)) {\n    return new XMLHttpRequest;\n  } else {\n    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n  }\n  throw Error(\"Browser-only version of superagent could not find XHR\");\n};\n\n/**\n * Removes leading and trailing whitespace, added to support IE.\n *\n * @param {String} s\n * @return {String}\n * @api private\n */\n\nvar trim = ''.trim\n  ? function(s) { return s.trim(); }\n  : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n\n/**\n * Serialize the given `obj`.\n *\n * @param {Object} obj\n * @return {String}\n * @api private\n */\n\nfunction serialize(obj) {\n  if (!isObject(obj)) return obj;\n  var pairs = [];\n  for (var key in obj) {\n    pushEncodedKeyValuePair(pairs, key, obj[key]);\n  }\n  return pairs.join('&');\n}\n\n/**\n * Helps 'serialize' with serializing arrays.\n * Mutates the pairs array.\n *\n * @param {Array} pairs\n * @param {String} key\n * @param {Mixed} val\n */\n\nfunction pushEncodedKeyValuePair(pairs, key, val) {\n  if (val != null) {\n    if (Array.isArray(val)) {\n      val.forEach(function(v) {\n        pushEncodedKeyValuePair(pairs, key, v);\n      });\n    } else if (isObject(val)) {\n      for(var subkey in val) {\n        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);\n      }\n    } else {\n      pairs.push(encodeURIComponent(key)\n        + '=' + encodeURIComponent(val));\n    }\n  } else if (val === null) {\n    pairs.push(encodeURIComponent(key));\n  }\n}\n\n/**\n * Expose serialization method.\n */\n\n request.serializeObject = serialize;\n\n /**\n  * Parse the given x-www-form-urlencoded `str`.\n  *\n  * @param {String} str\n  * @return {Object}\n  * @api private\n  */\n\nfunction parseString(str) {\n  var obj = {};\n  var pairs = str.split('&');\n  var pair;\n  var pos;\n\n  for (var i = 0, len = pairs.length; i < len; ++i) {\n    pair = pairs[i];\n    pos = pair.indexOf('=');\n    if (pos == -1) {\n      obj[decodeURIComponent(pair)] = '';\n    } else {\n      obj[decodeURIComponent(pair.slice(0, pos))] =\n        decodeURIComponent(pair.slice(pos + 1));\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Expose parser.\n */\n\nrequest.parseString = parseString;\n\n/**\n * Default MIME type map.\n *\n *     superagent.types.xml = 'application/xml';\n *\n */\n\nrequest.types = {\n  html: 'text/html',\n  json: 'application/json',\n  xml: 'text/xml',\n  urlencoded: 'application/x-www-form-urlencoded',\n  'form': 'application/x-www-form-urlencoded',\n  'form-data': 'application/x-www-form-urlencoded'\n};\n\n/**\n * Default serialization map.\n *\n *     superagent.serialize['application/xml'] = function(obj){\n *       return 'generated xml here';\n *     };\n *\n */\n\n request.serialize = {\n   'application/x-www-form-urlencoded': serialize,\n   'application/json': JSON.stringify\n };\n\n /**\n  * Default parsers.\n  *\n  *     superagent.parse['application/xml'] = function(str){\n  *       return { object parsed from str };\n  *     };\n  *\n  */\n\nrequest.parse = {\n  'application/x-www-form-urlencoded': parseString,\n  'application/json': JSON.parse\n};\n\n/**\n * Parse the given header `str` into\n * an object containing the mapped fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction parseHeader(str) {\n  var lines = str.split(/\\r?\\n/);\n  var fields = {};\n  var index;\n  var line;\n  var field;\n  var val;\n\n  lines.pop(); // trailing CRLF\n\n  for (var i = 0, len = lines.length; i < len; ++i) {\n    line = lines[i];\n    index = line.indexOf(':');\n    field = line.slice(0, index).toLowerCase();\n    val = trim(line.slice(index + 1));\n    fields[field] = val;\n  }\n\n  return fields;\n}\n\n/**\n * Check if `mime` is json or has +json structured syntax suffix.\n *\n * @param {String} mime\n * @return {Boolean}\n * @api private\n */\n\nfunction isJSON(mime) {\n  return /[\\/+]json\\b/.test(mime);\n}\n\n/**\n * Initialize a new `Response` with the given `xhr`.\n *\n *  - set flags (.ok, .error, etc)\n *  - parse header\n *\n * Examples:\n *\n *  Aliasing `superagent` as `request` is nice:\n *\n *      request = superagent;\n *\n *  We can use the promise-like API, or pass callbacks:\n *\n *      request.get('/').end(function(res){});\n *      request.get('/', function(res){});\n *\n *  Sending data can be chained:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' })\n *        .end(function(res){});\n *\n *  Or passed to `.send()`:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' }, function(res){});\n *\n *  Or passed to `.post()`:\n *\n *      request\n *        .post('/user', { name: 'tj' })\n *        .end(function(res){});\n *\n * Or further reduced to a single call for simple cases:\n *\n *      request\n *        .post('/user', { name: 'tj' }, function(res){});\n *\n * @param {XMLHTTPRequest} xhr\n * @param {Object} options\n * @api private\n */\n\nfunction Response(req) {\n  this.req = req;\n  this.xhr = this.req.xhr;\n  // responseText is accessible only if responseType is '' or 'text' and on older browsers\n  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n     ? this.xhr.responseText\n     : null;\n  this.statusText = this.req.xhr.statusText;\n  var status = this.xhr.status;\n  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n  if (status === 1223) {\n      status = 204;\n  }\n  this._setStatusProperties(status);\n  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n  // getResponseHeader still works. so we get content-type even if getting\n  // other headers fails.\n  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n  this._setHeaderProperties(this.header);\n\n  if (null === this.text && req._responseType) {\n    this.body = this.xhr.response;\n  } else {\n    this.body = this.req.method != 'HEAD'\n      ? this._parseBody(this.text ? this.text : this.xhr.response)\n      : null;\n  }\n}\n\nResponseBase(Response.prototype);\n\n/**\n * Parse the given body `str`.\n *\n * Used for auto-parsing of bodies. Parsers\n * are defined on the `superagent.parse` object.\n *\n * @param {String} str\n * @return {Mixed}\n * @api private\n */\n\nResponse.prototype._parseBody = function(str){\n  var parse = request.parse[this.type];\n  if(this.req._parser) {\n    return this.req._parser(this, str);\n  }\n  if (!parse && isJSON(this.type)) {\n    parse = request.parse['application/json'];\n  }\n  return parse && str && (str.length || str instanceof Object)\n    ? parse(str)\n    : null;\n};\n\n/**\n * Return an `Error` representative of this response.\n *\n * @return {Error}\n * @api public\n */\n\nResponse.prototype.toError = function(){\n  var req = this.req;\n  var method = req.method;\n  var url = req.url;\n\n  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n  var err = new Error(msg);\n  err.status = this.status;\n  err.method = method;\n  err.url = url;\n\n  return err;\n};\n\n/**\n * Expose `Response`.\n */\n\nrequest.Response = Response;\n\n/**\n * Initialize a new `Request` with the given `method` and `url`.\n *\n * @param {String} method\n * @param {String} url\n * @api public\n */\n\nfunction Request(method, url) {\n  var self = this;\n  this._query = this._query || [];\n  this.method = method;\n  this.url = url;\n  this.header = {}; // preserves header name case\n  this._header = {}; // coerces header names to lowercase\n  this.on('end', function(){\n    var err = null;\n    var res = null;\n\n    try {\n      res = new Response(self);\n    } catch(e) {\n      err = new Error('Parser is unable to parse the response');\n      err.parse = true;\n      err.original = e;\n      // issue #675: return the raw response if the response parsing fails\n      if (self.xhr) {\n        // ie9 doesn't have 'response' property\n        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;\n        // issue #876: return the http status code if the response parsing fails\n        err.status = self.xhr.status ? self.xhr.status : null;\n        err.statusCode = err.status; // backwards-compat only\n      } else {\n        err.rawResponse = null;\n        err.status = null;\n      }\n\n      return self.callback(err);\n    }\n\n    self.emit('response', res);\n\n    var new_err;\n    try {\n      if (!self._isResponseOK(res)) {\n        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n        new_err.original = err;\n        new_err.response = res;\n        new_err.status = res.status;\n      }\n    } catch(e) {\n      new_err = e; // #985 touching res may cause INVALID_STATE_ERR on old Android\n    }\n\n    // #1000 don't catch errors from the callback to avoid double calling it\n    if (new_err) {\n      self.callback(new_err, res);\n    } else {\n      self.callback(null, res);\n    }\n  });\n}\n\n/**\n * Mixin `Emitter` and `RequestBase`.\n */\n\nEmitter(Request.prototype);\nRequestBase(Request.prototype);\n\n/**\n * Set Content-Type to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.xml = 'application/xml';\n *\n *      request.post('/')\n *        .type('xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n *      request.post('/')\n *        .type('application/xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n * @param {String} type\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.type = function(type){\n  this.set('Content-Type', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Accept to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.json = 'application/json';\n *\n *      request.get('/agent')\n *        .accept('json')\n *        .end(callback);\n *\n *      request.get('/agent')\n *        .accept('application/json')\n *        .end(callback);\n *\n * @param {String} accept\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.accept = function(type){\n  this.set('Accept', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Authorization field value with `user` and `pass`.\n *\n * @param {String} user\n * @param {String} [pass] optional in case of using 'bearer' as type\n * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.auth = function(user, pass, options){\n  if (typeof pass === 'object' && pass !== null) { // pass is optional and can substitute for options\n    options = pass;\n  }\n  if (!options) {\n    options = {\n      type: 'function' === typeof btoa ? 'basic' : 'auto',\n    }\n  }\n\n  switch (options.type) {\n    case 'basic':\n      this.set('Authorization', 'Basic ' + btoa(user + ':' + pass));\n    break;\n\n    case 'auto':\n      this.username = user;\n      this.password = pass;\n    break;\n\n    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })\n      this.set('Authorization', 'Bearer ' + user);\n    break;\n  }\n  return this;\n};\n\n/**\n * Add query-string `val`.\n *\n * Examples:\n *\n *   request.get('/shoes')\n *     .query('size=10')\n *     .query({ color: 'blue' })\n *\n * @param {Object|String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.query = function(val){\n  if ('string' != typeof val) val = serialize(val);\n  if (val) this._query.push(val);\n  return this;\n};\n\n/**\n * Queue the given `file` as an attachment to the specified `field`,\n * with optional `options` (or filename).\n *\n * ``` js\n * request.post('/upload')\n *   .attach('content', new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n *   .end(callback);\n * ```\n *\n * @param {String} field\n * @param {Blob|File} file\n * @param {String|Object} options\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.attach = function(field, file, options){\n  if (file) {\n    if (this._data) {\n      throw Error(\"superagent can't mix .send() and .attach()\");\n    }\n\n    this._getFormData().append(field, file, options || file.name);\n  }\n  return this;\n};\n\nRequest.prototype._getFormData = function(){\n  if (!this._formData) {\n    this._formData = new root.FormData();\n  }\n  return this._formData;\n};\n\n/**\n * Invoke the callback with `err` and `res`\n * and handle arity check.\n *\n * @param {Error} err\n * @param {Response} res\n * @api private\n */\n\nRequest.prototype.callback = function(err, res){\n  // console.log(this._retries, this._maxRetries)\n  if (this._maxRetries && this._retries++ < this._maxRetries && shouldRetry(err, res)) {\n    return this._retry();\n  }\n\n  var fn = this._callback;\n  this.clearTimeout();\n\n  if (err) {\n    if (this._maxRetries) err.retries = this._retries - 1;\n    this.emit('error', err);\n  }\n\n  fn(err, res);\n};\n\n/**\n * Invoke callback with x-domain error.\n *\n * @api private\n */\n\nRequest.prototype.crossDomainError = function(){\n  var err = new Error('Request has been terminated\\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');\n  err.crossDomain = true;\n\n  err.status = this.status;\n  err.method = this.method;\n  err.url = this.url;\n\n  this.callback(err);\n};\n\n// This only warns, because the request is still likely to work\nRequest.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){\n  console.warn(\"This is not supported in browser version of superagent\");\n  return this;\n};\n\n// This throws, because it can't send/receive data as expected\nRequest.prototype.pipe = Request.prototype.write = function(){\n  throw Error(\"Streaming is not supported in browser version of superagent\");\n};\n\n/**\n * Check if `obj` is a host object,\n * we don't want to serialize these :)\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\nRequest.prototype._isHost = function _isHost(obj) {\n  // Native objects stringify to [object File], [object Blob], [object FormData], etc.\n  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';\n}\n\n/**\n * Initiate request, invoking callback `fn(res)`\n * with an instanceof `Response`.\n *\n * @param {Function} fn\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.end = function(fn){\n  if (this._endCalled) {\n    console.warn(\"Warning: .end() was called twice. This is not supported in superagent\");\n  }\n  this._endCalled = true;\n\n  // store callback\n  this._callback = fn || noop;\n\n  // querystring\n  this._finalizeQueryString();\n\n  return this._end();\n};\n\nRequest.prototype._end = function() {\n  var self = this;\n  var xhr = this.xhr = request.getXHR();\n  var data = this._formData || this._data;\n\n  this._setTimeouts();\n\n  // state change\n  xhr.onreadystatechange = function(){\n    var readyState = xhr.readyState;\n    if (readyState >= 2 && self._responseTimeoutTimer) {\n      clearTimeout(self._responseTimeoutTimer);\n    }\n    if (4 != readyState) {\n      return;\n    }\n\n    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n    // result in the error \"Could not complete the operation due to error c00c023f\"\n    var status;\n    try { status = xhr.status } catch(e) { status = 0; }\n\n    if (!status) {\n      if (self.timedout || self._aborted) return;\n      return self.crossDomainError();\n    }\n    self.emit('end');\n  };\n\n  // progress\n  var handleProgress = function(direction, e) {\n    if (e.total > 0) {\n      e.percent = e.loaded / e.total * 100;\n    }\n    e.direction = direction;\n    self.emit('progress', e);\n  }\n  if (this.hasListeners('progress')) {\n    try {\n      xhr.onprogress = handleProgress.bind(null, 'download');\n      if (xhr.upload) {\n        xhr.upload.onprogress = handleProgress.bind(null, 'upload');\n      }\n    } catch(e) {\n      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n      // Reported here:\n      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n    }\n  }\n\n  // initiate request\n  try {\n    if (this.username && this.password) {\n      xhr.open(this.method, this.url, true, this.username, this.password);\n    } else {\n      xhr.open(this.method, this.url, true);\n    }\n  } catch (err) {\n    // see #1149\n    return this.callback(err);\n  }\n\n  // CORS\n  if (this._withCredentials) xhr.withCredentials = true;\n\n  // body\n  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {\n    // serialize stuff\n    var contentType = this._header['content-type'];\n    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];\n    if (!serialize && isJSON(contentType)) {\n      serialize = request.serialize['application/json'];\n    }\n    if (serialize) data = serialize(data);\n  }\n\n  // set header fields\n  for (var field in this.header) {\n    if (null == this.header[field]) continue;\n\n    if (this.header.hasOwnProperty(field))\n      xhr.setRequestHeader(field, this.header[field]);\n  }\n\n  if (this._responseType) {\n    xhr.responseType = this._responseType;\n  }\n\n  // send stuff\n  this.emit('request', this);\n\n  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)\n  // We need null here if data is undefined\n  xhr.send(typeof data !== 'undefined' ? data : null);\n  return this;\n};\n\n/**\n * GET `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.get = function(url, data, fn){\n  var req = request('GET', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * HEAD `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.head = function(url, data, fn){\n  var req = request('HEAD', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * OPTIONS query to `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.options = function(url, data, fn){\n  var req = request('OPTIONS', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * DELETE `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} [data]\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nfunction del(url, data, fn){\n  var req = request('DELETE', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\nrequest['del'] = del;\nrequest['delete'] = del;\n\n/**\n * PATCH `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} [data]\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.patch = function(url, data, fn){\n  var req = request('PATCH', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * POST `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} [data]\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.post = function(url, data, fn){\n  var req = request('POST', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PUT `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.put = function(url, data, fn){\n  var req = request('PUT', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/superagent/lib/client.js\n// module id = 15\n// module chunks = 0","\r\n/**\r\n * Expose `Emitter`.\r\n */\r\n\r\nif (typeof module !== 'undefined') {\r\n  module.exports = Emitter;\r\n}\r\n\r\n/**\r\n * Initialize a new `Emitter`.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Emitter(obj) {\r\n  if (obj) return mixin(obj);\r\n};\r\n\r\n/**\r\n * Mixin the emitter properties.\r\n *\r\n * @param {Object} obj\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction mixin(obj) {\r\n  for (var key in Emitter.prototype) {\r\n    obj[key] = Emitter.prototype[key];\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Listen on the given `event` with `fn`.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.on =\r\nEmitter.prototype.addEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n    .push(fn);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds an `event` listener that will be invoked a single\r\n * time then automatically removed.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.once = function(event, fn){\r\n  function on() {\r\n    this.off(event, on);\r\n    fn.apply(this, arguments);\r\n  }\r\n\r\n  on.fn = fn;\r\n  this.on(event, on);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove the given callback for `event` or all\r\n * registered callbacks.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.off =\r\nEmitter.prototype.removeListener =\r\nEmitter.prototype.removeAllListeners =\r\nEmitter.prototype.removeEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  // all\r\n  if (0 == arguments.length) {\r\n    this._callbacks = {};\r\n    return this;\r\n  }\r\n\r\n  // specific event\r\n  var callbacks = this._callbacks['$' + event];\r\n  if (!callbacks) return this;\r\n\r\n  // remove all handlers\r\n  if (1 == arguments.length) {\r\n    delete this._callbacks['$' + event];\r\n    return this;\r\n  }\r\n\r\n  // remove specific handler\r\n  var cb;\r\n  for (var i = 0; i < callbacks.length; i++) {\r\n    cb = callbacks[i];\r\n    if (cb === fn || cb.fn === fn) {\r\n      callbacks.splice(i, 1);\r\n      break;\r\n    }\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Emit `event` with the given args.\r\n *\r\n * @param {String} event\r\n * @param {Mixed} ...\r\n * @return {Emitter}\r\n */\r\n\r\nEmitter.prototype.emit = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  var args = [].slice.call(arguments, 1)\r\n    , callbacks = this._callbacks['$' + event];\r\n\r\n  if (callbacks) {\r\n    callbacks = callbacks.slice(0);\r\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n      callbacks[i].apply(this, args);\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return array of callbacks for `event`.\r\n *\r\n * @param {String} event\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.listeners = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  return this._callbacks['$' + event] || [];\r\n};\r\n\r\n/**\r\n * Check if this emitter has `event` handlers.\r\n *\r\n * @param {String} event\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.hasListeners = function(event){\r\n  return !! this.listeners(event).length;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/component-emitter/index.js\n// module id = 16\n// module chunks = 0","/**\n * Module of mixed-in functions shared between node and client code\n */\nvar isObject = require('./is-object');\n\n/**\n * Expose `RequestBase`.\n */\n\nmodule.exports = RequestBase;\n\n/**\n * Initialize a new `RequestBase`.\n *\n * @api public\n */\n\nfunction RequestBase(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the prototype properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in RequestBase.prototype) {\n    obj[key] = RequestBase.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Clear previous timeout.\n *\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.clearTimeout = function _clearTimeout(){\n  clearTimeout(this._timer);\n  clearTimeout(this._responseTimeoutTimer);\n  delete this._timer;\n  delete this._responseTimeoutTimer;\n  return this;\n};\n\n/**\n * Override default response body parser\n *\n * This function will be called to convert incoming data into request.body\n *\n * @param {Function}\n * @api public\n */\n\nRequestBase.prototype.parse = function parse(fn){\n  this._parser = fn;\n  return this;\n};\n\n/**\n * Set format of binary response body.\n * In browser valid formats are 'blob' and 'arraybuffer',\n * which return Blob and ArrayBuffer, respectively.\n *\n * In Node all values result in Buffer.\n *\n * Examples:\n *\n *      req.get('/')\n *        .responseType('blob')\n *        .end(callback);\n *\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.responseType = function(val){\n  this._responseType = val;\n  return this;\n};\n\n/**\n * Override default request body serializer\n *\n * This function will be called to convert data set via .send or .attach into payload to send\n *\n * @param {Function}\n * @api public\n */\n\nRequestBase.prototype.serialize = function serialize(fn){\n  this._serializer = fn;\n  return this;\n};\n\n/**\n * Set timeouts.\n *\n * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.\n * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.\n *\n * Value of 0 or false means no timeout.\n *\n * @param {Number|Object} ms or {response, deadline}\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.timeout = function timeout(options){\n  if (!options || 'object' !== typeof options) {\n    this._timeout = options;\n    this._responseTimeout = 0;\n    return this;\n  }\n\n  for(var option in options) {\n    switch(option) {\n      case 'deadline':\n        this._timeout = options.deadline;\n        break;\n      case 'response':\n        this._responseTimeout = options.response;\n        break;\n      default:\n        console.warn(\"Unknown timeout option\", option);\n    }\n  }\n  return this;\n};\n\n/**\n * Set number of retry attempts on error.\n *\n * Failed requests will be retried 'count' times if timeout or err.code >= 500.\n *\n * @param {Number} count\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.retry = function retry(count){\n  // Default to 1 if no count passed or true\n  if (arguments.length === 0 || count === true) count = 1;\n  if (count <= 0) count = 0;\n  this._maxRetries = count;\n  this._retries = 0;\n  return this;\n};\n\n/**\n * Retry request\n *\n * @return {Request} for chaining\n * @api private\n */\n\nRequestBase.prototype._retry = function() {\n  this.clearTimeout();\n\n  // node\n  if (this.req) {\n    this.req = null;\n    this.req = this.request();\n  }\n\n  this._aborted = false;\n  this.timedout = false;\n\n  return this._end();\n};\n\n/**\n * Promise support\n *\n * @param {Function} resolve\n * @param {Function} [reject]\n * @return {Request}\n */\n\nRequestBase.prototype.then = function then(resolve, reject) {\n  if (!this._fullfilledPromise) {\n    var self = this;\n    if (this._endCalled) {\n      console.warn(\"Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises\");\n    }\n    this._fullfilledPromise = new Promise(function(innerResolve, innerReject){\n      self.end(function(err, res){\n        if (err) innerReject(err); else innerResolve(res);\n      });\n    });\n  }\n  return this._fullfilledPromise.then(resolve, reject);\n}\n\nRequestBase.prototype.catch = function(cb) {\n  return this.then(undefined, cb);\n};\n\n/**\n * Allow for extension\n */\n\nRequestBase.prototype.use = function use(fn) {\n  fn(this);\n  return this;\n}\n\nRequestBase.prototype.ok = function(cb) {\n  if ('function' !== typeof cb) throw Error(\"Callback required\");\n  this._okCallback = cb;\n  return this;\n};\n\nRequestBase.prototype._isResponseOK = function(res) {\n  if (!res) {\n    return false;\n  }\n\n  if (this._okCallback) {\n    return this._okCallback(res);\n  }\n\n  return res.status >= 200 && res.status < 300;\n};\n\n\n/**\n * Get request header `field`.\n * Case-insensitive.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nRequestBase.prototype.get = function(field){\n  return this._header[field.toLowerCase()];\n};\n\n/**\n * Get case-insensitive header `field` value.\n * This is a deprecated internal API. Use `.get(field)` instead.\n *\n * (getHeader is no longer used internally by the superagent code base)\n *\n * @param {String} field\n * @return {String}\n * @api private\n * @deprecated\n */\n\nRequestBase.prototype.getHeader = RequestBase.prototype.get;\n\n/**\n * Set header `field` to `val`, or multiple fields with one object.\n * Case-insensitive.\n *\n * Examples:\n *\n *      req.get('/')\n *        .set('Accept', 'application/json')\n *        .set('X-API-Key', 'foobar')\n *        .end(callback);\n *\n *      req.get('/')\n *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n *        .end(callback);\n *\n * @param {String|Object} field\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.set = function(field, val){\n  if (isObject(field)) {\n    for (var key in field) {\n      this.set(key, field[key]);\n    }\n    return this;\n  }\n  this._header[field.toLowerCase()] = val;\n  this.header[field] = val;\n  return this;\n};\n\n/**\n * Remove header `field`.\n * Case-insensitive.\n *\n * Example:\n *\n *      req.get('/')\n *        .unset('User-Agent')\n *        .end(callback);\n *\n * @param {String} field\n */\nRequestBase.prototype.unset = function(field){\n  delete this._header[field.toLowerCase()];\n  delete this.header[field];\n  return this;\n};\n\n/**\n * Write the field `name` and `val`, or multiple fields with one object\n * for \"multipart/form-data\" request bodies.\n *\n * ``` js\n * request.post('/upload')\n *   .field('foo', 'bar')\n *   .end(callback);\n *\n * request.post('/upload')\n *   .field({ foo: 'bar', baz: 'qux' })\n *   .end(callback);\n * ```\n *\n * @param {String|Object} name\n * @param {String|Blob|File|Buffer|fs.ReadStream} val\n * @return {Request} for chaining\n * @api public\n */\nRequestBase.prototype.field = function(name, val) {\n\n  // name should be either a string or an object.\n  if (null === name ||  undefined === name) {\n    throw new Error('.field(name, val) name can not be empty');\n  }\n\n  if (this._data) {\n    console.error(\".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()\");\n  }\n\n  if (isObject(name)) {\n    for (var key in name) {\n      this.field(key, name[key]);\n    }\n    return this;\n  }\n\n  if (Array.isArray(val)) {\n    for (var i in val) {\n      this.field(name, val[i]);\n    }\n    return this;\n  }\n\n  // val should be defined now\n  if (null === val || undefined === val) {\n    throw new Error('.field(name, val) val can not be empty');\n  }\n  if ('boolean' === typeof val) {\n    val = '' + val;\n  }\n  this._getFormData().append(name, val);\n  return this;\n};\n\n/**\n * Abort the request, and clear potential timeout.\n *\n * @return {Request}\n * @api public\n */\nRequestBase.prototype.abort = function(){\n  if (this._aborted) {\n    return this;\n  }\n  this._aborted = true;\n  this.xhr && this.xhr.abort(); // browser\n  this.req && this.req.abort(); // node\n  this.clearTimeout();\n  this.emit('abort');\n  return this;\n};\n\n/**\n * Enable transmission of cookies with x-domain requests.\n *\n * Note that for this to work the origin must not be\n * using \"Access-Control-Allow-Origin\" with a wildcard,\n * and also must set \"Access-Control-Allow-Credentials\"\n * to \"true\".\n *\n * @api public\n */\n\nRequestBase.prototype.withCredentials = function(on){\n  // This is browser-only functionality. Node side is no-op.\n  if(on==undefined) on = true;\n  this._withCredentials = on;\n  return this;\n};\n\n/**\n * Set the max redirects to `n`. Does noting in browser XHR implementation.\n *\n * @param {Number} n\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.redirects = function(n){\n  this._maxRedirects = n;\n  return this;\n};\n\n/**\n * Convert to a plain javascript object (not JSON string) of scalar properties.\n * Note as this method is designed to return a useful non-this value,\n * it cannot be chained.\n *\n * @return {Object} describing method, url, and data of this request\n * @api public\n */\n\nRequestBase.prototype.toJSON = function(){\n  return {\n    method: this.method,\n    url: this.url,\n    data: this._data,\n    headers: this._header\n  };\n};\n\n\n/**\n * Send `data` as the request body, defaulting the `.type()` to \"json\" when\n * an object is given.\n *\n * Examples:\n *\n *       // manual json\n *       request.post('/user')\n *         .type('json')\n *         .send('{\"name\":\"tj\"}')\n *         .end(callback)\n *\n *       // auto json\n *       request.post('/user')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // manual x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send('name=tj')\n *         .end(callback)\n *\n *       // auto x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // defaults to x-www-form-urlencoded\n *      request.post('/user')\n *        .send('name=tobi')\n *        .send('species=ferret')\n *        .end(callback)\n *\n * @param {String|Object} data\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.send = function(data){\n  var isObj = isObject(data);\n  var type = this._header['content-type'];\n\n  if (this._formData) {\n    console.error(\".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()\");\n  }\n\n  if (isObj && !this._data) {\n    if (Array.isArray(data)) {\n      this._data = [];\n    } else if (!this._isHost(data)) {\n      this._data = {};\n    }\n  } else if (data && this._data && this._isHost(this._data)) {\n    throw Error(\"Can't merge these send calls\");\n  }\n\n  // merge\n  if (isObj && isObject(this._data)) {\n    for (var key in data) {\n      this._data[key] = data[key];\n    }\n  } else if ('string' == typeof data) {\n    // default to x-www-form-urlencoded\n    if (!type) this.type('form');\n    type = this._header['content-type'];\n    if ('application/x-www-form-urlencoded' == type) {\n      this._data = this._data\n        ? this._data + '&' + data\n        : data;\n    } else {\n      this._data = (this._data || '') + data;\n    }\n  } else {\n    this._data = data;\n  }\n\n  if (!isObj || this._isHost(data)) {\n    return this;\n  }\n\n  // default to json\n  if (!type) this.type('json');\n  return this;\n};\n\n\n/**\n * Sort `querystring` by the sort function\n *\n *\n * Examples:\n *\n *       // default order\n *       request.get('/user')\n *         .query('name=Nick')\n *         .query('search=Manny')\n *         .sortQuery()\n *         .end(callback)\n *\n *       // customized sort function\n *       request.get('/user')\n *         .query('name=Nick')\n *         .query('search=Manny')\n *         .sortQuery(function(a, b){\n *           return a.length - b.length;\n *         })\n *         .end(callback)\n *\n *\n * @param {Function} sort\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.sortQuery = function(sort) {\n  // _sort default to true but otherwise can be a function or boolean\n  this._sort = typeof sort === 'undefined' ? true : sort;\n  return this;\n};\n\n/**\n * Compose querystring to append to req.url\n *\n * @api private\n */\nRequestBase.prototype._finalizeQueryString = function(){\n  var query = this._query.join('&');\n  if (query) {\n    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;\n  }\n  this._query.length = 0; // Makes the call idempotent\n\n  if (this._sort) {\n    var index = this.url.indexOf('?');\n    if (index >= 0) {\n      var queryArr = this.url.substring(index + 1).split('&');\n      if ('function' === typeof this._sort) {\n        queryArr.sort(this._sort);\n      } else {\n        queryArr.sort();\n      }\n      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');\n    }\n  }\n};\n\n// For backwards compat only\nRequestBase.prototype._appendQueryString = function() {console.trace(\"Unsupported\");}\n\n/**\n * Invoke callback with timeout error.\n *\n * @api private\n */\n\nRequestBase.prototype._timeoutError = function(reason, timeout, errno){\n  if (this._aborted) {\n    return;\n  }\n  var err = new Error(reason + timeout + 'ms exceeded');\n  err.timeout = timeout;\n  err.code = 'ECONNABORTED';\n  err.errno = errno;\n  this.timedout = true;\n  this.abort();\n  this.callback(err);\n};\n\nRequestBase.prototype._setTimeouts = function() {\n  var self = this;\n\n  // deadline\n  if (this._timeout && !this._timer) {\n    this._timer = setTimeout(function(){\n      self._timeoutError('Timeout of ', self._timeout, 'ETIME');\n    }, this._timeout);\n  }\n  // response timeout\n  if (this._responseTimeout && !this._responseTimeoutTimer) {\n    this._responseTimeoutTimer = setTimeout(function(){\n      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');\n    }, this._responseTimeout);\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/superagent/lib/request-base.js\n// module id = 17\n// module chunks = 0","\n/**\n * Module dependencies.\n */\n\nvar utils = require('./utils');\n\n/**\n * Expose `ResponseBase`.\n */\n\nmodule.exports = ResponseBase;\n\n/**\n * Initialize a new `ResponseBase`.\n *\n * @api public\n */\n\nfunction ResponseBase(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the prototype properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in ResponseBase.prototype) {\n    obj[key] = ResponseBase.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Get case-insensitive `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nResponseBase.prototype.get = function(field){\n    return this.header[field.toLowerCase()];\n};\n\n/**\n * Set header related properties:\n *\n *   - `.type` the content type without params\n *\n * A response of \"Content-Type: text/plain; charset=utf-8\"\n * will provide you with a `.type` of \"text/plain\".\n *\n * @param {Object} header\n * @api private\n */\n\nResponseBase.prototype._setHeaderProperties = function(header){\n    // TODO: moar!\n    // TODO: make this a util\n\n    // content-type\n    var ct = header['content-type'] || '';\n    this.type = utils.type(ct);\n\n    // params\n    var params = utils.params(ct);\n    for (var key in params) this[key] = params[key];\n\n    this.links = {};\n\n    // links\n    try {\n        if (header.link) {\n            this.links = utils.parseLinks(header.link);\n        }\n    } catch (err) {\n        // ignore\n    }\n};\n\n/**\n * Set flags such as `.ok` based on `status`.\n *\n * For example a 2xx response will give you a `.ok` of __true__\n * whereas 5xx will be __false__ and `.error` will be __true__. The\n * `.clientError` and `.serverError` are also available to be more\n * specific, and `.statusType` is the class of error ranging from 1..5\n * sometimes useful for mapping respond colors etc.\n *\n * \"sugar\" properties are also defined for common cases. Currently providing:\n *\n *   - .noContent\n *   - .badRequest\n *   - .unauthorized\n *   - .notAcceptable\n *   - .notFound\n *\n * @param {Number} status\n * @api private\n */\n\nResponseBase.prototype._setStatusProperties = function(status){\n    var type = status / 100 | 0;\n\n    // status / class\n    this.status = this.statusCode = status;\n    this.statusType = type;\n\n    // basics\n    this.info = 1 == type;\n    this.ok = 2 == type;\n    this.redirect = 3 == type;\n    this.clientError = 4 == type;\n    this.serverError = 5 == type;\n    this.error = (4 == type || 5 == type)\n        ? this.toError()\n        : false;\n\n    // sugar\n    this.accepted = 202 == status;\n    this.noContent = 204 == status;\n    this.badRequest = 400 == status;\n    this.unauthorized = 401 == status;\n    this.notAcceptable = 406 == status;\n    this.forbidden = 403 == status;\n    this.notFound = 404 == status;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/superagent/lib/response-base.js\n// module id = 18\n// module chunks = 0","\n/**\n * Return the mime type for the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nexports.type = function(str){\n  return str.split(/ *; */).shift();\n};\n\n/**\n * Return header field parameters.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nexports.params = function(str){\n  return str.split(/ *; */).reduce(function(obj, str){\n    var parts = str.split(/ *= */);\n    var key = parts.shift();\n    var val = parts.shift();\n\n    if (key && val) obj[key] = val;\n    return obj;\n  }, {});\n};\n\n/**\n * Parse Link header fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nexports.parseLinks = function(str){\n  return str.split(/ *, */).reduce(function(obj, str){\n    var parts = str.split(/ *; */);\n    var url = parts[0].slice(1, -1);\n    var rel = parts[1].split(/ *= */)[1].slice(1, -1);\n    obj[rel] = url;\n    return obj;\n  }, {});\n};\n\n/**\n * Strip content related fields from `header`.\n *\n * @param {Object} header\n * @return {Object} header\n * @api private\n */\n\nexports.cleanHeader = function(header, shouldStripCookie){\n  delete header['content-type'];\n  delete header['content-length'];\n  delete header['transfer-encoding'];\n  delete header['host'];\n  if (shouldStripCookie) {\n    delete header['cookie'];\n  }\n  return header;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/superagent/lib/utils.js\n// module id = 19\n// module chunks = 0","var ERROR_CODES = [\n  'ECONNRESET',\n  'ETIMEDOUT',\n  'EADDRINFO',\n  'ESOCKETTIMEDOUT'\n];\n\n/**\n * Determine if a request should be retried.\n * (Borrowed from segmentio/superagent-retry)\n *\n * @param {Error} err\n * @param {Response} [res]\n * @returns {Boolean}\n */\nmodule.exports = function shouldRetry(err, res) {\n  if (err && err.code && ~ERROR_CODES.indexOf(err.code)) return true;\n  if (res && res.status && res.status >= 500) return true;\n  // Superagent timeout\n  if (err && 'timeout' in err && err.code == 'ECONNABORTED') return true;\n  if (err && 'crossDomain' in err) return true;\n  return false;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/superagent/lib/should-retry.js\n// module id = 20\n// module chunks = 0","// randomColor by David Merfield under the CC0 license\n// https://github.com/davidmerfield/randomColor/\n\n;(function(root, factory) {\n\n  // Support CommonJS\n  if (typeof exports === 'object') {\n    var randomColor = factory();\n\n    // Support NodeJS & Component, which allow module.exports to be a function\n    if (typeof module === 'object' && module && module.exports) {\n      exports = module.exports = randomColor;\n    }\n\n    // Support CommonJS 1.1.1 spec\n    exports.randomColor = randomColor;\n\n  // Support AMD\n  } else if (typeof define === 'function' && define.amd) {\n    define([], factory);\n\n  // Support vanilla script loading\n  } else {\n    root.randomColor = factory();\n  }\n\n}(this, function() {\n\n  // Seed to get repeatable colors\n  var seed = null;\n\n  // Shared color dictionary\n  var colorDictionary = {};\n\n  // Populate the color dictionary\n  loadColorBounds();\n\n  var randomColor = function (options) {\n\n    options = options || {};\n\n    // Check if there is a seed and ensure it's an\n    // integer. Otherwise, reset the seed value.\n    if (options.seed !== undefined && options.seed !== null && options.seed === parseInt(options.seed, 10)) {\n      seed = options.seed;\n\n    // A string was passed as a seed\n    } else if (typeof options.seed === 'string') {\n      seed = stringToInteger(options.seed);\n\n    // Something was passed as a seed but it wasn't an integer or string\n    } else if (options.seed !== undefined && options.seed !== null) {\n      throw new TypeError('The seed value must be an integer or string');\n\n    // No seed, reset the value outside.\n    } else {\n      seed = null;\n    }\n\n    var H,S,B;\n\n    // Check if we need to generate multiple colors\n    if (options.count !== null && options.count !== undefined) {\n\n      var totalColors = options.count,\n          colors = [];\n\n      options.count = null;\n\n      while (totalColors > colors.length) {\n\n        // Since we're generating multiple colors,\n        // incremement the seed. Otherwise we'd just\n        // generate the same color each time...\n        if (seed && options.seed) options.seed += 1;\n\n        colors.push(randomColor(options));\n      }\n\n      options.count = totalColors;\n\n      return colors;\n    }\n\n    // First we pick a hue (H)\n    H = pickHue(options);\n\n    // Then use H to determine saturation (S)\n    S = pickSaturation(H, options);\n\n    // Then use S and H to determine brightness (B).\n    B = pickBrightness(H, S, options);\n\n    // Then we return the HSB color in the desired format\n    return setFormat([H,S,B], options);\n  };\n\n  function pickHue (options) {\n\n    var hueRange = getHueRange(options.hue),\n        hue = randomWithin(hueRange);\n\n    // Instead of storing red as two seperate ranges,\n    // we group them, using negative numbers\n    if (hue < 0) {hue = 360 + hue;}\n\n    return hue;\n\n  }\n\n  function pickSaturation (hue, options) {\n\n    if (options.hue === 'monochrome') {\n      return 0;\n    }\n\n    if (options.luminosity === 'random') {\n      return randomWithin([0,100]);\n    }\n\n    var saturationRange = getSaturationRange(hue);\n\n    var sMin = saturationRange[0],\n        sMax = saturationRange[1];\n\n    switch (options.luminosity) {\n\n      case 'bright':\n        sMin = 55;\n        break;\n\n      case 'dark':\n        sMin = sMax - 10;\n        break;\n\n      case 'light':\n        sMax = 55;\n        break;\n   }\n\n    return randomWithin([sMin, sMax]);\n\n  }\n\n  function pickBrightness (H, S, options) {\n\n    var bMin = getMinimumBrightness(H, S),\n        bMax = 100;\n\n    switch (options.luminosity) {\n\n      case 'dark':\n        bMax = bMin + 20;\n        break;\n\n      case 'light':\n        bMin = (bMax + bMin)/2;\n        break;\n\n      case 'random':\n        bMin = 0;\n        bMax = 100;\n        break;\n    }\n\n    return randomWithin([bMin, bMax]);\n  }\n\n  function setFormat (hsv, options) {\n\n    switch (options.format) {\n\n      case 'hsvArray':\n        return hsv;\n\n      case 'hslArray':\n        return HSVtoHSL(hsv);\n\n      case 'hsl':\n        var hsl = HSVtoHSL(hsv);\n        return 'hsl('+hsl[0]+', '+hsl[1]+'%, '+hsl[2]+'%)';\n\n      case 'hsla':\n        var hslColor = HSVtoHSL(hsv);\n        var alpha = options.alpha || Math.random();\n        return 'hsla('+hslColor[0]+', '+hslColor[1]+'%, '+hslColor[2]+'%, ' + alpha + ')';\n\n      case 'rgbArray':\n        return HSVtoRGB(hsv);\n\n      case 'rgb':\n        var rgb = HSVtoRGB(hsv);\n        return 'rgb(' + rgb.join(', ') + ')';\n\n      case 'rgba':\n        var rgbColor = HSVtoRGB(hsv);\n        var alpha = options.alpha || Math.random();\n        return 'rgba(' + rgbColor.join(', ') + ', ' + alpha + ')';\n\n      default:\n        return HSVtoHex(hsv);\n    }\n\n  }\n\n  function getMinimumBrightness(H, S) {\n\n    var lowerBounds = getColorInfo(H).lowerBounds;\n\n    for (var i = 0; i < lowerBounds.length - 1; i++) {\n\n      var s1 = lowerBounds[i][0],\n          v1 = lowerBounds[i][1];\n\n      var s2 = lowerBounds[i+1][0],\n          v2 = lowerBounds[i+1][1];\n\n      if (S >= s1 && S <= s2) {\n\n         var m = (v2 - v1)/(s2 - s1),\n             b = v1 - m*s1;\n\n         return m*S + b;\n      }\n\n    }\n\n    return 0;\n  }\n\n  function getHueRange (colorInput) {\n\n    if (typeof parseInt(colorInput) === 'number') {\n\n      var number = parseInt(colorInput);\n\n      if (number < 360 && number > 0) {\n        return [number, number];\n      }\n\n    }\n\n    if (typeof colorInput === 'string') {\n\n      if (colorDictionary[colorInput]) {\n        var color = colorDictionary[colorInput];\n        if (color.hueRange) {return color.hueRange;}\n      } else if (colorInput.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {\n        var hue = HexToHSB(colorInput)[0];\n        return [ hue, hue ];\n      }\n    }\n\n    return [0,360];\n\n  }\n\n  function getSaturationRange (hue) {\n    return getColorInfo(hue).saturationRange;\n  }\n\n  function getColorInfo (hue) {\n\n    // Maps red colors to make picking hue easier\n    if (hue >= 334 && hue <= 360) {\n      hue-= 360;\n    }\n\n    for (var colorName in colorDictionary) {\n       var color = colorDictionary[colorName];\n       if (color.hueRange &&\n           hue >= color.hueRange[0] &&\n           hue <= color.hueRange[1]) {\n          return colorDictionary[colorName];\n       }\n    } return 'Color not found';\n  }\n\n  function randomWithin (range) {\n    if (seed === null) {\n      return Math.floor(range[0] + Math.random()*(range[1] + 1 - range[0]));\n    } else {\n      //Seeded random algorithm from http://indiegamr.com/generate-repeatable-random-numbers-in-js/\n      var max = range[1] || 1;\n      var min = range[0] || 0;\n      seed = (seed * 9301 + 49297) % 233280;\n      var rnd = seed / 233280.0;\n      return Math.floor(min + rnd * (max - min));\n    }\n  }\n\n  function HSVtoHex (hsv){\n\n    var rgb = HSVtoRGB(hsv);\n\n    function componentToHex(c) {\n        var hex = c.toString(16);\n        return hex.length == 1 ? '0' + hex : hex;\n    }\n\n    var hex = '#' + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);\n\n    return hex;\n\n  }\n\n  function defineColor (name, hueRange, lowerBounds) {\n\n    var sMin = lowerBounds[0][0],\n        sMax = lowerBounds[lowerBounds.length - 1][0],\n\n        bMin = lowerBounds[lowerBounds.length - 1][1],\n        bMax = lowerBounds[0][1];\n\n    colorDictionary[name] = {\n      hueRange: hueRange,\n      lowerBounds: lowerBounds,\n      saturationRange: [sMin, sMax],\n      brightnessRange: [bMin, bMax]\n    };\n\n  }\n\n  function loadColorBounds () {\n\n    defineColor(\n      'monochrome',\n      null,\n      [[0,0],[100,0]]\n    );\n\n    defineColor(\n      'red',\n      [-26,18],\n      [[20,100],[30,92],[40,89],[50,85],[60,78],[70,70],[80,60],[90,55],[100,50]]\n    );\n\n    defineColor(\n      'orange',\n      [19,46],\n      [[20,100],[30,93],[40,88],[50,86],[60,85],[70,70],[100,70]]\n    );\n\n    defineColor(\n      'yellow',\n      [47,62],\n      [[25,100],[40,94],[50,89],[60,86],[70,84],[80,82],[90,80],[100,75]]\n    );\n\n    defineColor(\n      'green',\n      [63,178],\n      [[30,100],[40,90],[50,85],[60,81],[70,74],[80,64],[90,50],[100,40]]\n    );\n\n    defineColor(\n      'blue',\n      [179, 257],\n      [[20,100],[30,86],[40,80],[50,74],[60,60],[70,52],[80,44],[90,39],[100,35]]\n    );\n\n    defineColor(\n      'purple',\n      [258, 282],\n      [[20,100],[30,87],[40,79],[50,70],[60,65],[70,59],[80,52],[90,45],[100,42]]\n    );\n\n    defineColor(\n      'pink',\n      [283, 334],\n      [[20,100],[30,90],[40,86],[60,84],[80,80],[90,75],[100,73]]\n    );\n\n  }\n\n  function HSVtoRGB (hsv) {\n\n    // this doesn't work for the values of 0 and 360\n    // here's the hacky fix\n    var h = hsv[0];\n    if (h === 0) {h = 1;}\n    if (h === 360) {h = 359;}\n\n    // Rebase the h,s,v values\n    h = h/360;\n    var s = hsv[1]/100,\n        v = hsv[2]/100;\n\n    var h_i = Math.floor(h*6),\n      f = h * 6 - h_i,\n      p = v * (1 - s),\n      q = v * (1 - f*s),\n      t = v * (1 - (1 - f)*s),\n      r = 256,\n      g = 256,\n      b = 256;\n\n    switch(h_i) {\n      case 0: r = v; g = t; b = p;  break;\n      case 1: r = q; g = v; b = p;  break;\n      case 2: r = p; g = v; b = t;  break;\n      case 3: r = p; g = q; b = v;  break;\n      case 4: r = t; g = p; b = v;  break;\n      case 5: r = v; g = p; b = q;  break;\n    }\n\n    var result = [Math.floor(r*255), Math.floor(g*255), Math.floor(b*255)];\n    return result;\n  }\n\n  function HexToHSB (hex) {\n    hex = hex.replace(/^#/, '');\n    hex = hex.length === 3 ? hex.replace(/(.)/g, '$1$1') : hex;\n\n    var red = parseInt(hex.substr(0, 2), 16) / 255,\n          green = parseInt(hex.substr(2, 2), 16) / 255,\n          blue = parseInt(hex.substr(4, 2), 16) / 255;\n\n    var cMax = Math.max(red, green, blue),\n          delta = cMax - Math.min(red, green, blue),\n          saturation = cMax ? (delta / cMax) : 0;\n\n    switch (cMax) {\n      case red: return [ 60 * (((green - blue) / delta) % 6) || 0, saturation, cMax ];\n      case green: return [ 60 * (((blue - red) / delta) + 2) || 0, saturation, cMax ];\n      case blue: return [ 60 * (((red - green) / delta) + 4) || 0, saturation, cMax ];\n    }\n  }\n\n  function HSVtoHSL (hsv) {\n    var h = hsv[0],\n      s = hsv[1]/100,\n      v = hsv[2]/100,\n      k = (2-s)*v;\n\n    return [\n      h,\n      Math.round(s*v / (k<1 ? k : 2-k) * 10000) / 100,\n      k/2 * 100\n    ];\n  }\n\n  function stringToInteger (string) {\n    var total = 0\n    for (var i = 0; i !== string.length; i++) {\n      if (total >= Number.MAX_SAFE_INTEGER) break;\n      total += string.charCodeAt(i)\n    }\n    return total\n  }\n\n  return randomColor;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/randomcolor/randomColor.js\n// module id = 21\n// module chunks = 0"],"sourceRoot":""}